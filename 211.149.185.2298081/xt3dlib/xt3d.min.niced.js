'use strict';
var objkeys = ["\u4f4d\u7f6e\u5750\u6807\u9519\u8bef", "SCENE2D", "getValueOrClonedDefault", "isRotating", "stack-graphic-popup", "move", "addInner", "EasingFunction", "model", "responseText", "radar1", "EchartsLayer", "toFixed", "CircleWaveMaterial", "splitLayer", "scanPlaneRate", "TAILED_ATTACK_ARROW", "right", "PolylineEnergyTrans", "Array", "data:image/octet-stream;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAABCAYAAAAo2wu9AAAAOklEQVQoU2P8//+/McMoIDsEfv/+zcLKysrOwMDAAcVg9t+/fzmYmZkxxP/9+8fBxMSEIc7AwAAWAwD/kwzHVTmPqQAAAABJRU5ErkJggg==", 
"pointToLngLat", "sin", '</span>\n            <span class="MultiFieldAdaptWindow-close" title="\u5173\u95ed"  >\u00d7</span>\n          </div>\n          <div class="MultiFieldAdaptWindow-body">\n           \x3c!-- <div v-for="(field,index) in fields" :key="index" class="MultiFieldAdaptWindow-info-item">\n              <span class="MultiFieldAdaptWindow-ifno-label" :style="getFieldStyle()">{{field}}\uff1a</span>\n              <span class="MultiFieldAdaptWindow-ifno-text">{{formatValue(values[index])}}</span>\n            </div>--\x3e\n          </div>\n        </div>', 
"data:image/png;base64,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", 
"updateStyle", "device-name", "_frameState", "layer", "midDown", "createVideoFrustum", "registerMouseEvents", "_handler", "Entity", "tjxWidth", "multiplyByTranslation", "getOriginCoordinateSystemPoint", "Cesium", "_pickIds", "lune", "parse", "radian", "enableCollisionDetection", "\n#define USE_CUBE_MAP_SHADOW true\nuniform sampler2D colorTexture;\nuniform sampler2D depthTexture;\nvarying vec2 v_textureCoordinates;\nuniform mat4 camera_projection_matrix;\nuniform mat4 camera_view_matrix;\nuniform samplerCube shadowMap_textureCube;\nuniform mat4 shadowMap_matrix;\nuniform vec4 shadowMap_lightPositionEC;\nuniform vec4 shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness;\nuniform vec4 shadowMap_texelSizeDepthBiasAndNormalShadingSmooth;\nuniform float x_viewDistance; \nuniform vec4 x_visibleAreaColor;\nuniform vec4 x_invisibleAreaColor;\nstruct zx_shadowParameters\n{\n    vec3 texCoords;\n    float depthBias;\n    float depth;\n    float nDotL;\n    vec2 texelStepSize;\n    float normalShadingSmooth;\n    float darkness;\n};\nfloat czm_shadowVisibility(samplerCube shadowMap, zx_shadowParameters shadowParameters)\n{\n    float depthBias = shadowParameters.depthBias;\n    float depth = shadowParameters.depth;\n    float nDotL = shadowParameters.nDotL;\n    float normalShadingSmooth = shadowParameters.normalShadingSmooth;\n    float darkness = shadowParameters.darkness;\n    vec3 uvw = shadowParameters.texCoords;\n    depth -= depthBias;\n    float visibility = czm_shadowDepthCompare(shadowMap, uvw, depth);\n    return czm_private_shadowVisibility(visibility, nDotL, normalShadingSmooth, darkness);\n}\nvec4 getPositionEC(){\n    return czm_windowToEyeCoordinates(gl_FragCoord);\n}\nvec3 getNormalEC(){\n    return vec3(1.);\n}\nvec4 toEye(in vec2 uv,in float depth){\n    vec2 xy=vec2((uv.x*2.-1.),(uv.y*2.-1.));\n    vec4 posInCamera=czm_inverseProjection*vec4(xy,depth,1.);\n    posInCamera=posInCamera/posInCamera.w;\n    return posInCamera;\n}\nvec3 pointProjectOnPlane(in vec3 planeNormal,in vec3 planeOrigin,in vec3 point){\n    vec3 v01=point-planeOrigin;\n    float d=dot(planeNormal,v01);\n    return(point-planeNormal*d);\n}\nfloat getDepth(in vec4 depth){\n    float z_window=czm_unpackDepth(depth);\n    z_window=czm_reverseLogDepth(z_window);\n    float n_range=czm_depthRange.near;\n    float f_range=czm_depthRange.far;\n    return(2.*z_window-n_range-f_range)/(f_range-n_range);\n}\nfloat shadow(in vec4 positionEC){\n    vec3 normalEC=getNormalEC();\n    zx_shadowParameters shadowParameters;\n    shadowParameters.texelStepSize=shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.xy;\n    shadowParameters.depthBias=shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.z;\n    shadowParameters.normalShadingSmooth=shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.w;\n    shadowParameters.darkness=shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.w;\n    vec3 directionEC=positionEC.xyz-shadowMap_lightPositionEC.xyz;\n    float distance=length(directionEC);\n    directionEC=normalize(directionEC);\n    float radius=shadowMap_lightPositionEC.w;\n    if(distance>radius)\n    {\n        return 2.0;\n    }\n    vec3 directionWC=czm_inverseViewRotation*directionEC;\n    shadowParameters.depth=distance/radius-0.0003;\n    shadowParameters.nDotL=clamp(dot(normalEC,-directionEC),0.,1.);\n    shadowParameters.texCoords=directionWC;\n    float visibility=czm_shadowVisibility(shadowMap_textureCube,shadowParameters);\n    return visibility;\n}\nbool visible(in vec4 result)\n{\n    result.x/=result.w;\n    result.y/=result.w;\n    result.z/=result.w;\n    return result.x>=-1.&&result.x<=1.\n    &&result.y>=-1.&&result.y<=1.\n    &&result.z>=-1.&&result.z<=1.;\n}\nvoid main(){\n    // \u91c9\u8272 = \u7ed3\u6784\u4e8c\u7ef4(\u989c\u8272\u7eb9\u7406, \u7eb9\u7406\u5750\u6807)\n    gl_FragColor = texture2D(colorTexture, v_textureCoordinates);\n    // \u6df1\u5ea6 = \u83b7\u53d6\u6df1\u5ea6(\u7ed3\u6784\u4e8c\u7ef4(\u6df1\u5ea6\u7eb9\u7406, \u7eb9\u7406\u5750\u6807))\n    float depth = getDepth(texture2D(depthTexture, v_textureCoordinates));\n    // \u89c6\u89d2 = (\u7eb9\u7406\u5750\u6807, \u6df1\u5ea6)\n    vec4 viewPos = toEye(v_textureCoordinates, depth);\n    // \u4e16\u754c\u5750\u6807\n    vec4 wordPos = czm_inverseView * viewPos;\n    // \u865a\u62df\u76f8\u673a\u4e2d\u5750\u6807\n    vec4 vcPos = camera_view_matrix * wordPos;\n    float near = .001 * x_viewDistance;\n    float dis = length(vcPos.xyz);\n    if(dis > near && dis < x_viewDistance){\n        // \u900f\u89c6\u6295\u5f71\n        vec4 posInEye = camera_projection_matrix * vcPos;\n        // \u53ef\u89c6\u533a\u989c\u8272\n        //  vec4 x_visibleAreaColor=vec4(0.,1.,0.,1.0);\n        //  vec4 x_invisibleAreaColor=vec4(1.,0.,0.,1.0);\n        if(visible(posInEye)){\n            float vis = shadow(viewPos);\n            if(vis > 0.3){\n                gl_FragColor = mix(gl_FragColor,x_visibleAreaColor,.7);\n            } else{\n                gl_FragColor = mix(gl_FragColor,x_invisibleAreaColor,.7);\n            }\n        }\n    }\n}", 
"setTipContent", "</gml:coordinates></gml:Point></Intersects></Filter>", "horizontalViewAngle", "Credit", "dynamicWallEntity", "rgba(255, 255, 255, 0.2)", "ScanlineSource", "keyCode", "owner", "markdown-it-sanitizer", "setLineDash", "handleMouseDown", "create", '@keyframes dynamic-dynamic-divlabel-animate1 {\r\n    0%,\r\n    100% {\r\n        clip: rect(0px, var(--clip-width-1), 2px, 0px);\r\n    }\r\n    25% {\r\n        clip: rect(0px, 2px, var(--clip-height-1), 0px);\r\n    }\r\n    50% {\r\n        clip: rect( var(--clip-height-2), var(--clip-width-1), var(--clip-width-1), 0px);\r\n    }\r\n    75% {\r\n        clip: rect( 0px, var(--clip-width-1), var(--clip-height-1), var(--clip-width-2));\r\n    }\r\n}\r\n\r\n.dynamic-divlabel-container {\r\n    position: absolute;\r\n    left: 0px;\r\n    bottom: 0px;\r\n    pointer-events: none;\r\n    cursor: pointer;\r\n}\r\n\r\n.dynamic-divlabel-container1 {\r\n    --boder-height: 30px;\r\n    --clip-height-1: 40px;\r\n    --clip-height-2: 38px;\r\n    /* --border-color: rgb(24, 144, 255);\r\n    --box-shadow-color: rgba(24, 144, 255, 0.73); */\r\n    --text-color: #ccc;\r\n    --border-color: rgb(21, 209, 242);\r\n    --box-shadow-color: rgba(21, 209, 242, 0.56);\r\n    --text-font-size: 14px;\r\n    --clip-width-1: 165px;\r\n    --clip-width-2: 163px;\r\n    --boder-width: 150px;\r\n    --text-left-position: -75px;\r\n    --animation-name: dynamic-dynamic-divlabel-animate1;\r\n}\r\n\r\n.sz-component-animate-marker__boder {\r\n    width: var(--boder-width);\r\n    height: var(--boder-height);\r\n    margin: auto;\r\n    color: var(--border-color);\r\n    box-shadow: inset 0 0 0 1px var(--box-shadow-color);\r\n}\r\n\r\n.sz-component-animate-marker__text {\r\n    color: var(--text-color);\r\n    font-size: var(--text-font-size);\r\n    display: flex;\r\n    width: 100%;\r\n    height: 100%;\r\n    align-items: center;\r\n    justify-content: center;\r\n    font-weight: bolder;\r\n    user-select: none;\r\n    cursor: pointer;\r\n}\r\n\r\n.sz-component-animate-marker__boder,\r\n.sz-component-animate-marker__boder::before,\r\n.sz-component-animate-marker__boder::after {\r\n    position: absolute;\r\n    top: 0;\r\n    bottom: 0;\r\n    left: 0;\r\n    right: 0;\r\n}\r\n\r\n.sz-component-animate-marker__boder::before,\r\n.sz-component-animate-marker__boder::after {\r\n    content: "";\r\n    margin: -5%;\r\n    box-shadow: inset 0 0 0 2px;\r\n    animation: var(--animation-name) 8s linear infinite;\r\n}\r\n\r\n.sz-component-animate-marker__boder::before {\r\n    animation-delay: -4s;\r\n}', 
"velocity", "drawFrustumOutline", "addCameraFrustum", "fhDataServerBaseUrl", "DTH", "wEntity", "isDestroyed", "minPointCount", "surfaceDistance", "createIfNeeded", "Utils", "destination", "\u53f3\u952e\u70b9\u51fb\u53d6\u6d88", "is-shulie-item1", "pointsToDegreesArray", "canvasConfig", "_domeSurfaceMaterial", "clearPrimitive", "chordLength", "concat", "sentinel", "maximumHeights", "rotation", "flyTo", "targetEnterHedronEvent", "_pickSP", "_blank", "prototype", "addEventListener", "cos", "on_end", 
"addModels", "muted", "roll", "fromGeometry", "plotSelecteable", "getRoamTransform", "lookAtTransform", "primitive4", "addRoamLine", "\n                varying vec3 v_positionEC;\n                varying vec3 v_normalEC;\n                varying vec2 v_st;\n                void main()\n                {\n                    vec3 positionToEyeEC = -v_positionEC;\n                    vec3 normalEC = normalize(v_normalEC);\n                    #ifdef FACE_FORWARD\n                        normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\n                    #endif\n                    czm_materialInput materialInput;\n                    materialInput.normalEC = normalEC;\n                    materialInput.positionToEyeEC = positionToEyeEC;\n                    materialInput.st = v_st;\n                    czm_material material = czm_getMaterial(materialInput);\n                    gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n                }", 
"append", "handleEditMilitaryPlot", "bottomOuterCircleColor", "myCanvas", "promise", "generateGeoFeature", "transparencyGiven", "lineEntity", '.chart-popup3d-container {\r\n    background: #14193399;\r\n    position: absolute;\r\n    left: 0px;\r\n    bottom: 0px;\r\n    cursor: default;\r\n}\r\n\r\n.chart-popup3d-container::before {\r\n    content: "";\r\n    width: calc(100% + 22px);\r\n    height: 39px;\r\n    position: absolute;\r\n    bottom: -39px;\r\n    left: -22px;\r\n    background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAB4AAAAAlCAYAAACj1PQVAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyhpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTQ1IDc5LjE2MzQ5OSwgMjAxOC8wOC8xMy0xNjo0MDoyMiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTkgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MTJFMTU1RjExN0UzMTFFOTg3RTBFODdGNTY0NThGQkUiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MTJFMTU1RjIxN0UzMTFFOTg3RTBFODdGNTY0NThGQkUiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDoxMkUxNTVFRjE3RTMxMUU5ODdFMEU4N0Y1NjQ1OEZCRSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDoxMkUxNTVGMDE3RTMxMUU5ODdFMEU4N0Y1NjQ1OEZCRSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pj97JFoAAAV9SURBVHja7N1faJ1nHQfw33nzpuekaZfWNFmbLHXWdf7DWgvebF4M0SEZhTG8mKvFyzG9UJFKh9peVGnd0DkE/10Ic6s6BBEGbshggho3BVGnRnC2s1n/ras2J2uzc05PXp+3yZzSm7XJkvfi84HveZ9z3ve8F7/bL8/71oqiiMs8NhCLsCllfcpfAwAAAAAAAIDlsXM68jfgtl9K2Z3Sa8IAAAAAAAAAb7hjKW8uF9kS3/jdKR9PaZkxAAAAAAAAwPJa6h3A96X0pBxK+bLxAgAAAAAAACyfpSyAP5jy4ZQXUh747687p00ZAAAAAAAAYBlkS3if+xfW+1MuGC0AAAAAAADA8lqqAnh3yvaUZ1MeMlYAAAAAAACA5bcUBXBfyoGF9edSusYKAAAAAAAAsPyWogD+VMpYypMpTxgpAAAAAAAAwMpYbAG8IWVvylzKHuMEAAAAAAAAWDmLLYC/mDKQ8nDKH4wTAAAAAAAAYOUspgC+IeWelNmYL4IBAAAAAAAAWEGLKYAPpfSmfD1lyigBAAAAAAAAVtbVFsA3pdyR8lLMF8EAAAAAAAAArLCrKYBrKfcvHA+kNI0RAAAAAAAAYOVdTQFc7vwtdwA/l/ItIwQAAAAAAACohistgMt3/h5cWO9N6RghAAAAAAAAQDVcaQF8d8rWlImUnxgfAAAAAAAAQHVcSQF8Tcq+lCJlz8IRAAAAAAAAgIq4kgK4fOTzUMzv/J0wOgAAAAAAAIBqeb0F8FjKp2P+nb97jQ0AAAAAAACgel5vAXwgpS/l2ynPGRsAAAAAAABA9eSjd370sh+P7/q/r9tTdqc0Y74IBgAAAAAAAKCC8v9Zl7uB6yn9o4fHG+lYS2n/867Hv5bXivLcoZQzRgYAAAAAAABQTfnw5nvjxWMHe9N6cP+OyVtv2nj2ruFG6209WbGqM5c181rx9m5RO/ngn2/4zlf/tLV2fNfPCmMDAAAAAAAAqJ68LH+HGq2xRz7wu2+8a31zvCgiLs5FlC3vqp4YKS8638mzqZf7tqXlb1MuGBsAAAAAAABA9ZSPdh58tfyd7UScOh9xYjqLszNZlGVwN6U/71z7hR1/e/g9g9NbRg+P9xobAAAAAAAAQPVk+3ZMfujV8vf0TC3WXWzE9ZveHyNjt0UxOxCnp7NotiPWr2pfl67dk/6zxtgAAAAAAAAAqie7eePZXeVO33OtiOGsHqtvfjDi1scibnkkesafipHVI3HuQi3a3Yh3rpsZT/+5ZvTweM3oAAAAAAAAAKolH2q0byzf+dtuZ9G/8b0RW+587ezat0a84xPR+8z+aHU7MVDvbLhl05lrf3FyaGr08Hj5muA4/qMfmiIAAAAAAABABWS1KPJLTW75UR+8/Ir6uksvCi6K+a/Dfa26sQEAAAAAAABUT/ZyJz+Z19IiL6J7eiLi/NRrZ4tuxNEfRzvmorcnoj2XvfL41MZTMV8XAwAAAAAAAFAh2eS5tU9kWcRAo4ipC9MRP98ZMfnNiH/8IOLJO+LMC7+ORl83Gj0RR5r9z8x08nOhAAYAAAAAAAConPyzT2976H1D//7YYL21ZW5NN442n4/ep/ddeuxzK+air68bb2pEdCN75dEj192Xfp4xNgAAAAAAAIDqyWY6+akHnt16d7Oz6uRAPWJkoIi1azuxek0nhge6MdQXUatlrZ8+P/L5706+ZSLKXhgAAAAAAACAyik3+s5+/++bJ+751fbbfv/S+kc7c/l0WQSva0TUe2rtIzNrJr7yxxs/8pnfbPteurY5vPlej38GAAAAAAAAqKC8LHRfPHZw9penNvwl5ZP1nrmB268/MdafX+x96sTQ8aMz/f9K102ntJS/AAAAAAAAANX1HwEGAM75MhcANnAkAAAAAElFTkSuQmCC) 0px 0px no-repeat;\r\n    background-position: 0px 0px;\r\n}\r\n\r\n.chart-popup3d-header {\r\n    height: 30px;\r\n    color: white;\r\n    background: #1f3f8e;\r\n    line-height: 30px;\r\n}\r\n\r\n.chart-popup3d-header-title {\r\n    display: inline-block;\r\n    height: 100%;\r\n    margin-left: 5px;\r\n}\r\n\r\n.chart-popup3d-close {\r\n    position: absolute;\r\n    right: 1px;\r\n    font-size: 25px;\r\n    cursor: pointer;\r\n    width: 29px;\r\n    text-align: center;\r\n}\r\n\r\n.chart-popup3d-close:hover {\r\n    background: #dc2929b9;\r\n}\r\n\r\n\r\n/* .chart-popup3d-body {\r\n    height: 300px;\r\n    width: 500px;\r\n} */', 
"degreesArray", "MilitaryPlotEditMoveVertex", "href", "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables", "#ff9501", "MaterialSupport", "gradientCircleCanvas", "Can't convert object to primitive value", "invisibleAreaColor", "Dimensions", "latitude", "clockRange", "\u5fae\u4fe1\uff1axt3d2021", "appData", "domeSurfaceMaterial", "xt3dInfo", "HouseSelectedEvent", "infos", "moveVar", "errorEvent", "clickHighlightPrimitive", "fixPointCount", 
"handlePickFloor", "initMouseMoveEventHandler", "createAttributeLocations", "svgCompassRotationMarker", "\uff0c\u9700\u89813\u4e2a\u70b9", "html", "destination-out", "GetSides", "Quaternion", "TranslationRotationScale", "auto_play", "directionWC", "index", "nextStopsIndex", "Appearance", "createMarker", "remove", "\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a\u9759\u6001\u56f4\u680f\uff0c\u6700\u5c11\u9700\u89812\u4e2a\u70b9", "addEllipsoid", "_sectorLineVA", "angle2", "uniform sampler2D colorTexture; \n                                varying vec2 v_textureCoordinates; \n                                const int KERNEL_WIDTH=16; \n                                void main(void) \n                                { \n                                    vec2 step = 1.0 / czm_viewport.zw; \n                                    vec2 integralPos = v_textureCoordinates - mod(v_textureCoordinates, 8.0 * step); \n                                    vec3 averageValue = vec3(0.0); \n                                    for (int i = 0; i < KERNEL_WIDTH; i++) \n                                    { \n                                        for (int j = 0; j < KERNEL_WIDTH; j++) \n                                        { \n                                            averageValue += texture2D(colorTexture, integralPos + step * vec2(i, j)).rgb; \n                                        } \n                                    } \n                                    averageValue /= float(KERNEL_WIDTH * KERNEL_WIDTH); \n                                    gl_FragColor = vec4(averageValue, 1.0); \n                                } ", 
"#FFFF00", "RaisePoint", "setChartOption", "booleanPointInPolygon", "removeBookmark", "_rectangleSouthwestInMeters", "waveCircleShow", "count", "convertLL2MC", "NEAREST", "LLBAND", "ScanCircleType", "scene3d-mousedownview", "AdvancedPlugin", "polylinevolume", "PolylineMigrate", "radians", "cartographicToCartesian", "militaryPlot", "horizontal", "drawCanvas", "init", "lineHeight", "eachSeries", "512655zSleJQ", "moveType", "offset", "MOUSE_MOVE", "role", "pre-topCard-list-item-line", "offsetLeft", 
"    ", "moveLeft", "fdDataServerBaseUrl", "updateTargetPosition", "plotType", "positiveY", "_show", "addRing", "update", "divHeading", "toDataURL", "pointToLngLat\u65b9\u6cd5\u672a\u5b9e\u73b0", "versions", "interpolationPostions", "uniform sampler2D colorTexture;\nvarying vec2 v_textureCoordinates;\n\tfloat hash(float x){\n\t     return fract(sin(x*133.3)*13.13);\n\t }\n\tvoid main(void){\n\t     float time = czm_frameNumber / 600.0;\n\t     vec2 resolution = czm_viewport.zw; \n\t     vec2 uv=(gl_FragCoord.xy*2.-resolution.xy)/min(resolution.x,resolution.y);\n\t     vec3 c=vec3(.6,.7,.8); \n\t     float a=-.4;\n\t     float si=sin(a),co=cos(a);\n\t     uv*=mat2(co,-si,si,co);\n\t     uv*=length(uv+vec2(0,4.9))*.3+1.;\n\t     float v=1.-sin(hash(floor(uv.x*100.))*2.);\n\t     float b=clamp(abs(sin(20.*time*v+uv.y*(5./(2.+v))))-.95,0.,1.)*20.;\n\t     c*=v*b; \n\t     gl_FragColor = mix(texture2D(colorTexture, v_textureCoordinates), vec4(c,1), 0.5); \n\t}", 
"rec is undefined", "updateModelMatrix", "moveUp", "animateLine", "scene3d-mousedownview-img", "normal 40px MicroSoft YaHei", "embeddedComponent", "click", "createLightCamera", "rotateUp", "getAxis", "lngLatToPoint", "preload", "Water", "clearIntervalId", "strokeStyle", "POSITION_ONLY", "_resource", "max", "createFrustumOutlineGeometry", "_tileDiscardPolicy", "isEdited", "Matrix3", "_html5_api", "increment", "setPlotSelectable", "position", "shaderRedefine", "connPoint", "addBottomPolygon", "MultiFieldAdaptWindow-close", 
"moveing", "restore", "billboardImg", "getElementsByTagName", "focus", "catch", "mercatorToLngLat", "ellipsoidScan", "stepSize", "Property", "tempPoint4", "SCENE3D", "moveEndEvent", "13190wJymxX", '.video-popup3d-container {\r\n    min-width: 250px;\r\n    min-height: 200px;\r\n    max-width: 400px;\r\n    max-height: 400px;\r\n    background: #14193399;\r\n    position: absolute;\r\n    left: 0px;\r\n    bottom: 0px;\r\n    cursor: default;\r\n}\r\n\r\n.video-popup3d-container::before {\r\n    content: "";\r\n    width: calc(100% + 22px);\r\n    height: 39px;\r\n    position: absolute;\r\n    bottom: -39px;\r\n    left: -22px;\r\n    background: url(../../../../static/images/popup3d/popup3d.png) 0px 0px no-repeat;\r\n    background-position: 0px 0px;\r\n}\r\n\r\n.video-popup3d-header {\r\n    height: 30px;\r\n    color: white;\r\n    background: #1f3f8e;\r\n    line-height: 30px;\r\n}\r\n\r\n.video-popup3d-header-title {\r\n    display: inline-block;\r\n    height: 100%;\r\n    margin-left: 5px;\r\n}\r\n\r\n.video-popup3d-close {\r\n    position: absolute;\r\n    right: 1px;\r\n    font-size: 25px;\r\n    cursor: pointer;\r\n    width: 29px;\r\n    text-align: center;\r\n}\r\n\r\n.video-popup3d-close:hover {\r\n    background: #dc2929b9;\r\n}\r\n\r\n.video-jd-temp {\r\n    width: 400px;\r\n    height: 240px;\r\n}', 
"cameraMoveEnd", "BuildingSelectedEvent", "addCircle", "updateData", "opts", "hasAlphaChannel must not be called before the imagery provider is ready.", "hpRoll", "addMapData", "fromRotationZ", "visibleAreaColor", "htmlPlotLayer", "clock", "setOption", "modelUrl", "block", "mapv", "SECTOR", "ColorGeometryInstanceAttribute", '#ifdef GL_OES_standard_derivatives\r\n    #extension GL_OES_standard_derivatives : enable\r\n#endif\r\n\r\nuniform bool u_showIntersection;\r\nuniform bool u_showThroughEllipsoid;\r\n\r\nuniform float u_radius;\r\nuniform float u_xHalfAngle;\r\nuniform float u_yHalfAngle;\r\nuniform float u_normalDirection;\r\nuniform float u_type;\r\n\r\nvarying vec3 v_position;\r\nvarying vec3 v_positionWC;\r\nvarying vec3 v_positionEC;\r\nvarying vec3 v_normalEC;\r\n\r\nvec4 getColor(float sensorRadius, vec3 pointEC)\r\n{\r\n    czm_materialInput materialInput;\r\n\r\n    vec3 pointMC = (czm_inverseModelView * vec4(pointEC, 1.0)).xyz;\r\n    materialInput.st = sensor2dTextureCoordinates(sensorRadius, pointMC);\r\n    materialInput.str = pointMC / sensorRadius;\r\n\r\n    vec3 positionToEyeEC = -v_positionEC;\r\n    materialInput.positionToEyeEC = positionToEyeEC;\r\n\r\n    vec3 normalEC = normalize(v_normalEC);\r\n    materialInput.normalEC = u_normalDirection * normalEC;\r\n\r\n    czm_material material = czm_getMaterial(materialInput);\r\n    // czm_lightDirectionEC\u5728cesium1.66\u5f00\u59cb\u52a0\u5165\u7684\r\n    return mix(czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC), vec4(material.diffuse, material.alpha), 0.4);\r\n\r\n}\r\n\r\nbool isOnBoundary(float value, float epsilon)\r\n{\r\n    float width = getIntersectionWidth();\r\n    float tolerance = width * epsilon;\r\n\r\n#ifdef GL_OES_standard_derivatives\r\n    float delta = max(abs(dFdx(value)), abs(dFdy(value)));\r\n    float pixels = width * delta;\r\n    float temp = abs(value);\r\n    // There are a couple things going on here.\r\n    // First we test the value at the current fragment to see if it is within the tolerance.\r\n    // We also want to check if the value of an adjacent pixel is within the tolerance,\r\n    // but we don\'t want to admit points that are obviously not on the surface.\r\n    // For example, if we are looking for "value" to be close to 0, but value is 1 and the adjacent value is 2,\r\n    // then the delta would be 1 and "temp - delta" would be "1 - 1" which is zero even though neither of\r\n    // the points is close to zero.\r\n    return temp < tolerance && temp < pixels || (delta < 10.0 * tolerance && temp - delta < tolerance && temp < pixels);\r\n#else\r\n    return abs(value) < tolerance;\r\n#endif\r\n}\r\n\r\nvec4 shade(bool isOnBoundary)\r\n{\r\n    if (u_showIntersection && isOnBoundary)\r\n    {\r\n        return getIntersectionColor();\r\n    }\r\n    if(u_type == 1.0){\r\n        return getLineColor();\r\n    }\r\n    return getColor(u_radius, v_positionEC);\r\n}\r\n\r\nfloat ellipsoidSurfaceFunction(vec3 point)\r\n{\r\n    vec3 scaled = czm_ellipsoidInverseRadii * point;\r\n    return dot(scaled, scaled) - 1.0;\r\n}\r\n\r\nvoid main()\r\n{\r\n    vec3 sensorVertexWC = czm_model[3].xyz;      // (0.0, 0.0, 0.0) in model coordinates\r\n    vec3 sensorVertexEC = czm_modelView[3].xyz;  // (0.0, 0.0, 0.0) in model coordinates\r\n\r\n    //vec3 pixDir = normalize(v_position);\r\n    float positionX = v_position.x;\r\n    float positionY = v_position.y;\r\n    float positionZ = v_position.z;\r\n\r\n    vec3 zDir = vec3(0.0, 0.0, 1.0);\r\n    vec3 lineX = vec3(positionX, 0 ,positionZ);\r\n    vec3 lineY = vec3(0, positionY, positionZ);\r\n    float resX = dot(normalize(lineX), zDir);\r\n    if(resX < cos(u_xHalfAngle)-0.00001){\r\n        discard;\r\n    }\r\n    float resY = dot(normalize(lineY), zDir);\r\n    if(resY < cos(u_yHalfAngle)-0.00001){\r\n        discard;\r\n    }\r\n\r\n\r\n    float ellipsoidValue = ellipsoidSurfaceFunction(v_positionWC);\r\n\r\n    // Occluded by the ellipsoid?\r\n\tif (!u_showThroughEllipsoid)\r\n\t{\r\n\t    // Discard if in the ellipsoid\r\n\t    // PERFORMANCE_IDEA: A coarse check for ellipsoid intersection could be done on the CPU first.\r\n\t    if (ellipsoidValue < 0.0)\r\n\t    {\r\n            discard;\r\n\t    }\r\n\r\n\t    // Discard if in the sensor\'s shadow\r\n\t    if (inSensorShadow(sensorVertexWC, v_positionWC))\r\n\t    {\r\n\t        discard;\r\n\t    }\r\n    }\r\n\r\n    // Notes: Each surface functions should have an associated tolerance based on the floating point error.\r\n    bool isOnEllipsoid = isOnBoundary(ellipsoidValue, czm_epsilon3);\r\n    //isOnEllipsoid = false;\r\n    //if((resX >= 0.8 && resX <= 0.81)||(resY >= 0.8 && resY <= 0.81)){\r\n    /*if(false){\r\n        gl_FragColor = vec4(1.0,0.0,0.0,1.0);\r\n    }else{\r\n        gl_FragColor = shade(isOnEllipsoid);\r\n    }\r\n*/\r\n    gl_FragColor = shade(isOnEllipsoid);\r\n\r\n}', 
"dMaximumHeights", "silhouetteSize", "updateEndPosition", "CylinderGlowFlowWall", "ComponentDatatype", "currentHeight", "bounce", ' .gradient-label {\r\n     text-align: center;\r\n     position: absolute;\r\n     padding: 5px 30px;\r\n     margin: 0;\r\n     color: #fff;\r\n     background: linear-gradient(rgb(7 10 203 / 75%), rgb(16 238 220));\r\n     -webkit-border-radius: 5px;\r\n     -moz-border-radius: 5px;\r\n     border-radius: 5px;\r\n     max-width: 180px;\r\n     max-height: 134px;\r\n     -webkit-user-select: none;\r\n     -moz-user-select: none;\r\n     -ms-user-select: none;\r\n     user-select: none;\r\n }\r\n \r\n .gradient-label:after {\r\n     content: "";\r\n     position: absolute;\r\n     bottom: -60px;\r\n     left: calc(50% - 3px);\r\n     display: block;\r\n     width: 3px;\r\n     height: 60px;\r\n     border-right: 3px solid #2bcdbb;\r\n }', 
"frustumOutline", "framebuffer", "createYaxis", "Model", "getDate", "zoy", "fillText", "rgba(255,255,255,0.4)", "ShaderProgram", "calStopsTimes", "getOption", "EllipsoidOutlineGeometry", "_ready", "BlendingState", "bindMouseEvent", "cameraLine", "url", "ConvertLLAToXYZ", "size", "_visiable", "Symbol", "_removeSubscription", "toPrimitive", "rPositions", "cylinder", "imgUrl", "ConvertXYZToLLA", "GATHERING_PLACE", "isWgs84", "viewPosition", "clientHeight", "outer_controlPoints", "\u76f4\u7bad\u5934", 
"traceHandler", "_scanePlaneYHalfAngle", "czm_material czm_getMaterial(czm_materialInput materialInput)\n       {\n             czm_material material = czm_getDefaultMaterial(materialInput);\n             vec2 st = materialInput.st;\n             vec4 colorImage = texture2D(image, vec2(fract(st.s - time), st.t));\n             material.alpha = colorImage.a * color.a;\n             material.diffuse = color.rgb*1.5;\n             return material;\n     }", "keydown", "lineTo", "showThroughEllipsoid", 
"getPlotNam", "outlineWidth", "tileDiscardPolicy", "getPosition", "GeometryAttributes", "bindEvent", "gct", "\u591a\u8fb9\u4f53", "_backFaceRS", "uniforms", "_pickRS", "addPosition", "look", "flowWallMaterial", "minWidth", "cartesianToCanvasCoordinates", "getImageData", "_camerafov", "setRequestHeader", "checkTargetIsIntersect", "dynamicfence", "createVideoPolygon", "img_d", "gcj02towgs84", "json", "czm_selectedIdTextureWidth", "RED", "colorSubscription", "indices", "glowRange", "getMilliseconds", 
'<div class="compass"  style="display: none;" title="" data-bind="visible: showCompass, event: { mousedown: handleMouseDown, dblclick: handleDoubleClick }"><div class="compass-outer-ring-background"></div> <div class="compass-rotation-marker" data-bind="visible: isOrbiting, style: { transform: \'rotate(-\' + orbitCursorAngle + \'rad)\', \'-webkit-transform\': \'rotate(-\' + orbitCursorAngle + \'rad)\', opacity: orbitCursorOpacity }, cesiumSvgPath: { path: svgCompassRotationMarker, width: 145, height: 145 }"></div> <div class="compass-outer-ring" title="" data-bind="style: { transform: \'rotate(-\' + heading + \'rad)\', \'-webkit-transform\': \'rotate(-\' + heading + \'rad)\' }, cesiumSvgPath: { path: svgCompassOuterRing, width: 145, height: 145 }"></div> <div class="compass-gyro-background"></div> <div class="compass-gyro" data-bind="cesiumSvgPath: { path: svgCompassGyro, width: 145, height: 145 }, css: { \'compass-gyro-active\': isOrbiting }"></div></div><div class="navigation-controls"   style="display: none;" >\x3c!-- ko foreach: controls --\x3e<div data-bind="click: activate, attr: { title: $data.name }, css: $root.isLastControl($data) ? \'navigation-control-last\' : \'navigation-control\' ">   \x3c!-- ko if: $data.hasText --\x3e   <div data-bind="text: $data.text, css: $data.isActive ?  \'navigation-control-icon-active \' + $data.cssClass : $data.cssClass"></div>   \x3c!-- /ko --\x3e  \x3c!-- ko ifnot: $data.hasText --\x3e  <div data-bind="cesiumSvgPath: { path: $data.svgIcon, width: $data.svgWidth, height: $data.svgHeight }, css: $data.isActive ?  \'navigation-control-icon-active \' + $data.cssClass : $data.cssClass"></div>  \x3c!-- /ko --\x3e </div> \x3c!-- /ko --\x3e</div>', 
"onmouseenter", "fontSize", "_domeBackCommand", "DrawStartEvent", "\uff0c\u6700\u5c11\u9700\u89812\u4e2a\u70b9", "lengthComputable", "start", "defaultResetView", "dataSource", "/home_icon_20.png)", "CHARTREUSE", "createZaxis", "windowClose", "addEntities", "initLeftClickEvent", "depthTestAgainstTerrain", "navigation-control-icon-zoom-", "normal 34px MicroSoft YaHei", "createLinearGradient", "czm_material czm_getMaterial(czm_materialInput materialInput)\n { czm_material material = czm_getDefaultMaterial(materialInput); vec2 st = materialInput.st;\n    vec4 colorImage = texture2D(image, vec2(fract(st.s), st.t));\n     material.alpha = colorImage.a * color.a;\n     material.diffuse = (colorImage.rgb + color.rgb)* 1.3 ;\n     return material;}", 
"ELLIPSE", "credit", "_sourcePrograms", "NEED", "gps2point", "fromQuaternion", "chart-popup3d-body", "Scanline", "LEFT_DOWN", "device-status-t0", '&filter=<Filter xmlns="http://www.opengis.net/ogc" xmlns:gml="http://www.opengis.net/gml"><Intersects><PropertyName>the_geom</PropertyName><gml:Point><gml:coordinates>', "_time", "handleQueryResult", "cursor", "getPoints", "sampler", "SCROLL", "normalMap", "stopsTimes", "addWall", "call", "subType", "renderPass_", "headAngle", "minHeight", "BillboardCollection", 
"ScrollWallImage", "arc", "need max and min when not auto", "hierarchy", "CylinderGlowCircleSource", "VelocityOrientationProperty", "pixelAspectRatio", "handleEditPlot", "/fangxiang.png", "[object Window]", "\n        uniform sampler2D colorTexture;\n        uniform vec2 colorTextureDimensions;\n        uniform sampler2D depthTexture;\n\n        uniform sampler2D maskTexture;\n        uniform sampler2D maskDepthTexture;\n        uniform float thresholdAngle;\n        uniform bool showOutlineOnly;\n         \n        uniform float outlineWidth;\n        uniform float devicePixelRatio;\n        uniform vec3 visibleEdgeColor;\n        uniform vec3 hiddenEdgeColor;\n        uniform bool useSingleColor;\n\n        varying vec2 v_textureCoordinates;\n  \n        float lengthSq(vec3 v){\n            return v.x * v.x + v.y * v.y + v.z * v.z;\n        }\n        float normal_angleTo(vec3 a,vec3 b){\n            float denominator =  sqrt(  lengthSq(a) * lengthSq(b) );\n            if ( denominator == 0. ) return czm_pi / 2.;\n            float theta = dot(a, b ) / denominator;\n            // clamp, to handle numerical problems\n            return  acos(  clamp( theta, - 1., 1. ) );\n        }\n\n        float compareNormal(vec4 n1,vec4 n2){\n              if(  abs (  normal_angleTo( n1.xyz , n2.xyz ) ) < thresholdAngle ){\n                  return 0.;\n              }else{\n                  return 1.;\n              }\n        }\n \n        float compareDepth(const in vec2 uv){\n            float maskDepth = czm_readDepth( maskDepthTexture, uv);\n            float nonDepth = czm_readDepth( depthTexture, uv);\n            return maskDepth>nonDepth?1.:0.;\n        }\n\n        void main(){\n\n            vec2 vUv=v_textureCoordinates;\n\n            // vec4 color = texture2D( colorTexture, vUv); \n            vec4 maskColor = texture2D( maskTexture, vUv);\n             \n            if( maskColor.a < 0.0001){\n                // gl_FragColor =color;\n                discard;\n                return;\n            }\n\n            vec2 invSize = outlineWidth / colorTextureDimensions;\n            vec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\n \n            vec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\n            vec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\n            vec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\n            vec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\n            \n            float d;\n            if(showOutlineOnly){\n                float diff1 = (c1.a - c2.a)*0.5;\n                float diff2 = (c3.a - c4.a)*0.5;\n                d = length( vec2(diff1, diff2) );\n            }\n            else{ \n                float diff1 = compareNormal(c1,c2)*0.5;\n                float diff2 = compareNormal(c3,c4)*0.5;\n                d = length( vec2(diff1, diff2) );\n            }\n                    \n            if(useSingleColor==false){\n                float dp1 = compareDepth( vUv + uvOffset.xy);\n                float dp2 = compareDepth( vUv - uvOffset.xy);\n                float dp3 = compareDepth( vUv + uvOffset.yw);\n                float dp4 = compareDepth( vUv - uvOffset.yw);\n            \n                float a1 = min(dp1, dp2);\n                float a2 = min(dp3, dp4);\n                float visibilityFactor = min(a1, a2);\n                vec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;\n            \n                // gl_FragColor =color+ vec4( edgeColor , 1. ) * vec4(d);\n                gl_FragColor = vec4( edgeColor , 1. ) * vec4(d);\n            }else{\n                // gl_FragColor =color+ vec4( visibleEdgeColor , 1. ) * vec4(d);\n                gl_FragColor =  vec4( visibleEdgeColor , 1. ) * vec4(d);\n            }\n        }\n        ", 
"Cesium-navigation/ResetViewNavigationControl:   options.defaultResetView Cesium Cesium.Rectangle is  invalid!", "removeById", "texture", "multipleRingBuffer", "setZIndex", "atan", "uniform sampler2D czm_selectedIdTexture; \nuniform float czm_selectedIdTextureStep; \nuniform float czm_selectedIdTextureWidth; \nbool czm_selected(vec4 id) \n{ \n    bool selected = false;\n    for (int i = 0; i < 1024000; i++) \n    { \n        vec4 selectedId = texture2D(czm_selectedIdTexture, vec2((float(i) + 0.5) * czm_selectedIdTextureStep, 0.5)); \n        if (all(equal(id, selectedId))) \n        { \n            return true; \n        } \n       if(float(i)>czm_selectedIdTextureWidth)break;\n    } \n    return false; \n} \n\n", 
"cartesian3", "circle", "IE_PROTO", "geodeticSurfaceNormal", "PerspectiveOffCenterFrustum", '</p>\n            </div>\n            <div class="hot-spot-line hot-spot-line-medium"></div>\n          </div>', "uniformMap", "addLayer", "heatmapConfig", "image/jpeg", "CloudType", "_viewMatrix", "defineProperties", "BYTES_PER_ELEMENT", "LabelStyle", "addSample", "requestImage", "EllipsoidGeometry", "focusIndex", "cesium-image-layer-split", "clone", "circleDsToPositions", "activeVideo", "invertClassification", 
"\u534a\u7403\u4f53", "extrudedPolygonE", "EllipsoidSurfaceAppearance", "getParticleImage", "draw_while_loading", "getVideoWallPlotCenterPosition", "getPointCoordinates", "createParticleSystem", "mousemoveEvent", "_lightPositionEC", "CESIUM_3D_TILE", "getRectanglePointsByTwoPoint", "getSize", "TWO_PI", "time", "width", "BuildGradientPrimitive", "removeFrustum", "CloudSource", "combinedUniforms1", "maximumRadius", "pte", "progressbar_foreground_color", "color:red;font-size:20px", "postProcess", "PostProcessStageLibrary", 
"dataConfig", "mapProjection", "Geometry", "createBookmark", "rotateInitialCursorAngle", "position:absolute;left:0px;bottom:0px;pointer-events: none", "getTailPoints", "mousePoint", "firstChild", "function", "simple-label-container", "reomveModelPrimitive", "\u8bf7\u786e\u8ba4\u9ad8\u5ea6\u662f\u975e\u96f6\u6570\u503c\uff01", "PathGraphics", "polylineBuffer", "object", "handlePickEditEntity", "changeColor", "amplitude", "getElementById", "drawRingCanvas", "EllipsoidStripeVerticalSource", "CircleDiffWall", 
"insertBefore", "shaderCache", "syncVEventHandle", "fan1", "setSelectedPlot", "tooltip", "ATTACK_ARROW", "swallowTailPnt", "getValue", "easingFunction3", "CubeMap", "getGeoPlotCenterPosition", "vjs-default-skin", "mountPoint", "czm_material czm_getMaterial(czm_materialInput materialInput)\n{\n   czm_material material = czm_getDefaultMaterial(materialInput);\n   vec2 st = materialInput.st;\n   vec4 colorImage = texture2D(image,  vec2(st ));\n   material.alpha = colorImage.a * color.a;\n   material.diffuse =  1.5* color.rgb  ;\n   return material;\n}", 
"getOwnPropertyDescriptor", "createGeometry", "createPrimitive", "setMapCenterByCameraPosition", "addPyramidModel", "BufferUsage", "then", "device-status-container-green", "navigationLocked", "from", "static/images/poi/float.png", '.MultiFieldAdaptWindow-container {\r\n    position: absolute;\r\n    left: 0px;\r\n    bottom: 0px;\r\n    min-width: 350px;\r\n    min-height: 200px;\r\n    color: white;\r\n}\r\n\r\n.MultiFieldAdaptWindow-container::before {\r\n    position: absolute;\r\n    content: "";\r\n    top: 100%;\r\n    left: calc(50% - 20px);\r\n    border: 20px solid transparent;\r\n    border-top: 40px solid rgba(30, 32, 42, 0.5);\r\n}\r\n\r\n.MultiFieldAdaptWindow-header {\r\n    height: 30px;\r\n    line-height: 30px;\r\n    color: white;\r\n    min-width: 200px;\r\n    padding: 0px 10px;\r\n    background: #1a4879;\r\n    border-top-right-radius: 4px;\r\n    border-top-left-radius: 4px;\r\n    position: relative;\r\n    user-select: none;\r\n}\r\n\r\n.MultiFieldAdaptWindow-close {\r\n    position: absolute;\r\n    right: 1px;\r\n    font-size: 25px;\r\n    cursor: pointer;\r\n    width: 29px;\r\n    text-align: center;\r\n}\r\n\r\n.MultiFieldAdaptWindow-close:hover {\r\n    background: #dc2929b9;\r\n}\r\n\r\n.MultiFieldAdaptWindow-body {\r\n    padding: 5px;\r\n    background: linear-gradient( 0deg, rgba(30, 32, 42, 0.5), rgba(13, 16, 19, 0.7));\r\n    border: 1px solid rgb(29, 26, 26);\r\n    border-top: 0px;\r\n    border-bottom-right-radius: 4px;\r\n    border-bottom-left-radius: 4px;\r\n}\r\n\r\n.MultiFieldAdaptWindow-info-item {\r\n    margin: 14px 0px;\r\n    max-width: 350px;\r\n}\r\n\r\n.MultiFieldAdaptWindow-ifno-label {\r\n    display: inline-block;\r\n    min-width: 60px;\r\n    text-align: justify;\r\n    text-align-last: justify;\r\n    background: #fff6f625;\r\n}\r\n\r\n.MultiFieldAdaptWindow-ifno-text {\r\n    background: #fff6f60e;\r\n}', 
"\n        varying vec3 vOutlineNormal;\n        void main(){\n            #ifdef HAS_NORMAL\n                vOutlineNormal = normal;\n            #else\n                #ifdef HAS_V_NORMAL\n                    vOutlineNormal = v_normal;\n                #else\n                    vOutlineNormal=vec3(0.);\n                #endif\n            #endif\n        }\n        ", " is not iterable!", "createBlackAndWhiteStage", "normal", "selected", "VideoWallPlotEditMove", "registerCoordinateSystem", "GradientSource", 
"createMaterial", "setPoints", '</div>\n                          <div class="label-content">\n                            <div class="data-li">\n                              <div class="data-label">\u5b9e\u65f6\u6d41\u91cf\uff1a</div>\n                              <div class="data-value">\n                                <span class="label-num">', "ConeGlowBottomCircleType", "resultPolylines", "startSceneEventListeners", "getBookmark", "getDistance", "midpoint", "\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a\u8d34\u5730\u591a\u8fb9\u5f62\u6587\u5b57\u8d34\u56fe\uff0c\u81f3\u5c11\u9700\u89813\u4e2a\u70b9", 
"ShadowMode", "unknown", "CESIUM\u7248\u672c\uff1a", "div", "handleEditVideoWallPlot", "getFramebuffer", "distanceLegendViewModel", "\u603b\u8ddd\u79bb\uff1a", "_domeVA", "speed", "response", "\u7eac\u5ea6\uff1a", "uniform float direction;uniform float speed;uniform vec4 u_color;czm_material czm_getMaterial( czm_materialInput cmi )\n                        {\n                            czm_material material = czm_getDefaultMaterial(cmi);\n                            vec2 st = cmi.st;\n                            float t = fract(speed*czm_frameNumber/1000.0) * direction;\n                            vec2 st1 = vec2(fract(st.s - t),st.t);\n                            vec4 color = vec4(0.,0.,0.,0.);\n                            float alpha = 1.-st.t;\n                            float value = fract(st1.s/0.25);\n                            alpha *= sin(value * 3.1415926);\n                            color = vec4(u_color.rgb * u_color.a, alpha * 1.2);\n                            material.diffuse = color.rgb;\n                            material.alpha = color.a;\n                            return material;\n                        }", 
"scanDirection", "addStates", "lonId", "maximumScale", "JSON", "SvgPathBindingHandler", "handleEditEntity", "pickIds", "PlotDrawEndEvent", "fit", "getData", "bottomPolygon", "_definitionChanged", "cylinderHeight", "random", "getBg", '.popup3d1-container {\r\n    min-height: 200px;\r\n    min-width: 350px;\r\n    background: #3183bdb0;\r\n    position: absolute;\r\n    left: 0px;\r\n    bottom: 0px;\r\n    cursor: default;\r\n}\r\n\r\n.popup3d1-container::before {\r\n    position: absolute;\r\n    content: "";\r\n    top: 100%;\r\n    left: calc(50% - 20px);\r\n    border: 20px solid transparent;\r\n    border-top: 40px solid #3183bdb0;\r\n}\r\n\r\n.popup3d1-header {\r\n    color: white;\r\n    background: #2152bb;\r\n    height: 30px;\r\n    line-height: 30px;\r\n}\r\n\r\n.popup3d1-header-title {\r\n    display: inline-block;\r\n    height: 100%;\r\n    margin-left: 5px;\r\n}\r\n\r\n.popup3d1-close {\r\n    position: absolute;\r\n    right: 1px;\r\n    font-size: 25px;\r\n    cursor: pointer;\r\n    width: 29px;\r\n    text-align: center;\r\n}\r\n\r\n.popup3d1-close:hover {\r\n    background: #dc2929b9;\r\n}\r\n\r\n.popup3d1-body {\r\n    padding: 10px;\r\n    color: white;\r\n}', 
"\n        <span>\u8bbe\u5907\u540d\u79f0\uff1a</span>\n        <span>", "content", "PolylineLightingType", "czm_selectedIdTextureStep", "_viewer", "isEmpty", "addPrimitive", "PolylineVolumeTrialSource", "getArrowBodyPoints", "_globeTranslucencyState", "m 66.5625,0 0,15.15625 3.71875,0 0,-10.40625 5.5,10.40625 4.375,0 0,-15.15625 -3.71875,0 0,10.40625 L 70.9375,0 66.5625,0 z M 72.5,20.21875 c -28.867432,0 -52.28125,23.407738 -52.28125,52.28125 0,28.87351 23.413818,52.3125 52.28125,52.3125 28.86743,0 52.28125,-23.43899 52.28125,-52.3125 0,-28.873512 -23.41382,-52.28125 -52.28125,-52.28125 z m 0,1.75 c 13.842515,0 26.368948,5.558092 35.5,14.5625 l -11.03125,11 0.625,0.625 11.03125,-11 c 8.9199,9.108762 14.4375,21.579143 14.4375,35.34375 0,13.764606 -5.5176,26.22729 -14.4375,35.34375 l -11.03125,-11 -0.625,0.625 11.03125,11 c -9.130866,9.01087 -21.658601,14.59375 -35.5,14.59375 -13.801622,0 -26.321058,-5.53481 -35.4375,-14.5 l 11.125,-11.09375 c 6.277989,6.12179 14.857796,9.90625 24.3125,9.90625 19.241896,0 34.875,-15.629154 34.875,-34.875 0,-19.245847 -15.633104,-34.84375 -34.875,-34.84375 -9.454704,0 -18.034511,3.760884 -24.3125,9.875 L 37.0625,36.4375 C 46.179178,27.478444 58.696991,21.96875 72.5,21.96875 z m -0.875,0.84375 0,13.9375 1.75,0 0,-13.9375 -1.75,0 z M 36.46875,37.0625 47.5625,48.15625 C 41.429794,54.436565 37.65625,63.027539 37.65625,72.5 c 0,9.472461 3.773544,18.055746 9.90625,24.34375 L 36.46875,107.9375 c -8.96721,-9.1247 -14.5,-21.624886 -14.5,-35.4375 0,-13.812615 5.53279,-26.320526 14.5,-35.4375 z M 72.5,39.40625 c 18.297686,0 33.125,14.791695 33.125,33.09375 0,18.302054 -14.827314,33.125 -33.125,33.125 -18.297687,0 -33.09375,-14.822946 -33.09375,-33.125 0,-18.302056 14.796063,-33.09375 33.09375,-33.09375 z M 22.84375,71.625 l 0,1.75 13.96875,0 0,-1.75 -13.96875,0 z m 85.5625,0 0,1.75 14,0 0,-1.75 -14,0 z M 71.75,108.25 l 0,13.9375 1.71875,0 0,-13.9375 -1.71875,0 z", 
"dayMaximumHeights", "addEntity", "_lateralSurfaceTranslucent", "skyBox", "tileXYToNativeRectangle", "endScale", "getHeight", "MeasureAreaVertex", "LEFT_UP", "Not a GIF file.", '#ifdef GL_OES_standard_derivatives\r\n    #extension GL_OES_standard_derivatives : enable\r\n#endif\r\n\r\nuniform bool u_showIntersection;\r\nuniform bool u_showThroughEllipsoid;\r\n\r\nuniform float u_radius;\r\nuniform float u_xHalfAngle;\r\nuniform float u_yHalfAngle;\r\nuniform float u_normalDirection;\r\nuniform vec4 u_color;\r\n\r\nvarying vec3 v_position;\r\nvarying vec3 v_positionWC;\r\nvarying vec3 v_positionEC;\r\nvarying vec3 v_normalEC;\r\n\r\nvec4 getColor(float sensorRadius, vec3 pointEC)\r\n{\r\n    czm_materialInput materialInput;\r\n\r\n    vec3 pointMC = (czm_inverseModelView * vec4(pointEC, 1.0)).xyz;\r\n    materialInput.st = sensor2dTextureCoordinates(sensorRadius, pointMC);\r\n    materialInput.str = pointMC / sensorRadius;\r\n\r\n    vec3 positionToEyeEC = -v_positionEC;\r\n    materialInput.positionToEyeEC = positionToEyeEC;\r\n\r\n    vec3 normalEC = normalize(v_normalEC);\r\n    materialInput.normalEC = u_normalDirection * normalEC;\r\n\r\n    czm_material material = czm_getMaterial(materialInput);\r\n\r\n    material.diffuse = u_color.rgb;\r\n    material.alpha = u_color.a;\r\n    // czm_lightDirectionEC\u5728cesium1.66\u5f00\u59cb\u52a0\u5165\u7684\r\n    return mix(czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC), vec4(material.diffuse, material.alpha), 0.4);\r\n\r\n}\r\n\r\nbool isOnBoundary(float value, float epsilon)\r\n{\r\n    float width = getIntersectionWidth();\r\n    float tolerance = width * epsilon;\r\n\r\n#ifdef GL_OES_standard_derivatives\r\n    float delta = max(abs(dFdx(value)), abs(dFdy(value)));\r\n    float pixels = width * delta;\r\n    float temp = abs(value);\r\n    // There are a couple things going on here.\r\n    // First we test the value at the current fragment to see if it is within the tolerance.\r\n    // We also want to check if the value of an adjacent pixel is within the tolerance,\r\n    // but we don\'t want to admit points that are obviously not on the surface.\r\n    // For example, if we are looking for "value" to be close to 0, but value is 1 and the adjacent value is 2,\r\n    // then the delta would be 1 and "temp - delta" would be "1 - 1" which is zero even though neither of\r\n    // the points is close to zero.\r\n    return temp < tolerance && temp < pixels || (delta < 10.0 * tolerance && temp - delta < tolerance && temp < pixels);\r\n#else\r\n    return abs(value) < tolerance;\r\n#endif\r\n}\r\n\r\nvec4 shade(bool isOnBoundary)\r\n{\r\n    if (u_showIntersection && isOnBoundary)\r\n    {\r\n        return getIntersectionColor();\r\n    }\r\n    return getColor(u_radius, v_positionEC);\r\n}\r\n\r\nfloat ellipsoidSurfaceFunction(vec3 point)\r\n{\r\n    vec3 scaled = czm_ellipsoidInverseRadii * point;\r\n    return dot(scaled, scaled) - 1.0;\r\n}\r\n\r\nvoid main()\r\n{\r\n    vec3 sensorVertexWC = czm_model[3].xyz;      // (0.0, 0.0, 0.0) in model coordinates\r\n    vec3 sensorVertexEC = czm_modelView[3].xyz;  // (0.0, 0.0, 0.0) in model coordinates\r\n\r\n    //vec3 pixDir = normalize(v_position);\r\n    float positionX = v_position.x;\r\n    float positionY = v_position.y;\r\n    float positionZ = v_position.z;\r\n\r\n    vec3 zDir = vec3(0.0, 0.0, 1.0);\r\n    vec3 lineX = vec3(positionX, 0 ,positionZ);\r\n    vec3 lineY = vec3(0, positionY, positionZ);\r\n    float resX = dot(normalize(lineX), zDir);\r\n    if(resX < cos(u_xHalfAngle) - 0.0001){\r\n        discard;\r\n    }\r\n    float resY = dot(normalize(lineY), zDir);\r\n    if(resY < cos(u_yHalfAngle)- 0.0001){\r\n        discard;\r\n    }\r\n\r\n\r\n    float ellipsoidValue = ellipsoidSurfaceFunction(v_positionWC);\r\n\r\n    // Occluded by the ellipsoid?\r\n\tif (!u_showThroughEllipsoid)\r\n\t{\r\n\t    // Discard if in the ellipsoid\r\n\t    // PERFORMANCE_IDEA: A coarse check for ellipsoid intersection could be done on the CPU first.\r\n\t    if (ellipsoidValue < 0.0)\r\n\t    {\r\n            discard;\r\n\t    }\r\n\r\n\t    // Discard if in the sensor\'s shadow\r\n\t    if (inSensorShadow(sensorVertexWC, v_positionWC))\r\n\t    {\r\n\t        discard;\r\n\t    }\r\n    }\r\n\r\n    // Notes: Each surface functions should have an associated tolerance based on the floating point error.\r\n    bool isOnEllipsoid = isOnBoundary(ellipsoidValue, czm_epsilon3);\r\n    gl_FragColor = shade(isOnEllipsoid);\r\n\r\n}', 
"online2", "createAxis", "layerid", "LabelCollection", "Transforms", "addFillFrustum", "values", "timeInfo", "currentRadius", "attribute vec4 position;\r\nattribute vec3 normal;\r\n\r\nvarying vec3 v_position;\r\nvarying vec3 v_positionWC;\r\nvarying vec3 v_positionEC;\r\nvarying vec3 v_normalEC;\r\n\r\nvoid main()\r\n{\r\n    gl_Position = czm_modelViewProjection * position;\r\n    v_position = vec3(position);\r\n    v_positionWC = (czm_model * position).xyz;\r\n    v_positionEC = (czm_modelView * position).xyz;\r\n    v_normalEC = czm_normal * normal;\r\n}", 
"_primitiveBias", "liquidFill", "tjxColor", "DEFAULT_VIEW_RECTANGLE", "getFrustumQuaternion", "PolylineMigrateSource", "0.2, 0.5, 1.0, 1.0", "COLOR_BUFFER_BIT", "property", "postRenderHandler", "divH", "_context", "dimensions", "_alpha", "locationBillboard", "swipeleft", "timoutId", "maximumSpeed", "translucency", "useLogDepth", "eastNorthUpToFixedFrame", "change:center", "wallMaterial", "0px", "SQUAD_COMBAT", "high", '.is-shulie {\r\n    width: 15px;\r\n    text-align: center;\r\n    background: transparent;\r\n    font-size: 9px;\r\n    font-weight: 600;\r\n    color: white;\r\n    font-family: "Microsoft YaHei", "Helvetica Neue For Number", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Hiragino Sans GB", "PingFang SC", "Helvetica Neue", Helvetica, Arial, sans-serif !important;\r\n    position: absolute;\r\n    display: block;\r\n    box-sizing: border-box;\r\n    pointer-events: none;\r\n}\r\n\r\n.is-shulie-item {\r\n    writing-mode: vertical-lr;\r\n    font-size: 16px;\r\n    letter-spacing: 4px;\r\n}\r\n\r\n.pre-topCard-list-item-line {\r\n    display: block;\r\n    height: 100px;\r\n    width: 1px;\r\n    margin-left: calc(50% + 2px);\r\n    margin-top: 3px;\r\n    background-color: #fff;\r\n}\r\n\r\n.pre-topCard-list-item-circle {\r\n    width: 10px;\r\n    height: 10px;\r\n    background-color: #fff;\r\n    border-radius: 50%;\r\n    margin-left: 5px;\r\n    margin-top: -10px;\r\n}', 
"normalOffsetScale", "east", "addPath", "device-num", "isMeasure", "duration3", '  <div class="popup3d1-container" v-if="show">\n          <div class="popup3d1-header">\n            <span class="popup3d1-header-title">  ', "/3.png", "PolylineLinkPulseSource", "initKeyEvent", "sigma", "c_h", "121415yuAcuq", "assign", "billboards", "addBookmark", "flowWallEntity", "PolylineMaterialAppearance", "updatePositionAction", "pixelMax", "getPolygonCoordinates", "area", "swallowTailFactor", "prepareMaterial", 
"vp_h", "origialImg", "bgUrl", "wStation", "gcj02tobd09", "CircleEmitter", "\u6309\u4e0b\u9f20\u6807\u5de6\u952e\u786e\u5b9a\u7b2c\u4e00\u4e2a\u70b9\u7684\u4f4d\u7f6e", "\nvec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\n\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\n\nconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\nconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\n\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\n\nconst float ShiftRight8 = 1. / 256.;\n\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\n\treturn r * PackUpscale;\n}\n\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\n\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\n\n// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\n\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\n\n// NOTE: https://twitter.com/gonnavis/status/1377183786949959682\n\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n", 
".stack-graphic-popup {\r\n    --padding-width: 10px;\r\n    text-align: center;\r\n    position: absolute;\r\n    pointer-events: none;\r\n}\r\n\r\n.stack-graphic-popup .stack-graphic-popup-panel {\r\n    padding: 10px 15px;\r\n    background-color: rgba(54, 54, 54, 0.6);\r\n    color: #fff;\r\n}\r\n\r\n.stack-graphic-popup .stack-graphic-popup-bottom {\r\n    width: 0;\r\n    height: 0;\r\n    border-top: 10px solid rgba(54, 54, 54, 0.6);\r\n    border-right: 10px solid transparent;\r\n    border-bottom: 10px solid transparent;\r\n    border-left: 10px solid transparent;\r\n    margin: auto;\r\n}", 
"slider", "loaded", "orientation", "activate", "log", "initHeights", '<div class="distance-legend" data-bind="visible: distanceLabel && barWidth"><div class="distance-legend-label" data-bind="text: distanceLabel"></div><div class="distance-legend-scale-bar" data-bind="style: { width: barWidth + \'px\', left: (5 + (125 - barWidth) / 2) + \'px\' }"></div></div>', "triangle", "startImgUrl", "crossOrigin", "fromRotationTranslation", "\n                            uniform vec4 color;\n                            uniform float repeat;\n                            uniform float offset;\n                            uniform float thickness;\n                            czm_material czm_getMaterial(czm_materialInput materialInput)\n                            {\n                                czm_material material = czm_getDefaultMaterial(materialInput);\n                                float sp = 1.0/repeat;\n                                vec2 st = materialInput.st;\n                                float dis = distance(st, vec2(0.5));\n                                float m = mod(dis + offset, sp);\n                                float a = step(sp*(1.0-thickness), m);\n                                material.diffuse = color.rgb;\n                                material.alpha = a * color.a * dis * 1.2;\n                                return material;\n                            }\n                        ", 
"boundingSphere", "enterPlotCodes", "animation", "primitive", "getView", "StopsArrivedEvent", "viewer1", "TEXT", "cartesian3ToPoint3D", "inverseTransformation", "Matrix4", "initSlider", "_renderPassCache", "handlePickGeoPlot", "addTrailLine", "leftClickEvent", "tileVisibleEventHandler", "centerAt", "PolylineLightingSource", "scaleByDistance", "terria", "rectangle", "transparencyIndex", "CylinderGlowGradientWallType", "Composite", "devicePixelRatio", "setData", "addScan1", "  czm_material czm_getMaterial(czm_materialInput materialInput) \n                        { \n                             czm_material material = czm_getDefaultMaterial(materialInput); \n                             vec2 st = materialInput.st; \n                             vec4 colorImage = texture2D(image, vec2(fract(st.t - time), st.t)); \n                             float powerRatio = fract(czm_frameNumber / 30.0) + 1.0; \n                             float alpha = pow(1.0 -  st.t, powerRatio);\n                             material.alpha = colorImage.a * color.a *alpha; \n                             material.diffuse =  1.5 * color.rgb  ; \n                             return material; \n                         } ", 
"getCameraFocus", "fromAxisAngle", "console", "PolylineSpriteSource", ".leaflet-popup-container {\r\n    position: absolute;\r\n    text-align: center;\r\n}\r\n\r\n.leaflet-popup-close-button {\r\n    position: absolute;\r\n    top: 0;\r\n    right: 0;\r\n    padding: 4px 4px 0 0;\r\n    text-align: center;\r\n    width: 18px;\r\n    height: 14px;\r\n    font: 16px/14px Tahoma, Verdana, sans-serif;\r\n    color: #c3c3c3;\r\n    text-decoration: none;\r\n    font-weight: bold;\r\n    background: transparent;\r\n    cursor: pointer;\r\n}\r\n\r\n.leaflet-popup-content-wrapper {\r\n    text-align: center;\r\n    max-height: 200px;\r\n    overflow-y: auto;\r\n    background: rgba(63, 72, 84, 0.7);\r\n    box-shadow: 0 3px 14px rgb(0 0 0 / 40%);\r\n    padding: 1px;\r\n    text-align: left;\r\n    border-radius: 4px;\r\n    padding: 8px;\r\n    color: white;\r\n}\r\n\r\n.leaflet-popup-tip-container {\r\n    margin: 0 auto;\r\n    width: 40px;\r\n    height: 20px;\r\n    position: relative;\r\n    overflow: hidden;\r\n}\r\n\r\n.leaflet-popup-tip {\r\n    background: rgba(63, 72, 84, 0.7);\r\n    box-shadow: 0 3px 14px rgb(0 0 0 / 40%);\r\n    width: 17px;\r\n    height: 17px;\r\n    padding: 1px;\r\n    margin: -10px auto 0;\r\n    transform: rotate( 45deg);\r\n}", 
"EditMoveCenterPositoin", "boxShadow", "lct", "backgroundImage", "RGBA", "horizontalAngle", "draw", "registEvent", "hemisphere", "uvs", "attackarrow", "http://api1.map.bdimg.com/customimage/tile?&x={x}&y={y}&z={z}&scale=1&customid=", "LL2MC", "fields", "createCanvas", '.popup3d2-container {\r\n    width: 350px;\r\n    height: 200px;\r\n    background: #14193399;\r\n    position: absolute;\r\n    left: 0px;\r\n    bottom: 0px;\r\n    cursor: default;\r\n}\r\n\r\n.popup3d2-container::before {\r\n    content: "";\r\n    width: calc(100% + 22px);\r\n    height: 39px;\r\n    position: absolute;\r\n    bottom: -39px;\r\n    left: -22px;\r\n    background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAB4AAAAAlCAYAAACj1PQVAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyhpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTQ1IDc5LjE2MzQ5OSwgMjAxOC8wOC8xMy0xNjo0MDoyMiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTkgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MTJFMTU1RjExN0UzMTFFOTg3RTBFODdGNTY0NThGQkUiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MTJFMTU1RjIxN0UzMTFFOTg3RTBFODdGNTY0NThGQkUiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDoxMkUxNTVFRjE3RTMxMUU5ODdFMEU4N0Y1NjQ1OEZCRSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDoxMkUxNTVGMDE3RTMxMUU5ODdFMEU4N0Y1NjQ1OEZCRSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pj97JFoAAAV9SURBVHja7N1faJ1nHQfw33nzpuekaZfWNFmbLHXWdf7DWgvebF4M0SEZhTG8mKvFyzG9UJFKh9peVGnd0DkE/10Ic6s6BBEGbshggho3BVGnRnC2s1n/ras2J2uzc05PXp+3yZzSm7XJkvfi84HveZ9z3ve8F7/bL8/71oqiiMs8NhCLsCllfcpfAwAAAAAAAIDlsXM68jfgtl9K2Z3Sa8IAAAAAAAAAb7hjKW8uF9kS3/jdKR9PaZkxAAAAAAAAwPJa6h3A96X0pBxK+bLxAgAAAAAAACyfpSyAP5jy4ZQXUh747687p00ZAAAAAAAAYBlkS3if+xfW+1MuGC0AAAAAAADA8lqqAnh3yvaUZ1MeMlYAAAAAAACA5bcUBXBfyoGF9edSusYKAAAAAAAAsPyWogD+VMpYypMpTxgpAAAAAAAAwMpYbAG8IWVvylzKHuMEAAAAAAAAWDmLLYC/mDKQ8nDKH4wTAAAAAAAAYOUspgC+IeWelNmYL4IBAAAAAAAAWEGLKYAPpfSmfD1lyigBAAAAAAAAVtbVFsA3pdyR8lLMF8EAAAAAAAAArLCrKYBrKfcvHA+kNI0RAAAAAAAAYOVdTQFc7vwtdwA/l/ItIwQAAAAAAACohistgMt3/h5cWO9N6RghAAAAAAAAQDVcaQF8d8rWlImUnxgfAAAAAAAAQHVcSQF8Tcq+lCJlz8IRAAAAAAAAgIq4kgK4fOTzUMzv/J0wOgAAAAAAAIBqeb0F8FjKp2P+nb97jQ0AAAAAAACgel5vAXwgpS/l2ynPGRsAAAAAAABA9eSjd370sh+P7/q/r9tTdqc0Y74IBgAAAAAAAKCC8v9Zl7uB6yn9o4fHG+lYS2n/867Hv5bXivLcoZQzRgYAAAAAAABQTfnw5nvjxWMHe9N6cP+OyVtv2nj2ruFG6209WbGqM5c181rx9m5RO/ngn2/4zlf/tLV2fNfPCmMDAAAAAAAAqJ68LH+HGq2xRz7wu2+8a31zvCgiLs5FlC3vqp4YKS8638mzqZf7tqXlb1MuGBsAAAAAAABA9ZSPdh58tfyd7UScOh9xYjqLszNZlGVwN6U/71z7hR1/e/g9g9NbRg+P9xobAAAAAAAAQPVk+3ZMfujV8vf0TC3WXWzE9ZveHyNjt0UxOxCnp7NotiPWr2pfl67dk/6zxtgAAAAAAAAAqie7eePZXeVO33OtiOGsHqtvfjDi1scibnkkesafipHVI3HuQi3a3Yh3rpsZT/+5ZvTweM3oAAAAAAAAAKolH2q0byzf+dtuZ9G/8b0RW+587ezat0a84xPR+8z+aHU7MVDvbLhl05lrf3FyaGr08Hj5muA4/qMfmiIAAAAAAABABWS1KPJLTW75UR+8/Ir6uksvCi6K+a/Dfa26sQEAAAAAAABUT/ZyJz+Z19IiL6J7eiLi/NRrZ4tuxNEfRzvmorcnoj2XvfL41MZTMV8XAwAAAAAAAFAh2eS5tU9kWcRAo4ipC9MRP98ZMfnNiH/8IOLJO+LMC7+ORl83Gj0RR5r9z8x08nOhAAYAAAAAAAConPyzT2976H1D//7YYL21ZW5NN442n4/ep/ddeuxzK+air68bb2pEdCN75dEj192Xfp4xNgAAAAAAAIDqyWY6+akHnt16d7Oz6uRAPWJkoIi1azuxek0nhge6MdQXUatlrZ8+P/L5706+ZSLKXhgAAAAAAACAyik3+s5+/++bJ+751fbbfv/S+kc7c/l0WQSva0TUe2rtIzNrJr7yxxs/8pnfbPteurY5vPlej38GAAAAAAAAqKC8LHRfPHZw9penNvwl5ZP1nrmB268/MdafX+x96sTQ8aMz/f9K102ntJS/AAAAAAAAANX1HwEGAM75MhcANnAkAAAAAElFTkSuQmCC) 0px 0px no-repeat;\r\n    background-position: 0px 0px;\r\n}\r\n\r\n.popup3d2-header {\r\n    height: 30px;\r\n    color: white;\r\n    background: #1f3f8e;\r\n    line-height: 30px;\r\n}\r\n\r\n.popup3d2-title {\r\n    display: inline-block;\r\n    height: 100%;\r\n    margin-left: 5px;\r\n    padding-left: 5px;\r\n}\r\n\r\n.popup3d2-close {\r\n    position: absolute;\r\n    right: 1px;\r\n    font-size: 25px;\r\n    cursor: pointer;\r\n    width: 29px;\r\n    text-align: center;\r\n}\r\n\r\n.popup3d2-close:hover {\r\n    background: #dc2929b9;\r\n}\r\n\r\n.popup3d2-body {\r\n    padding: 10px;\r\n    color: white;\r\n}', 
".div-mask {\r\n    background: #0000;\r\n    position: absolute;\r\n    left: 0px;\r\n    top: 0px;\r\n    width: 100%;\r\n    height: 100%;\r\n    box-shadow: inset 1px 0px 500px 170px #000000;\r\n    pointer-events: none;\r\n    z-index: 999;\r\n}", "createXaxis", "ConeGlowBottomCircle", "videoTexture", "topUrl", "videoElement", "u_type", "depthFailMaterial", "return", "shaderSource", "pickEllipsoid", "/2.png", "xt3d-logo-img", "Material", "multiplyByScalar", "TextMapPlotEditVertex", "visibilitychange", 
"setAlpha", "WGSe2", "getModelMatrix", "activate must be implemented in the derived class.", "removeEventListener", "ClassificationPrimitive", "onResize", "version", "fragmentShaderSource", "ymax", "hedronCenter", "sceneFramebuffer", "WGS84", "handleCameraMoveEvent", ' .video-popup3d-container {\r\n     min-width: 250px;\r\n     min-height: 200px;\r\n     max-width: 400px;\r\n     max-height: 400px;\r\n     background: #14193399;\r\n     position: absolute;\r\n     left: 0px;\r\n     bottom: 0px;\r\n     cursor: default;\r\n }\r\n \r\n .video-popup3d-container::before {\r\n     content: "";\r\n     width: calc(100% + 22px);\r\n     height: 39px;\r\n     position: absolute;\r\n     bottom: -39px;\r\n     left: -22px;\r\n     background: url(../../../../static/images/popup3d/popup3d.png) 0px 0px no-repeat;\r\n     background-position: 0px 0px;\r\n }\r\n \r\n .video-popup3d-header {\r\n     height: 30px;\r\n     color: white;\r\n     background: #1f3f8e;\r\n     line-height: 30px;\r\n }\r\n \r\n .video-popup3d-header-title {\r\n     display: inline-block;\r\n     height: 100%;\r\n     margin-left: 5px;\r\n }\r\n \r\n .video-popup3d-close {\r\n     position: absolute;\r\n     right: 1px;\r\n     font-size: 25px;\r\n     cursor: pointer;\r\n     width: 29px;\r\n     text-align: center;\r\n }\r\n \r\n .video-popup3d-close:hover {\r\n     background: #dc2929b9;\r\n }\r\n \r\n .video-jd-temp {\r\n     width: 400px;\r\n     height: 240px;\r\n }', 
"getMatrix3", "symbol-registry", '  <div class="popup3d2-container" v-if="show">\n          <div class="popup3d2-header">\n            <span class="popup3d2-title">  ', "axisList", "PixelFormat", "polygonHierarchy", "startPosition", "Symbol.", "totalArea", "labelEntity", "device-status-container", "LineFlowWall", "flyToBoundingSphere", "webMercator2LonLat", "toCssColorString", "bufCount", "outWidth", "clockwise", "getScanOrientation", "EventHelper", "is-shulie-item", "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAEACAYAAADSoXR2AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTQ1IDc5LjE2MzQ5OSwgMjAxOC8wOC8xMy0xNjo0MDoyMiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTkgKFdpbmRvd3MpIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjExQTg0NDEyMDEzQjExRUFBNDhBRjhGMUMzOUUyNTU0IiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjExQTg0NDEzMDEzQjExRUFBNDhBRjhGMUMzOUUyNTU0Ij4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6MTFBODQ0MTAwMTNCMTFFQUE0OEFGOEYxQzM5RTI1NTQiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6MTFBODQ0MTEwMTNCMTFFQUE0OEFGOEYxQzM5RTI1NTQiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz41vRwAAAAE90lEQVR42uydyW4UMRCG3T2dgYSAEGs4sp44cCJBcGUJbwCvALwWPAI8ABwAiUVwgLBdkEikJEiAGMhkZqhfU1aa1sy0g+yaJPyWSupOpPjz0uVyucrJer2eG2fJ3ZgLAQhAgC0PgN8XIlkqgGLE75oih0WmRVZEvop0rHog18rnRe6IzInsthyCXFt+TuSKyGmRXZZDgK5eFrkv8l7kiUhrxN/JSo3pigSvcNmI1bCh3b5LK2+NqHyvyEF9x3z5HgqRRViOAXhW5JrCoNdei/y20gMYxhmRSyIXRY6JTMT4DENLW+SdyD19x/NajDmwmYIW79Hnn+MA4GJEAAIQgABJbMJB+n5Sl9zWZvR9DABUfkJkVt8fi3zUldAEoKl24Y2S1fPZEmBdZFHkkb4vxTLRQ5djbyUf0ncYrD/UADUB8MZno2Q19yx7gIqIAAQgAAEIQIAtYZT+85LvRnjQCoPKR3rQUgN4Y3ZeK30g8qps0qeeAzDn4TWD9+ySG+BBS90DaGnVg9a2tgnR4il9/jkOACoiAhCAAASIZpAAFl6yulO0JACo/IDrn6CedP1zxOciv6wAYNnAP3RVBeWtJQCWzG8iL/X9g4vkqNzMctzUXtintt2KM/aS+bmQaY90rb8CF6tSKiICEIAABCAAAQiwbfcFIWVCbUcc9bZDLKiYAKj4uOv7Bb+ILLj+8W7PCgC7Jhzv44Qdh9yrru8V61jPgd645gD2io+15RiC5ZA5ENNPmGmDmtrta9YAVEQE2FlrQUM/J6efU8cSAD87ojodBaccS6kgiiErGiq/qe93XT+3oGU5BJnbyKrIUs6BQZoQUEcrQ7CYagiGqeKiMgnXLXsg5uJUm/RQJKy8fGS7PMw6SgVQPrJFGZr0kCfUL/7IFjIzrLGpemBQ0kPbehL6I9vMjUh6oEVEAAIQgAAEIAABdpyj0qcK71YrqGUJANNrv+sHOcAiRpDDM1cTY1BEHk7kqyP/2Ac5vLEEQEG8aDnIoTb5ObZRWg5ywG5o1dX4ClNYxT7IISgJPsXGpLut9MCWU0S5bqkmdAa3LQEwcZDAfkZ3tthQfkwNkVeeD6kiuaUabcp6DpS9YyalrAdQ8bT1EFQVUabarND9fNuyB2gREYAABCAAAQhAAAIQoM770UgBXARCIr/koDogVlzgrWuxemBKd0m4JnBed0+5ZQ9gn3BK5LK+P4y5ewoB8DFiKO91COLFfwVuTCZV1hSoYw1APZCsFIkbN1Haaa87wwiKQe6eT27AEX6esPVVd8/kOOdAz/oz9FE0p+uGIKUeqE5C8xgSKiICEIAABCAAAQhAAAIQgAAEIAABCECA6AA+sbkREyDUUYlKD6ggZwzRkr8tewBhusisv+0in5qE/hFchoZTE0TL4p8sTbtIpyahQ4Ag5fKpSVBmfdDECvQTZjoM0U9N6KgkwH9xY7PXpPiCmq5yuaLVldHIO7jgNi5XfOEhCqNh9udHV/RnC5YAUDTftdV4/ivvwEoRVS9XXPWa1FIT5ird8jpSB+BDN3rO8AaGMnGy0I0QRYTvdk6NkOsucuhGCMAgI8Q0isaHbmAevNMhiD4P6iZhstANGiQE2PEGCRo2NcgAsQDwKnxWFdlT17/duWU1BJmuHz6A5bwbEsCScgh+qAHit3Jr1oooOPExdRBLbeJjSpuwuy30AAH+CDAAPH5ltESNYl4AAAAASUVORK5CYII=", 
"div-mask", "min", "tiles", "SingleTileImageryProvider", "sideRes", "baseHeight", "\n                attribute vec3 position3DHigh;\n                attribute vec3 position3DLow;\n                attribute vec3 normal;\n                attribute vec2 st;\n                attribute float batchId;\n                varying vec2 v_st;\n                varying vec3 v_normalEC;\n                varying vec3 v_positionEC;\n                void main()\n                {\n                    vec4 p = czm_translateRelativeToEye(position3DHigh,position3DLow);\n                    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;\n                    v_normalEC = czm_normal * normal;\n                    v_st=st;\n                    gl_Position = czm_modelViewProjectionRelativeToEye * p;\n                }", 
"handler", "height", "wallEntity", "strokeType", "getIteratorMethod", "DataLoadedEvent", "points", "Zoom ", "MilitaryPlotEditVertex", "_billboardCollection", "opaqueFrustumNearOffset", "logDepth", "halfAngle must be greater than or equal to zero.", "_debugFrustum", "viewport", "animatorMoveendEvent", "getPointCount", "bufDis", "COLUMBUS_VIEW", "moveRight", "CylinderGlowCircleType", "CYAN", "viewShadowMap", "KEY", "plotPointsToPositions", "bounceHeight", "device-status-t1", "ASSAULT_DIRECTION", "multiplyByVector", 
"CLOSED_CURVE", "shouldAnimate", "tailWidthFactor", "PI_OVER_TWO", "duration", "autoRadiusConfig", "stRotation", "\u5de6\u952e\u70b9\u51fb\u786e\u5b9a\u6a21\u578b\u4f4d\u7f6e", "CylinderGeometry", "fov", "orbitMouseMoveFunction", "czm_material czm_getMaterial(czm_materialInput materialInput)\n {\n      czm_material material = czm_getDefaultMaterial(materialInput);\n      vec2 st = materialInput.st;\n      vec4 colorImage = texture2D(image, vec2(fract(st.t - time), st.t));\n      material.alpha = colorImage.a * color.a;\n      material.diffuse =  1.9 * color.rgb  ;\n      return material;\n  }", 
"_domeFrontCommand", "measureEnd", "toArray", "addModel", "drawResultLine", "e_sq", "processData", "generatSectorPoints", "WGSF", "\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a\u6587\u672c\uff0c\u9700\u89811\u4e2a\u70b9", "isActive", "_lastLegendUpdate", "fenceEntity", "initLeftDownEventHandler", "ringCanvas", "material", "getTranslation", "dispose", "_sectorBackCommand", "valueOf", "Cannot call a class as a function", "HDR", "parentSelected", "Polygon", "getSiteTimes", "EARTHRADIUS", "moveBackward", 
"riverPrimitive", "ConeGlowBottomRotateCircleType", "initMouseMoveEvent", "\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a\u77e9\u5f62\uff0c\u9700\u89812\u4e2a\u70b9", "unit", "lineColor", "postRenderEventHandle", "MIDDLE_DOWN", "fromRadians", "\u7b80\u5355\u6587\u672c", "virtual", "\uff0c\u6700\u5c11\u9700\u89813\u4e2a\u70b9", "bd09togcj02", "addSatellite", "gatheringplace", "http://shangetu1.map.bdimg.com/it/u=x={x};y={y};z={z};v=009;type=sate&fm=46", "inner_controlPoints", "addEllipse", "fragmentShader", 
"enableRotate", "createNightVisionStage", "vertexEntities", "PerspectiveFrustum", "renderPass", "_scanePlaneSP", "ConeGlowBottomCircleMaterialProperty", "status", "    me_isSelected=czm_selected()?1.:0.;\n", "_scanUniforms", "store", "ImageryProvider", "loadGif", "sourceShaders", "\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a\u591a\u8fb9\u4f53\uff0c\u81f3\u5c11\u9700\u89813\u4e2a\u70b9", "chart", "queryByPoint", "maximumParticleLife", "fire", "xt3d-logo-text", "pickPosition", "gradients-label-container", 
"removeChild", "stack-graphic-popup-panel", "enableTilt", "Pass", "\u6309\u4e0b\u9f20\u6807\u5de6\u952e\u786e\u5b9a\u7b2c1\u4e2a\u70b9", "img", "_sectorSegmentLineVA", "swipeRight", "setCursor", "uniform vec4 u_color;\nczm_material czm_getMaterial(czm_materialInput materialInput){\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    vec2 st = materialInput.st;\n    float time = fract(czm_frameNumber / 90.) ;\n    vec2 new_st = fract(st-vec2(time,time));\n    vec4 color = texture2D(image,new_st);\n\n    vec3 diffuse = color.rgb;\n    float alpha = color.a;\n    diffuse *= u_color.rgb;\n    alpha *= u_color.a;\n    alpha *= u_color.a;\n    material.diffuse = diffuse;\n    material.alpha = alpha * pow(1. - st.t,u_color.a);\n    return material;\n}", 
"MIDDLE_UP", "normalize", "collection", ": can't set as prototype!", "_position", "slicePartitions", "styleSheet", "M 7.5,0 C 3.375,0 0,3.375 0,7.5 0,11.625 3.375,15 7.5,15 c 3.46875,0 6.375,-2.4375 7.21875,-5.625 l -1.96875,0 C 12,11.53125 9.9375,13.125 7.5,13.125 4.40625,13.125 1.875,10.59375 1.875,7.5 1.875,4.40625 4.40625,1.875 7.5,1.875 c 1.59375,0 2.90625,0.65625 3.9375,1.6875 l -3,3 6.5625,0 L 15,0 12.75,2.25 C 11.4375,0.84375 9.5625,0 7.5,0 z", "tileVisible", "Html", "pre-topCard-list-item-circle", 
"TimeInterval", "getPostion", "relativeAmount", "_sectorFrontCommand", "toStringTag", "PolylineEnergyTransSource", "maximumDistance", "addAnimatorEvent", "play", "extent", "mesureResultEntity", "headHeightFactor", "registerEvens", "MultiFieldAdaptWindow-info-item", "generateCircle", "CLAMPED", "selectedPlot", "_offsetHeight", "FLOAT", "getElementsByClassName", "targetLeaveHedronEvent", "gif", "LEFT_DOUBLE_CLICK", "xaxis", "PolylineArrowMaterialProperty", "updateColor", "when", "activateContainer", 
"removeInputAction", "addSideWall", "convertor", "putImageData", "#define ", "_scanePlaneXHalfAngle", "lctSize", "Lobster Two", "pixelRange", "plot", "PerInstanceColorAppearance", "</td>\n                </tr>", "getFeature", "handlePickPlot", "hidden", "depthTest", "TEXTURED", "camera", "stages", "fillFrustum", "initLeftClickEventHandler", "czm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    vec2 st = materialInput.st;\n    float t = time;\n    t *= 1.03;\n    float alpha = smoothstep(t- 0.1, t, st.s) * step(-t, -st.s);\n    alpha += 0.1;\n    material.diffuse= color.rgb;\n    material.alpha = alpha;\n    return material;\n}\n", 
"getRotation", "EncodedCartesian3", "unifiedHeight", "_rectangleNortheastInMeters", "orbitCursorOpacity", "positionToTileXY", "imagerySplitPosition", "apply", "entities", "cluserImages", "geom", "LinearGradient", "positionCartographic", "hiddenAreaColor", "createchart", "applyGravity", "/keduzhi.png", "handleMoveEvent", "calculateExtent", "getFog_fs", "map", "initEvent", "globeDepth", "GeometryInstance", "trails", "rgba(255, 255, 255, 1.0)", "color:", "sqrt", "fillStyle", "showFloor", "open", "getFullYear", 
"toCartesian", "addCircles", "setColumn", "selectedPlotChanged", "ColorBlendMode", "initTip", "getViewPitch", "superGif", "_textureSize", "__core-js_shared__", "__proto__", '<div class="compass" title="" data-bind="visible: showCompass, event: { mousedown: handleMouseDown, dblclick: handleDoubleClick }"><div class="compass-outer-ring-background"></div>', "getE3CoordinateSystem", "CylinderGlowCircle", "GeoPlotEditMove", "UNSIGNED_BYTE", "plotBase", "LinearGradientType", "isOpened", "generate", "tileXYToRectangle", 
"freehandpolygon", "onFreeze", "dataURLtoBlob", "defaultValue", "credit must not be called before the imagery provider is ready.", "cylinderEntity", "cssColor", "6339896KtFIlH", "geometry", "clampToHeight", "scanPlaneMode", "pickId", "getNavigationLocked", "\u6309\u4e0b\u9f20\u6807\u53f3\u952e\u53d6\u6d88\u7ed8\u5236", "closePath", "MCBAND", "initEventHandler", "GeoJsonDataSource", "getTextMapPlotCenterPosition", "MC2LL", "gradientslabel", "EditablePolygon", "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAACYCAYAAACS0lH9AAAACXBIWXMAAAsTAAALEwEAmpwYAAAJ0GlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNi4wLWMwMDIgMTE2LjE2NDY1NSwgMjAyMS8wMS8yNi0xNTo0MToyMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOkRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDplODY0YmNmNy1lZGIyLWIyNDQtYWI0NC04OWZkNmMwOTQ4MDYiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NjIyOGMxMDUtODFmZS00MjAxLWIwOTEtZDkwMGI0NTI0NWMwIiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9IjcxNzA5OEJGODAwODNEREJGRDQyQzAzMzQ5NDlDRDFDIiBkYzpmb3JtYXQ9ImltYWdlL3BuZyIgcGhvdG9zaG9wOkNvbG9yTW9kZT0iMyIgcGhvdG9zaG9wOklDQ1Byb2ZpbGU9IiIgdGlmZjpJbWFnZVdpZHRoPSI1MTIiIHRpZmY6SW1hZ2VMZW5ndGg9IjE1MiIgdGlmZjpQaG90b21ldHJpY0ludGVycHJldGF0aW9uPSIyIiB0aWZmOlNhbXBsZXNQZXJQaXhlbD0iMyIgdGlmZjpYUmVzb2x1dGlvbj0iMS8xIiB0aWZmOllSZXNvbHV0aW9uPSIxLzEiIHRpZmY6UmVzb2x1dGlvblVuaXQ9IjEiIGV4aWY6RXhpZlZlcnNpb249IjAyMzEiIGV4aWY6Q29sb3JTcGFjZT0iNjU1MzUiIGV4aWY6UGl4ZWxYRGltZW5zaW9uPSI1MTIiIGV4aWY6UGl4ZWxZRGltZW5zaW9uPSIxNTIiIHhtcDpDcmVhdGVEYXRlPSIyMDIxLTAyLTIzVDEwOjAyOjQxKzA4OjAwIiB4bXA6TW9kaWZ5RGF0ZT0iMjAyMS0wMi0yM1QxMDowODo0NCswODowMCIgeG1wOk1ldGFkYXRhRGF0ZT0iMjAyMS0wMi0yM1QxMDowODo0NCswODowMCI+IDx4bXBNTTpIaXN0b3J5PiA8cmRmOlNlcT4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOmZmYTk5ZjhhLTdiZmQtNDcxNi04MTgwLWJmZTUyMmFmNGUzNSIgc3RFdnQ6d2hlbj0iMjAyMS0wMi0yM1QxMDowODo0NCswODowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDIxLjIgKE1hY2ludG9zaCkiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249ImNvbnZlcnRlZCIgc3RFdnQ6cGFyYW1ldGVycz0iZnJvbSBpbWFnZS9qcGVnIHRvIGltYWdlL3BuZyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0iZGVyaXZlZCIgc3RFdnQ6cGFyYW1ldGVycz0iY29udmVydGVkIGZyb20gaW1hZ2UvanBlZyB0byBpbWFnZS9wbmciLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjYyMjhjMTA1LTgxZmUtNDIwMS1iMDkxLWQ5MDBiNDUyNDVjMCIgc3RFdnQ6d2hlbj0iMjAyMS0wMi0yM1QxMDowODo0NCswODowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDIxLjIgKE1hY2ludG9zaCkiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPC9yZGY6U2VxPiA8L3htcE1NOkhpc3Rvcnk+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOmZmYTk5ZjhhLTdiZmQtNDcxNi04MTgwLWJmZTUyMmFmNGUzNSIgc3RSZWY6ZG9jdW1lbnRJRD0iNzE3MDk4QkY4MDA4M0REQkZENDJDMDMzNDk0OUNEMUMiIHN0UmVmOm9yaWdpbmFsRG9jdW1lbnRJRD0iNzE3MDk4QkY4MDA4M0REQkZENDJDMDMzNDk0OUNEMUMiLz4gPHBob3Rvc2hvcDpEb2N1bWVudEFuY2VzdG9ycz4gPHJkZjpCYWc+IDxyZGY6bGk+NzE3MDk4QkY4MDA4M0REQkZENDJDMDMzNDk0OUNEMUM8L3JkZjpsaT4gPC9yZGY6QmFnPiA8L3Bob3Rvc2hvcDpEb2N1bWVudEFuY2VzdG9ycz4gPHRpZmY6Qml0c1BlclNhbXBsZT4gPHJkZjpTZXE+IDxyZGY6bGk+ODwvcmRmOmxpPiA8cmRmOmxpPjg8L3JkZjpsaT4gPHJkZjpsaT44PC9yZGY6bGk+IDwvcmRmOlNlcT4gPC90aWZmOkJpdHNQZXJTYW1wbGU+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+h9EbuwAAA01JREFUeJzt3TuOFVkQBNDoJhmEkDBgZv8L5GMgIcRvHg5ryDTiHKn98Co67q16T4/HYwIAVHm+DgAA7FMAAKCQAgAAhSbJ03UIAGCXBQAACikAAFDIEQAAFLIAAEAhBQAACikAAFBoogQAQB0PfwAopAAAQCGvAQJAIQsAABSyAABAIQsAABSyAABAIQUAAAo5AgCAQr4ECACFPPwBoJACAACFHAEAQCEPfwAoZAEAgEIe/gBQyAIAAIU8/AGgkAUAAAr5LQAAKOS/fwAoZAEAgELuAABAIQsAABRSAACgkAIAAIXcAQCAQhYAAChkAQCAQgoAABRSAACgkIc/ABSaJC+uQwAAu7wFAACFFAAAKDR//wCAIhYAACjkEiAAFLIAAEChSfLyOgQAsMuXAAGgkLcAAKCQAgAAhbwFAACFFAAAKOQIAAAKTZJ/rkMAALsUAAAo5AgAAAr5EiAAFFIAAKCQOwAAUEgBAIBCk+TVdQgAYNckeXMdAgDYNUneXocAAHZNkvfXIQCAXZPkv+sQAMCuSfLvdQgAYNckeXcdAgDY5RIgABSaJK+vQwAAu/wWAAAUmiRP1yEAgF2T5HEdAgDYNUl+XocAAHZNkm/XIQCAXZPky3UIAGDXJPl8HQIA2DVJPl6HAAB2TZIP1yEAgF2T5NN1CABgl0uAAFBokny9DgEA7Jok369DAAC7JsmP6xAAwC4FAAAK+S0AACikAABAoUny6zoEALDLHQAAKKQAAEAhRwAAUGiS/L4OAQDsUgAAoJAjAAAopAAAQKFJ8v91CABgly8BAkChSfK4DgEA7PIWAAAUsgAAQCFvAQBAIQsAABRSAACgkEuAAFDo+ToAALDPlwABoJACAACFFAAAKOQtAAAoZAEAgEIWAAAopAAAQCEFAAAKuQMAAIUsAABQyKeAAaCQBQAACrkDAACFHAEAQCELAAAUsgAAQCELAAAUsgAAQCELAAAUsgAAQCEFAAAKOQIAgEIWAAAo5LcAAKCQAgAAhRwBAEAhCwAAFLIAAEAhCwAAFLIAAEAhBQAACvkSIAAUsgAAQCEFAAAKKQAAUMhrgABQyAIAAIUUAAAo5AgAAApZAACgkAIAAIUUAAAo5A4AABT6A6gaPQ6/wRIfAAAAAElFTkSuQmCC", 
"createOrientation", "Camera", "labelHtml", "params", "getLoop", "isOrbiting", "key", "refreshBegin", "addFan3", "mousemove", "getArrowHeadPoints", "bottomRadius", "zeroToTwoPi", "meters", "fromHeadingPitchRoll", "\u6309\u4e0b\u9f20\u6807\u5de6\u952e\u786e\u5b9a\u4f4d\u7f6e", "postStage", "bottom", "http://online1.map.bdimg.com/tile/?qt=tile&x={x}&y={y}&z={z}&styles=", "PolylineTrailType", "silhouetteColor", "divLng", "chart-popup3d-container", "MapVLayer", "TRANSLUCENT", " Iterator", "defineProperty", 
"ver", "handleEditGeoPlot", "subtract", "xt3dLogo", "ConeGlowBottomCircleImage", "rgb(255, 255, 255)", "mapVOptions", "xmin", "prevStageUpdate", "rotateFrame", "getHeadingByOString", "_scanRadialCommand", "trailLineInfo", "specify totalArea if auto resize", "AnimateStartEvent", "addModelPrimitive", "_showThroughEllipsoid", "POLYLINE", "contains", "PolygonHierarchy", "rectangleToNativeRectangle", "militaryPlotLayer", "ellipsoidFill", "Accessors not supported!", "viewMatrix", "lngLatToMercator", "get_canvas", 
"fill", "createElement", "StartEvent", "Framebuffer", "EndEvent", "addFan1", "xmax", "SceneMode", "measureHeight", "_DRAW", "animator", '  <div class="MultiFieldAdaptWindow-container" v-if="show">\n          <div class="MultiFieldAdaptWindow-header">\n            <span class="MultiFieldAdaptWindow-title">  ', ");  background-size: cover;", "PolygonGeometry", "MousePoint", "POSITIVE_INFINITY", "split", "booleanClockwise", "addGeometry", "rightWC", "innerCircleMaterial", "mouseClickPosition", "registerLeftDownEvent", 
"ConeGlowBottomRotateCircleMaterialProperty", "scanType", "__created", "getRain_fs", "data:image/octet-stream;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAUCAYAAAB7wJiVAAACgklEQVRoQ9WZi27DIAxFIeGX9n53//9FBTy5rSNESDC2U2mVqkQRgc7X1wczDwC/zrmQUgrzPM+3a3DOzeVzvL99L89zzmGapss953k5pnG/rAcAwXuP83rH+AAAeO+Tc27km3POaZqmRNfB9/G9rHmf1osx5hDC8ts9AJzqoHKD1xm3Eos7/iYKSxDnHBTBzKOBbYxXz5FSypjbkt/iz+fzKYSwCh45pifWqFO2xhfOIMdNDIPQkO4fDwAZnaR0htpZJFaMMZXOIPHQIT/czKUyxnXQVvCZ62GScD+arNa8WyaCyTwoyDcGKMYYNE4hsbgiNBxxcWn1XCwIOQIAkoAxS6BrVgiZk1NK6Yro63WrnKEgX0VZWuBaZjG3fDEdtMUWMdgrjnTL1y0YFhltMUcqwU6CjAJ4CZ4VQ+oyJgW7kTPMWMF1RsmQT2ZNb7qnB32la0zB7pyzyOhD50CHfBzAkK6DmAxhg13pDLUjqAzWjOkxo2YJCTJasqzG77mO1hCD3cgRSxMo6StGeyQU5L0sK1sA33o+yhDulnm0Y5eCXdmXmHfsKMibkCGc7FaNkYLdyBmHsmJv2/tqwRArp9yrY6eASPsKrbO2OnZ0CApixYRyni7Ymc5kg13pDAtHYA+0bBAkzEFBXsrAjHbsWmcwd1tisNe7L2nnfq+OHQV53jsOZ2axihWVQ1tzSU5+/13Hju5CQZ72mrvOsUm3LHHPtkiU2jFSsCv7EhJzVX5GmUOs4HbsJIgVQ5pOGRWl4UrTjp3EktT40b6is8aKWyjIo4Yh3L5i4P8grVNfNtiVzjisY+eKj4I8HHwexXEfh0FisCt3X6ujeG5wN8bt7ub+ANZIqbIlvAh5AAAAAElFTkSuQmCC", 
"location", "alpha", "close", "mbDis", "distance", "addGltfEntity", "delta", "getTileCredits", "getViewHeading", "normal 60px MicroSoft YaHei", "baseWaterColor", "ellipse", "MeasureEndEvent", "_rectangle", "invisibleColor", "editPositions", "viewEntity", "setPointVisible", "freehandline", "gravity", "viewPitch", "60\u7c73", "center", "VertexArray", "set", "body", "DrawEndEvent", "topRadius", "\u65b9\u5411\uff1a", "BlurComposite", "hpr", "PolylineObject", "shaderProgram", "getNumberOfYTilesAtLevel", 
"low", "setPrototypeOf", "updateCallback", "addColorStop", "shader", "this.radius must be greater than or equal to zero.", "softShadows", "\u7f16\u8bd1\u65f6\u95f4\uff1a2022-02-18 11:15", "round", "drawSketch", "unwrap", "positionWC", "createDocumentFragment", "register", "indexs", "zoomEndEvent", "video-popup3d-header-title", "autoMaxMin", "clearMidVertex", "isArray", "fhPrimitives", "equalsEpsilon", "slice", "CylinderGraphics", "bookmarkList", "bgColor", "ConeEmitter", "setNavigationLocked", "head", 
"_aspectRatio", "featureCollection", "PolylineGlowMaterialProperty", "PolylineSuperType", "labels", "knockout", "_horizontalAngle", "dataToPoint", "data-li-state", "bgImageUrl", "x-user-defined", "Cartographic", "toRadians", "appendChild", "OrthographicFrustum", "preUpdateEvent", "scanRadius", "floatMarker", "progressbar_background_color", "DEPTH_COMPONENT", "getMilitaryPlotCenterPosition", "showSectorSegmentLines", "_tilingScheme", "LIME", "get_atan", "vp_l", "text/plain; charset=x-user-defined", 
"minimumClusterSize", "hammerjs", "_sectorLineCommand", "polyline", "EditableMarker", "speedVector", "clock_onTickHandler", "feature", "write", "insertAt", "wallColor", "reduce", "emitterModelMatrix", "_color", "value", "derivedCommands", "removeCircleEntity", "PolylineTrialFlow", "syncV1ToV2", "verticalOrigin", "geoPlotLayer", "elevation", "addEnt", "undefined", "czm_material czm_getMaterial(czm_materialInput materialInput)\n{\n     czm_material material = czm_getDefaultMaterial(materialInput);\n     vec2 st = materialInput.st;\n     vec4 colorImage = texture2D(image,  vec2(st ));\n     material.alpha = colorImage.a * color.a;\n     material.diffuse =  1.5* color.rgb  ;\n     return material;\n }", 
"PostProcessStageSampleMode", "WebMercatorProjection", "img_z", "tileHeight must not be called before the imagery provider is ready.", "EllipsoidStripeVerticalType", "imgHeight", "queryResultFeatures", "siteTimes", "Particle", "vertexIndex", "uniform sampler2D colorTexture;\n  uniform sampler2D depthTexture;\n  varying vec2 v_textureCoordinates;\n  void main(void)\n  {\n      vec4 origcolor=texture2D(colorTexture, v_textureCoordinates);\n      vec4 fogcolor=vec4(0.8,0.8,0.8,0.5);\n      float depth = czm_readDepth(depthTexture, v_textureCoordinates);\n      vec4 depthcolor=texture2D(depthTexture, v_textureCoordinates);\n      float f=(depthcolor.r-0.7)/0.2;\n      if(f<0.0) f=0.0;\n      else if(f>1.0) f=1.0;\n      gl_FragColor = mix(origcolor,fogcolor,f);\n   }", 
"swipeLeft", "createE_MaskRegion", "PolylineSpriteType", "openEditMode", "createContent", "online3", "\u89c6\u9ad8\uff1a", "cartesianToCartographic", "image", "heading", "ellipsoidStroke", "czm_material czm_getMaterial(czm_materialInput materialInput)\n{\n     czm_material material = czm_getDefaultMaterial(materialInput);\n     vec2 st = materialInput.st;\n     vec4 colorImage = texture2D(image, vec2(fract(st.t - time), st.t));\n     material.alpha = colorImage.a;\n     material.diffuse = colorImage.rgb * 1.3 ;\n     return material;\n }", 
"vid", "createVideoEle", "methods", "animatorMovestartEvent", "toDegrees", "initMouseTip", "validate", "requestImage must not be called before the imagery provider is ready.", "LinearGradientSource", "_container", "String", "IDENTITY", "percent", "near", "point", "pointEdit", "point2dToPoint3d", "maximumLevel", "EMPTY_OBJECT", "cloudEntity", "cirdrawGradientCircleCanvas", "DODGERBLUE", "newDiv", "normal 24px MicroSoft YaHei", "getCluserImage", "CIRCLE", "enableCursorStyle", "frustumCommandsList", 
"PolylineDashMaterialProperty", "_scene", "contentWindow", "extType", "terria is required", "_unsubcribeFromPostRender", "preUpdateHandle", ");\n}\n", ");\n    }\n    return isSelected;\n}\n    ", "createStartEntity", "scanHeading", "createExtrudedPolygon", "xHalfAngle", "cancelFlight", "curve", "_subdomains", "__esModule", "editEntity", "Super expression must either be null or a function, not ", "default", "getBoundingClientRect", "resize", "eEntity", "removeFrustunPrimitive", "circles", "shaderProgramId", 
"getOwnPropertySymbols", "generatePolyline", "enableLook", '<div class="hot-spot">\n            <div class="hot-spot-board hot-spot-board-medium">\n              <h5> ', "MultiFieldAdaptWindow-body", "setSelected", "preUpdateHandle1", "getHierarchy", "getDerivedResource", "editVertext", "createPropertyDescriptor", "far", "_rendererResources", "generatePoints", "initDom", "multiplyByMatrix3", "Accept-Charset", "addPostProcess", "CallbackProperty", "text/css", "\u897f\u5317\u98ce", "stop", "Ray", "GeoPlot", 
"clusterImage", "AnimateEndEvent", "_lightCamera", "eof", "setEndPoints", "southwest", "position-info-status-bar", "LineFlowWallSource", "pixelFormat", "corridor", " <div class=\"compass-rotation-marker\" data-bind=\"visible: isOrbiting, style: { transform: 'rotate(-' + orbitCursorAngle + 'rad)', '-webkit-transform': 'rotate(-' + orbitCursorAngle + 'rad)', opacity: orbitCursorOpacity }, cesiumSvgPath: { path: svgCompassRotationMarker, width: 145, height: 145 }\"></div> <div class=\"compass-outer-ring\" title=\"\" data-bind=\"style: { transform: 'rotate(-' + heading + 'rad)', '-webkit-transform': 'rotate(-' + heading + 'rad)' }, cesiumSvgPath: { path: svgCompassOuterRing, width: 145, height: 145 }\"></div> <div class=\"compass-gyro-background\"></div> <div class=\"compass-gyro\" data-bind=\"cesiumSvgPath: { path: svgCompassGyro, width: 145, height: 145 }, css: { 'compass-gyro-active': isOrbiting }\"></div></div><div class=\"navigation-controls\">\x3c!-- ko foreach: controls --\x3e<div data-bind=\"click: activate, attr: { title: $data.name }, css: $root.isLastControl($data) ? 'navigation-control-last' : 'navigation-control' \">   \x3c!-- ko if: $data.hasText --\x3e   <div data-bind=\"text: $data.text, css: $data.isActive ?  'navigation-control-icon-active ' + $data.cssClass : $data.cssClass\"></div>   \x3c!-- /ko --\x3e  \x3c!-- ko ifnot: $data.hasText --\x3e  <div data-bind=\"cesiumSvgPath: { path: $data.svgIcon, width: $data.svgWidth, height: $data.svgHeight }, css: $data.isActive ?  'navigation-control-icon-active ' + $data.cssClass : $data.cssClass\"></div>  \x3c!-- /ko --\x3e </div> \x3c!-- /ko --\x3e</div>", 
"PlotEditEndEvent", "enable", "\u8bbe\u5907\u72b6\u6001\uff1a", "setCharts", "setCenter", "destroy", "normalShadingSmooth", "multiply", "GET", "fromCharCode", "DISABLED", "positions", "pick", "_direction", "hanging", "\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a\u666e\u901a\u5899\u4f53\uff0c\u6700\u5c11\u9700\u89812\u4e2a\u70b9\u3002", "translucent", "smoke", "getContext", "startnalysis", "ymin", "getDataURL", "_computedScanPlaneModelMatrix", "Gradient", "type", "stops", "\nvarying float me_isSelected;\nbool czm_selected(){\n    bool isSelected= me_isSelected>0.0000001;\n    if(!isSelected){\n        isSelected= czm_selected(", 
"yHalfAngle", "options", "mapvBaseLayer", "updateLabel", "UNSIGNED_SHORT", "createFrusum", "deActiveVideo", "viewHeading", "fcPrimitives", "updateCesium", "_frontFaceRS", "czm_material czm_getMaterial(czm_materialInput materialInput)\n    {\n         czm_material material = czm_getDefaultMaterial(materialInput);\n         vec2 st = materialInput.st;\n         vec4 colorImage = texture2D(image, vec2(fract(count*st.t - time), fract(st.s)));\n         material.alpha = colorImage.a * color.a;\n         material.diffuse =  1.5* color.rgb  ;\n         return material;\n     }", 
"_origin", "\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a", "canvasLayer", "addCilcle", "_verticalAngle", "fromElements", "</label>\uff1a", "xt3d", "_positionWC", "recToPolygon", "read", "depthBias", "range", "tan", "projection", "imageToCanvas", "clickEvent", "data", "\n                            uniform vec4 color;\n                            uniform float repeat;\n                            uniform float offset;\n                            uniform float thickness;\n                            czm_material czm_getMaterial(czm_materialInput materialInput)\n                            {\n                                czm_material material = czm_getDefaultMaterial(materialInput);\n                                float sp = 1.0/repeat;\n                                vec2 st = materialInput.st;\n                                float dis = distance(st, vec2(0.5));\n                                float m = mod(dis + offset, sp);\n                                float a = step(sp*(1.0-thickness), m);\n                                material.diffuse = color.rgb;\n                                material.alpha = a * color.a;\n                                return material;\n                            }\n                        ", 
"off", "getMagnitude", "HeadingPitchRange", "filter", "WALL", "Hammer", "save", "line", "setMouseTipContent", "fromUniformScale", "overrideMimeType", "getLineStringCoordinates", "timeSum", "hot-spot-board", "floor", "headWidthFactor", "varying", "lerp", "resolutions", "setSelectedPlotByCode", "done", "frameState", "asin", "moveForward", "join", "createEditVertex", "northeast", "MORPHING", "terminator", "innerMoveEnd", "tabindex", "bottomImage", "EditMove", "registerMouseMoveEvent", "position:absolute;height:80px;width:80px;pointer-events:none", 
"appearance", "addVisibleRegion", "download", "addSeconds", "reset", "englishTitle", "rgba(255,0,22,.8)", "EditEndEvent", "czm_material czm_getMaterial(czm_materialInput materialInput)\n{\n     czm_material material = czm_getDefaultMaterial(materialInput);\n     vec2 st = materialInput.st;\n     vec4 colorImage = texture2D(image,  vec2(st ));\n     material.alpha = colorImage.a * color.a*0.6;\n     material.diffuse =  2.2* color.rgb  ;\n     return material;\n }", "cssClass", "czm_material czm_getMaterial(czm_materialInput materialInput) { \n    czm_material material = czm_getDefaultMaterial(materialInput); \n    vec2 st = materialInput.st;\n    if(move){\n        float r = sqrt((st.x-0.8)*(st.x-0.8) + (st.y-0.8)*(st.y-0.8));\n        float r2 = sqrt((st.x-0.2)*(st.x-0.2) + (st.y-0.2)*(st.y-0.2));\n        float z = cos(moveVar.x*r + czm_frameNumber/100.0*moveVar.y)/moveVar.z;\n        float z2 = cos(moveVar.x*r2 + czm_frameNumber/100.0*moveVar.y)/moveVar.z;\n        st += sqrt(z*z+z2*z2);\n        st.s += reflux * czm_frameNumber/1000.0 * speed;\n        st.s = mod(st.s,1.0);\n    }\n    if(flipY){\n        st = vec2(st.t,st.s);\n    }\n    vec4 colorImage = texture2D(image, st);\n    material.alpha = alpha;\n    material.diffuse = colorImage.rgb; \n    return material; \n}", 
"\n        <span>\u8bbe\u5907\u7f16\u53f7\uff1a</span>\n        <span>", " km", "prevStageExecute", "addPoint", "addAminateModel", "observable", "headingPitchRollQuaternion", "amd", "polylineEntity", "/1.png", "isEnabledTime", "Polyline", "removeByPlotCode", "czm_material czm_getMaterial(czm_materialInput materialInput){\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    vec2 st = materialInput.st;\n    vec2 center = st - vec2(0.5,0.5);\n    float time = -czm_frameNumber * 3.1415926 / 180.;//\u626b\u63cf\u901f\u5ea61\u5ea6\n    float sin_t = sin(time);\n    float cos_t = cos(time);\n    vec2 center_rotate = vec2(center.s*cos_t-center.t*sin_t+0.5,center.s*sin_t+center.t*cos_t+0.5);\n    vec4 color = texture2D(image,center_rotate);\n    vec3 tColor = color.rgb * u_color.rgb;\n    tColor *= u_color.a;\n    material.diffuse = tColor;\n    float length = 2. - length(center)/0.5;\n    material.alpha = color.a * pow(length, 0.5);//color.r = 0 \u62161\n    return material;\n}", 
"#ffff00ab", "delayTime", "materialType", "_attributeLocations", "MultiPolygon", "c_w", "domId", "Map3dTools", "backgroundColor", "HAS_V_NORMAL", "fromTranslationRotationScale", "onTick", "\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a\u7acb\u4f53\u5899\u6587\u5b57\u8d34\u56fe\uff0c\u9700\u89812\u4e2a\u70b9", '</span>\n            <span class="popup3d1-close" title="\u5173\u95ed"  >\u00d7</span>\n          </div>\n          <div class="popup3d1-body">\n          ', "debugFrustum", "parentNode", "popup3d1-close", 
"number", "GradientType", "\nbool czm_selected(){ \n    return czm_selected(", "addToScene", "nodeType", "czm_material czm_getMaterial(czm_materialInput materialInput)\n { czm_material material = czm_getDefaultMaterial(materialInput); vec2 st = materialInput.st;\n    vec4 colorImage = texture2D(image, vec2(fract(st.s - time), st.t));\n     material.alpha = colorImage.a * color.a;\n     material.diffuse = (colorImage.rgb + color.rgb)* 2.5 ;\n     return material;}", "HAS_NORMAL", "left", "shadowMap", 
"setContent", "frustum", "ArrayBuffer", "handlePickHouse", "state", "fcDataServerBaseUrl", " is not a function!", "MeasureAreaResult", "UNIT_X", "isTranslucent", "Unnamed Control", "TextMapPlotEditMidVertex", "czm_material czm_getMaterial(czm_materialInput materialInput)\n { czm_material material = czm_getDefaultMaterial(materialInput); vec2 st = materialInput.st;\n    vec4 colorImage = texture2D(image, vec2(fract( count * st.s - time),fract(st.t)));\n     material.alpha =  colorImage.a * color.a;\n     material.diffuse =  color.rgb *3.0 ;\n     return material;}", 
"(); \n", "createEndEntity", "clearAnimateEntity", "models", "target", "21056SnAoSb", "_us", "computeCirclularFlight", "PointObject", "online6", "addClampFeature", "PolylineSprite", "bjColor", "TextMapPlotEditMove", "handleFhQueryResult", "clusterEvent", "isInRange", "north", "CYLINDER", "hdr", "visible", "\u8ba1\u7b97\u5de6\u53f3\u4fa7\u70b9\u51fa\u95ee\u9898\uff01", "west", "WGSa", "DiffCircleMaterial1Type", "$container", "chart-body", "ScanCircleSource", "\u4e1c\u5357\u98ce", "ePosition", "className", 
"video", "toWGS84", " markdown", "TextMapPlot", "DARKGREEN", "forEach", "BASEGRADIENT", "WaterPlugin", "zoomStartEvent", "zoom", "_textureAtlasGUID", "GLOBE", "_tileHeight", "font", "angle", "edgeCount", "\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a\u5706\uff0c\u9700\u89812\u4e2a\u70b9\u3002", "DiffCircleMaterial1", "\u591a\u8fb9\u5f62\u6587\u5b57\u8d34\u56fe", "\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a\u77e9\u5f62\uff0c\u9700\u89812\u4e2a\u70b9\u3002", "navigationDiv", "vertical", "vp_t", "showFrustum", 
"moveStart", "specify width and height if not auto resize", "createPolygonEntity", '&filter=<Filter xmlns="http://www.opengis.net/ogc" xmlns:gml="http://www.opengis.net/gml"><Intersects><PropertyName>the_geom</PropertyName><gml:Polygon><gml:outerBoundaryIs><gml:LinearRing><gml:coordinates>', "HEMISPHERE", "vmInstance", "CloudMaterialProperty", "\u76ee\u6807\u4f4d\u7f6e", "assaultdirection", "addWindowEvent", "PositionPick", "symbol", "initDynamicWall", "addInnerCircle", "FrustumOutlineGeometry", 
"ellipsoid", "auto", "geoJsonDataSource", "LineString", "max_width", "echartMap", "getTimestamp", "app", "generatePolygon", "12fYtIAq", "passes", "billboardEntity", "moveHandler", "Event", "setPolygonCenter", "particleSize", "markerEntity", "south", "removeEffect", "shadowMaps", "midPosition", "_shadowMapMatrix", "NETSCAPE", "appearance1", "showIntersection", "marker", "unRegisterEvents", "\u6309\u4e0b\u9f20\u6807\u53f3\u952e\u7ed3\u675f\u7ed8\u5236", "getPositions", "PolylineEnergyTransType", "M 72.46875,22.03125 C 59.505873,22.050338 46.521615,27.004287 36.6875,36.875 L 47.84375,47.96875 C 61.521556,34.240041 83.442603,34.227389 97.125,47.90625 l 11.125,-11.125 C 98.401629,26.935424 85.431627,22.012162 72.46875,22.03125 z", 
"opacity", "applyBindings", "getMonth", "czm_material czm_getMaterial(czm_materialInput materialInput)\n{\n     czm_material material = czm_getDefaultMaterial(materialInput);\n     vec2 st = materialInput.st;\n     vec4 colorImage = texture2D(image,   vec2(fract(st.s + time),fract(st.t)));\n     material.alpha = colorImage.a * color.a  ;\n     material.diffuse =  1.3 * color.rgb  ;\n     return material;\n }", "zoomTo", "arraybuffer", "\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a\u89c6\u9891\u5899\uff0c\u9700\u89812\u4e2a\u70b9\u3002", 
"exportImage", "PolylineVolumeTrialType", "extent is empty", "outerHTML", "fillColor", "normal 28px MicroSoft YaHei", "angleBetween", "RoamEndEvent", "show_progress_bar", "createPostStage", "addOuterCircle", "scale", "defined", "flyHome", "LineFlowWallType", "CLAMP_TO_GROUND", "_slices", "modelMatrix", "catesian3ToDegrees", "fillRect", "requestRender", "otherwise", "deactivate", "updateOrientation", "svgWidth", "stack-graphic-popup-bottom", "chartOption", "orbitLastTimestamp", "_xHalfAngle", "getWeak", 
"circular_clone_topPoints", "video-popup3d-container", "RECTANGLE", "_selectedIdTexture", "distanceDisplayCondition", "moveStartEvent", "this hasn't been initialised - super() hasn't been called", "style", "initAnimator", "createShadowMap", "CalculateCoordinates", "Texture", "defines", "setPositionsHeight", "neckHeightFactor", "interlaced", "wgs84ToWindowCoordinates", "push", "getFlagForKeyCode", "enableInputs", "current_frame", "\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a\u8d34\u5730\u591a\u8fb9\u5f62\u6587\u5b57\u8d34\u56fe\uff0c\u6700\u5c11\u9700\u89813\u4e2a\u70b9\u3002", 
"label-led-container", "SceneDominate", "plotName", "clientWidth", "PolylineTrailSource", "\u5206\u961f\u6218\u6597\u5c3e", "graphic", "initWall", "rgba(255,255,255,0)", "markdown-it", "jsgif_toolbar", "tailedattackarrow", "czm_non_", "chineseTitle", "viewportScale", "getSnow_fs", "\u8fdb\u653b\u65b9\u5411\u5c3e", "lateralSurfaceMaterial", "ScreenSpaceEventHandler", "yaxis", "enu_to_ecef", "computeViewRectangle", "ColorType", "out", "czm_material czm_getMaterial(czm_materialInput materialInput)\n { czm_material material = czm_getDefaultMaterial(materialInput); vec2 st = materialInput.st;\n    vec4 colorImage = texture2D(image, vec2(fract( count * st.s - time),fract(st.t)));\n     material.alpha =  colorImage.a * color.a;\n     material.diffuse =  color.rgb *1.5 ;\n     return material;}", 
"gltfPlotLayer", "cPrimitive", "online1", "_value", "4251730zGsyRD", "$body", "useGlobeDepthFramebuffer", "createMaterialAppearance", "addBottomCircle", "http://211.149.185.229:8080/", "terrainShadows", "startSync", "ConeGlowBottomCircleSource", "\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a\u666e\u901a\u56f4\u680f\uff0c\u6700\u5c11\u9700\u89812\u4e2a\u70b9\u3002", "unRegisterMouseEvents", "pickFromRay", "/home_icon_19.png)", "aspectRatio", "FILL_AND_OUTLINE", "radar", "invertClassificationColor", "test", 
"_speed", "negate", "setHeading", "mouseMoveEvent", "rgba(238,103,98,0.5)", "_sources", "OPAQUE", "track", "disposalMethod", "cylinderPrimitive", "reserved", "VERTEX_FORMAT", "_translucent", "lineWidth", "createEditMoveCenterEntity", "/faguang.png", "PixelDatatype", "12859QXirjc", "polygonEdit", "OrthographicOffCenterFrustum", "scene.png", "\u5b57\u6bb5\u548c\u503c\u5fc5\u987b\u4e3a\u6570\u7ec4\u7c7b\u578b", "\u7acb\u4f53\u89c6\u9891\u5899", "createPositionProperty", "argCheck", "MultiFieldAdaptWindow-ifno-text", 
"rotateMouseMoveFunction", "ClassificationType", "\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a\u666e\u901a\u5899\u4f53\uff0c\u6700\u5c11\u9700\u89812\u4e2a\u70b9", "liquidfill_", "Math", "static/images/excavate/excavate_bottom_min.jpg", "passState", "dataSet", "isAnimating", "loop_mode", "overrideViewport", "controls", "bindingHandlers", "isOpening", "createSilhouetteStage", "replace", "player", "LINES", "moveEnd", "OutlineEffect", "normal 42px MicroSoft YaHei", "initLeftUpEventHandler", "PostProcessStageComposite", 
"createW_MaskRegion", "find", "progressbar_height", "getIterator", "project", "CullFace", "bold ", "vertexs", "depthStencilTexture", "czm_material czm_getMaterial(czm_materialInput materialInput)\n{\nczm_material material = czm_getDefaultMaterial(materialInput);\nmaterial.diffuse = 1.8 * color.rgb;\nvec2 st = materialInput.st;\nfloat dis = distance(st, vec2(0.5, 0.5));\nfloat per = fract(time);\nif(dis > per * 0.5){\nmaterial.alpha = 0.0;\ndiscard;\n}else {\nmaterial.alpha = color.a  * dis / per / 1.0;\n}\nreturn material;\n}", 
"setFrustumVisible", "clearData", "addRadarScan", "getArrowPoints", "\u535a\u5ba2\uff1ahttps://blog.csdn.net/xietao20/", "bottomRotateCircle", "activeVideoListener", "error", "_maximumLevel", "data:image/png;base64,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", 
"TimeIntervalCollection", "_height", "spacing", "LOOP_STOP", "transform", "root", "_uniforms", ' <div class="info-item info-item-close">\n         <span class="info-close" title="\u5173\u95ed" id=\'closeId\'>\u00d7</span>\n       </div>\n       <div class="info-item">\n         <span class="info-label">\u7ecf\u5ea6\uff1a</span>\n         <span class="info-label lonId"  >{{ point.x.toFixed(10)}}</span>\n       </div>\n       <div class="info-item">\n         <span class="info-label">\u7eac\u5ea6\uff1a</span>\n         <span class="info-label latId"  >{{point.y.toFixed(10)}}</span>\n       </div>\n       <div class="info-item">\n         <span class="info-label">\u9ad8\u5ea6\uff1a</span>\n         <span class="info-label altId" >{{point.z.toFixed(10)}}</span>\n       </div>', 
"tooltip-container", "$label", "rightClickEvent", "lng", "setPointCoordinates", "createMidVertex", "videoInfo", "addFlowWall", "getDistanceByLL", "video-popup3d-body", "neckAngle", "flag", "wgs84togcj02", "application/x-mpegURL", "setCamera", "/90+.png", "cluster2", "scanPlaneColor", "total", "_shadowMapTexture", "czm_material czm_getMaterial(czm_materialInput materialInput)\n \n       {\n \n          czm_material material = czm_getDefaultMaterial(materialInput);\n \n           material.diffuse = 1.5 * color.rgb;\n\n           vec2 st = materialInput.st;\n\n           vec3 str = materialInput.str;\n\n           float dis = distance(st, vec2(0.5, 0.5));\n\n           float per = fract(time);\n\n           if (abs(str.z) > 0.001) {\n\n            discard;\n\n        }\n\n        if (dis > 0.5) { \n\n            discard; \n\n        } else { \n\n            float perDis = 0.5 / count;\n\n            float disNum; \n\n            float bl = .0; \n\n            for (int i = 0; i <= 999; i++) { \n\n                if (float(i) <= count) { \n\n                    disNum = perDis *float(i) - dis + per / count; \n\n                    if (disNum > 0.0) { \n \n                        if (disNum < perDis) { \n\n                            bl = 1.0 - disNum / perDis;\n\n                        }\n  \n                        else if(disNum - perDis < perDis) { \n \n                            bl = 1.0 - abs(1.0 - disNum / perDis); \n\n                        } \n  \n                        material.alpha = pow(bl, gradient); \n\n                    } \n\n                } \n\n            } \n\n        } \n\n        return material; \n\n    } \n", 
"ShowGeometryInstanceAttribute", "_size", "Vector", "generateEntity", "addLabel", "SMOKE", "showSectorLines", "vp_w", "_yHalfAngle", "DistanceDisplayConditionGeometryInstanceAttribute", "spaceDistance", "PolylineSuper", "PolylineMigrateType", "PolylineArrowOpacitySource", "queryBySQL", "Blur2", "combinedUniforms2", "/home_icon_21.png)", "ready", "readyPromise", "initCameraParam", "point-sample-label-text", "point-sample-label-container", "gltfEntity", "readByte", "glowRangeHeight", "offsetHeight", 
"varying vec3 v_positionMC;\nvarying vec3 v_positionEC;\nvarying vec2 v_st;\n\nvoid main()\n{\n    czm_materialInput materialInput;\n\n    vec3 normalEC = normalize(czm_normal3D * czm_geodeticSurfaceNormal(v_positionMC, vec3(0.0), vec3(1.0)));\n    #ifdef FACE_FORWARD\n        normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\n    #endif\n\n    materialInput.s = v_st.s;\n    materialInput.st = v_st;\n    materialInput.str = vec3(v_st, 0.0);\n\n    // Convert tangent space material normal to eye space\n    materialInput.normalEC = normalEC;\n    materialInput.tangentToEyeMatrix = czm_eastNorthUpToEyeCoordinates(v_positionMC, materialInput.normalEC);\n\n    // Convert view vector to world space\n    vec3 positionToEyeEC = -v_positionEC;\n    materialInput.positionToEyeEC = positionToEyeEC;\n\n    czm_material material = czm_getMaterial(materialInput);\n\n    #ifdef FLAT\n        gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n    #else\n        gl_FragColor = czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);\n    #endif\n}\n", 
"getPositionCount", "Out", "_root", "length", "screenSpaceCameraController", "); \n}", "rgba(255, 255, 255, 0.0)", "orbitTickFunction", "charCodeAt", "bounceMarker", "\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a\u5706\uff0c\u9700\u89812\u4e2a\u70b9", "Lines2Plane", "rgb(255,255,255)", "clientY", "\n                   uniform vec4 color; \n                   czm_material czm_getMaterial(czm_materialInput materialInput)\n                   {\n                       czm_material material = czm_getDefaultMaterial(materialInput); \n                       vec2 st = materialInput.st;  \n                       material.diffuse = color.rgb; \n                       float alpha = pow(st.t,1.0); \n                       material.alpha = color.a  * alpha;                            \n                       return material;\n                   }\n                   ", 
"Mask", "azimuth", "excavateDepth", "particleSystem", "selectedEntityChanged", "fromCartesian", "FINE_ARROW", "document", "classList", "xt3d-logo-container", "getLabelEntityPosition", "distanceLabel", "/150+.png", "vertexFormat", "autoResize", "_useHdr", "\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a\u9762\uff0c\u6700\u5c11\u9700\u89813\u4e2a\u70b9\u3002", "Rectangle", "refreshing", "video-popup3d-close", "custom", "_defaultColorTexture", "PostProcessStage", "\nvarying vec2 v_textureCoordinates;\nuniform sampler2D colorTexture;\nuniform vec2 colorTextureDimensions;\nuniform vec2 direction;\nuniform float kernelRadius;\n\nfloat gaussianPdf(in float x, in float sigma) {\n    return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n}\nvoid main() {    vec2 vUv=v_textureCoordinates;\n    vec2 invSize = 1.0 / colorTextureDimensions;    float weightSum = gaussianPdf(0.0, kernelRadius);    vec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;    vec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);    vec2 uvOffset = delta;    for( int i = 1; i <= MAX_RADIUS; i ++ ) {        float w = gaussianPdf(uvOffset.x, kernelRadius);        vec4 sample1 = texture2D( colorTexture, vUv + uvOffset);        vec4 sample2 = texture2D( colorTexture, vUv - uvOffset);        diffuseSum += ((sample1 + sample2) * w);        weightSum += (2.0 * w);        uvOffset += delta;    }    gl_FragColor = diffuseSum/weightSum;}", 
"copy", "container", "scanEllipsoid", ".scene3d-mousedownview {\r\n    position: absolute;\r\n    top: 0;\r\n    left: 0;\r\n    width: 40px;\r\n    height: 40px;\r\n    margin-top: -23px;\r\n    margin-left: -23px;\r\n    pointer-events: none;\r\n    visibility: hidden;\r\n    opacity: 0;\r\n    -webkit-transition: visibility 0s .2s, opacity .2s ease-in;\r\n    -moz-transition: visibility 0s .2s, opacity .2s ease-in;\r\n    transition: visibility 0s .2s, opacity .2s ease-in;\r\n}\r\n\r\n.scene3d-mousedownview-img {\r\n    width: 36px;\r\n    height: 36px;\r\n    background-image: url(data:image/png;base64,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);\r\n    background-size: 100% 100%\r\n}\r\n\r\n.scene3d-mousedownview-show {\r\n    visibility: visible;\r\n    opacity: 1;\r\n    -webkit-transition: opacity .2s ease-out;\r\n    -moz-transition: opacity .2s ease-out;\r\n    transition: opacity .2s ease-out\r\n}", 
"getPositionHeight", "viewShedStage", "MeasureStartEvent", "getTileCredits must not be called before the imagery provider is ready.", "bottomInnerCircleColor", "</span>", "hAngle", "renderState", "uniform float mixNum;uniform sampler2D colorTexture;uniform sampler2D stcshadow; uniform sampler2D videoTexture;uniform sampler2D depthTexture;uniform mat4 _shadowMap_matrix; uniform vec4 shadowMap_lightPositionEC; uniform vec4 shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness; uniform vec4 shadowMap_texelSizeDepthBiasAndNormalShadingSmooth; varying vec2 v_textureCoordinates;vec4 toEye(in vec2 uv, in float depth){  vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));  vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0);  posInCamera =posInCamera / posInCamera.w;  return posInCamera;}float getDepth(in vec4 depth){  float z_window = czm_unpackDepth(depth);  z_window = czm_reverseLogDepth(z_window);  float n_range = czm_depthRange.near;  float f_range = czm_depthRange.far;  return (2.0 * z_window - n_range - f_range) / (f_range - n_range);}float _czm_sampleShadowMap(sampler2D shadowMap, vec2 uv){  return texture2D(shadowMap, uv).r;}float _czm_shadowDepthCompare(sampler2D shadowMap, vec2 uv, float depth){  return step(depth, _czm_sampleShadowMap(shadowMap, uv));}float _czm_shadowVisibility(sampler2D shadowMap, czm_shadowParameters shadowParameters){  float depthBias = shadowParameters.depthBias;  float depth = shadowParameters.depth;  float nDotL = shadowParameters.nDotL;  float normalShadingSmooth = shadowParameters.normalShadingSmooth;  float darkness = shadowParameters.darkness;  vec2 uv = shadowParameters.texCoords;  depth -= depthBias;  vec2 texelStepSize = shadowParameters.texelStepSize;  float radius = 1.0;  float dx0 = -texelStepSize.x * radius;  float dy0 = -texelStepSize.y * radius;  float dx1 = texelStepSize.x * radius;  float dy1 = texelStepSize.y * radius;  float visibility =   (  _czm_shadowDepthCompare(shadowMap, uv, depth)  +_czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy0), depth) +  _czm_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy0), depth) +  _czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy0), depth) +  _czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, 0.0), depth) +  _czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, 0.0), depth) +  _czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy1), depth) +  _czm_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy1), depth) +  _czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy1), depth)  ) * (1.0 / 9.0)  ;  return visibility;}vec3 pointProjectOnPlane(in vec3 planeNormal, in vec3 planeOrigin, in vec3 point){  vec3 v01 = point -planeOrigin;  float d = dot(planeNormal, v01) ;  return (point - planeNormal * d);}float ptm(vec3 pt){  return sqrt(pt.x*pt.x + pt.y*pt.y + pt.z*pt.z);}void main() {   const float PI = 3.141592653589793;  vec4 color = texture2D(colorTexture, v_textureCoordinates);  vec4 currD = texture2D(depthTexture, v_textureCoordinates);  if(currD.r>=1.0){ gl_FragColor = color; return;  } float depth = getDepth(currD);  vec4 positionEC = toEye(v_textureCoordinates, depth);  vec3 normalEC = vec3(1.0);  czm_shadowParameters shadowParameters;   shadowParameters.texelStepSize = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.xy;   shadowParameters.depthBias = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.z;   shadowParameters.normalShadingSmooth = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.w;   shadowParameters.darkness = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.w;   shadowParameters.depthBias *= max(depth * 0.01, 1.0);   vec3 directionEC = normalize(positionEC.xyz - shadowMap_lightPositionEC.xyz);   float nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0);   vec4 shadowPosition = _shadowMap_matrix * positionEC;   shadowPosition /= shadowPosition.w;   if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0))))   {  gl_FragColor = color; return;  }  shadowParameters.texCoords = shadowPosition.xy;   shadowParameters.depth = shadowPosition.z;   shadowParameters.nDotL = nDotL;   float visibility = _czm_shadowVisibility(stcshadow, shadowParameters);   vec4 videoColor = texture2D(videoTexture,shadowPosition.xy);  if(visibility==1.0){ gl_FragColor = mix(color,vec4(videoColor.xyz,1.0),mixNum*videoColor.a);  }else{ if(abs(shadowPosition.z-0.0)<0.01){   return; } gl_FragColor = color;  }} ", 
"abcdefghijklmnopqrst", "cesium", "color", "PolylineTrialFlowSource", "scene2map", "inverse", "toGeoJson", "Type", "updateMaxMin", "orbitFrame", "../../../static/images/particlesystem/fountain.png", "charAt", "minimumSpeed", "createDom", "vertexShaderSource", "BaseHeight", "getHeights", "getSceneDepthTexture", "initConsts", "cameraPosition", "\u89c2\u5bdf\u4f4d\u7f6e", "getStyle", "WaveCircleMaterialType", "fromGltf", "QQ \uff1a1911074953", "flyToByPlotCode", "createRadialGradient", "withAlpha", 
"DYNAMICFENCE", "DiffCircleMaterial1Source", "getSampledPositionProperty", "negativeX", "plotDrawTip", "circleHeight", "pixelSize", "projectionMatrix", "rotateMouseUpFunction", "fromCssColorString", "viewer", "_terria", "ZERO", "setView", "drawEntity", "outline", "configurable", "FIRE", "offsetWidth", "ScreenSpaceEventType", "_ellipsoid", "_hiddenAreaColor", "enableDistanceLegend", "features", "inset 1px 0px 500px 170px ", "attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec2 st;\nattribute float batchId;\n\nvarying vec3 v_positionMC;\nvarying vec3 v_positionEC;\nvarying vec2 v_st;\n\nvoid main()\n{\n    vec4 p = czm_computePosition();\n\n    v_positionMC = position3DHigh + position3DLow;           // position in model coordinates\n    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;     // position in eye coordinates\n    v_st = st;\n\n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\n}\n", 
"Color", "viewer2", "ShadowMap", "static/images/excavate/excavate_side_min.jpg", "postRender", "removeAll", "moveDir", "_computedModelMatrix", "load", "BLUE", "generateView", "enumerable", "propertyIsEnumerable", "_url", "verticalAngle", "device-status-container-yellow", "addScan", "hide", "showCompass", "markdown", "createLayer", "textMapPlotLayer", "../../static/lukou.mp4", "bboxPolygon", "DiffCircle2MaterialType", "distanceLegendDiv", "_radius", "addRegionData", "addInnerContainer", "updateHeatmap", 
"svgIcon", "computeModelMatrix", "EllipsoidStripeVertical", "CameraDominate", "replaceCache", "VtxfShader1", "getPickRay", "\u4e1c\u5317\u98ce", "handleEditTextMapPlot", ' <div class="div-point-container">\n                  <div class="divpoint divpoint-theme">\n                    <div class="divpoint-wrap">\n                      <div class="area">\n                        <div class="arrow-lt"></div>\n                        <div class="b-t"></div>\n                        <div class="b-r"></div>\n                        <div class="b-b"></div>\n                        <div class="b-l"></div>\n                        <div class="arrow-rb"></div>\n                        <div class="label-wrap">\n                          <div class="title">', 
"midVertexEntities", "webkitHidden", "currentTarget", "startScale", "clippingPlanes", " <div class=\"compass-rotation-marker\" data-bind=\"visible: isOrbiting, style: { transform: 'rotate(-' + orbitCursorAngle + 'rad)', '-webkit-transform': 'rotate(-' + orbitCursorAngle + 'rad)', opacity: orbitCursorOpacity }, cesiumSvgPath: { path: svgCompassRotationMarker, width: 145, height: 145 }\"></div> <div class=\"compass-outer-ring\" title=\"\" data-bind=\"style: { transform: 'rotate(-' + heading + 'rad)', '-webkit-transform': 'rotate(-' + heading + 'rad)' }, cesiumSvgPath: { path: svgCompassOuterRing, width: 145, height: 145 }\"></div> <div class=\"compass-gyro-background\"></div> <div class=\"compass-gyro\" data-bind=\"cesiumSvgPath: { path: svgCompassGyro, width: 145, height: 145 }, css: { 'compass-gyro-active': isOrbiting }\"></div></div><div class=\"navigation-controls\"    >\x3c!-- ko foreach: controls --\x3e<div data-bind=\"click: activate, attr: { title: $data.name }, css: $root.isLastControl($data) ? 'navigation-control-last' : 'navigation-control' \">   \x3c!-- ko if: $data.hasText --\x3e   <div data-bind=\"text: $data.text, css: $data.isActive ?  'navigation-control-icon-active ' + $data.cssClass : $data.cssClass\"></div>   \x3c!-- /ko --\x3e  \x3c!-- ko ifnot: $data.hasText --\x3e  <div data-bind=\"cesiumSvgPath: { path: $data.svgIcon, width: $data.svgWidth, height: $data.svgHeight }, css: $data.isActive ?  'navigation-control-icon-active ' + $data.cssClass : $data.cssClass\"></div>  \x3c!-- /ko --\x3e </div> \x3c!-- /ko --\x3e</div>", 
"lightCamera", "minimumParticleLife", "box", "generatePoint", "gce", "clampFeature", "90%", "/300+.png", "navigationViewModel", "neckWidthFactor", "enablePickFeatures", "CircleWaveSource", "ScanlineType", "_visibleAreaColor", "fixPosition", "fromArray", "imgWidth", "uniform", "createVertexBuffer", "BACK", "indexOf", "globe", "GltfPlot", "GeoPlotEditMidVertex", "_isFlyAnimation", "$video", "createVertex", "globalCompositeOperation", "fromColor", "SceneTransforms", "fan2", "\n        uniform sampler2D colorTexture;\n        uniform sampler2D edgeTexture1;\n        uniform sampler2D edgeTexture2;\n        uniform sampler2D lineTexture;\n        uniform sampler2D maskTexture;\n        uniform bool showGlow;\n        uniform float edgeGlow;\n        uniform bool edgeOnly;\n        uniform float edgeStrength;\n\n        varying vec2 v_textureCoordinates;\n        void main(){\n            \n            vec2 vUv =v_textureCoordinates;\n            vec4 edgeColor=texture2D( lineTexture, vUv);\n            vec4 color=texture2D( colorTexture, vUv);\n            float opacity=1.;\n            if(edgeOnly){\n                vec4 maskColor=texture2D( maskTexture, vUv);\n                opacity=1.-maskColor.a;\n                gl_FragColor = maskColor;\n                return;\n            }\n  \n            if(showGlow){\n                float visFactor= czm_selected()?1.:0.;\n                vec4 edgeValue1 = texture2D(edgeTexture1, vUv);\n                vec4 edgeValue2 = texture2D(edgeTexture2, vUv);\n                vec4 glowColor = edgeValue1 + edgeValue2 * edgeGlow;\n                gl_FragColor = opacity * color + edgeColor + edgeStrength * (1. - edgeColor.r) * glowColor;\n            }\n            else{\n                gl_FragColor = opacity * color + edgeColor;\n            }\n        }\n        ", 
"getCirclePoint", "cylinderEntity1", "getFeatureByPrimitiveId", "50%", "\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a\u7ebf\uff0c\u6700\u5c11\u9700\u89812\u4e2a\u70b9\u3002", "atan2", "hiddenEdgeColor", "sources", "_domeLineCommand", "opt", "semiMajorAxis", "fromDate", "_materialCache", "mozHidden", "exp", "measureArea", "getApper", "HouseCode", "barWidth", "secondsDifference", "MeasureDistanceVertex", "HedronPlot", "imageSize", "PolylineLightingImage", "czm_material czm_getMaterial(czm_materialInput materialInput)\n{\n     czm_material material = czm_getDefaultMaterial(materialInput);\n     vec2 st = materialInput.st;\n     vec4 colorImage = texture2D(image, vec2(fract(st.t - time), st.t));\n     material.alpha = colorImage.a * color.a;\n     material.diffuse =  2.5 * color.rgb  ;\n     return material;\n }", 
"/10+.png", "autoplay", "videoEntity", "getType", "Cartesian4", "utils", "gctFlag", "playVideo", "_boundingSphereWC", "handleMouseMoveEvent", "execute", "\uff0c\u9700\u89814\u4e2a\u70b9", '.LocationPlot-container {\r\n    min-height: 65px;\r\n    min-width: 186px;\r\n    background: #e3eee59e;\r\n    position: absolute;\r\n    left: 0px;\r\n    bottom: 0px;\r\n    cursor: default;\r\n    padding: 0px 2px 5px 5px;\r\n    border: 1px solid #9c9944e8;\r\n}\r\n\r\n.LocationPlot-container::before {\r\n    position: absolute;\r\n    content: "";\r\n    left: 50%;\r\n    bottom: -50px;\r\n    height: 48px;\r\n    border-left: 2px dashed #c5e22770;\r\n    pointer-events: none;\r\n}\r\n\r\n.LocationPlot-container .info-item-close {\r\n    position: relative;\r\n    height: 15px;\r\n}\r\n\r\n.LocationPlot-container .info-close {\r\n    display: block;\r\n    height: 15px;\r\n    width: 15px;\r\n    position: absolute;\r\n    right: 0px;\r\n    background: #dc9e9e4d;\r\n    line-height: 15px;\r\n    text-align: center;\r\n}\r\n\r\n.LocationPlot-container .info-close:hover {\r\n    background: #e01c1c88;\r\n}', 
"NORMALFENCE", "pointerEvents", "showDomeSurfaces", "Blur1", "uniform sampler2D colorTexture;\nvarying vec2 v_textureCoordinates;\nfloat snow(vec2 uv,float scale)\n{\n    float time = czm_frameNumber / 60.0;\n    float w=smoothstep(1.,0.,-uv.y*(scale/10.));if(w<.1)return 0.;\n    uv+=time/scale;uv.y+=time*2./scale;uv.x+=sin(uv.y+time*.5)/scale;\n    uv*=scale;vec2 s=floor(uv),f=fract(uv),p;float k=3.,d;\n    p=.5+.35*sin(11.*fract(sin((s+p+scale)*mat2(7,3,6,5))*5.))-f;d=length(p);k=min(d,k);\n    k=smoothstep(0.,k,sin(f.x+f.y)*0.01);\n    return k*w;\n}\nvoid main(void){\n     vec2 resolution = czm_viewport.zw;\n     vec2 uv=(gl_FragCoord.xy*2.-resolution.xy)/min(resolution.x,resolution.y);\n     vec3 finalColor=vec3(0);\n     float c = 0.0;\n     c+=snow(uv,30.)*.0;\n     c+=snow(uv,20.)*.0;\n     c+=snow(uv,15.)*.0;\n     c+=snow(uv,10.);\n     c+=snow(uv,8.);\n     c+=snow(uv,6.);\n     c+=snow(uv,5.);\n     finalColor=(vec3(c));\n     gl_FragColor = mix(texture2D(colorTexture, v_textureCoordinates), vec4(finalColor,1), 0.5);\n}", 
"ceil", "jsgif", "_tileWidth", "outlineFrustum", "TAILED_SQUAD_COMBAT", "targetEntity", "PolylineArrowOpacityType", "pitch", "handleFcQueryResult", "createVideo", "radius", "getRadius", "getShader", "getByPlotCode", "LINEAR", "hasAlphaChannel", "clusterColors", "options.terria is required.", "targetPosition", "online7", "GIF", "background: url(", "lonLat2WebMercator", "Additive", "iconUrl", "pow", "\u672a\u547d\u540d", "sideWall", "createLabelEntity", "FencePlot", "stackPartitions", "reverse", "RIGHT_CLICK", 
"ptHeader", "red", "editGeoPlot", "PolylineVolumeTrial", "createPromitive", "\u7a97\u53e3\u5185\u5bb9\n          </div>\n        </div>", "setValue", "getAppear", "fromRotationMatrix", "midnight", "stopTime", "enableZoomControls", "\u96c6\u7ed3\u5730", "100.0", "totalTime", "vertexArray", "exports", "easingFunction2", "polygonEntity", "STATIC_DRAW", "sanjiao_arrow", "textureUrl", "addMaterial", "LEFT_CLICK", "context", "originMat4", "worldToCameraCoordinatesPoint", "createCircleEntitiy", "RenderState", 
"enableCompass", "\u6e10\u53d8\u6587\u672c", "raiseEvent", "originalShader", "unbindEvent", "difference", "firstPosition", "cross", "); // \u989c\u8272\n            gl_FragColor *= vec4(vec3(position.z / 100.0), 1.0); // \u6e10\u53d8\n            // \u52a8\u6001\u5149\u73af\n            float time = fract(czm_frameNumber / 360.0);\n            time = abs(time - 0.5) * 2.0;\n            float diff = step(0.005, abs( clamp(position.z / glowRange, 0.0, 1.0) - time));\n            gl_FragColor.rgb += gl_FragColor.rgb * (1.0 - diff);\n        }\n       ", 
"setScale", "LINEFLOW", "createPlane", "EditMidVertex", "handlePickTextMapPlot", "specularIntensity", "gravityScratch", "CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,TextTrackList,TouchList", 
"initEvents", "../../../static/images/particlesystem/fire.png", "highlightAxis", "userInput", "showDomeLines", " is not a symbol!", "getByPlotIntersect", "ClockRange", "convertMC2LL", "16888ozUAri", "Point", "removeSplitLayer", "Primitive", "circlePoints_2", "minRadius", "createLineEntity", "\u897f\u5357\u98ce", "_cameraPosition", "_y_direction", "getCameraView", "fromDegreesArray", "fan3", "\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a\u7ebf\uff0c\u6700\u5c11\u9700\u89812\u4e2a\u70b9", "WHITE", "varying vec3 v_positionEC;\n            void main(void){\n            vec4 position = czm_inverseModelView * vec4(v_positionEC,1); // \u4f4d\u7f6e\n            float glowRange =", 
"unproject", "getBookmarkList", "addOuter", "fromCache", "addFrustum", "_unvisiable", "\u5706\u67f1\u4f53", "animateModel", "centerDegrees", "clearIntervalNum", "mouseup", "negativeY", "constructor", "_element", "BLACK", "ODLineMaterial", "boolean", "czm_material czm_getMaterial(czm_materialInput materialInput)\n{\n     czm_material material = czm_getDefaultMaterial(materialInput);\n     vec2 st = materialInput.st;\n     vec4 colorImage = texture2D(image, vec2(st ));\n     material.diffuse = 2.5 * color.rgb  ;\n     material.alpha = colorImage.a ;\n     return material;\n }", 
"isActivate", "angle1", "YELLOW", "rotateInitialCameraAngle", "squadcombat", "getDistanceByMC", "isDestroy", "isSelected", "enableTranslate", "polygon", "primitive2", "_model", "fromRotationX", "none", "SampledPositionProperty", "LINEARGRADIENT", "editPlot", "setHeight", "ClippingPlaneCollection", "addPostRender", "orbitIsLook", "setVisible", "entity", "resetView", "sig", "setPolygonCoordinates", "tileHeight", "POLYGON", "_domeLineVA", "getPrototypeOf", "DistanceDisplayCondition", "czm_material czm_getMaterial(czm_materialInput materialInput)\n { czm_material material = czm_getDefaultMaterial(materialInput); vec2 st = materialInput.st;\n    vec4 colorImage = texture2D(image, vec2(fract( count * st.s - time),fract(st.t)));\n     material.alpha =  colorImage.a * color.a;\n     material.diffuse =  color.rgb * 3.0 ;\n     return material;}", 
"unbindMouseEvent", "boxMeta", "keyup", "AQUA", "cesium-widget", "divPitch", "image/png", "load_url", "addOnDestroyListener", "xhr - response", "leaflet-popup-tip", "\uff0c\u9700\u89811\u4e2a\u70b9", "upWC", "Buffer", "MARKER", "bind", "string", "rAngle", "splitDirection", "VideoWallPlotEditMidVertex", "stroke", "commands", "_distanceDisplayCondition", "ScanlineMaterialProperty", "frontFaceAlpha", "currentOpenHeight", "clearEditVertex", "getAttribute", "startTime", "longitude", "heatmap", "mode", 
"\u5206\u961f\u4f5c\u6218\u5c3e", "moveDown", "navigation-control-icon-reset", "meta", "fromPointNormal", "loop_delay", "_cubeMap", "uniform sampler2D colorTexture;uniform sampler2D depthTexture;varying vec2 v_textureCoordinates;uniform vec4 u_scanCenterEC;uniform vec3 u_scanPlaneNormalEC;uniform vec3 u_scanLineNormalEC;uniform float u_radius;uniform vec4 u_scanColor;vec4 toEye(in vec2 uv, in float depth) { vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0)); vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0); posInCamera =posInCamera / posInCamera.w; return posInCamera; }bool isPointOnLineRight(in vec3 ptOnLine, in vec3 lineNormal, in vec3 testPt){vec3 v01 = testPt - ptOnLine;normalize(v01);vec3 temp = cross(v01, lineNormal);float d = dot(temp, u_scanPlaneNormalEC);return d > 0.5;}vec3 pointProjectOnPlane(in vec3 planeNormal, in vec3 planeOrigin, in vec3 point){vec3 v01 = point -planeOrigin;float d = dot(planeNormal, v01) ;return (point - planeNormal * d);}float distancePointToLine(in vec3 ptOnLine, in vec3 lineNormal, in vec3 testPt){vec3 tempPt = pointProjectOnPlane(lineNormal, ptOnLine, testPt);return length(tempPt - ptOnLine);}float getDepth(in vec4 depth){float z_window = czm_unpackDepth(depth);z_window = czm_reverseLogDepth(z_window);float n_range = czm_depthRange.near;float f_range = czm_depthRange.far;return (2.0 * z_window - n_range - f_range) / (f_range - n_range);}void main(){gl_FragColor = texture2D(colorTexture, v_textureCoordinates);float depth = getDepth( texture2D(depthTexture, v_textureCoordinates));vec4 viewPos = toEye(v_textureCoordinates, depth);vec3 prjOnPlane = pointProjectOnPlane(u_scanPlaneNormalEC.xyz, u_scanCenterEC.xyz, viewPos.xyz);float dis = length(prjOnPlane.xyz - u_scanCenterEC.xyz);float twou_radius = u_radius * 2.0;if(dis < u_radius){float f0 = 1.0 -abs(u_radius - dis) / u_radius;f0 = pow(f0, 64.0);vec3 lineEndPt = vec3(u_scanCenterEC.xyz) + u_scanLineNormalEC * u_radius;float f = 0.0;if(isPointOnLineRight(u_scanCenterEC.xyz, u_scanLineNormalEC.xyz, prjOnPlane.xyz)){float dis1= length(prjOnPlane.xyz - lineEndPt);f = abs(twou_radius -dis1) / twou_radius;f = pow(f, 3.0);}gl_FragColor = mix(gl_FragColor, u_scanColor, f + f0);}}", 
"text", "BoundingSphere", "next", "lineString", "\u5b57\u6bb5\u548c\u503c\u6570\u7ec4\u957f\u5ea6\u4e0d\u4e00\u81f4\uff01", "\u5e73\u65b9\u7c73", "MultiFieldAdaptWindow-ifno-label", "setPosition", "cameraFrustum", "findChild", "getInterpolationValues", "_hasAlphaChannel", "_createCanvas", "absolute", "addBottomRotateCircle", "enabled", "source", "_darkness", "zIndex", "scanSpeed", "initPrimitive", "getViewport", "Symbol is not a constructor!", "renderType", "setPositions", "identifier", "authCode", 
"_pickIdQualifier", "executeGlobeCommands", "BoundingRectangle", "hot-spot", "wfStage", "getTrailLineInfo", "mousePointEntity", "setTransform", "9tIdPyw", "czm_selectedIdTexture", "#FF0000", "_environmentState", "MaterialAppearance", "getHeadingPitchRoll", "magnitude", "getPlotBy_textureAtlasGUID", "setFlagStatus", "shift", "FOUNTAIN", "addEvent", "PolylineLinkPulse", "parentElement", "coordinates", "dataSources", "subdomains", "updatePass", "outlineColor", "num", "removeEvent", "EllipsoidGeodesic", 
"appendForwardSlash", "bbox", "verticalViewAngle", "_projection", "\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a\u52a8\u6001\u56f4\u680f\uff0c\u6700\u5c11\u9700\u89812\u4e2a\u70b9\u3002", "swiperight", "Resource", "ent", "getZoomUnits", "SIMPLELABEL", "PolylineArrowOpacity", "\u4e2a\u70b9\uff0c\u6309\u4e0b\u9f20\u6807\u5de6\u952e\u786e\u5b9a\u7b2c", "addPlot", "\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a\u534a\u7403\u4f53\uff0c\u9700\u89811\u4e2a\u70b9", "\u8bf7\u786e\u8ba4\u70b9\u662fCartesian3\u7c7b\u578b\uff01", 
"EllipsoidObject", "WHEEL", "getPointDistance", "createLabel", "PolylineTrail", "gradient", "clustering", "DrawCommand", "smokeImage", "frustumQuaternion", "Cartesian2", "bottomCircle", "GeometryAttribute", "intersectionWidth", "477HbIudo", "Sampler", "originPosition", "name", "renderStateProcess", "openHeight", "buffer", "generatePlot", "openEntityEditModel", "chart-popup3d-header-title", "VertexFormat", "shallowClone", "addBillboard", "duration2", "leaflet-popup-tip-container", "clientX", "globalAlpha", 
"responseType", "pos", "minimumPixelSize", "simplelabel", "EditablePolyline", '.is-shulie {\r\n    width: 15px;\r\n    text-align: center;\r\n    background: transparent;\r\n    font-size: 9px;\r\n    font-weight: 600;\r\n    color: white;\r\n    font-family: "Microsoft YaHei", "Helvetica Neue For Number", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Hiragino Sans GB", "PingFang SC", "Helvetica Neue", Helvetica, Arial, sans-serif !important;\r\n    position: absolute;\r\n    display: block;\r\n    box-sizing: border-box;\r\n    pointer-events: none;\r\n}\r\n\r\n.is-shulie-item {\r\n    writing-mode: vertical-lr;\r\n    font-size: 16px;\r\n    letter-spacing: 4px;\r\n}\r\n\r\n.pre-topCard-list-item-line {\r\n    display: block;\r\n    height: 40px;\r\n    width: 1px;\r\n    margin-left: calc(50% + 2px);\r\n    margin-top: 3px;\r\n    background-color: #fff;\r\n}\r\n\r\n.pre-topCard-list-item-circle {\r\n    width: 10px;\r\n    height: 10px;\r\n    background-color: #fff;\r\n    border-radius: 50%;\r\n    margin-left: 5px;\r\n    margin-top: -10px;\r\n}', 
"LIMEGREEN", "plotCode", "gctSize", "\u4fef\u4ef0\u89d2\uff1a", "commandList", "tileWidth must not be called before the imagery provider is ready.", "frequency", "BuildCode", "handleFirstPosition", "NearFarScalar", "createResultLabel", "title", "rgba(255, 255, 255,255)", "Undefined", "\u66f2\u7ebf\u9762", "writable", "pointer", "background", "PolygonObject", "highlightFloorEntity", "getEditEntityPositions", "registerLeftUpEvent", "parseHtmlFragment", "FloorSelectedEvent", "aotuPickHeight", "getOnLinePointByLen", 
"LabelPlotting", "finearrow", "onclick", "cssText", "isObject3D", "%c xt3d-sdk", "class", "keys", "GRADIENTSLABEL", "asyncIterator", "show", "Can't call method on  ", "_canvasUpdate", "setBaseViewer", "svgHeight", "getRectanglePositions", "scene", "video-popup3d-header", "VideoWallPlotEditVertex", "minimumLevel must not be called before the imagery provider is ready.", "ScrollWallType", "lctFlag", "flipY", "MarkdownIt", "span", "colors", "_hidden", "entries", "fromDegrees", "flow", "Gltf", "\u672a\u627e\u5230pickId", 
"all", "_scanPlaneBackCommand", "childNodes", "isStart", "$data", "@@iterator", "KeyboardDominate", "path", "DiffCircle2Material", "LINEAR_NONE", "plotLayer", "rgba(255, 255, 255, 0.9)", "textEntity", "_colorSubscription", "drawEnd", '@charset "UTF-8";\n\n@font-face {\n  font-family: "LED";\n  src: url("LED.woff2") format("woff2"),\n       url("LED.woff") format("woff"),\n       url("LED.ttf") format("truetype"),\n       url("LED.eot") format("embedded-opentype"),\n       url("LED.svg") format("svg");\n  font-weight: normal;\n  font-style: normal;\n}', 
"DOUBLE", "HIGHLIGHT", "direction", "fixedFrameTransforms", "czm_material czm_getMaterial(czm_materialInput materialInput)\n {\n      czm_material material = czm_getDefaultMaterial(materialInput);\n      vec2 st = materialInput.st;\n      vec4 colorImage = texture2D(image, vec2(fract(st.t - time), st.t));\n      material.alpha = colorImage.a * color.a;\n      material.diffuse =  1.5* color.rgb  ;\n      return material;\n  }", "divLat", "eventHandler", "ImageProvider", "primitives", "positiveZ", 
"getCenterPosition", ' .plot-draw-tip-container {\r\n     position: absolute;\r\n     background: rgba(0, 0, 0, 0.637);\r\n     padding: 6px;\r\n     color: white;\r\n     pointer-events: none;\r\n }\r\n \r\n .plot-draw-tip-container::before {\r\n     position: absolute;\r\n     content: "";\r\n     top: calc(50% - 10px);\r\n     left: -10px;\r\n     border-bottom: 10px solid transparent;\r\n     border-top: 10px solid transparent;\r\n     border-right: 10px solid rgba(0, 0, 0, 0.637);\r\n }', "TilesetPlugin", 
"plots", "scrollWidth", "attr", "PlotEditVertex", "command", "_scanPlaneFrontCommand", "info-close", "resizeCanvas", "animateEntity", "BOTTOM", "addLimitEllipsoid", "getClusterColor", "green", "Anonymous", "vAngle", "canvas", "getPolygonByBbox", "label", "convertData", "clear", "moveTo", "rotateRight", "video-jd-temp", "_readyPromise", "_pointBias", "varying vec3 v_positionEC;\n            void main(void){\n                vec4 position = czm_inverseModelView * vec4(v_positionEC,1); // \u4f4d\u7f6e \n                gl_FragColor = vec4(", 
"ClippingPlane", '.gradients-label-container {\r\n    background-image: linear-gradient(to right, #e64dc1, #00ffc3);\r\n    position: absolute;\r\n    left: 0px;\r\n    bottom: 0px;\r\n    cursor: default;\r\n    padding: 5px;\r\n    border: 1px solid #9c9944e8;\r\n}\r\n\r\n.gradients-label-container:hover {\r\n    border: 1px solid rgb(9, 255, 0);\r\n}\r\n\r\n.gradients-label-container::before {\r\n    position: absolute;\r\n    content: "";\r\n    left: 50%;\r\n    bottom: -30px;\r\n    height: 30px;\r\n    border-left: 1px dashed #c5e22770;\r\n}\r\n\r\n\r\n/* \u7b80\u5355 */\r\n\r\n.simple-label-container {\r\n    background: #e3eee59e;\r\n    position: absolute;\r\n    left: 0px;\r\n    bottom: 0px;\r\n    cursor: default;\r\n    padding: 5px;\r\n    border: 1px solid #9c9944e8;\r\n}\r\n\r\n.label-container-is-selected {\r\n    border: 2px solid yellow;\r\n}\r\n\r\n.label-container-is-selected::before {\r\n    border-left: 2px dashed yellow !important;\r\n}\r\n\r\n.simple-label-container:hover {\r\n    border: 1px solid rgb(9, 255, 0);\r\n}\r\n\r\n.simple-label-container::before {\r\n    position: absolute;\r\n    content: "";\r\n    left: 50%;\r\n    bottom: -30px;\r\n    height: 30px;\r\n    border-left: 1px dashed #c5e22770;\r\n}', 
"hasOwnProperty", "/home_icon_18.png)", "cameraMoveEndHanle", "\u9ad8\u5ea6\uff1a", "scene3d-mousedownview-show", "emissionRate", "cancelSync", "_errorEvent", "is_vp", "endPosition", "localFrameToFixedFrameGenerator", "getParams", "VideoWallPlot", "addDatasource", "move_to", "currentTime", '</span>\n                                <span class="label-unit">m</span>\n                              </div>\n                            </div>\n                            <div class="data-li data-li-state">\n                              <div class="data-label">\u6c34\u6cf5\u72b6\u6001\uff1a</div>\n                             \x3c!-- <div class="data-value" v-for="(item, index) in wStation.status" :key="index">\n                                <el-tooltip\n                                  class="item"\n                                  effect="dark"\n                                  :content="item.stateName"\n                                  placement="bottom"\n                                >\n                                  <span class="label-tag" :style="{\'background\':getBg(item.state)}">{{item.num}}\u53f7</span>\n                                </el-tooltip>\n                              </div>--\x3e\n                            </div>\n                          </div>\n                        </div>\n                      </div>\n                      <div class="b-t-l"></div>\n                      <div class="b-b-r"></div>\n                    </div>\n                    <div class="arrow"></div>\n                  </div>\n                </div>', 
"replaceMain", "HtmlPlot", "pre-topCard-list-item-line1", "stage", "cartesian3ToDegrees", "\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a\u9762\uff0c\u6700\u5c11\u9700\u89813\u4e2a\u70b9", "cone", "orbitMouseUpFunction", "UNIT_Z", "czm_", "readUnsigned", ".cesium-image-layer-split {\r\n    position: absolute;\r\n    left: 50%;\r\n    top: 0px;\r\n    background-color: #d3d3d3;\r\n    width: 5px;\r\n    height: 100%;\r\n    z-index: 9999;\r\n}\r\n\r\n.cesium-image-layer-split:hover {\r\n    cursor: ew-resize;\r\n}", 
"\u603b\u9762\u79ef", "circleRadius", "fixPositionCount", "altitude", "getDegreesArrayHeights", "iterator", "MarkdownItSanitizer", "$htmlContainer", "DOUBLE_ARROW", "\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a\u70b9\uff0c\u9700\u89811\u4e2a\u70b9", "uniform float mixNum;uniform sampler2D colorTexture;uniform sampler2D stcshadow; uniform sampler2D videoTexture;uniform sampler2D depthTexture;uniform mat4 _shadowMap_matrix; uniform vec4 shadowMap_lightPositionEC; uniform vec4 shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness; uniform vec4 shadowMap_texelSizeDepthBiasAndNormalShadingSmooth; varying vec2 v_textureCoordinates;vec4 toEye(in vec2 uv, in float depth){  vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));  vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0);  posInCamera =posInCamera / posInCamera.w;  return posInCamera;}float getDepth(in vec4 depth){  float z_window = czm_unpackDepth(depth);  z_window = czm_reverseLogDepth(z_window);  float n_range = czm_depthRange.near;  float f_range = czm_depthRange.far;  return (2.0 * z_window - n_range - f_range) / (f_range - n_range);}float _czm_sampleShadowMap(sampler2D shadowMap, vec2 uv){  return texture2D(shadowMap, uv).r;}float _czm_shadowDepthCompare(sampler2D shadowMap, vec2 uv, float depth){  return step(depth, _czm_sampleShadowMap(shadowMap, uv));}float _czm_shadowVisibility(sampler2D shadowMap, czm_shadowParameters shadowParameters){  float depthBias = shadowParameters.depthBias;  float depth = shadowParameters.depth;  float nDotL = shadowParameters.nDotL;  float normalShadingSmooth = shadowParameters.normalShadingSmooth;  float darkness = shadowParameters.darkness;  vec2 uv = shadowParameters.texCoords;  depth -= depthBias;  vec2 texelStepSize = shadowParameters.texelStepSize;  float radius = 1.0;  float dx0 = -texelStepSize.x * radius;  float dy0 = -texelStepSize.y * radius;  float dx1 = texelStepSize.x * radius;  float dy1 = texelStepSize.y * radius;  float visibility =   (  _czm_shadowDepthCompare(shadowMap, uv, depth)  +_czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy0), depth) +  _czm_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy0), depth) +  _czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy0), depth) +  _czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, 0.0), depth) +  _czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, 0.0), depth) +  _czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy1), depth) +  _czm_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy1), depth) +  _czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy1), depth)  ) * (1.0 / 9.0)  ;  return visibility;}vec3 pointProjectOnPlane(in vec3 planeNormal, in vec3 planeOrigin, in vec3 point){  vec3 v01 = point -planeOrigin;  float d = dot(planeNormal, v01) ;  return (point - planeNormal * d);}float ptm(vec3 pt){  return sqrt(pt.x*pt.x + pt.y*pt.y + pt.z*pt.z);}void main() {   const float PI = 3.141592653589793;  vec4 color = texture2D(colorTexture, v_textureCoordinates);  vec4 currD = texture2D(depthTexture, v_textureCoordinates);  if(currD.r>=1.0){ gl_FragColor = color; return;  } float depth = getDepth(currD);  vec4 positionEC = toEye(v_textureCoordinates, depth);  vec3 normalEC = vec3(1.0);  czm_shadowParameters shadowParameters;   shadowParameters.texelStepSize = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.xy;   shadowParameters.depthBias = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.z;   shadowParameters.normalShadingSmooth = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.w;   shadowParameters.darkness = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.w;   shadowParameters.depthBias *= max(depth * 0.01, 1.0);   vec3 directionEC = normalize(positionEC.xyz - shadowMap_lightPositionEC.xyz);   float nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0);   vec4 shadowPosition = _shadowMap_matrix * positionEC;   shadowPosition /= shadowPosition.w;   if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0))))   {  gl_FragColor = color; return;  }  shadowParameters.texCoords = shadowPosition.xy;   shadowParameters.depth = shadowPosition.z;   shadowParameters.nDotL = nDotL;   float visibility = _czm_shadowVisibility(stcshadow, shadowParameters);   vec4 videoColor = texture2D(videoTexture,shadowPosition.xy);  if(visibility==1.0){ gl_FragColor = mix(color,vec4(videoColor.xyz,1.0),mixNum*videoColor.a);  }else{  if(abs(shadowPosition.z-0.0)<0.01){   return; } gl_FragColor = color; }}", 
"getScanSegmentShader", "trackedEntity", "hpRange", "czm_material czm_getMaterial(czm_materialInput materialInput)\n{\n     czm_material material = czm_getDefaultMaterial(materialInput);\n     vec2 st = materialInput.st;\n     vec4 colorImage = texture2D(image, vec2(fract(st.t - time), st.t));\n     material.alpha = colorImage.a * color.a;\n     material.diffuse =  1.9 * color.rgb  ;\n     return material;\n }", "coordinateSystem", "createPerspectiveFrustum", "Arguments", "CylinderGlowGradientWall", 
"GeoPlotEditVertex", '<div class="compass"  style="display: none;" title="" data-bind="visible: showCompass, event: { mousedown: handleMouseDown, dblclick: handleDoubleClick }"><div class="compass-outer-ring-background"></div>', "TRIANGLES", "removeAllChild", "_fragmentShaderText", "</h5>\n              <p> ", "readBytes", "(); \n} \n", "onload", "online0", "animationSpeed", "clearSelectedPlot", "drawType", "bankAngle", "FENCENORMAL", "MeasureHeightVertex", "BoxGeometry", "black", "TextureMinificationFilter", 
"uniform samplerCube u_cubeMap;\n    varying vec3 v_texCoord;\n    void main()\n    {\n    vec4 color = textureCube(u_cubeMap, normalize(v_texCoord));\n    gl_FragColor = vec4(czm_gammaCorrect(color).rgb, czm_morphTime);\n    }\n    ", "op-symbols", "device-status", "tilingScheme", "addFanBlad", "addCone", "tailedsquadcombat", "orbitCursorAngle", "EllipsoidStripeVerticalImage", "getOrientation", "primitive1", "_command", "rotationMatrixFromPositionVelocity", "modelPositon", "addData", "_scanPlaneVA", 
"POLYHEDRON", "\uff0c\u9700\u89812\u4e2a\u70b9", "map2scene", "u_normalDirection", "pass", "EditVertex", "colorStops", "30\u7c73", "mapv0", "ScrollWall", "2.6.12", "rgb(", "removeData", "czm_material czm_getMaterial(czm_materialInput materialInput){\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    vec4 tColor = u_color;\n    vec2 st = materialInput.st;\n    vec2 center = st - vec2(0.5,0.5);\n    float length = length(center)/0.5;\n    float time = 1. - abs(czm_frameNumber / 360. - 0.5);\n\n    float param = 1. - step(length, 0.6);//\u5927\u4e8e0.6\u6a21\u7cca\uff0crate = 0.6\n    float scale = param * length;// 0.6< length \u8fd4\u56de0\uff0c\u53cd\u4e4b\u8fd4\u56de1.\n    float alpha = param * (1.0 - abs(scale - 0.8) / 0.2);// 0.8 < length \u8fd4\u56de0\uff0c\u53cd\u4e4b\u8fd4\u56de1.\n\n    float param1 = step(length, 0.7);//\u5c0f\u4e8e0.5\u6a21\u7cca\n    float scale1 = param1 * length;// 0.6< length \u8fd4\u56de0\uff0c\u53cd\u4e4b\u8fd4\u56de1.\n    alpha += param1 * (1.0 - abs(scale1 - 0.35) / 0.35);// 0.8 < length \u8fd4\u56de0\uff0c\u53cd\u4e4b\u8fd4\u56de1.\n\n    material.diffuse = u_color.rgb * vec3(u_color.a);\n    material.alpha = pow(alpha, 4.0);\n    return material;\n}", 
"rotateIsLook", "initChart", "addClippingPlanes", "properties", "cesiumWidget", "visibleEdgeColor", "imageryLayers", "setAttribute", "lookAt", "removeTickEvent", "dynamic-divlabel-container1", "getOwnPropertyNames", "headingPitchRollToFixedFrame", "80px sans-serif", "_distance", "addImageryProvider", "clearQueryResult", "radii", "fromType", "url(", "editVideoWallPlot", "leftPos", "is-shulie", "fromDegreesArrayHeights", "intersectionColor", "pixels", "beginPath", "void main() \n{ \n", "vertexShader", 
"PlotDrawStartEvent", "POLYLINEVOLUME", "MilitaryPlot", "featuresLength", "circleImage", "generatePositions", "PolylineLinkPulseType", "outerCircle", "\u56fe\u6807\u70b9", "QObject", "src", "GREEN", "/static/images/particlesystem/0003.png", "now", "clearPrimitives", "data:image/png;base64,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", 
"preUpdate", "setClusterEvent", "latId", "createCameraLine", "middle", "registerEvents", "afterWidgetChanged", "wallHeight", "initPlots", "_cache_", "circleEntity", "uniform vec4 color;\nuniform float speed;\nfloat circle(vec2 uv, float r, float blur) {\n  float d = length(uv) * 2.0;\n  float c = smoothstep(r+blur, r, d);\n  return c;\n}\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n  czm_material material = czm_getDefaultMaterial(materialInput);\n  vec2 st = materialInput.st - 0.5;\n  material.diffuse =2.8 * color.rgb;\n  material.emission = vec3(0);\n  float t =fract(czm_frameNumber * speed / 1000.0);\n  float s = 0.3;\n  float radius1 = smoothstep(.0, s, t) * 0.5;\n  float alpha1 = circle(st, radius1, 0.01) * circle(st, radius1, -0.01);\n  float alpha2 = circle(st, radius1, 0.01 - radius1) * circle(st, radius1, 0.01);\n  float radius2 = 0.5 + smoothstep(s, 1.0, t) * 0.5;\n  float alpha3 = circle(st, radius1, radius2 + 0.01 - radius1) * circle(st, radius1, -0.01);\n  material.alpha = smoothstep(1.0, s, t) * (alpha1 + alpha2*0.1 + alpha3*0.1);\n  material.alpha *=color.a ;\n  return material;\n} ", 
"moveEntityByOffset", "</table> ", "lzwMinCodeSize", ".div-point-container {\r\n    position: absolute;\r\n    left: 0px;\r\n    bottom: 0px;\r\n    display: block;\r\n}\r\n\r\n.divpoint-wrap {\r\n    position: relative;\r\n    padding: 30px;\r\n    overflow: hidden;\r\n}\r\n\r\n.divpoint-theme .arrow,\r\n.divpoint-theme .title::before {\r\n    /* background-color: #28bbf0; */\r\n    background-color: #4984ed;\r\n}\r\n\r\n.divpoint .arrow {\r\n    position: absolute;\r\n    bottom: 0;\r\n    left: 0;\r\n    width: 45px;\r\n    height: 2px;\r\n    transform: rotate(-45deg) translate(5px, -15px);\r\n}\r\n\r\n.divpoint-theme .area {\r\n    background-image: linear-gradient( 135deg, transparent 30px, #28bbf06c 30px, #28bbf06c 50%, transparent 50%), linear-gradient( -45deg, transparent 30px, #28bbf06c 30px, #28bbf06c 50.1%, transparent 50%);\r\n}\r\n\r\n.divpoint .area {\r\n    position: relative;\r\n    min-width: 180px;\r\n    min-height: 150px;\r\n}\r\n\r\n.divpoint-theme .b-b,\r\n.divpoint-theme .b-b-r,\r\n.divpoint-theme .b-l,\r\n.divpoint-theme .b-r,\r\n.divpoint-theme .b-t,\r\n.divpoint-theme .b-t-l {\r\n    /* background:  #29baf1; */\r\n    background-color: #4984ed;\r\n    /* box-shadow: 0 0 10px 2px #29baf1; */\r\n    box-shadow: 0 0 10px 2px #4984ed;\r\n}\r\n\r\n.divpoint .b-t-l {\r\n    position: absolute;\r\n    top: 0;\r\n    left: 0;\r\n    width: 1px;\r\n    height: 62px;\r\n    transform: rotate(45deg) translate(52px, -22px);\r\n    z-index: 10;\r\n}\r\n\r\n.divpoint .b-b-r {\r\n    position: absolute;\r\n    bottom: 0;\r\n    right: 0;\r\n    width: 1px;\r\n    height: 62px;\r\n    transform: rotate(45deg) translate(-52px, 22px);\r\n    z-index: 10;\r\n}\r\n\r\n.divpoint .b-t {\r\n    position: absolute;\r\n    top: 0;\r\n    left: 44px;\r\n    right: 0;\r\n    height: 1px;\r\n    z-index: 10;\r\n}\r\n\r\n.divpoint .b-r {\r\n    position: absolute;\r\n    top: 0;\r\n    right: 0;\r\n    bottom: 44px;\r\n    width: 1px;\r\n    z-index: 10;\r\n}\r\n\r\n.divpoint .b-b {\r\n    position: absolute;\r\n    left: 0;\r\n    right: 44px;\r\n    bottom: 0;\r\n    height: 1px;\r\n    z-index: 10;\r\n}\r\n\r\n.divpoint .b-l {\r\n    position: absolute;\r\n    top: 44px;\r\n    left: 0;\r\n    bottom: 0;\r\n    width: 1px;\r\n    z-index: 10;\r\n}\r\n\r\n.divpoint .label-wrap {\r\n    padding-left: 12px;\r\n    color: #fff;\r\n    font-size: 16px;\r\n    white-space: nowrap;\r\n    overflow: hidden;\r\n}\r\n\r\n.divpoint-theme .title {\r\n    /* background-image: linear-gradient(135deg, transparent 25px, #29baf1 25px); */\r\n    background-image: linear-gradient(135deg, transparent 25px, #4984ed 25px);\r\n}\r\n\r\n.divpoint .title {\r\n    margin-top: 20px;\r\n    padding: 0 12px 0 30px;\r\n    height: 36px;\r\n    line-height: 36px;\r\n    position: relative;\r\n}\r\n\r\n.divpoint .data-li {\r\n    padding: 4px 45px 4px 0;\r\n}\r\n\r\n.data-value,\r\n.divpoint .data-label {\r\n    display: inline-block;\r\n}\r\n\r\n.divpoint .data-value {\r\n    font-size: 14px;\r\n}\r\n\r\n.data-value,\r\n.divpoint .data-label {\r\n    display: inline-block;\r\n}\r\n\r\n.divpoint .label-num {\r\n    margin-right: 3px;\r\n    color: #f09e28;\r\n    font-weight: 600;\r\n}\r\n\r\n.divpoint .label-tag {\r\n    display: inline-block;\r\n    position: relative;\r\n    margin-right: 6px;\r\n    padding: 0 6px;\r\n    font-weight: 600;\r\n    cursor: pointer;\r\n    background-color: #909399;\r\n    border-radius: 4px;\r\n}", 
'\n                <tr>\n                  <td><label style="color:#e0f102;">', "mergeAll", "addLabels", "moveModel", "_view", "JulianDate", "focalDistance", "addCylinder", "setGeometry", "splice", "VerticalOrigin", "drawImage", "cesiumNavigation", "BOTH", "getDefaultStyle", "pointsToPositions", "abs", "FloorNumbe", "image/octet-stream", "innerHTML", "extrudedHeight", "add", "ConeGlowBottomRotateCircle", "defer", "showScanPlane", "fromPlane", "viewDistance", "sorted", "fanBladColor", "toString", 
"getFar", "initDevicePixelRatio", "_onDestroyListeners", "FUCHSIA", "translation", "_sectorSegmentLineCommand", "mouseClickHeight", "addOutlineFrustum", "_mapOffset", "getNumberOfXTilesAtLevel", "tileset", "uuid\uff1a", "_credit", "ImageMaterialProperty", "sideImage", "setLineStringCoordinates", "selctedFeature", "multiplyByUniformScale", "preUpdateHandle2", "\u5206\u961f\u4f5c\u6218", "Feature", "tickEventHandler", "rgba(255, 0, 0, 0.2)", "Ellipsoid", "PolylineSuperSource", "Invalid attempt to destructure non-iterable instance", 
"ptData", "_reset", "sampleHeight", "HeightReference", "createDepthOfFieldStage", "beforeUpdate", "getFirstPosition", "ALPHA_BLEND", "primitive3", "lat", "clickHighlight", "editTextMapPlot", "u_color", "2.02", "sketch", "_lateralSurfaceMaterial", "return this", "ClearCommand", "measureDistance", "/*html {\n    height: 100%;\n    -webkit-font-smoothing: antialiased;\n}\n\nbody {\n    height: 100%;\n    width: 100%;\n    margin: 0;\n    overflow: hidden;\n    padding: 0;\n    background: #000;\n    font-size: 15px;\n    font-family: @default-font;\n}*/\n\n.full-window {\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    margin: 0;\n    overflow: hidden;\n    padding: 0;\n    -webkit-transition: left 0.25s ease-out;\n    -moz-transition: left 0.25s ease-out;\n    -ms-transition: left 0.25s ease-out;\n    -o-transition: left 0.25s ease-out;\n    transition: left 0.25s ease-out;\n}\n\n.transparent-to-input {\n    pointer-events: none;\n}\n\n.opaque-to-input {\n    pointer-events: auto;\n}\n\n.clickable {\n    cursor: pointer;\n}\n\n\n/*a {\n    text-decoration: none;\n    color: @highlight-color;\n}*/\n\na:hover {\n    text-decoration: underline;\n}\n\n\n/*\n@modal-background-color: @panel-background-color;\n@modal-text-color: @panel-emphasized-text-color;\n@modal-header-background-color: rgba(0,0,0,0.2);\n@modal-header-text-color: @panel-emphasized-text-color;*/\n\n\n/*.modal-background {\n    .opaque-to-input;\n    position: fixed;\n    left: 0;\n    right: 0;\n    top: 0;\n    bottom: 0;\n    background-color: rgba(0,0,0,0.5);\n    z-index: 1000;  required for IE9 \n}*/\n\n\n/*\n.modal {\n    position: absolute;\n    margin: auto;\n    background-color: @modal-background-color;\n    top: 0;\n    left: 0;\n    bottom: 0;\n    right: 0;\n    max-height: 100%;\n    max-width: 100%;\n    font-family: @default-font;\n    color: @modal-text-color;\n}\n\n.modal-header {\n  background-color: @modal-header-background-color;\n  border-bottom: @panel-element-border;\n  font-size: 15px;\n  line-height: 40px;\n  margin: 0;\n}\n\n.modal-header h1 {\n  font-size: 15px;\n  color: @modal-header-text-color;\n  margin-left: 15px;\n}*/\n\n\n/* Commented out due to conflicts with client apps. \n.modal-content {\n  margin-left: 15px;\n  margin-right: 15px;\n  margin-bottom: 15px;\n  padding-top: 15px;\n  overflow: auto;\n}*/\n\n\n/*.modal-close-button {\n    position: absolute;\n    right: 15px;\n    cursor: pointer;\n    font-size: 18px;\n    color: @modal-header-text-color;\n}*/\n\n#ui {\n    z-index: 2100;\n}\n\n@media print {\n    .full-window {\n        position: initial;\n    }\n}\n\n\n/* input[type=text] {\n  height: 38px;\n  background-color: #eeeeee;\n  color: @input-text-color;\n  font-size: 14px;\n}\n\n::-webkit-input-placeholder {\n  color: fade(@input-text-color, 75%);\n  font-style: italic;\n}\n\n:-moz-placeholder { /* Firefox 18- \n  color: fade(@input-text-color, 75%);\n  font-style: italic;\n}\n\n::-moz-placeholder {  /* Firefox 19+  \n  color: fade(@input-text-color, 75%);\n  font-style: italic;\n}\n\n:-ms-input-placeholder {\n  color: fade(@input-text-color, 75%);\n  font-style: italic;\n}\n\ninput:focus {\n    outline-color: #FFFFFF;\n}\n*/\n\n\n/*select {\n  display: block;\n  background-color: @panel-form-input-background-color;\n  color: @panel-form-input-text-color;\n  height: 40px;\n  border: 0;\n  margin-top: 10px;\n  font-size: 14px;\n  padding-left: 5px;\n}*/\n\n.markdown img {\n    max-width: 100%;\n}\n\n.markdown svg {\n    max-height: 100%;\n}\n\n.markdown input,\n.markdown select,\n.markdown textarea,\n.markdown fieldset {\n    font-family: inherit;\n    font-size: 1rem;\n    box-sizing: border-box;\n    margin-top: 0;\n    margin-bottom: 0;\n}\n\n.markdown label {\n    vertical-align: middle;\n}\n\n.markdown h1,\n.markdown h2,\n.markdown h3,\n.markdown h4,\n.markdown h5,\n.markdown h6 {\n    font-family: inherit;\n    font-weight: bold;\n    line-height: 1.25;\n    margin-top: 1em;\n    margin-bottom: .5em;\n}\n\n.markdown h1 {\n    font-size: 2rem;\n}\n\n.markdown h2 {\n    font-size: 1.5rem;\n}\n\n.markdown h3 {\n    font-size: 1.25rem;\n}\n\n.markdown h4 {\n    font-size: 1rem;\n}\n\n.markdown h5 {\n    font-size: 0.875rem;\n}\n\n.markdown h6 {\n    font-size: 0.75rem;\n}\n\n.markdown p {\n    margin-top: 0;\n    margin-bottom: 1rem;\n}\n\n.markdown strong {\n    font-weight: bold;\n}\n\n.markdown em {\n    font-style: italic;\n}\n\n.markdown small {\n    font-size: 80%;\n}\n\n.markdown mark {\n    color: #000;\n    background: #ff0;\n}\n\n.markdown u {\n    text-decoration: underline;\n}\n\n.markdown s {\n    text-decoration: line-through;\n}\n\n.markdown dl,\n.markdown ol,\n.markdown ul {\n    margin-top: 0;\n    margin-bottom: 1rem;\n}\n\n.markdown ol {\n    list-style: decimal inside;\n}\n\n.markdown ul {\n    list-style: disc inside;\n}\n\n.markdown pre,\n.markdown code,\n.markdown samp {\n    font-family: monospace;\n    font-size: inherit;\n}\n\n.markdown pre {\n    margin-top: 0;\n    margin-bottom: 1rem;\n    overflow-x: scroll;\n}\n\n.markdown a {\n    color: #68ADFE;\n    text-decoration: none;\n}\n\n.markdown a:hover {\n    text-decoration: underline;\n}\n\n.markdown pre,\n.markdown code {\n    background-color: transparent;\n    border-radius: 3px;\n}\n\n.markdown hr {\n    border: 0;\n    border-bottom-style: solid;\n    border-bottom-width: 1px;\n    border-bottom-color: rgba(0, 0, 0, 0.125);\n}\n\n.markdown .left-align {\n    text-align: left;\n}\n\n.markdown .center {\n    text-align: center;\n}\n\n.markdown .right-align {\n    text-align: right;\n}\n\n.markdown .justify {\n    text-align: justify;\n}\n\n.markdown .truncate {\n    max-width: 100%;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.markdown ol.upper-roman {\n    list-style-type: upper-roman;\n}\n\n.markdown ol.lower-alpha {\n    list-style-type: lower-alpha;\n}\n\n.markdown ul.circle {\n    list-style-type: circle;\n}\n\n.markdown ul.square {\n    list-style-type: square;\n}\n\n.markdown .list-reset {\n    list-style: none;\n    padding-left: 0;\n}\n\n.floating {\n    pointer-events: auto;\n    position: absolute;\n    border-radius: 15px;\n}\n\n.floating-horizontal {\n    pointer-events: auto;\n    position: absolute;\n    border-radius: 15px;\n    padding-left: 5px;\n    padding-right: 5px;\n}\n\n.floating-vertical {\n    pointer-events: auto;\n    position: absolute;\n    border-radius: 15px;\n    padding-top: 5px;\n    padding-bottom: 5px;\n}\n\n@media print {\n    .floating {\n        display: none;\n    }\n}\n\n.distance-legend {\n    pointer-events: auto;\n    position: absolute;\n    border-radius: 15px;\n    padding-left: 5px;\n    padding-right: 5px;\n    bottom: 30px;\n    height: 30px;\n    width: 125px;\n    box-sizing: content-box;\n}\n\n.distance-legend-label {\n    display: inline-block;\n    font-family: 'Roboto', sans-serif;\n    font-size: 14px;\n    font-weight: lighter;\n    line-height: 30px;\n    color: #FFFFFF;\n    width: 125px;\n    text-align: center;\n}\n\n.distance-legend-scale-bar {\n    border-left: 1px solid #FFFFFF;\n    border-right: 1px solid #FFFFFF;\n    border-bottom: 1px solid #FFFFFF;\n    position: absolute;\n    height: 10px;\n    top: 15px;\n}\n\n@media print {\n    .distance-legend {\n        display: none;\n    }\n}\n\n@media screen and (max-width: 700px),\nscreen and (max-height: 420px) {\n    .distance-legend {\n        display: none;\n    }\n}\n\n.navigation-controls {\n    position: absolute;\n    right: 30px;\n    top: 210px;\n    width: 30px;\n    border: 1px solid rgba(255, 255, 255, 0.1);\n    font-weight: 300;\n    -webkit-touch-callout: none;\n    -webkit-user-select: none;\n    -khtml-user-select: none;\n    -moz-user-select: none;\n    -ms-user-select: none;\n    user-select: none;\n}\n\n.navigation-control {\n    cursor: pointer;\n    border-bottom: 1px solid #555555;\n}\n\n.naviagation-control:active {\n    color: #FFF;\n}\n\n.navigation-control-last {\n    cursor: pointer;\n    border-bottom: 1px solid #555555;\n    border-bottom: 0;\n}\n\n.navigation-control-icon-zoom-in {\n    position: relative;\n    text-align: center;\n    font-size: 20px;\n    color: #FFFFFF;\n    padding-bottom: 4px;\n}\n\n.navigation-control-icon-zoom-out {\n    position: relative;\n    text-align: center;\n    font-size: 20px;\n    color: #FFFFFF;\n}\n\n.navigation-control-icon-reset {\n    position: relative;\n    left: 10px;\n    width: 10px;\n    height: 10px;\n    fill: rgba(255, 255, 255, 0.8);\n    padding-top: 6px;\n    padding-bottom: 6px;\n    box-sizing: content-box;\n}\n\n.compass {\n    pointer-events: auto;\n    position: absolute;\n    right: 0px;\n    top: 100px;\n    width: 95px;\n    height: 95px;\n    overflow: hidden;\n}\n\n.compass-outer-ring {\n    position: absolute;\n    top: 0;\n    width: 95px;\n    height: 95px;\n    fill: rgba(255, 255, 255, 0.5);\n}\n\n.compass-outer-ring-background {\n    position: absolute;\n    top: 14px;\n    left: 14px;\n    width: 44px;\n    height: 44px;\n    border-radius: 44px;\n    border: 12px solid rgba(47, 53, 60, 0.8);\n    box-sizing: content-box;\n}\n\n.compass-gyro {\n    pointer-events: none;\n    position: absolute;\n    top: 0;\n    width: 95px;\n    height: 95px;\n    fill: #CCC;\n}\n\n.compass-gyro-active {\n    fill: #68ADFE;\n}\n\n.compass-gyro-background {\n    position: absolute;\n    top: 30px;\n    left: 30px;\n    width: 33px;\n    height: 33px;\n    border-radius: 33px;\n    background-color: rgba(47, 53, 60, 0.8);\n    border: 1px solid rgba(255, 255, 255, 0.2);\n    box-sizing: content-box;\n}\n\n.compass-gyro-background:hover+.compass-gyro {\n    fill: #68ADFE;\n}\n\n.compass-rotation-marker {\n    position: absolute;\n    top: 0;\n    width: 95px;\n    height: 95px;\n    fill: #68ADFE;\n}\n\n@media screen and (max-width: 700px),\nscreen and (max-height: 420px) {\n    .navigation-controls {\n        display: none;\n    }\n    .compass {\n        display: none;\n    }\n}\n\n@media print {\n    .navigation-controls {\n        display: none;\n    }\n    .compass {\n        display: none;\n    }\n}", 
"removeListener", "addTickEvent", "setInputAction", "delay", "_colorCommands", "clearAllEditVertex", "postRenderEvent", "_maximumDistance", "BoundingRect", "equals", "Cloud", "showLateralSurfaces", "refreshEnd", "CylinderGlowFlowWallType", "_minimumLevel", "fromRotationY", "render", "documentElement", "M_PI", "online4", "option", "generateEndPoint", "SpatialAnalysis", "isEditing", "_navigationLocked", "PlotType", "PolylineTrialFlowType", "wall", "fromVertices", "#extension GL_OES_standard_derivatives : enable\r\nuniform sampler2D colorTexture;\r\nuniform sampler2D depthTexture;\r\nuniform float lineWidth;\r\nuniform float height;\r\nuniform bvec3 strokeType;\r\nuniform vec3 tjxColor;\r\nuniform vec3 bjColor;\r\nuniform vec3 cameraPos;\r\nuniform float mbDis;\r\nvarying vec2 v_textureCoordinates;\r\nvec4 toEye(in vec2 uv, in float depth){\r\n    vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));\r\n    vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0);\r\n    posInCamera =posInCamera / posInCamera.w;\r\n    return posInCamera;\r\n}\r\nfloat getDepth(in vec4 depth){\r\n    float z_window = czm_unpackDepth(depth);\r\n    z_window = czm_reverseLogDepth(z_window);\r\n    float n_range = czm_depthRange.near;\r\n    float f_range = czm_depthRange.far;\r\n    return (2.0 * z_window - n_range - f_range) / (f_range - n_range);\r\n}\r\nbool isTJX(vec2 uv,float lw){\r\n    vec2 pixelSize = lw / czm_viewport.zw;\r\n    float dx0 = -pixelSize.x;\r\n    float dy0 = -pixelSize.y;\r\n    float dx1 = pixelSize.x;\r\n    float dy1 = pixelSize.y;\r\n\r\n    vec2 currUV = uv + vec2(dx0, dy0);\r\n    vec4 currDepth = texture2D(depthTexture, currUV);\r\n    float depth = getDepth(currDepth);\r\n    if(depth>=1.0)return true;\r\n\r\n    currUV = uv + vec2(0.0, dy0);\r\n    currDepth = texture2D(depthTexture, currUV);\r\n    depth = getDepth(currDepth);\r\n    if(depth>=1.0)return true;\r\n\r\n    currUV = uv + vec2(dx1, dy0);\r\n    currDepth = texture2D(depthTexture, currUV);\r\n    depth = getDepth(currDepth);\r\n    if(depth>=1.0)return true;\r\n\r\n    currUV = uv + vec2(dx0, 0.0);\r\n    currDepth = texture2D(depthTexture, currUV);\r\n    depth = getDepth(currDepth);\r\n    if(depth>=1.0)return true;\r\n\r\n    currUV = uv + vec2(dx1, 0.0);\r\n    currDepth = texture2D(depthTexture, currUV);\r\n    depth = getDepth(currDepth);\r\n    if(depth>=1.0)return true;\r\n\r\n    currUV = uv + vec2(dx0, dy1);\r\n    currDepth = texture2D(depthTexture, currUV);\r\n    depth = getDepth(currDepth);\r\n    if(depth>=1.0)return true;\r\n\r\n    currUV = uv + vec2(0.0, dy1);\r\n    currDepth = texture2D(depthTexture, currUV);\r\n    depth = getDepth(currDepth);\r\n    if(depth>=1.0)return true;\r\n\r\n    currUV = uv + vec2(dx1, dy1);\r\n    currDepth = texture2D(depthTexture, currUV);\r\n    depth = getDepth(currDepth);\r\n    if(depth>=1.0)return true;\r\n\r\n    return false;\r\n}\r\nvoid main(){\r\n\r\n\r\n    vec4 color = texture2D(colorTexture, v_textureCoordinates);\r\n    if(height>14102.0){\r\n        gl_FragColor = color;\r\n        return;\r\n    }\r\n    vec4 currD = texture2D(depthTexture, v_textureCoordinates);\r\n    if(currD.r>=1.0){\r\n        gl_FragColor = color;\r\n        return;\r\n    }\r\n    float depth = getDepth(currD);\r\n    vec4 positionEC = toEye(v_textureCoordinates, depth);\r\n    vec3 dx = dFdx(positionEC.xyz);\r\n    vec3 dy = dFdy(positionEC.xyz);\r\n    vec3 normal = normalize(cross(dx,dy));\r\n\r\n    if(strokeType.y||strokeType.z){\r\n        vec4 wp = czm_inverseView * positionEC;\r\n        if(distance(wp.xyz,cameraPos)>mbDis){\r\n            gl_FragColor = color;\r\n        }else{\r\n            float dotNum = abs(dot(normal,normalize(positionEC.xyz)));\r\n            if(dotNum<0.05){\r\n                gl_FragColor = vec4(bjColor,1.0);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    if(strokeType.x||strokeType.z){\r\n        bool tjx = isTJX(v_textureCoordinates,lineWidth);\r\n        if(tjx){\r\n            gl_FragColor = vec4(tjxColor,1.0);\r\n            return;\r\n        }\r\n    }\r\n    gl_FragColor = color;\r\n}", 
"selectedEntity", "Object", "_sp", "getRange", "cameraMoveEndEventHnadle", "callback", "_modelMatrix", "</gml:coordinates></gml:LinearRing></gml:outerBoundaryIs></gml:Polygon></Intersects></Filter>", "_sectorVA", "drawContext", "rectangle must not be called before the imagery provider is ready.", "addPositionsHeight", "minPositionCount", "viewPositionEnd", "leaflet-popup-close-button", "multiplyByPoint", "getTime", "EPSILON", "config", "polyhedron", "PrimitiveType", "divcH", "uniform vec4 color;\nuniform float speed;\nuniform float percent;\nuniform float gradient;\n\nczm_material czm_getMaterial(czm_materialInput materialInput){\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    vec2 st = materialInput.st;\n    float t =fract(czm_frameNumber * speed / 1000.0);\n    t *= (1.0 + percent);\n    float alpha = smoothstep(t- percent, t, st.s) * step(-t, -st.s);\n    alpha += gradient;\n    material.diffuse = color.rgb;\n    material.alpha = alpha;\n    return material;\n}", 
"innerMoveStart", "tempPositions", "minimumHeights", "FloorHeigh", "BuildingEffects", "endImgUrl", "updateHeading", "handlePickMilitaryPlot", "linePositions", "get", "SceneControl", "DeveloperError", "axis", "Cartesian3", "createEntity", "positiveX", "rectangleEntity", "EditMoveCenterEntity", "billboard", "moveModelByKey", "http://www.xtgis.cc/", "headTailFactor", "FrustumGeometry", "postProcessStages", "GltfModel", "\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a\u5706\u67f1\u4f53\uff0c\u9700\u89811\u4e2a\u70b9", 
"; // \u5149\u73af\u7684\u79fb\u52a8\u8303\u56f4(\u9ad8\u5ea6)\n            gl_FragColor = vec4(", "video-js", "fromAlpha", "_boundingSphere", "20px \u5fae\u8f6f\u96c5\u9ed1", "_material", "modelEntity", "zox", "this.sources is required and must have positiveX, negativeX, positiveY, negativeY, positiveZ, and negativeZ properties.", "GradientImage", "removePrimitive", "minimumLevel", "_isPointLight", "getPositionByHeight", "ScanCircle", "_orientation", "\n                    uniform vec4 color; \n                    czm_material czm_getMaterial(czm_materialInput materialInput)\n                    {\n                        czm_material material = czm_getDefaultMaterial(materialInput); \n                        vec2 st = materialInput.st;                        \n                        float alpha = distance(st,vec2(0.5, 0.5)); \n                        material.alpha = color.a  * alpha  * 1.5; \n                        material.diffuse = color.rgb * 1.3;                            \n                        return material;\n                    }\n                    ", 
"innerCircle", " \n                    uniform float totoalFrameCount_1;\n                    uniform vec4 color_0; \n                    czm_material czm_getMaterial(czm_materialInput materialInput)\n                    {\n                        czm_material material = czm_getDefaultMaterial(materialInput);\n                        vec2 st = materialInput.st;  \n                        float t = mod(czm_frameNumber, totoalFrameCount_1) / totoalFrameCount_1; \n                        t *= 1.03;\n                        float alpha = smoothstep(t- 0.03, t, st.s) * step(-t, -st.s); \n                        alpha += 0.1;\n                        alpha *= step(-0.4, -abs(0.5-st.t));                             \n                        material.diffuse = color_0.rgb;\n                        material.alpha = alpha;\n                        return material;\n                    } \n                ", 
"addClassificationPrimitive", "updatePosition", "label-container-is-selected", "\u7acb\u4f53\u5899\u6587\u5b57\u8d34\u56fe", "removeRenderEvent", "com", "_frustum", "getSceneImage", "topPos", "HeadingPitchRoll", "\u7a81\u51fb\u65b9\u5411", "DiffCircle2MaterialSource", "display", "trs", "callee", "ParticleSystem", '</span>\n                                <span class="label-unit">m\u00b3/s</span>\n                              </div>\n                            </div>\n\n                            <div class="data-li">\n                              <div class="data-label">\u6c34\u6c60\u6db2\u4f4d\uff1a</div>\n                              <div class="data-value">\n                                <span class="label-num">', 
"ShaderSource", "CesiumWidget or Viewer is required.", "moveAnimation", "addScan2", "TexureUrl", "fireImage", "clearRect", "bottomCircleHeight", "fromRandom", "screenSpaceEventHandler", "top", "createCircleEditVertex", "scanPostStage", "fromTranslation", "maxRadius", "closeEntityEditMode", "RELATIVE_TO_GROUND", "svgCompassOuterRing", "DARKBLUE"];
function hahaha(partKeys) {
  return objkeys[partKeys - 362];
}
!function(window, factory) {
  if ("object" == typeof exports && "undefined" != typeof module) {
    factory(require("markdown-it-sanitizer"), require("markdown-it"), require("hammerjs"));
  } else {
    if ("function" == typeof define && define.amd) {
      define(".markdown-it-sanitizer", "markdown-it", "hammerjs", factory);
    } else {
      factory(window.MarkdownItSanitizer, window.MarkdownIt, window.Hammer);
    }
  }
}(this, function(obj, definition, foo) {
  function appendCSS(text, node) {
    if (void 0 === node) {
      node = {};
    }
    var self;
    var content = node.insertAt;
    if (text && "undefined" != typeof document) {
      self = document.head || document.getElementsByTagName("head")[0];
      (node = document.createElement("style")).type = "text/css";
      if ("top" === content && self.firstChild) {
        self.insertBefore(node, self.firstChild);
      } else {
        self.appendChild(node);
      }
      if (node.styleSheet) {
        node.styleSheet.cssText = text;
      } else {
        node.appendChild(document.createTextNode(text));
      }
    }
  }
  function _interopRequireWildcard(obj) {
    return obj && obj.__esModule && Object.prototype.hasOwnProperty.call(obj, "default") ? obj.default : obj;
  }
  function __webpack_require__(fn, module) {
    return fn(module = {
      "exports" : {}
    }, module.exports), module.exports;
  }
  function ctx(fn, elem, o) {
    if (!function(src) {
      if ("function" != typeof src) {
        throw TypeError(src + " is not a function!");
      }
    }(fn), void 0 === elem) {
      return fn;
    }
    switch(o) {
      case 1:
        return function(event) {
          return fn.call(elem, event);
        };
      case 2:
        return function(event, xTmp) {
          return fn.call(elem, event, xTmp);
        };
      case 3:
        return function(event, xTmp, yTmp) {
          return fn.call(elem, event, xTmp, yTmp);
        };
    }
    return function() {
      return fn.apply(elem, arguments);
    };
  }
  function isObject(obj) {
    return "object" == typeof obj ? null !== obj : "function" == typeof obj;
  }
  function resolve(name) {
    if (!isObject(name)) {
      throw TypeError(name + " is not an object!");
    }
    return name;
  }
  function processResource(urlReplacer) {
    try {
      return !!urlReplacer();
    } catch (_0x2a019a) {
      return true;
    }
  }
  function createElement(name) {
    return isFile ? document.createElement(name) : {};
  }
  function hash(obj, options) {
    if (!isObject(obj)) {
      return obj;
    }
    var fn;
    var val;
    if (options && "function" == typeof(fn = obj.toString) && !isObject(val = fn.call(obj))) {
      return val;
    }
    if ("function" == typeof(fn = obj.valueOf) && !isObject(val = fn.call(obj))) {
      return val;
    }
    if (!options && "function" == typeof(fn = obj.toString) && !isObject(val = fn.call(obj))) {
      return val;
    }
    throw TypeError("Can't convert object to primitive value");
  }
  function createDesc(buildingApp, replace) {
    return {
      "enumerable" : !(1 & buildingApp),
      "configurable" : !(2 & buildingApp),
      "writable" : !(4 & buildingApp),
      "value" : replace
    };
  }
  function has(target, key) {
    return hasOwn.call(target, key);
  }
  function setProp(type, name, value) {
    return utils.defineProperty(type, name, value);
  }
  function ColorMaterialProperty(color) {
    this._definitionChanged = new Cesium.Event;
    this._color = void 0;
    this._colorSubscription = void 0;
    this.color = color;
  }
  function PolylineArrowMaterialProperty(color) {
    this._definitionChanged = new Cesium.Event;
    this._color = void 0;
    this._colorSubscription = void 0;
    this.color = color;
  }
  function parseNode(element, t, data) {
    call(this, parseNode);
    this.viewer = element;
    this.position = t;
    this.style = data;
    this.height = data.height || 300;
    this.bottomRadius = data.bottomRadius || 30;
    this.color = data.color || Cesium.Color.AQUA;
    this.circleHeight = Cesium.Cartographic.fromCartesian(t).height;
    this.addCone();
    this.addBottomCircle();
    this.addBottomRotateCircle();
  }
  function ReferenceProperty(worldWindow, layersPanel) {
    this._definitionChanged = new Cesium.Event;
    this.color = worldWindow || Cesium.Color.YELLOW;
    this.speed = layersPanel || 10;
  }
  function updateObject(value, point, options) {
    call(this, updateObject);
    this.viewer = value;
    this.position = point;
    options = options || {};
    this.radius = options.radius || 200;
    this.color = options.color || Cesium.Color.YELLOW;
    this.speed = options.speed || 10;
    this.addEnt();
  }
  function redraw(value, position, options) {
    call(this, redraw);
    this.viewer = value;
    this.position = position;
    this.radius = options.radius;
    this.textureUrl = options.textureUrl;
    this.height = Cesium.Cartographic.fromCartesian(position).height;
    this.entities = [];
    this.addEntities();
  }
  function Number(it) {
    return isNaN(it = +it) ? 0 : (0 < it ? floor : ceil)(it);
  }
  function assertDefined(it) {
    if (null == it) {
      throw TypeError("Can't call method on  " + it);
    }
    return it;
  }
  function lookup(value) {
    return objectToString$2.call(value).slice(8, -1);
  }
  function find(name) {
    return exists(assertDefined(name));
  }
  function toLength(value) {
    return 0 < value ? $min(Number(value), 9007199254740991) : 0;
  }
  function uid(name) {
    return "Symbol(".concat(void 0 === name ? "" : name, ")_", (++_idx + num).toString(36));
  }
  function pick(object, names) {
    var key;
    var value = find(object);
    var i = 0;
    var obj = [];
    for (key in value) {
      if (key != active && has(value, key)) {
        obj.push(key);
      }
    }
    for (; names.length > i;) {
      if (has(value, key = names[i++])) {
        if (!~iteratee(obj, key)) {
          obj.push(key);
        }
      }
    }
    return obj;
  }
  function modules() {
  }
  function setToStringTag(value, source, match) {
    if (value && !has(value = match ? value : value.prototype, method)) {
      def(value, method, {
        "configurable" : true,
        "value" : source
      });
    }
  }
  function toObject(it) {
    return Object(assertDefined(it));
  }
  function returnThis() {
    return this;
  }
  function defineProperty(o, key, value) {
    if (key in o) {
      $.f(o, key, createDesc(0, value));
    } else {
      o[key] = value;
    }
  }
  function recurse(e) {
    var value;
    return void 0 === e ? "Undefined" : null === e ? "Null" : "string" == typeof(e = function(eventsDict, event) {
      try {
        return eventsDict[event];
      } catch (_0xb6fd12) {
      }
    }(value = Object(e), b)) ? e : valueMightNeedDecoding ? lookup(value) : "Object" == (e = lookup(value)) && "function" == typeof value.callee ? "Arguments" : e;
  }
  function report(value, percent, options) {
    call(this, report);
    this.viewer = value;
    this.feature = percent;
    this.options = options || {
      "bufCount" : 50,
      "bufDis" : 20,
      "color" : Cesium.Color.WHITE
    };
    percent = this.multipleRingBuffer(percent, this.options.bufCount, this.options.bufDis);
    this.addRegionData(percent, this.options.bufCount);
  }
  function Link(point1, point2) {
    return call(this, Link), new Cesium["Primitive"]({
      "geometryInstances" : new Cesium["GeometryInstance"]({
        "geometry" : point1
      }),
      "appearance" : this.createMaterialAppearance(point2)
    });
  }
  function val(pos, value, range) {
    var result = [];
    range = range || 360;
    var runCount = parseInt(360 / range);
    var i = 0;
    for (; i <= 360; i = i + runCount) {
      result.push(gen(pos[0], pos[1], i, value));
    }
    return result;
  }
  function gen(counter, duration, step, start) {
    var startingAngle = start * Math.sin(step * Math.PI / 180);
    start = start * Math.cos(step * Math.PI / 180);
    step = 6356725 + 21412 * (90 - duration) / 90;
    return [180 * (startingAngle / (step * Math.cos(duration * Math.PI / 180)) + counter * Math.PI / 180) / Math.PI, 180 * (start / step + duration * Math.PI / 180) / Math.PI];
  }
  function parser(text) {
    if ((text = text.toLowerCase()) && /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/.test(text)) {
      if (4 === text.length) {
        var infoValue = "#";
        var i = 1;
        for (; i < 4; i = i + 1) {
          infoValue = infoValue + text.slice(i, i + 1).concat(text.slice(i, i + 1));
        }
        text = infoValue;
      }
      var parts = [];
      i = 1;
      for (; i < 7; i = i + 2) {
        parts.push(parseInt("0x" + text.slice(i, i + 2)));
      }
      return parts;
    }
    return text;
  }
  function replace(value, p, options) {
    call(this, replace);
    this.viewer = value;
    options = options || {};
    this.radius = options.radius || 100;
    this.cylinderHeight = options.cylinderHeight || 200;
    this.bottomCircleHeight = Cesium.Cartographic.fromCartesian(p).height;
    this.generatePositions(p);
    this.wallMaterial = new Location({
      "color" : options.fillColor || Cesium.Color.WHITE,
      "img" : options.TexureUrl + "/4.png"
    });
    this.flowWallMaterial = new DataString({
      "color" : options.fillColor || Cesium.Color.WHITE,
      "duration" : options.duration || 1E3,
      "img" : options.TexureUrl + "/3.png"
    });
    this.innerCircleMaterial = new Range({
      "color" : options.bottomInnerCircleColor || Cesium.Color.WHITE,
      "img" : options.TexureUrl + "/1.png"
    });
    this.outerrCircleMaterial = new Range({
      "color" : options.bottomOuterCircleColor || Cesium.Color.WHITE,
      "img" : options.TexureUrl + "/2.png"
    });
    this.addWall();
    this.addFlowWall();
    this.addInnerCircle(p);
    this.addOuterCircle(p);
  }
  function buildLightbox(viewer, e, ellipseMode) {
    call(this, buildLightbox);
    this.viewer = viewer;
    this.position = e;
    this.cssColor = ellipseMode;
    this.initDom();
    this.initEvent();
  }
  function Label(name, data, options) {
    call(this, Label);
    this.viewer = name;
    this.style = options;
    this.position = data;
    this.extrudedHeight = Cesium.defaultValue(options.height, 1E3);
    this.u_color = Cesium.defaultValue(options.color, Cesium.Color.fromCssColorString("#00ffff"));
    this._show = Cesium.defaultValue(options.show, true);
    this._distanceDisplayCondition = Cesium.defaultValue(options.distanceDisplayCondition, new Cesium["DistanceDisplayConditionGeometryInstanceAttribute"]);
    options = Cesium.defaultValue(options.radius, 100);
    this.topRadius = options / 100;
    this.topRadius = 1 < this.topRadius ? 1 : this.topRadius;
    this.inner_controlPoints = rotate(this.position, 0.7 * options);
    this.outer_controlPoints = rotate(this.position, options);
    this.circular_clone_topPoints = rotate(this.position, this.topRadius);
    this.circlePoints_2 = rotate(this.position, 2 * options);
    this.primitive1 = null;
    this.primitive2 = null;
    this.primitive3 = null;
    this.primitive4 = null;
    this.ringCanvas = this.drawRingCanvas();
    this.gradientCircleCanvas = this.cirdrawGradientCircleCanvas();
    this.draw();
  }
  function createGeometry(geometry, options) {
    return geometry = new Cesium.PolygonGeometry({
      "polygonHierarchy" : new Cesium["PolygonHierarchy"](geometry),
      "perPositionHeight" : options.perPositionHeight
    }), new Cesium["GeometryInstance"]({
      "geometry" : geometry,
      "attributes" : {
        "distanceDisplayCondition" : options.distanceDisplayCondition
      }
    });
  }
  function update(geometry, options, prop) {
    var id = prop.height;
    var outlineColor = prop.color || new Cesium["Color"](0.5, 0.8, 1, 2);
    var heading = geometry.slice();
    var width = geometry.length;
    var l = 2 * width;
    var vs = [];
    var x = 1 / (width - 1);
    var indices = [];
    var nodes = [];
    var i = 0;
    for (; i < width; i++) {
      nodes.push(function(a, s) {
        if (s = Number(s) || 0, isNaN(s) || 0 == s) {
          return a;
        }
        {
          if (a instanceof Array) {
            var r = [];
            var i = 0;
            var az = a.length;
            for (; i < az; i++) {
              var position = Cesium.Cartographic.fromCartesian(a[i]);
              var id = Cesium.Cartesian3.fromRadians(position.longitude, position.latitude, position.height + s);
              r.push(id);
            }
            return r;
          }
          return position = Cesium.Cartographic.fromCartesian(a), Cesium.Cartesian3.fromRadians(position.longitude, position.latitude, position.height + s);
        }
      }(options[i], id));
      vs.push(i * x);
      vs.push(0);
      var j = (i + 1) % width;
      var k = l - (i + 1);
      indices.push.apply(indices, [k - 1, k, i]);
      indices.push.apply(indices, [i, j, k - 1]);
    }
    var n = 0;
    for (; n < nodes.length; n++) {
      heading.push(nodes[width - n - 1]);
      vs.push(1 - n * x);
      vs.push(1);
    }
    return geometry = new Cesium.PolygonGeometry({
      "polygonHierarchy" : new Cesium.PolygonHierarchy(heading),
      "perPositionHeight" : true
    }), (geometry = Cesium.PolygonGeometry.createGeometry(geometry)).indices = indices, geometry.attributes.st.values = vs, new Cesium["GeometryInstance"]({
      "geometry" : geometry,
      "attributes" : {
        "color" : Cesium.ColorGeometryInstanceAttribute.fromColor(outlineColor),
        "distanceDisplayCondition" : prop.distanceDisplayCondition
      }
    });
  }
  function rotate(center, options, completionCallback) {
    var clientHeight = 2 < arguments.length && void 0 !== completionCallback ? completionCallback : 120;
    var self = [];
    var matrix = Cesium.Transforms.eastNorthUpToFixedFrame(center);
    var clientAspectRatio = 2 * Math.PI / clientHeight;
    var first_position = 2 * Math.PI * 270 / 360;
    var targetOffsetHeight = 0;
    for (; targetOffsetHeight < clientHeight; targetOffsetHeight++) {
      var position = first_position - clientAspectRatio * targetOffsetHeight;
      position = new Cesium.Cartesian3(Math.sin(position) * options, Math.cos(position) * options, 0);
      self.push(Cesium.Matrix4.multiplyByPoint(matrix, position, new Cesium["Cartesian3"]));
    }
    return self.push(self[0]), self;
  }
  function World(viewer, width, settings) {
    call(this, World);
    this.viewer = viewer;
    this.tileset = width;
    this.clickHighlight = settings.clickHighlight;
    this.color = settings.color || "0.2, 0.5, 1.0, 1.0";
    this.glowRange = settings.glowRange;
    this.glowRangeHeight = settings.glowRangeHeight || "100.0";
    this.shader = settings.shader || this.getShader();
    this.selctedFeature = {};
    this.addEvent();
  }
  function Box(name, style) {
    var same = this;
    return call(this, Box), this.style = style || {}, this.primitive = this.createPrimitive(name), this.primitive.updateColor = function(index) {
      var rel2Mstr = hahaha;
      same[rel2Mstr(1023)][rel2Mstr(1789)][rel2Mstr(1187)][rel2Mstr(681)][rel2Mstr(2240)] = index;
    }, this.primitive;
  }
  function copy(value, p, from) {
    call(this, copy);
    this.viewer = value;
    this.position = p;
    this.style = from || {};
    this.addPyramidModel();
    this.addCilcle();
  }
  function Node(props) {
    call(this, Node);
    this._definitionChanged = new Cesium.Event;
    this._color = void 0;
    this._colorSubscription = void 0;
    this.color = props.color;
    this.duration = props.duration;
    this._time = (new Date).getTime();
  }
  function getDimensions(value, index, style) {
    call(this, getDimensions);
    this.viewer = value;
    this.position = index;
    this.style = style;
    this.createEntity();
  }
  function PolylineGlowProperty(options) {
    call(this, PolylineGlowProperty);
    this._definitionChanged = new Cesium.Event;
    this._color = void 0;
    this._colorSubscription = void 0;
    this.color = options.color;
    this.url = options.url;
  }
  function source(value, i, s) {
    call(this, source);
    this.viewer = value;
    this.position = i;
    this.style = s;
    this.maxRadius = s.radius || 200;
    this.createEntity();
  }
  function GridMaterialProperty(options) {
    call(this, GridMaterialProperty);
    this._definitionChanged = new Cesium.Event;
    this._color = void 0;
    this._colorSubscription = void 0;
    this.color = options.color;
    this.url = options.url;
  }
  function inject(element, $compile, scope) {
    call(this, inject);
    this.viewer = element;
    this.position = $compile;
    this.style = scope;
    this.radius = scope.radius || 10;
    this.addCircle();
  }
  function parseModel(value, data, attributes) {
    call(this, parseModel);
    this.viewer = value;
    this.position = data;
    this.style = attributes || {};
    this.addRadarScan(this.position, attributes.radius || 100, attributes.color || Cesium.Color.RED, attributes.duration || 1E3);
  }
  function Animation(options) {
    call(this, Animation);
    options = Cesium.defaultValue(options, Cesium.defaultValue.EMPTY_OBJECT);
    this._definitionChanged = new Cesium.Event;
    this._color = void 0;
    this._colorSubscription = void 0;
    this.color = options.color;
    this.duration = Cesium.defaultValue(options.duration, 1E3);
    this.count = Cesium.defaultValue(options.count, 2);
    if (this.count <= 0) {
      this.count = 1;
    }
    this.gradient = Cesium.defaultValue(options.gradient, 0.1);
    if (this.gradient < 0) {
      this.gradient = 0;
    } else {
      if (1 < this.gradient) {
        this.gradient = 1;
      }
    }
    this._time = (new Date).getTime();
  }
  function attribute(value, data, style) {
    call(this, attribute);
    this.viewer = value;
    this.position = data;
    this.style = style;
    this.radius = style.radius || 10;
    this.addCircle();
  }
  function v(value, i, p) {
    call(this, v);
    this.viewer = value;
    this.position = i;
    this.rAngle = p || 0.05;
  }
  function selected(value, target) {
    call(this, selected);
    this.viewer = value;
    this.bookmarkList = target || [];
  }
  function emit(value, target, options) {
    call(this, emit);
    this.viewer = value;
    this.position = target;
    this.options = options || {};
    this.initLimit();
  }
  function path(value, target) {
    call(this, path);
    this.viewer = value;
    this.rAngle = Cesium.Math.toRadians(target || -0.05);
  }
  function fullName(value) {
    call(this, fullName);
    this.viewer = value;
  }
  function label(value, target) {
    call(this, label);
    this.viewer = value;
    this.opts = target;
  }
  function getResult(obj, type) {
    call(this, getResult);
    this.viewer = obj;
    this.totalTime = type || 60;
  }
  function selector(value, target) {
    call(this, selector);
    this.viewer = value;
    this.mouseClickPosition = void 0;
    this.fdDataServerBaseUrl = target.fdDataServerBaseUrl;
    this.BuildingSelectedEvent = new Cesium.Event;
    this.initEvents();
  }
  function addEvent(value, target) {
    call(this, addEvent);
    this.viewer = value;
    this.fcPrimitives = [];
    this.fcDataServerBaseUrl = target.fcDataServerBaseUrl;
    this.FloorSelectedEvent = new Cesium.Event;
    this.initEvents();
  }
  function fireEvent(value, extra) {
    call(this, fireEvent);
    this.viewer = value;
    this.fhPrimitives = [];
    this.fcDataServerBaseUrl = extra.fcDataServerBaseUrl;
    this.fhDataServerBaseUrl = extra.fhDataServerBaseUrl;
    this.HouseSelectedEvent = new Cesium.Event;
    this.initEvents();
  }
  function initialize(viewer, pos, text, data, values) {
    if (call(this, initialize), !Array.isArray(data) || !Array.isArray(values)) {
      throw "\u5b57\u6bb5\u548c\u503c\u5fc5\u987b\u4e3a\u6570\u7ec4\u7c7b\u578b";
    }
    if (data.length != values.length) {
      throw "\u5b57\u6bb5\u548c\u503c\u6570\u7ec4\u957f\u5ea6\u4e0d\u4e00\u81f4\uff01";
    }
    this.viewer = viewer;
    this.position = pos;
    this.title = text;
    this.fields = data;
    this.values = values;
    this.createDom();
    viewer.cesiumWidget.container.appendChild(this.container);
    this.initDom();
    this.initEvent();
    this.addPostRender();
  }
  function name(value, target, options) {
    call(this, name);
    this.viewer = value;
    this.position = target;
    this.options = options || {};
    this.add();
  }
  function index(value, i, data, options) {
    call(this, index);
    this.viewer = value;
    this.position = i;
    this.text = data;
    this.options = options || {};
    this.add();
  }
  function node(value, position, options) {
    call(this, node);
    this.viewer = value;
    var cart = Cesium.Cartographic.fromCartesian(position);
    value = Cesium.Math.toDegrees(cart.longitude);
    position = Cesium.Math.toDegrees(cart.latitude);
    this.point = [value, position, cart.height];
    this.options = options || {};
    this.addEntity();
    if (this.options.label) {
      this.addLabel();
    }
  }
  function open(name, value, target, options, extra_options) {
    call(this, open);
    this.viewer = name;
    this.position = value;
    this.title = target;
    this.options = options;
    this.style = extra_options || {};
    this.init();
  }
  function scroll(value, target, data) {
    call(this, scroll);
    this.viewer = value;
    this.position = target;
    this.html = data;
    this.createDom();
    this.initEvent();
  }
  function url(value, obj, data) {
    call(this, url);
    this.viewer = value;
    this.modelPositon = obj;
    this.animateEntity = this.viewer.entities.add({
      "position" : obj,
      "model" : {
        "uri" : data.modelUrl,
        "scale" : data.scale
      }
    });
  }
  function Notification(value, x, options) {
    call(this, Notification);
    this.viewer = value;
    this.modelPositon = x;
    this.animateEntity = this.viewer.entities.add({
      "position" : x,
      "billboard" : {
        "image" : options.iconUrl,
        "scaleByDistance" : options.scaleByDistance || new Cesium["NearFarScalar"](1200, 1, 5200, 0.4),
        "distanceDisplayCondition" : options.distanceDisplayCondition || new Cesium["DistanceDisplayCondition"](0, 1E4)
      }
    });
  }
  function list(value, obj, name) {
    call(this, list);
    this.viewer = value;
    this.position = obj;
    this.label = name;
    this.animateEntity = this.viewer.entities.add({
      "position" : obj,
      "point" : {
        "pixelSize" : 0.1,
        "color" : Cesium.Color.WHITE.withAlpha(0.001)
      }
    });
    this.createDom();
    this.addPostRender();
  }
  function options(name, element) {
    call(this, options);
    echarts.registerCoordinateSystem("cesium", this.getE3CoordinateSystem(name));
    this.init(name, element);
    this.visible = true;
    this.setChartOption(element);
  }
  function Timer(options) {
    call(this, Timer);
    this._definitionChanged = new Cesium.Event;
    this._color = void 0;
    this._colorSubscription = void 0;
    this.color = options.color;
    this.duration = options.duration;
    this.count = options.count;
    this._time = (new Date).getTime();
  }
  function comment(value, data, target) {
    call(this, comment);
    this.viewer = value;
    this.position = data;
    this.style = target || {};
    this.addPrimitive();
  }
  function step(value, name, data) {
    call(this, step);
    this.viewer = value;
    this.position = name;
    this.style = data || {};
    this.addPrimitive();
  }
  function render_glance(val) {
    var line = [];
    return val.map(function(value) {
      line.push(function(position) {
        return position = Cesium.Cartographic.fromCartesian(position), [Cesium.Math.toDegrees(position.longitude), Cesium.Math.toDegrees(position.latitude)];
      }(value));
    }), line.push(line[0]), val = turf.lineString(line), turf.booleanClockwise(val);
  }
  function createPath3D(values) {
    var length = values.length;
    var connections = [];
    var i = 0;
    for (; i < length; ++i) {
      var n = (i + 1) % length;
      var p = Cesium.Cartesian3.add(values[i], values[n], new Cesium.Cartesian3);
      p = Cesium.Cartesian3.multiplyByScalar(p, 0.5, p);
      var a = Cesium.Cartesian3.normalize(p, new Cesium.Cartesian3);
      n = Cesium.Cartesian3.subtract(values[n], p, new Cesium["Cartesian3"]);
      n = Cesium.Cartesian3.normalize(n, n);
      n = Cesium.Cartesian3.cross(n, a, new Cesium["Cartesian3"]);
      n = Cesium.Cartesian3.normalize(n, n);
      a = new Cesium.Plane(n, 0);
      p = Cesium.Plane.getPointDistance(a, p);
      connections.push(new Cesium["ClippingPlane"](n, p));
    }
    return connections;
  }
  function func(data) {
    return data = Cesium.Cartographic.fromCartesian(data), [Cesium.Math.toDegrees(data.longitude), Cesium.Math.toDegrees(data.latitude), data.height];
  }
  function target(value) {
    call(this, target);
    this.viewer = value;
  }
  function current(value) {
    call(this, current);
    this.viewer = value;
  }
  function values(obj) {
    call(this, values);
    this.viewer = obj;
    this.initKeyEvent();
  }
  function tick(value, target, config) {
    call(this, tick);
    this.viewer = value;
    this.position = target;
    this.modelUrl = config.modelUrl;
    this.enable = false;
    this.options = config;
    this.radian = Cesium.Math.toRadians(config.angle || 1);
    this.speed = config.speed || 1;
    this.speedVector = new Cesium["Cartesian3"];
    this.flag = {
      "moveUp" : false,
      "moveDown" : false,
      "moveLeft" : false,
      "moveRight" : false
    };
  }
  function prepare(value, target, config) {
    call(this, prepare);
    this.viewer = value;
    this.position = target;
    this.modelUrl = config.modelUrl;
    this.options = config;
    this.enable = false;
    this.radian = Cesium.Math.toRadians(config.angle || 1);
    this.hpRange = new Cesium["HeadingPitchRange"];
    this.speed = config.speed || 1;
    this.speedVector = new Cesium["Cartesian3"];
    this.role = config.role || 0;
    this.aotuPickHeight = config.aotuPickHeight;
    this.flag = {
      "moveUp" : false,
      "moveDown" : false,
      "moveLeft" : false,
      "moveRight" : false
    };
  }
  function tabs(callback) {
    call(this, tabs);
    this.viewer = callback;
    this.viewer.cesiumWidget.screenSpaceEventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);
    this.initEvents();
  }
  function entry(value) {
    call(this, entry);
    this.viewer = value;
    this.initEventHandler();
  }
  function constructor(name, value, target) {
    call(this, constructor);
    this.viewer = name;
    this.position = value;
    this.label = target;
    this.initDom();
    this.initEvent();
  }
  function count(v, data, label) {
    call(this, count);
    this.viewer = v;
    this.position = data;
    this.label = label;
    this.initDom();
    this.initEvent();
  }
  function createIntervalElements() {
    var d = new Date;
    var myLink = d.getFullYear() + "";
    return myLink = myLink + (d.getMonth() + 1), myLink = myLink + d.getDate(), myLink = myLink + d.getHours(), myLink = myLink + d.getMinutes(), myLink = myLink + d.getSeconds(), myLink = myLink + d.getMilliseconds();
  }
  function geocode(deps, context) {
    context = context || get(deps[0]);
    var i = 0;
    for (; i < deps.length; i++) {
      var json = require(deps[i]);
      deps[i] = Cesium.Cartesian3.fromDegrees(json.x, json.y, context);
    }
    return context;
  }
  function get(c) {
    return Cesium.Cartographic.fromCartesian(c).height;
  }
  function require(p) {
    return p = Cesium.Cartographic.fromCartesian(p), {
      "x" : Cesium.Math.toDegrees(p.longitude),
      "y" : Cesium.Math.toDegrees(p.latitude),
      "z" : p.height
    };
  }
  function geodeticToGeocentric(p, c) {
    if (!p || !c) {
      return null;
    }
    return p = require(p), c = require(c), c = {
      "x" : (p.x + c.x) / 2,
      "y" : (p.y + c.y) / 2,
      "z" : (p.z + c.z) / 2
    }, Cesium.Cartesian3.fromDegrees(c.x, c.y, c.z);
  }
  function parseFloat(position) {
    return position = Cesium.Cartographic.fromCartesian(position), [Cesium.Math.toDegrees(position.longitude), Cesium.Math.toDegrees(position.latitude)];
  }
  function compute(position) {
    return position = Cesium.Cartographic.fromCartesian(position), [Cesium.Math.toDegrees(position.longitude), Cesium.Math.toDegrees(position.latitude), position.height];
  }
  function all(x2) {
    var primaryReplicas = [];
    return x2.forEach(function(item) {
      var stringify = hahaha;
      primaryReplicas[stringify(2008)](parseFloat(item));
    }), primaryReplicas;
  }
  function getDistance(value, i) {
    var p;
    var len = parseFloat(value);
    var k = parseFloat(i);
    return p = k, i = (value = len)[1] * Math.PI / 180, k = p[1] * Math.PI / 180, len = i - k, p = value[0] * Math.PI / 180 - p[0] * Math.PI / 180, p = 2 * Math.asin(Math.sqrt(Math.pow(Math.sin(len / 2), 2) + Math.cos(i) * Math.cos(k) * Math.pow(Math.sin(p / 2), 2))), p = p * 6378.137, p = Math.round(1E4 * p) / 10;
  }
  function renderer(value) {
    call(this, renderer);
    this.viewer = value;
    this.createDom();
    this.addPostRender();
  }
  function anonymous(data) {
    call(this, anonymous);
    this.viewer = data;
    this.addPoint();
  }
  function addFile(cfg, container) {
    return {
      "value" : container,
      "done" : !!cfg
    };
  }
  function onLoad(name) {
    var object = core.Symbol || (core.Symbol = {});
    if (!("_" == name.charAt(0) || name in object)) {
      maybeDefine(object, name, {
        "value" : ret.f(name)
      });
    }
  }
  function wrap(tag) {
    var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
    return sym._k = tag, sym;
  }
  function check(value, obj) {
    resolve(value);
    var i;
    var ret = function(value) {
      var result = flatten(value);
      var callback = req.f;
      if (callback) {
        var key;
        var args = callback(value);
        var isEnum = pIE.f;
        var argIndex = 0;
        for (; args.length > argIndex;) {
          if (isEnum.call(value, key = args[argIndex++])) {
            result.push(key);
          }
        }
      }
      return result;
    }(obj = find(obj));
    var r = 0;
    var rl = ret.length;
    for (; r < rl;) {
      set(value, i = ret[r++], obj[i]);
    }
    return value;
  }
  function respond(res, key) {
    if (resolve(res), !isObject(key) && null !== key) {
      throw TypeError(key + ": can't set as prototype!");
    }
  }
  function Variable(type, obj) {
    return map.create(type, obj);
  }
  function loadModel(str, name) {
    var ret = [];
    name = name || 0;
    var tmp;
    var _storeName;
    var i = 0;
    for (; i < str.length; i++) {
      ret.push((tmp = str[i], _storeName = name, Cesium.Cartesian3.fromDegrees(tmp[0], tmp[1], _storeName)));
    }
    return ret;
  }
  function stringify(position) {
    return position = Cesium.Cartographic.fromCartesian(position), [Cesium.Math.toDegrees(position.longitude), Cesium.Math.toDegrees(position.latitude)];
  }
  function assert(val) {
    var res = [];
    var i = 0;
    for (; i < val.length; i++) {
      res.push(stringify(val[i]));
    }
    return res;
  }
  function table(value, type) {
    call(this, table);
    this.viewer = value;
    this.properties = type.properties;
    this.properties.plotBase = "MilitaryPlot";
    this.coordinates = type.geometry.coordinates;
    this.style = this.properties.style;
    this.initConsts();
    this.setPoints(this.coordinates[0]);
  }
  function TacoTableCell(props, current) {
    return call(this, TacoTableCell), current = getPrototypeOf(this, (TacoTableCell.__proto__ || Object.getPrototypeOf(TacoTableCell)).call(this, props, current)), current.properties.plotType = IPTYPE.POLYGON, current.properties.plotName = "\u9762", current.generateEntity(), current.minPointCount = 3, current;
  }
  function cb(value, other) {
    return Math.sqrt(Math.pow(value[0] - other[0], 2) + Math.pow(value[1] - other[1], 2));
  }
  function keys(obj) {
    var html = 0;
    return obj && Array.isArray(obj) && 0 < obj.length && obj.forEach(function(data, type) {
      var getKey = hahaha;
      if (type < obj[getKey(2189)] - 1) {
        html = html + cb(data, obj[type + 1]);
      }
    }), html;
  }
  function merge(val) {
    return Math.pow(keys(val), 0.99);
  }
  function format(a, v) {
    return [(a[0] + v[0]) / 2, (a[1] + v[1]) / 2];
  }
  function getValue(target, source) {
    var oldOffset = void 0;
    var theta = Math.asin(Math.abs(source[1] - target[1]) / cb(target, source));
    return source[1] >= target[1] && source[0] >= target[0] ? oldOffset = theta + Math.PI : source[1] >= target[1] && source[0] < target[0] ? oldOffset = 2 * Math.PI - theta : source[1] < target[1] && source[0] < target[0] ? oldOffset = theta : source[1] < target[1] && source[0] >= target[0] && (oldOffset = Math.PI - theta), oldOffset;
  }
  function print(path, view, url) {
    return (url = getValue(view, path) - getValue(view, url)) < 0 ? url + 2 * Math.PI : url;
  }
  function transform(i, array, tagName) {
    return (tagName[1] - i[1]) * (array[0] - i[0]) > (array[1] - i[1]) * (tagName[0] - i[0]);
  }
  function filter(t, value, path, event, filename) {
    var height = 1 - (t = Math.max(Math.min(t, 1), 0));
    var sqrT = t * t;
    var cubT = sqrT * t;
    var y = height * height;
    var y2 = y * height;
    return [y2 * value[0] + 3 * y * t * path[0] + 3 * height * sqrT * event[0] + cubT * filename[0], y2 * value[1] + 3 * y * t * path[1] + 3 * height * sqrT * event[1] + cubT * filename[1]];
  }
  function callback(s, v, p, value, i) {
    return s = getValue(s, v), s = i ? s + p : s - p, p = value * Math.cos(s), s = value * Math.sin(s), [v[0] + p, v[1] + s];
  }
  function debug(s, context, x, y) {
    var value = fillCorner(context, x, y);
    var xGrid = null;
    var _0xdb8791 = null;
    var height = null;
    var len = Math.sqrt(value[0] * value[0] + value[1] * value[1]);
    var t = value[0] / len;
    var ratio = value[1] / len;
    var v = cb(context, x);
    value = cb(x, y);
    _0xdb8791 = 0.000003 < len ? transform(context, x, y) ? (height = s * v, xGrid = [x[0] - height * ratio, x[1] + height * t], height = s * value, [x[0] + height * ratio, x[1] - height * t]) : (height = s * v, xGrid = [x[0] + height * ratio, x[1] - height * t], height = s * value, [x[0] - height * ratio, x[1] + height * t]) : (xGrid = [x[0] + s * (context[0] - x[0]), x[1] + s * (context[1] - x[1])], [x[0] + s * (y[0] - x[0]), x[1] + s * (y[1] - x[1])]);
    return [xGrid, _0xdb8791];
  }
  function toString(input) {
    if (input.length <= 2) {
      return input;
    }
    var data = [];
    var i = input.length - 1;
    var x = 0;
    for (; x <= 1; x = x + 0.01) {
      var errorPath = 0;
      var value = 0;
      var j = 0;
      for (; j <= i; j++) {
        var result = pow(i, j);
        var sign = Math.pow(x, j);
        var descending = Math.pow(1 - x, i - j);
        errorPath = errorPath + result * sign * descending * input[j][0];
        value = value + result * sign * descending * input[j][1];
      }
      data.push([errorPath, value]);
    }
    return data.push(input[i]), data;
  }
  function factorial(n) {
    var t = 1;
    switch(n) {
      case n <= 1:
        t = 1;
        break;
      case 2 === n:
        t = 2;
        break;
      case 3 === n:
        t = 6;
        break;
      case 24 === n:
        t = 24;
        break;
      case 5 === n:
        t = 120;
        break;
      default:
        var i = 1;
        for (; i <= n; i++) {
          t = t * i;
        }
    }
    return t;
  }
  function clamp(val) {
    if (val.length <= 2) {
      return val;
    }
    var ops = [];
    var rightBase = val.length - 2 - 1;
    ops.push(val[0]);
    var base = 0;
    for (; base <= rightBase; base++) {
      var X = 0;
      for (; X <= 1; X = X + 0.05) {
        var author = 0;
        var cursorA = 0;
        var i = 0;
        for (; i <= 2; i++) {
          var result = calculate(i, X);
          author = author + result * val[base + i][0];
          cursorA = cursorA + result * val[base + i][1];
        }
        ops.push([author, cursorA]);
      }
    }
    return ops.push(val[val.length - 1]), ops;
  }
  function StarRatingComponent(props, current) {
    return call(this, StarRatingComponent), current = getPrototypeOf(this, (StarRatingComponent.__proto__ || Object.getPrototypeOf(StarRatingComponent)).call(this, props, current)), current.properties.plotType = IPTYPE.CLOSED_CURVE, current.properties.plotName = "\u66f2\u7ebf\u9762", current;
  }
  function FormTextInput(props, current) {
    return call(this, FormTextInput), current = getPrototypeOf(this, (FormTextInput.__proto__ || Object.getPrototypeOf(FormTextInput)).call(this, props, current)), current.properties.plotType = IPTYPE.CIRCLE, current.properties.plotName = "\u6b63\u5706", current.fixPointCount = 2, current;
  }
  function ShareCollection(props, current) {
    return call(this, ShareCollection), current = getPrototypeOf(this, (ShareCollection.__proto__ || Object.getPrototypeOf(ShareCollection)).call(this, props, current)), current.properties.plotType = IPTYPE.ELLIPSE, current.properties.plotName = "\u692d\u5706", current;
  }
  function RemoveStyleControls(props, current) {
    return call(this, RemoveStyleControls), current = getPrototypeOf(this, (RemoveStyleControls.__proto__ || Object.getPrototypeOf(RemoveStyleControls)).call(this, props, current)), current.properties.plotType = IPTYPE.SECTOR, current.properties.plotName = "\u6247\u5f62", current;
  }
  function Scene3DViewer(props, current) {
    return call(this, Scene3DViewer), current = getPrototypeOf(this, (Scene3DViewer.__proto__ || Object.getPrototypeOf(Scene3DViewer)).call(this, props, current)), current.properties.plotType = IPTYPE.RECTANGLE, current.properties.plotName = "\u77e9\u5f62", current;
  }
  function TopSelect(config, value) {
    return call(this, TopSelect), value = getPrototypeOf(this, (TopSelect.__proto__ || Object.getPrototypeOf(TopSelect)).call(this, config, value)), value.properties.plotType = IPTYPE.FINE_ARROW, value.properties.plotName = "\u76f4\u7bad\u5934", value;
  }
  function FastArray(value, def) {
    return call(this, FastArray), def = getPrototypeOf(this, (FastArray.__proto__ || Object.getPrototypeOf(FastArray)).call(this, value, def)), def.properties.plotType = IPTYPE.ASSAULT_DIRECTION, def.properties.plotName = "\u7a81\u51fb\u65b9\u5411", def;
  }
  function PatternMask(opts, current) {
    return call(this, PatternMask), current = getPrototypeOf(this, (PatternMask.__proto__ || Object.getPrototypeOf(PatternMask)).call(this, opts, current)), current.properties.plotType = IPTYPE.ATTACK_ARROW, current.properties.plotName = "\u8fdb\u653b\u65b9\u5411", current;
  }
  function ReactGoogleAutocomplete(props, current) {
    return call(this, ReactGoogleAutocomplete), current = getPrototypeOf(this, (ReactGoogleAutocomplete.__proto__ || Object.getPrototypeOf(ReactGoogleAutocomplete)).call(this, props, current)), current.properties.plotType = IPTYPE.TAILED_ATTACK_ARROW, current.properties.plotName = "\u8fdb\u653b\u65b9\u5411\u5c3e", current;
  }
  function ColorControls(props, current) {
    return call(this, ColorControls), current = getPrototypeOf(this, (ColorControls.__proto__ || Object.getPrototypeOf(ColorControls)).call(this, props, current)), current.properties.plotType = IPTYPE.DOUBLE_ARROW, current.properties.plotName = "\u94b3\u51fb", current;
  }
  function ElementEditor(props, context) {
    return call(this, ElementEditor), context = getPrototypeOf(this, (ElementEditor.__proto__ || Object.getPrototypeOf(ElementEditor)).call(this, props, context)), context.properties.plotType = IPTYPE.GATHERING_PLACE, context.properties.plotName = "\u96c6\u7ed3\u5730", context;
  }
  function LineChart(data, parent, container) {
    return call(this, LineChart), container = getPrototypeOf(this, (LineChart.__proto__ || Object.getPrototypeOf(LineChart)).call(this, data, parent, container)), container.properties.plotType = IPTYPE.SQUAD_COMBAT, container.properties.plotName = "\u5206\u961f\u6218\u6597", container.minPointCount = 2, container;
  }
  function ScatterChart(err, container) {
    return call(this, ScatterChart), container = getPrototypeOf(this, (ScatterChart.__proto__ || Object.getPrototypeOf(ScatterChart)).call(this, err, container)), container.properties.plotType = IPTYPE.TAILED_SQUAD_COMBAT, container.properties.plotName = "\u5206\u961f\u6218\u6597\u5c3e", container.minPointCount = 2, container;
  }
  function onready(element) {
    call(this, onready);
    this.viewer = element;
    this.viewer.cesiumWidget.screenSpaceEventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);
    this.initEvents();
  }
  function SyncedObject(value, target) {
    call(this, SyncedObject);
    this.viewer = value;
    this.militaryPlotLayer = target;
    this.initEventHandler();
  }
  function match(name) {
    call(this, match);
    this.viewer = name;
    this.plots = [];
    this.plotSelecteable = false;
  }
  function ThreadForm(obj) {
    return call(this, ThreadForm), obj = getPrototypeOf(this, (ThreadForm.__proto__ || Object.getPrototypeOf(ThreadForm)).call(this, obj)), obj.selectedPlotChanged = new Cesium.Event, obj.initEvent(), obj;
  }
  function i(value, target) {
    call(this, i);
    this.viewer = value;
    this.htmlPlotLayer = target;
    this.registerMouseEvents();
  }
  function proceed(type, value) {
    call(this, proceed);
    this.properties = value.properties;
    this.coordinates = value.geometry.coordinates;
    this.style = this.properties.style || {};
    this.position = Cesium.Cartesian3.fromDegrees(this.coordinates[0], this.coordinates[1], this.coordinates[2]);
    this.properties.plotBase = "Html";
    this.viewer = type;
    this.addBillboard();
  }
  function _class(className, value) {
    call(this, _class);
    var self = getPrototypeOf(this, (_class.__proto__ || Object.getPrototypeOf(_class)).call(this, className, value));
    return self.properties.plotType = _0x5694b1.SIMPLELABEL, self.properties.plotName = "\u7b80\u5355\u6587\u672c", self.label = self.properties.attr.label, self.createDom(), self.container.onclick = function(branch) {
      if (self.layer && self.layer.setSelectedPlot) {
        self.layer.setSelectedPlot(self);
      }
    }, self.addPostRender(), self;
  }
  function Tooltip(ecTheme, messageCenter) {
    call(this, Tooltip);
    var self = getPrototypeOf(this, (Tooltip.__proto__ || Object.getPrototypeOf(Tooltip)).call(this, ecTheme, messageCenter));
    return self.properties.plotType = _0x5694b1.GRADIENTSLABEL, self.properties.plotName = "\u6e10\u53d8\u6587\u672c", self.label = self.properties.attr.label, self.createDom(), self.container.onclick = function(branch) {
      if (self.layer && self.layer.setSelectedPlot) {
        self.layer.setSelectedPlot(self);
      }
    }, self.addPostRender(), self;
  }
  function StyleButton(base) {
    return call(this, StyleButton), base = getPrototypeOf(this, (StyleButton.__proto__ || Object.getPrototypeOf(StyleButton)).call(this, base)), base.selectedPlotChanged = new Cesium.Event, base.initEvent(), base;
  }
  function end(v, data) {
    call(this, end);
    this.viewer = v;
    this.properties = data.properties;
    this.properties.plotBase = "HedronPlot";
    this.properties.attr = this.properties.attr || {
      "name" : "\u672a\u547d\u540d"
    };
    this.geometry = data.geometry;
    this.coordinates = data.geometry.coordinates;
    this.style = this.properties.style || {};
    this.generatePositions();
  }
  function cache(start, x, size) {
    var d = parseFloat(start);
    var i = get(start);
    start = turf.point(d);
    d = all(x);
    d.push(d[0]);
    d = turf.polygon([d]);
    if (!turf.booleanContains(d, start)) {
      return false;
    }
    return x = get(x[0]), x < i && i < x + size;
  }
  function Polygon(name, data) {
    return call(this, Polygon), data = getPrototypeOf(this, (Polygon.__proto__ || Object.getPrototypeOf(Polygon)).call(this, name, data)), data.properties.plotName = "\u591a\u8fb9\u4f53", data.properties.plotType = Draw.POLYHEDRON, data.minPositionCount = 3, data.style.color = data.style.color || Cesium.Color.LIME.withAlpha(0.5).toCssColorString(), data.style.extrudedHeight = data.style.extrudedHeight || 100, data.properties.style = data.style, data.createEntity(), data.createLabelEntity(), data;
  }
  function Area(name, data) {
    return call(this, Area), data = getPrototypeOf(this, (Area.__proto__ || Object.getPrototypeOf(Area)).call(this, name, data)), data.properties.plotName = "\u534a\u7403\u4f53", data.properties.plotType = Draw.HEMISPHERE, data.fixPositionCount = 1, data.style.color = data.style.color || Cesium.Color.LIME.withAlpha(0.5).toCssColorString(), data.style.radius = data.style.radius || 200, data.properties.style = data.style, data.createEntity(), data.createLabelEntity(), data;
  }
  function Circle(params, obj) {
    return call(this, Circle), obj = getPrototypeOf(this, (Circle.__proto__ || Object.getPrototypeOf(Circle)).call(this, params, obj)), obj.properties.plotName = "\u5706\u67f1\u4f53", obj.properties.plotType = Draw.CYLINDER, obj.fixPositionCount = 1, obj.style.radius = obj.style.radius || 200, obj.style.color = obj.style.color || Cesium.Color.LIME.withAlpha(0.5).toCssColorString(), obj.style.extrudedHeight = obj.style.extrudedHeight || 100, obj.properties.style = obj.style, obj.createEntity(), obj.createLabelEntity(), 
    obj;
  }
  function Header(value) {
    call(this, Header);
    this.viewer = value;
    this.viewer.cesiumWidget.screenSpaceEventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);
    this.initEvents();
  }
  function annotationViewerShown(viewer, annotations) {
    call(this, annotationViewerShown);
    this.viewer = viewer;
    this.plotLayer = annotations;
    this.registerMouseEvents();
  }
  function Wizard(viewer, options) {
    call(this, Wizard);
    this.viewer = viewer;
    this.plotLayer = options;
    this.initEventHandler();
  }
  function KeyBoardHelper(obj) {
    return call(this, KeyBoardHelper), obj = getPrototypeOf(this, (KeyBoardHelper.__proto__ || Object.getPrototypeOf(KeyBoardHelper)).call(this, obj)), obj.selectedPlotChanged = new Cesium.Event, obj.initEvent(), obj.targetEnterHedronEvent = new Cesium.Event, obj.targetLeaveHedronEvent = new Cesium.Event, obj.enterPlotCodes = {}, obj;
  }
  function parseGeocodingResults(results, data) {
    call(this, parseGeocodingResults);
    this.viewer = results;
    this.properties = data.properties;
    this.properties.plotBase = "TextMapPlot";
    this.geometry = data.geometry;
    this.coordinates = data.geometry.coordinates;
    this.generatePositions();
  }
  function renderImage(data) {
    var label = data.text;
    var scene = document.createElement("canvas");
    var ctx = (label + "").length * data.fontSize;
    return scene.width = ctx, scene.height = data.fontSize, ctx = scene.getContext("2d"), ctx.fillStyle = data.color, ctx.font = "bold " + data.fontSize + "px \u5fae\u8f6f\u96c5\u9ed1", ctx.textBaseline = "hanging", ctx.fillText(label, 0, 0), scene;
  }
  function FastFunction(def, obj) {
    return call(this, FastFunction), obj = getPrototypeOf(this, (FastFunction.__proto__ || Object.getPrototypeOf(FastFunction)).call(this, def, obj)), obj.properties.plotName = "\u591a\u8fb9\u5f62\u6587\u5b57\u8d34\u56fe", obj.properties.plotType = GraphNodeType.POLYGON, obj.minPositionCount = 3, obj.style = obj.properties.style || obj.getDefaultStyle(), obj.properties.style = obj.style, obj.createEntity(), obj;
  }
  function Path(params, obj) {
    return call(this, Path), obj = getPrototypeOf(this, (Path.__proto__ || Object.getPrototypeOf(Path)).call(this, params, obj)), obj.properties.plotName = "\u7acb\u4f53\u5899\u6587\u5b57\u8d34\u56fe", obj.properties.plotType = GraphNodeType.WALL, obj.fixPositionCount = 2, obj.style = obj.properties.style || obj.getDefaultStyle(), obj.properties.style = obj.style, obj.createEntity(), obj;
  }
  function Draggable(element) {
    call(this, Draggable);
    this.viewer = element;
    this.viewer.cesiumWidget.screenSpaceEventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);
    this.initEvents();
  }
  function desc(value, target) {
    call(this, desc);
    this.viewer = value;
    this.textMapPlotLayer = target;
    this.initEventHandler();
  }
  function SlackData(obj) {
    return call(this, SlackData), obj = getPrototypeOf(this, (SlackData.__proto__ || Object.getPrototypeOf(SlackData)).call(this, obj)), obj.initEvent(), obj.selectedPlotChanged = new Cesium.Event, obj;
  }
  function dragOver(element, data) {
    call(this, dragOver);
    this.viewer = element;
    this.properties = data.properties;
    this.properties.plotBase = "GeoPlot";
    this.geometry = data.geometry;
    this.coordinates = data.geometry.coordinates;
    this.style = this.properties.style;
    this.generatePositions();
  }
  function ReactTooltip(props, current) {
    return call(this, ReactTooltip), current = getPrototypeOf(this, (ReactTooltip.__proto__ || Object.getPrototypeOf(ReactTooltip)).call(this, props, current)), current.properties.plotType = cur.MARKER, current.properties.plotName = "\u56fe\u6807\u70b9", current.style = current.properties.style || current.getDefaultStyle(), current.createEntity(), current.fixPositionCount = 1, current;
  }
  function Cell(tile, data) {
    return call(this, Cell), data = getPrototypeOf(this, (Cell.__proto__ || Object.getPrototypeOf(Cell)).call(this, tile, data)), data.properties.plotType = cur.TEXT, data.properties.plotName = "\u6587\u672c", data.properties.attr = data.properties.attr || {
      "text" : "\u6587\u672c"
    }, data.style = data.properties.style || data.getDefaultStyle(), data.createEntity(), data.fixPositionCount = 1, data;
  }
  function e(value, type) {
    return call(this, e), type = getPrototypeOf(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, value, type)), type.properties.plotName = "\u7ebf", type.properties.plotType = cur.POLYLINE, type.minPositionCount = 2, type.createEntity(), type;
  }
  function Text(props, context) {
    return call(this, Text), context = getPrototypeOf(this, (Text.__proto__ || Object.getPrototypeOf(Text)).call(this, props, context)), context.properties.plotName = "\u9762", context.properties.plotType = cur.POLYGON, context.minPositionCount = 3, context.createEntity(), context;
  }
  function BarChart(data, parent) {
    return call(this, BarChart), parent = getPrototypeOf(this, (BarChart.__proto__ || Object.getPrototypeOf(BarChart)).call(this, data, parent)), parent.properties.plotName = "\u6b63\u5706", parent.properties.plotType = cur.CIRCLE, parent.fixPositionCount = 2, parent.createEntity(), parent;
  }
  function Agent(counter, context) {
    return call(this, Agent), context = getPrototypeOf(this, (Agent.__proto__ || Object.getPrototypeOf(Agent)).call(this, counter, context)), context.properties.plotName = "\u77e9\u5f62", context.properties.plotType = cur.RECTANGLE, context.fixPositionCount = 2, context.createEntity(), context;
  }
  function onload(value) {
    call(this, onload);
    this.viewer = value;
    this.viewer.cesiumWidget.screenSpaceEventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);
    this.initEvents();
  }
  function number(value, target) {
    call(this, number);
    this.viewer = value;
    this.geoPlotLayer = target;
    this.initEventHandler();
  }
  function Singleline(obj) {
    return call(this, Singleline), obj = getPrototypeOf(this, (Singleline.__proto__ || Object.getPrototypeOf(Singleline)).call(this, obj)), obj.initEvent(), obj.selectedPlotChanged = new Cesium.Event, obj;
  }
  function username(value) {
    call(this, username);
    this.viewer = value;
    this.viewer.cesiumWidget.screenSpaceEventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);
    this.initEvents();
  }
  function dragLeave(event) {
    call(this, dragLeave);
    this.viewer = event;
    this.initEventHandler();
  }
  function reset(element, value, position) {
    call(this, reset);
    this.position = value;
    this.index = (new Date).getTime();
    this.viewer = element;
    this.options = position;
    position = Cesium.Cartographic.fromCartesian(this.position);
    position = {
      "x" : Cesium.Math.toDegrees(position.longitude),
      "y" : Cesium.Math.toDegrees(position.latitude),
      "z" : position.height
    };
    this.createDom();
    element.cesiumWidget.container.appendChild(this.container);
    this.addPostRender();
    this.addBillboard();
    this.initEvents();
    this.setValue(position);
  }
  function push(position) {
    return position = Cesium.Cartographic.fromCartesian(position), [Cesium.Math.toDegrees(position.longitude), Cesium.Math.toDegrees(position.latitude)];
  }
  function inverse(p, x) {
    var angle;
    var i = push(p);
    var y = push(x);
    return angle = y, x = (p = i)[1] * Math.PI / 180, y = angle[1] * Math.PI / 180, i = x - y, angle = p[0] * Math.PI / 180 - angle[0] * Math.PI / 180, angle = 2 * Math.asin(Math.sqrt(Math.pow(Math.sin(i / 2), 2) + Math.cos(x) * Math.cos(y) * Math.pow(Math.sin(angle / 2), 2))), angle = angle * 6378.137, angle = Math.round(1E4 * angle) / 10;
  }
  function positionNode(position) {
    return position = Cesium.Cartographic.fromCartesian(position), [Cesium.Math.toDegrees(position.longitude), Cesium.Math.toDegrees(position.latitude), position.height];
  }
  function fix(data) {
    if (data.length < 2) {
      return 0;
    }
    var c2Score = 0;
    var i = 0;
    for (; i < data.length - 1; i++) {
      c2Score = c2Score + Cesium.Cartesian3.distance(data[i], data[i + 1]);
    }
    return c2Score.toFixed(3);
  }
  function loaded(d) {
    if (d.length < 3) {
      return 0;
    }
    var inner = [];
    return d.forEach(function(p) {
      inner.push(push(p));
    }), inner.push(inner[0]), d = turf.polygon([inner]), turf.area(d).toFixed(3);
  }
  function expand(value) {
    call(this, expand);
    this.viewer = value;
    this.initEvents();
    this.positions = [];
    this.vertexEntities = [];
    this.labelEntity = void 0;
    this.measureHeight = 0;
  }
  function Renderer(type, options) {
    call(this, Renderer);
    this.viewer = type;
    this.options = options;
    this.initEvents();
    this.positions = [];
    this.tempPositions = [];
    this.vertexEntities = [];
    this.labelEntity = void 0;
    this.measureDistance = 0;
  }
  function header(value) {
    call(this, header);
    this.viewer = value;
    this.initEvents();
    this.positions = [];
    this.tempPositions = [];
    this.vertexEntities = [];
    this.labelEntity = void 0;
    this.measureArea = 0;
  }
  function select(target, value, text, data, values) {
    if (call(this, select), !Array.isArray(data) || !Array.isArray(values)) {
      throw "\u5b57\u6bb5\u548c\u503c\u5fc5\u987b\u4e3a\u6570\u7ec4\u7c7b\u578b";
    }
    if (data.length != values.length) {
      throw "\u5b57\u6bb5\u548c\u503c\u6570\u7ec4\u957f\u5ea6\u4e0d\u4e00\u81f4\uff01";
    }
    this.viewer = target;
    this.position = value;
    this.title = text;
    this.fields = data;
    this.values = values;
    this.createDom();
    target.cesiumWidget.container.appendChild(this.container);
    this.initDom();
    this.initEvent();
    this.addPostRender();
  }
  function Layer(name, obj, type) {
    call(this, Layer);
    this.viewer = name;
    this.position = obj;
    this.infos = type;
    this.createDom();
    name.cesiumWidget.container.appendChild(this.container);
    this.addPostRender();
  }
  function done(value, target, data, result) {
    call(this, done);
    this.viewer = value;
    this.position = target;
    this.fields = data;
    this.values = result;
    this.init();
  }
  function test(target, value, text, callback) {
    call(this, test);
    this.viewer = target;
    this.position = value;
    this.title = text;
    this.html = callback;
    this.createDom();
    target.cesiumWidget.container.appendChild(this.container);
    this.initEvent();
    this.addPostRender();
  }
  function add(target, value, title, text) {
    call(this, add);
    this.viewer = target;
    this.position = value;
    this.title = title;
    this.html = text;
    this.createDom();
    target.cesiumWidget.container.appendChild(this.container);
    this.initEvent();
    this.addPostRender();
  }
  function geoJsonToFeatureInfo(viewer, data) {
    call(this, geoJsonToFeatureInfo);
    this.viewer = viewer;
    this.properties = data.properties;
    this.coordinates = data.geometry.coordinates;
    this.properties.plotBase = "Particle";
    this.style = this.properties.style;
    this.position = Cesium.Cartesian3.fromDegrees(this.coordinates[0], this.coordinates[1], this.coordinates[2]);
  }
  function Container(parent, controller) {
    return call(this, Container), parent = getPrototypeOf(this, (Container.__proto__ || Object.getPrototypeOf(Container)).call(this, parent, controller)), parent.properties.plotType = Tile.FIRE, parent.properties.plotName = "\u706b\u7130", parent.style = controller.properties.style || parent.getDefaultStyle(), parent.properties.style = parent.style, parent.init(), parent;
  }
  function Slider(current, context) {
    return call(this, Slider), current = getPrototypeOf(this, (Slider.__proto__ || Object.getPrototypeOf(Slider)).call(this, current, context)), current.properties.plotType = Tile.FOUNTAIN, current.properties.plotName = "\u55b7\u6cc9", current.style = context.properties.style || current.getDefaultStyle(), current.properties.style = current.style, current.init(), current;
  }
  function Overlay(config, map) {
    return call(this, Overlay), config = getPrototypeOf(this, (Overlay.__proto__ || Object.getPrototypeOf(Overlay)).call(this, config, map)), config.properties.plotType = Tile.SMOKE, config.properties.plotName = "\u70df\u96fe", config.style = map.properties.style || config.getDefaultStyle(), config.properties.style = config.style, config.init(), config;
  }
  function FastCallback(base) {
    return call(this, FastCallback), base = getPrototypeOf(this, (FastCallback.__proto__ || Object.getPrototypeOf(FastCallback)).call(this, base)), base.initEvent(), base.selectedPlotChanged = new Cesium.Event, base;
  }
  function remove(value, obj, prop) {
    call(this, remove);
    this.viewer = value;
    this.position = obj;
    this.style = prop || this.getDefaultStyle();
    this.circles = [];
    this.labels = [];
    this.init();
  }
  function info(name, value, target) {
    call(this, info);
    this.viewer = name;
    this.position = value;
    this.label = target;
    this.createDom();
    this.addPostRender();
  }
  function query(value, target, options) {
    call(this, query);
    this.viewer = value;
    this.position = target;
    this.color = options.color || Cesium.Color.RED;
    this.iconUrl = options.iconUrl;
    this.pixelSize = options.pixelSize || 10;
    this.pixelMax = options.pixelMax || 50;
    this.outWidth = options.outWidth || 20;
    this.createMarker();
  }
  function bitsToNum(bitArray) {
    return bitArray.reduce(function(levelMergeAxisLength, z) {
      return 2 * levelMergeAxisLength + z;
    }, 0);
  }
  function splice(val) {
    var result = [];
    var bit = 7;
    for (; 0 <= bit; bit--) {
      result.push(!!(val & 1 << bit));
    }
    return result;
  }
  function Stream(data) {
    this.data = data;
    this.len = this.data.length;
    this.pos = 0;
    this.readByte = function() {
      if (this.pos >= this.data.length) {
        throw new Error("Attempted to read past end of stream.");
      }
      return data instanceof Uint8Array ? data[this.pos++] : 255 & data.charCodeAt(this.pos++);
    };
    this.readBytes = function(n) {
      var bytesRead = [];
      var hits = 0;
      for (; hits < n; hits++) {
        bytesRead.push(this.readByte());
      }
      return bytesRead;
    };
    this.read = function(i) {
      var resp = "";
      var whichFriend = 0;
      for (; whichFriend < i; whichFriend++) {
        resp = resp + String.fromCharCode(this.readByte());
      }
      return resp;
    };
    this.readUnsigned = function() {
      var buffer = this.readBytes(2);
      return (buffer[1] << 8) + buffer[0];
    };
  }
  function lzwDecode(minCodeSize, data) {
    var code;
    var last;
    var pos = 0;
    var output = [];
    var clearCode = 1 << minCodeSize;
    var oldCode = 1 + clearCode;
    var codeSize = minCodeSize + 1;
    var dict = [];
    for (;;) {
      if (last = code, (code = function(size) {
        var x = 0;
        var s = 0;
        for (; s < size; s++) {
          if (data.charCodeAt(pos >> 3) & 1 << (7 & pos)) {
            x = x | 1 << s;
          }
          pos++;
        }
        return x;
      }(codeSize)) !== clearCode) {
        if (code === oldCode) {
          break;
        }
        if (code < dict.length) {
          if (last !== clearCode) {
            dict.push(dict[last].concat(dict[code][0]));
          }
        } else {
          if (code !== dict.length) {
            throw new Error("Invalid LZW code.");
          }
          dict.push(dict[last].concat(dict[last][0]));
        }
        output.push.apply(output, dict[code]);
        if (dict.length === 1 << codeSize && codeSize < 12) {
          codeSize++;
        }
      } else {
        !function() {
          dict = [];
          codeSize = minCodeSize + 1;
          var i = 0;
          for (; i < clearCode; i++) {
            dict[i] = [i];
          }
          dict[clearCode] = [];
          dict[oldCode] = null;
        }();
      }
    }
    return output;
  }
  function start(stream, handler) {
    function parseCT(entries) {
      var ct = [];
      var i = 0;
      for (; i < entries; i++) {
        ct.push(stream.readBytes(3));
      }
      return ct;
    }
    function readSubBlocks() {
      var count;
      var data = "";
      for (; count = stream.readByte(), data = data + stream.read(count), 0 !== count;) {
      }
      return data;
    }
    function parse(block) {
      var data;
      var object;
      var parent;
      switch(block.label = stream.readByte(), block.label) {
        case 249:
          block.extType = "gce";
          (function(block) {
            var toCamel = hahaha;
            stream[toCamel(2182)]();
            var opts = splice(stream[toCamel(2182)]());
            block[toCamel(2070)] = opts[toCamel(2998)](0, 3);
            block.disposalMethod = bitsToNum(opts.splice(0, 3));
            block[toCamel(2495)] = opts.shift();
            block[toCamel(467)] = opts[toCamel(2651)]();
            block[toCamel(1815)] = stream[toCamel(2858)]();
            block[toCamel(1042)] = stream[toCamel(2182)]();
            block[toCamel(1782)] = stream[toCamel(2182)]();
            if (handler[toCamel(2342)]) {
              handler[toCamel(2342)](block);
            }
          })(block);
          break;
        case 254:
          block.extType = "com";
          (parent = block).comment = readSubBlocks();
          if (handler.com) {
            handler.com(parent);
          }
          break;
        case 1:
          block.extType = "pte";
          object = block;
          stream.readByte();
          object.ptHeader = stream.readBytes(12);
          object.ptData = readSubBlocks();
          if (handler.pte) {
            handler.pte(object);
          }
          break;
        case 255:
          block.extType = "app";
          data = block;
          stream.readByte();
          data.identifier = stream.read(8);
          data.authCode = stream.read(3);
          if ("NETSCAPE" === data.identifier) {
            object = data;
            stream.readByte();
            object.unknown = stream.readByte();
            object.iterations = stream.readUnsigned();
            object.terminator = stream.readByte();
            if (handler.app && handler.app.NETSCAPE) {
              handler.app.NETSCAPE(object);
            }
          } else {
            (data = data).appData = readSubBlocks();
            if (handler.app && handler.app[data.identifier]) {
              handler.app[data.identifier](data);
            }
          }
          break;
        default:
          block.extType = "unknown";
          (data = block).data = readSubBlocks();
          if (handler.unknown) {
            handler.unknown(data);
          }
      }
    }
    function parseImg(img) {
      img.leftPos = stream.readUnsigned();
      img.topPos = stream.readUnsigned();
      img.width = stream.readUnsigned();
      img.height = stream.readUnsigned();
      var lzwData = splice(stream.readByte());
      img.lctFlag = lzwData.shift();
      img.interlaced = lzwData.shift();
      img.sorted = lzwData.shift();
      img.reserved = lzwData.splice(0, 2);
      img.lctSize = bitsToNum(lzwData.splice(0, 3));
      if (img.lctFlag) {
        img.lct = parseCT(1 << img.lctSize + 1);
      }
      img.lzwMinCodeSize = stream.readByte();
      lzwData = readSubBlocks();
      img.pixels = lzwDecode(img.lzwMinCodeSize, lzwData);
      if (img.interlaced) {
        img.pixels = function(bitmaps, texPerChild) {
          var bestPrefixPathIndex;
          var i;
          var arrAllFiles = new Array(bitmaps.length);
          var naiveInsertIndex = bitmaps.length / texPerChild;
          var nextIdLookup = [0, 4, 2, 1];
          var _0x271d2a = [8, 8, 4, 2];
          var contactCapacity = 0;
          var indexLookupKey = 0;
          for (; indexLookupKey < 4; indexLookupKey++) {
            var currentIndex = nextIdLookup[indexLookupKey];
            for (; currentIndex < naiveInsertIndex; currentIndex = currentIndex + _0x271d2a[indexLookupKey]) {
              bestPrefixPathIndex = currentIndex;
              i = contactCapacity;
              i = bitmaps.slice(i * texPerChild, (i + 1) * texPerChild);
              arrAllFiles.splice.apply(arrAllFiles, [bestPrefixPathIndex * texPerChild, texPerChild].concat(i));
              contactCapacity++;
            }
          }
          return arrAllFiles;
        }(img.pixels, img.width);
      }
      if (handler.img) {
        handler.img(img);
      }
    }
    function parseBlock() {
      var block = {};
      switch(block.sentinel = stream.readByte(), String.fromCharCode(block.sentinel)) {
        case "!":
          block.type = "ext";
          parse(block);
          break;
        case ",":
          block.type = "img";
          parseImg(block);
          break;
        case ";":
          block.type = "eof";
          if (handler.eof) {
            handler.eof(block);
          }
          break;
        default:
          throw new Error("Unknown block: 0x" + block.sentinel.toString(16));
      }
      if ("eof" !== block.type) {
        setTimeout(parseBlock, 0);
      }
    }
    handler = handler || {};
    (function() {
      var hdr = {};
      if (hdr.sig = stream.read(3), hdr.ver = stream.read(3), "GIF" !== hdr.sig) {
        throw new Error("Not a GIF file.");
      }
      hdr.width = stream.readUnsigned();
      hdr.height = stream.readUnsigned();
      var lazyQuedElements = splice(stream.readByte());
      hdr.gctFlag = lazyQuedElements.shift();
      hdr.colorRes = bitsToNum(lazyQuedElements.splice(0, 3));
      hdr.sorted = lazyQuedElements.shift();
      hdr.gctSize = bitsToNum(lazyQuedElements.splice(0, 3));
      hdr.bgColor = stream.readByte();
      hdr.pixelAspectRatio = stream.readByte();
      if (hdr.gctFlag) {
        hdr.gct = parseCT(1 << hdr.gctSize + 1);
      }
      if (handler.hdr) {
        handler.hdr(hdr);
      }
    })();
    setTimeout(parseBlock, 0);
  }
  function SuperGif(opts) {
    function clear() {
      kind = key;
      ctx = key = value = text = null;
    }
    function doParse() {
      var errorFunc = hahaha;
      try {
        start(stream, handler);
      } catch (_0x18fca5) {
        doLoadError(errorFunc(402));
      }
    }
    function setSizes(w, h) {
      var parseInt = hahaha;
      area.width = w * get_canvas_scale();
      area[parseInt(1132)] = h * get_canvas_scale();
      values[parseInt(1998)][parseInt(686)] = w * get_canvas_scale() + "px";
      o[parseInt(807)] = w;
      o[parseInt(1132)] = h;
      o.style[parseInt(807)] = w + "px";
      o[parseInt(1998)][parseInt(1132)] = h + "px";
      o[parseInt(1714)]("2d")[parseInt(2641)](1, 0, 0, 1, 0, 0);
    }
    function doShowProgress(length, pos, height) {
      var parseInt = hahaha;
      var r;
      var i;
      var end;
      if (height && viewBoxWidth) {
        height = _expandHeight;
        if (options[parseInt(2839)]) {
          end = ctx_scaled ? (i = (options[parseInt(1906)] + options[parseInt(999)] - height) / get_canvas_scale(), height = height / get_canvas_scale(), r = options[parseInt(1557)] / get_canvas_scale() + length / pos * (options[parseInt(2165)] / get_canvas_scale()), area[parseInt(807)] / get_canvas_scale()) : (i = options.vp_t + options[parseInt(999)] - height, r = options[parseInt(1557)] + length / pos * options[parseInt(2165)], area.width);
        } else {
          i = (area.height - height) / (ctx_scaled ? get_canvas_scale() : 1);
          r = length / pos * area[parseInt(807)] / (ctx_scaled ? get_canvas_scale() : 1);
          end = area[parseInt(807)] / (ctx_scaled ? get_canvas_scale() : 1);
          height = height / (ctx_scaled ? get_canvas_scale() : 1);
        }
        item[parseInt(1339)] = grid_account_acl;
        item.fillRect(r, i, end - r, height);
        item[parseInt(1339)] = grid_logs_orchestration_view;
        item[parseInt(1980)](0, i, r, height);
      }
    }
    function stepFrame(amount) {
      i = i + amount;
      putFrame();
    }
    function onload() {
      if (null !== handle_file_exists_response) {
        handle_file_exists_response(size);
      }
      mSeqCol++;
      if (false !== mSeqCol2 || mSeqCol < 0) {
        tryParseQRCode();
      } else {
        f_globals = f_locals = false;
      }
    }
    function doDecodeProgress(draw) {
      var normalizeNumber = hahaha;
      doShowProgress(stream[normalizeNumber(2711)], stream[normalizeNumber(1752)][normalizeNumber(2189)], draw);
    }
    function doNothing() {
    }
    function withProgress(fn, draw) {
      return function(responce) {
        fn(responce);
        doDecodeProgress(draw);
      };
    }
    function init() {
      var parseInt = hahaha;
      var info = document.createElement(parseInt(889));
      area = document.createElement(parseInt(2818));
      item = area[parseInt(1714)]("2d");
      values = document[parseInt(1442)](parseInt(889));
      o = document.createElement(parseInt(2818));
      info.width = area.width = size[parseInt(807)];
      info[parseInt(1132)] = area[parseInt(1132)] = size[parseInt(1132)];
      values[parseInt(1998)][parseInt(686)] = size[parseInt(807)] + "px";
      info[parseInt(1883)] = parseInt(2414);
      values[parseInt(1883)] = parseInt(2023);
      info.appendChild(area);
      info[parseInt(1545)](values);
      if (options[parseInt(1819)] && options[parseInt(986)]) {
        setSizes(options.c_w, options[parseInt(986)]);
      }
      _0x353ca2 = true;
    }
    function load_setup(value) {
      return !result && (callback = value || false, result = true, data = [], clear(), !(buffer = ctx = kind = type = null));
    }
    var prop;
    var stream;
    var info;
    var options = {
      "vp_l" : 0,
      "vp_t" : 0,
      "vp_w" : null,
      "vp_h" : null,
      "c_w" : null,
      "c_h" : null
    };
    for (prop in opts) {
      options[prop] = opts[prop];
    }
    if (options.vp_w && options.vp_h) {
      options.is_vp = true;
    }
    var loadError = null;
    var result = false;
    var text = null;
    var value = null;
    var key = null;
    var type = null;
    var kind = null;
    var ctx = null;
    var buffer = null;
    var f_globals = true;
    var ctx_scaled = false;
    var data = [];
    var args = [];
    var size = options.gif;
    if (void 0 === options.auto_play) {
      options.auto_play = !size.getAttribute("rel:auto_play") || "1" == size.getAttribute("rel:auto_play");
    }
    var f_locals;
    var tryParseQRCode;
    var i;
    var mSeqCol;
    var load;
    var putFrame;
    var handle_file_exists_response = options.hasOwnProperty("on_end") ? options.on_end : null;
    var reconnectTimeIncrease = options.hasOwnProperty("loop_delay") ? options.loop_delay : 0;
    var mSeqCol2 = options.hasOwnProperty("loop_mode") ? options.loop_mode : "auto";
    var drawWhileLoading = !options.hasOwnProperty("draw_while_loading") || options.draw_while_loading;
    var viewBoxWidth = !!drawWhileLoading && (!options.hasOwnProperty("show_progress_bar") || options.show_progress_bar);
    var _expandHeight = options.hasOwnProperty("progressbar_height") ? options.progressbar_height : 25;
    var grid_account_acl = options.hasOwnProperty("progressbar_background_color") ? options.progressbar_background_color : "rgba(255,255,255,0.4)";
    var grid_logs_orchestration_view = options.hasOwnProperty("progressbar_foreground_color") ? options.progressbar_foreground_color : "rgba(255,0,22,.8)";
    var doLoadError = function(originOfError) {
      var parseInt = hahaha;
      loadError = originOfError;
      info = {
        "width" : size.width,
        "height" : size.height
      };
      data = [];
      item[parseInt(1339)] = parseInt(2896);
      item[parseInt(1980)](0, 0, options[parseInt(1819)] || info.width, options[parseInt(986)] || info.height);
      item[parseInt(575)] = parseInt(2447);
      item[parseInt(2073)] = 3;
      item[parseInt(2823)](0, 0);
      item[parseInt(670)](options[parseInt(1819)] || info[parseInt(807)], options.c_h || info[parseInt(1132)]);
      item[parseInt(2823)](0, options[parseInt(986)] || info[parseInt(1132)]);
      item[parseInt(670)](options[parseInt(1819)] || info[parseInt(807)], 0);
      item[parseInt(2587)]();
    };
    var layout = function() {
      var parseInt = hahaha;
      if (ctx) {
        data[parseInt(2008)]({
          "data" : ctx[parseInt(688)](0, 0, info.width, info[parseInt(1132)]),
          "delay" : value
        });
        args[parseInt(2008)]({
          "x" : 0,
          "y" : 0
        });
      }
    };
    var player = (f_locals = !(i = -1), {
      "init" : function() {
        var parseInt = hahaha;
        if (!loadError) {
          if (!(options[parseInt(1819)] && options[parseInt(986)])) {
            item[parseInt(1972)](get_canvas_scale(), get_canvas_scale());
          }
          if (options[parseInt(502)]) {
            load();
          } else {
            i = 0;
            putFrame();
          }
        }
      },
      "step" : load = function() {
        if (!f_locals) {
          setTimeout(tryParseQRCode, 0);
        }
      },
      "play" : function() {
        f_globals = true;
        load();
      },
      "pause" : function() {
        f_globals = false;
      },
      "playing" : f_globals,
      "move_relative" : stepFrame,
      "current_frame" : function() {
        return i;
      },
      "length" : function() {
        return data.length;
      },
      "move_to" : function(frame_idx) {
        i = frame_idx;
        putFrame();
      }
    });
    var area;
    var item;
    var values;
    var o;
    var handler = {
      "hdr" : withProgress(function(options) {
        var getAllocIID = hahaha;
        setSizes((info = options)[getAllocIID(807)], info[getAllocIID(1132)]);
      }),
      "gce" : withProgress(function(node) {
        var getMatchFunctionFor = hahaha;
        layout();
        clear();
        text = node[getMatchFunctionFor(467)] ? node[getMatchFunctionFor(1042)] : null;
        value = node[getMatchFunctionFor(1815)];
        key = node[getMatchFunctionFor(2068)];
      }),
      "com" : withProgress(doNothing),
      "app" : {
        "NETSCAPE" : withProgress(doNothing)
      },
      "img" : withProgress(function(values) {
        var parseInt = hahaha;
        ctx = ctx || o[parseInt(1714)]("2d");
        var size_human = data[parseInt(2189)];
        var subwikiListsCache = values.lctFlag ? values[parseInt(1056)] : info[parseInt(678)];
        if (0 < size_human) {
          if (3 === kind) {
            if (null !== type) {
              ctx.putImageData(data[type][parseInt(1752)], 0, 0);
            } else {
              ctx[parseInt(3186)](buffer[parseInt(2949)], buffer[parseInt(3171)], buffer.width, buffer[parseInt(1132)]);
            }
          } else {
            type = size_human - 1;
          }
          if (2 === kind) {
            ctx.clearRect(buffer.leftPos, buffer[parseInt(3171)], buffer.width, buffer[parseInt(1132)]);
          }
        }
        var orig = ctx[parseInt(688)](values.leftPos, values[parseInt(3171)], values[parseInt(807)], values.height);
        values[parseInt(2953)][parseInt(1889)](function(wikiId, canCreateDiscussions) {
          var toInt = parseInt;
          if (wikiId !== text) {
            orig[toInt(1752)][4 * canCreateDiscussions + 0] = subwikiListsCache[wikiId][0];
            orig[toInt(1752)][4 * canCreateDiscussions + 1] = subwikiListsCache[wikiId][1];
            orig[toInt(1752)][4 * canCreateDiscussions + 2] = subwikiListsCache[wikiId][2];
            orig[toInt(1752)][4 * canCreateDiscussions + 3] = 255;
          }
        });
        ctx[parseInt(1292)](orig, values[parseInt(2949)], values.topPos);
        if (!ctx_scaled) {
          item[parseInt(1972)](get_canvas_scale(), get_canvas_scale());
          ctx_scaled = true;
        }
        if (drawWhileLoading) {
          item[parseInt(3E3)](o, 0, 0);
          drawWhileLoading = options.auto_play;
        }
        buffer = values;
      }, !(mSeqCol = 0)),
      "eof" : function(block) {
        var parseInt = hahaha;
        layout();
        doDecodeProgress(false);
        if (!(options.c_w && options[parseInt(986)])) {
          area[parseInt(807)] = info[parseInt(807)] * get_canvas_scale();
          area.height = info[parseInt(1132)] * get_canvas_scale();
        }
        player[parseInt(535)]();
        result = false;
        if (callback) {
          callback(size);
        }
      }
    };
    var get_canvas_scale = function() {
      var parseInt = hahaha;
      var scale = options[parseInt(1927)] && info && info[parseInt(807)] > options.max_width ? options[parseInt(1927)] / info[parseInt(807)] : 1;
      return scale;
    };
    var _0x353ca2 = !(putFrame = function() {
      var trim = hahaha;
      var rect;
      if ((i = parseInt(i, 10)) > data[trim(2189)] - 1) {
        i = 0;
      }
      if (i < 0) {
        i = 0;
      }
      rect = args[i];
      o[trim(1714)]("2d").putImageData(data[i][trim(1752)], rect.x, rect.y);
      item[trim(2365)] = trim(2225);
      item.drawImage(o, 0, 0);
    });
    var callback = !(tryParseQRCode = function doStep() {
      var getAttr = hahaha;
      var waitBeforeReconnect;
      if (f_locals = f_globals) {
        stepFrame(1);
        waitBeforeReconnect = (waitBeforeReconnect = 10 * data[i][getAttr(3068)]) || 100;
        if (0 == (i + 1 + data[getAttr(2189)]) % data[getAttr(2189)]) {
          waitBeforeReconnect = waitBeforeReconnect + reconnectTimeIncrease;
          setTimeout(onload, waitBeforeReconnect);
        } else {
          setTimeout(doStep, waitBeforeReconnect);
        }
      }
    });
    return {
      "play" : player.play,
      "pause" : player.pause,
      "move_relative" : player.move_relative,
      "move_to" : player.move_to,
      "get_playing" : function() {
        return f_globals;
      },
      "get_canvas" : function() {
        return area;
      },
      "get_canvas_scale" : function() {
        return get_canvas_scale();
      },
      "get_loading" : function() {
        return result;
      },
      "get_auto_play" : function() {
        var plural = hahaha;
        return options[plural(502)];
      },
      "get_length" : function() {
        var puts = hahaha;
        return player[puts(2189)]();
      },
      "get_current_frame" : function() {
        var gotoNewOfflinePage = hahaha;
        return player[gotoNewOfflinePage(2011)]();
      },
      "load_url" : function(callback, request) {
        var d3_layout_cellPadNull = hahaha;
        if (load_setup(request)) {
          (request = new XMLHttpRequest)[d3_layout_cellPadNull(1341)](d3_layout_cellPadNull(1704), callback, true);
          if (d3_layout_cellPadNull(1764) in request) {
            request[d3_layout_cellPadNull(1764)](d3_layout_cellPadNull(1558));
          } else {
            if (d3_layout_cellPadNull(2710) in request) {
              request.responseType = d3_layout_cellPadNull(1959);
            } else {
              request[d3_layout_cellPadNull(690)](d3_layout_cellPadNull(1677), d3_layout_cellPadNull(1542));
            }
          }
          request.onloadstart = function() {
            if (!_0x353ca2) {
              init();
            }
          };
          request.onload = function(fileLoadedEvent) {
            var pad = d3_layout_cellPadNull;
            if (200 != this[pad(1225)]) {
              doLoadError(pad(2576));
            }
            if (!(pad(896) in this)) {
              this[pad(896)] = (new VBArray(this[pad(371)]))[pad(1174)]().map(String[pad(1705)])[pad(1778)]("");
            }
            var data = this[pad(896)];
            if (0 < data[pad(3018)]()[pad(2358)](pad(1842))) {
              data = new Uint8Array(data);
            }
            stream = new Stream(data);
            setTimeout(doParse, 0);
          };
          request.onprogress = function(nAll) {
            var setUploadProgress = d3_layout_cellPadNull;
            if (nAll[setUploadProgress(709)]) {
              doShowProgress(nAll[setUploadProgress(1009)], nAll[setUploadProgress(2155)], true);
            }
          };
          request.onerror = function() {
            doLoadError("xhr");
          };
          request.send();
        }
      },
      "load" : function(obj) {
        var getConfigIdentifier = hahaha;
        this[getConfigIdentifier(2574)](size[getConfigIdentifier(2594)]("rel:animated_src") || size[getConfigIdentifier(2967)], obj);
      },
      "load_raw" : function(arr, callback) {
        if (load_setup(callback)) {
          if (!_0x353ca2) {
            init();
          }
          stream = new Stream(arr);
          setTimeout(doParse, 0);
        }
      },
      "set_frame_offset" : function(index, el) {
        if (args[index]) {
          if (void 0 !== el.x) {
            args[index].x = el.x;
          }
          if (void 0 !== el.y) {
            args[index].y = el.y;
          }
        } else {
          args[index] = el;
        }
      }
    };
  }
  function search(value, target, uri) {
    var rpm_traffic = this;
    call(this, search);
    this.viewer = value;
    this.position = target;
    var img = document.createElement("img");
    img.src = uri;
    img.onload = function() {
      var now = hahaha;
      rpm_traffic[now(1230)](img);
    };
  }
  function address(value, obj, name) {
    call(this, address);
    this.viewer = value;
    this.position = obj;
    this.label = name;
    this.createDom();
    this.addPostRender();
  }
  function top(value, position, id) {
    call(this, top);
    this.viewer = value;
    this.position = position;
    this.label = id;
    this.createDom();
    this.addPostRender();
  }
  function capture(element, position, config) {
    call(this, capture);
    this.viewer = element;
    this.position = position;
    position = Cesium.Cartographic.fromCartesian(position);
    this.lng = Cesium.Math.toDegrees(position.longitude);
    this.lat = Cesium.Math.toDegrees(position.latitude);
    this.height = position.height;
    this.style = config || {
      "image" : "static/images/marker/mark3.png",
      "bounceHeight" : 100,
      "increment" : 0.05
    };
    this.add();
  }
  function append(value, position, properties) {
    call(this, append);
    this.viewer = value;
    position = Cesium.Cartographic.fromCartesian(position);
    this.lng = Cesium.Math.toDegrees(position.longitude);
    this.lat = Cesium.Math.toDegrees(position.latitude);
    this.height = position.height;
    this.style = properties || {
      "image" : "static/images/poi/float.png",
      "lineHeight" : 16,
      "bounceHeight" : 1,
      "increment" : 0.008
    };
    this.add();
  }
  function event(value, target, data) {
    call(this, event);
    this.viewer = value;
    this.position = target;
    this.text = data || "";
    this.init();
  }
  function addItem(target, value, name) {
    call(this, addItem);
    this.viewer = target;
    this.position = value;
    this.label = name;
    this.createDom();
    target.cesiumWidget.container.appendChild(this.$container);
    this.addPostRender();
  }
  function _(value) {
    call(this, _);
    this.viewer = value;
    this.billboards = this.viewer.scene.primitives.add(new Cesium["BillboardCollection"]);
    this.labels = this.viewer.scene.primitives.add(new Cesium["LabelCollection"]);
  }
  function self(value, options, target) {
    call(this, self);
    this.viewer = value;
    this.data = options;
    this.options = target;
    this.DataLoadedEvent = new Cesium.Event;
    this.addDatasource();
  }
  function close(value, options, target) {
    call(this, close);
    this.viewer = value;
    this.data = options;
    this.options = target;
    this.clusterColors = target.colors;
    this.DataLoadedEvent = new Cesium.Event;
    this.cluserImages = {};
    this.addDatasource();
  }
  function load(value, obj, source) {
    call(this, load);
    this.viewer = value;
    this.position = obj;
    this.option = source;
    this.domId = "liquidfill_" + (new Date).getTime();
    this.createDom();
    this.initChart();
    this.addPostRender();
  }
  function show(target, obj, value) {
    var base_c = this;
    call(this, show);
    this.viewer = target;
    this.position = obj;
    this.style = value;
    this.createDom();
    target.cesiumWidget.container.appendChild(this.container);
    this.addPostRender();
    this.container.getElementsByClassName("hot-spot")[0].style.backgroundImage = "url(" + value.bgImageUrl + "/home_icon_18.png)";
    this.container.getElementsByClassName("hot-spot-board")[0].style.backgroundImage = "url(" + value.bgImageUrl + "/home_icon_19.png)";
    this.container.onmouseover = function(event) {
      var getConcrete = hahaha;
      base_c[getConcrete(2226)][getConcrete(1280)](getConcrete(2637))[0].style[getConcrete(1057)] = "url(" + value.bgImageUrl + getConcrete(2175);
      base_c[getConcrete(2226)][getConcrete(1280)](getConcrete(1767))[0][getConcrete(1998)][getConcrete(1057)] = getConcrete(2947) + value.bgImageUrl + getConcrete(713);
    };
    this.container.onmouseout = function(event) {
      var getConcrete = hahaha;
      base_c[getConcrete(2226)].getElementsByClassName(getConcrete(2637))[0][getConcrete(1998)][getConcrete(1057)] = getConcrete(2947) + value.bgImageUrl + getConcrete(2832);
      base_c[getConcrete(2226)][getConcrete(1280)](getConcrete(1767))[0][getConcrete(1998)][getConcrete(1057)] = "url(" + value[getConcrete(1541)] + getConcrete(2054);
    };
  }
  function insertAfter(target, value, source) {
    call(this, insertAfter);
    this.viewer = target;
    this.position = value;
    this.wStation = source;
    this.createDom();
    target.cesiumWidget.container.appendChild(this.$container);
    this.addStates();
    this.addPostRender();
  }
  function input(value, options, target) {
    call(this, input);
    this.viewer = value;
    this.data = options;
    this.options = target;
    this.clusterColors = target.colors;
    this.DataLoadedEvent = new Cesium.Event;
    this.cluserImages = {};
    this.addDatasource();
  }
  function track(value, options, target) {
    call(this, track);
    this.viewer = value;
    this.data = options;
    this.options = target;
    this.clusterColors = target.colors;
    this.DataLoadedEvent = new Cesium.Event;
    this.cluserImages = {};
    this.addDatasource();
  }
  function bind(value, options, target) {
    call(this, bind);
    this.viewer = value;
    this.data = options;
    this.options = target;
    this.clusterColors = target.colors;
    this.DataLoadedEvent = new Cesium.Event;
    this.cluserImages = {};
    this.addDatasource();
  }
  function inner(name, options) {
    return call(this, inner), this.positions = name, this.options = options, this.createPrimitive();
  }
  function draw(d) {
    var value = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {
      "autoMaxMin" : true,
      "data" : []
    };
    var t = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : [-180, -90, 180, 90];
    var config = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : {};
    var obj = this;
    var streamSize2 = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : {
      "enabled" : true,
      "min" : 6375E3,
      "max" : 1E7,
      "maxRadius" : 40,
      "minRadius" : 10
    };
    var options = 5 < arguments.length && void 0 !== arguments[5] ? arguments[5] : {
      "totalArea" : 1036800,
      "autoResize" : true
    };
    if (call(this, draw), "undefined" != typeof window) {
      this.viewer = d;
      this.bbox = t;
      this.autoRadiusConfig = streamSize2;
      this.max = void 0;
      this.min = void 0;
      var b = clone(t, 4);
      var h = b[0];
      d = b[1];
      t = b[2];
      b = b[3];
      d = b - d;
      t = t - h;
      if (this.boxMeta = {
        "top" : b,
        "left" : h,
        "height" : d,
        "width" : t
      }, options.autoResize) {
        if (!options.totalArea) {
          throw "specify totalArea if auto resize";
        }
        h = Math.floor(Math.sqrt(d * options.totalArea));
        d = Math.floor(h * t / d);
        this.canvasConfig = assign({}, options, {
          "width" : d,
          "height" : h
        });
      } else {
        if (!options.width || !options.height) {
          throw "specify width and height if not auto resize";
        }
        this.canvasConfig = options;
      }
      config = assign({}, config);
      if (!config.container) {
        this.mountPoint = extend({
          "position" : "absolute",
          "top" : 0,
          "left" : 0,
          "z-index" : -100,
          "overflow" : "hidden",
          "width" : 0,
          "height" : 0
        }, document.body);
        config.container = extend({
          "width" : this.canvasConfig.width,
          "height" : this.canvasConfig.height
        }, this.mountPoint);
      }
      this.heatmapConfig = config;
      this.heatmap = h337.create(config);
      config = void 0;
      if (!(config = Array.isArray(value) ? {
        "autoMaxMin" : true,
        "data" : value
      } : assign({}, value)).autoMaxMin) {
        if (!config.min || !config.max) {
          throw "need max and min when not auto";
        }
        this.min = config.min;
        this.max = config.max;
      }
      value = config.data.map(function(args) {
        var parseInt = hahaha;
        return obj.updateMaxMin(args[parseInt(1573)]), obj[parseInt(2821)](args);
      });
      delete config.data;
      this.dataConfig = config;
      this.data = value;
      value = {
        "max" : this.max,
        "min" : this.min,
        "data" : value
      };
      this.heatmap.setData(value);
      this.updateCesium(streamSize2.enabled);
      this.cameraMoveEnd = function() {
        return obj.updateCesium(true);
      };
      if (streamSize2.enabled) {
        this.viewer.camera.moveEnd.addEventListener(this.cameraMoveEnd);
      }
    }
  }
  function extend(obj, a) {
    var key;
    var t = document.createElement("div");
    for (key in a && a.append(t), obj) {
      if ("number" != typeof obj[key]) {
        t.style[key] = obj[key];
      } else {
        t.style[key] = obj[key] + "px";
      }
    }
    return t;
  }
  function from(value, target, options) {
    call(this, from);
    this.viewer = value;
    this.positions = target;
    this.options = options || {
      "fillColor" : Cesium.Color.BLUE.withAlpha(0.5),
      "lineWidth" : 2,
      "lineColor" : Cesium.Color.AQUA.withAlpha(0.7)
    };
    this.createW_MaskRegion();
    this.createE_MaskRegion(target);
  }
  function Connection(options) {
    call(this, Connection);
    this._definitionChanged = new Cesium.Event;
    this._color = void 0;
    this._colorSubscription = void 0;
    this.color = options.color;
    this.duration = options.duration;
    this.url = options.url;
    this.count = options.count;
    this._time = (new Date).getTime();
  }
  function Player(options) {
    call(this, Player);
    this._definitionChanged = new Cesium.Event;
    this._color = void 0;
    this._colorSubscription = void 0;
    this.color = options.color;
    this.duration = options.duration;
    this.count = options.count;
    this.url = options.url;
    this._time = (new Date).getTime();
  }
  function Light(color) {
    call(this, Light);
    this._definitionChanged = new Cesium.Event;
    this._color = void 0;
    this._colorSubscription = void 0;
    this.color = color;
  }
  function PolylineOutlineMaterialProperty(options) {
    call(this, PolylineOutlineMaterialProperty);
    this._definitionChanged = new Cesium.Event;
    this._color = void 0;
    this._colorSubscription = void 0;
    this.color = options.color;
    this.duration = options.duration;
    this.url = options.url;
    this._time = (new Date).getTime();
  }
  function ImageMaterialProperty(options) {
    call(this, ImageMaterialProperty);
    options = Cesium.defaultValue(options, Cesium.defaultValue.EMPTY_OBJECT);
    this._definitionChanged = new Cesium.Event;
    this._color = void 0;
    this._colorSubscription = void 0;
    this.color = options.color;
    this.duration = options.duration;
    this.url = options.url;
    this._time = performance.now();
  }
  function PolylineSpriteMaterialProperty(options) {
    call(this, PolylineSpriteMaterialProperty);
    this._definitionChanged = new Cesium.Event;
    this.duration = options.duration;
    this.url = options.url;
    this._time = performance.now();
  }
  function Entity(options) {
    call(this, Entity);
    options = Cesium.defaultValue(options, Cesium.defaultValue.EMPTY_OBJECT);
    this._definitionChanged = new Cesium.Event;
    this.colorSubscription = void 0;
    this.speed = options.speed || 6 * Math.random();
    this.color = options.color || Cesium.Color.RED;
    this.percent = options.percent || 0.1;
    this.gradient = options.gradient || 0.01;
  }
  function Property(data) {
    call(this, Property);
    data = Cesium.defaultValue(data, Cesium.defaultValue.EMPTY_OBJECT);
    this._definitionChanged = new Cesium.Event;
    this._color = void 0;
    this._colorSubscription = void 0;
    this.color = data.color;
    this.duration = data.duration;
    this._time = performance.now();
  }
  function message(options) {
    call(this, message);
    this._definitionChanged = new Cesium.Event;
    this._color = void 0;
    this._colorSubscription = void 0;
    this.color = options.color;
    this.duration = options.duration;
    this.count = options.count;
    this.url = options.url;
    this._time = (new Date).getTime();
  }
  function Application(options) {
    call(this, Application);
    this._definitionChanged = new Cesium.Event;
    this._color = void 0;
    this._colorSubscription = void 0;
    this.color = options.color;
    this.duration = options.duration;
    this.count = options.count;
    this.url = options.url;
    this._time = (new Date).getTime();
  }
  function exports(value, target) {
    call(this, exports);
    this.viewer = value;
    this.params = target || {};
    this.addPath();
  }
  function output(value, type, target) {
    call(this, output);
    this.viewer = value;
    this.property = type;
    this.style = target || {};
    this.addCylinder();
  }
  function CesiumWidget(value, options, target) {
    call(this, CesiumWidget);
    this.viewer = value;
    this.splitLayer = options;
    this.splitLayer = this.viewer.imageryLayers.addImageryProvider(options);
    this.splitLayer.splitDirection = target;
    this.initSlider();
  }
  function next(name, e, item) {
    e = Cesium.getElement(e);
    var shortmove = function(ul) {
      var body = document.createElement("div");
      body.innerHTML = ul;
      var results = document.createDocumentFragment();
      for (; body.firstChild;) {
        results.appendChild(body.firstChild);
      }
      return results;
    }(name);
    var results = [];
    var i = 0;
    for (; i < shortmove.childNodes.length; ++i) {
      results.push(shortmove.childNodes[i]);
    }
    e.appendChild(shortmove);
    i = 0;
    for (; i < results.length; ++i) {
      var form = results[i];
      if (!(1 !== form.nodeType && 8 !== form.nodeType)) {
        Cesium.knockout.applyBindings(item, form);
      }
    }
    return results;
  }
  function DistanceLegendViewModel(options) {
    function addUpdateSubscription() {
      var scene;
      if (Cesium.defined(that.terria)) {
        scene = that.terria.scene;
        that._removeSubscription = scene.postRender.addEventListener(function() {
          !function(viewModel, scene) {
            if (!viewModel.enableDistanceLegend) {
              return viewModel.barWidth = void 0, viewModel.distanceLabel = void 0;
            }
            if (!((data = Cesium.getTimestamp()) < viewModel._lastLegendUpdate + 250)) {
              viewModel._lastLegendUpdate = data;
              var right = scene.canvas.clientWidth;
              var globe = scene.canvas.clientHeight;
              var data = scene.camera.getPickRay(new Cesium["Cartesian2"](right / 2 | 0, globe - 1));
              right = scene.camera.getPickRay(new Cesium["Cartesian2"](1 + right / 2 | 0, globe - 1));
              data = (globe = scene.globe).pick(data, scene);
              scene = globe.pick(right, scene);
              if (!Cesium.defined(data) || !Cesium.defined(scene)) {
                return viewModel.barWidth = void 0, viewModel.distanceLabel = void 0;
              }
              data = globe.ellipsoid.cartesianToCartographic(data);
              scene = globe.ellipsoid.cartesianToCartographic(scene);
              geodesic.setEndPoints(data, scene);
              var distance;
              var pixelDistance = geodesic.surfaceDistance;
              var i = distances.length - 1;
              for (; !Cesium.defined(distance) && 0 <= i; --i) {
                if (distances[i] / pixelDistance < 100) {
                  distance = distances[i];
                }
              }
              if (Cesium.defined(distance)) {
                scene = 1E3 <= distance ? (distance / 1E3).toString() + " km" : distance.toString() + " m";
                viewModel.barWidth = distance / pixelDistance | 0;
                viewModel.distanceLabel = scene;
              } else {
                viewModel.barWidth = void 0;
                viewModel.distanceLabel = void 0;
              }
            }
          }(this, scene);
        }, that);
      }
    }
    if (!Cesium.defined(options) || !Cesium.defined(options.terria)) {
      throw new Cesium["DeveloperError"]("options.terria is required.");
    }
    this.terria = options.terria;
    this._removeSubscription = void 0;
    this._lastLegendUpdate = void 0;
    this.EventHelper = new Cesium["EventHelper"];
    this.distanceLabel = void 0;
    this.barWidth = void 0;
    this.enableDistanceLegend = !Cesium.defined(options.enableDistanceLegend) || options.enableDistanceLegend;
    Cesium.knockout.track(this, ["distanceLabel", "barWidth"]);
    this.EventHelper.add(this.terria.afterWidgetChanged, function() {
      if (Cesium.defined(this._removeSubscription)) {
        this._removeSubscription();
        this._removeSubscription = void 0;
      }
    }, this);
    var that = this;
    addUpdateSubscription();
    this.EventHelper.add(this.terria.afterWidgetChanged, function() {
      addUpdateSubscription();
    }, this);
  }
  function UserInterfaceControl(terria) {
    if (!Cesium.defined(terria)) {
      throw new Cesium.DeveloperError("terria is required");
    }
    this._terria = terria;
    this.name = "Unnamed Control";
    this.text = void 0;
    this.svgIcon = void 0;
    this.svgHeight = void 0;
    this.svgWidth = void 0;
    this.cssClass = void 0;
    this.isActive = false;
    Cesium.knockout.track(this, ["name", "svgIcon", "svgHeight", "svgWidth", "cssClass", "isActive"]);
  }
  function HttpStatusError(message) {
    UserInterfaceControl.apply(this, arguments);
  }
  function ResetViewNavigationControl(terria) {
    HttpStatusError.apply(this, arguments);
    this.name = "\u91cd\u7f6e\u89c6\u56fe";
    this.navigationLocked = false;
    this.svgIcon = "M 7.5,0 C 3.375,0 0,3.375 0,7.5 0,11.625 3.375,15 7.5,15 c 3.46875,0 6.375,-2.4375 7.21875,-5.625 l -1.96875,0 C 12,11.53125 9.9375,13.125 7.5,13.125 4.40625,13.125 1.875,10.59375 1.875,7.5 1.875,4.40625 4.40625,1.875 7.5,1.875 c 1.59375,0 2.90625,0.65625 3.9375,1.6875 l -3,3 6.5625,0 L 15,0 12.75,2.25 C 11.4375,0.84375 9.5625,0 7.5,0 z";
    this.svgHeight = 15;
    this.svgWidth = 15;
    this.cssClass = "navigation-control-icon-reset";
  }
  function ZoomNavigationControl(terria, zoomIn) {
    HttpStatusError.apply(this, arguments);
    this.name = "Zoom " + (zoomIn ? "In" : "Out");
    this.text = zoomIn ? "+" : "-";
    this.cssClass = "navigation-control-icon-zoom-" + (zoomIn ? "in" : "out");
    this.relativeAmount = 2;
    if (zoomIn) {
      this.relativeAmount = 1 / this.relativeAmount;
    }
  }
  function NavigationViewModel(options) {
    function widgetChange() {
      if (Cesium.defined(that.terria)) {
        if (that._unsubcribeFromPostRender) {
          that._unsubcribeFromPostRender();
          that._unsubcribeFromPostRender = void 0;
        }
        that.showCompass = that.enableCompass;
        that._unsubcribeFromPostRender = that.terria.scene.postRender.addEventListener(function() {
          that.heading = that.terria.scene.camera.heading;
        });
      } else {
        if (that._unsubcribeFromPostRender) {
          that._unsubcribeFromPostRender();
          that._unsubcribeFromPostRender = void 0;
        }
        that.showCompass = false;
      }
    }
    this.terria = options.terria;
    this.EventHelper = new Cesium["EventHelper"];
    this.enableZoomControls = !Cesium.defined(options.enableZoomControls) || options.enableZoomControls;
    this.enableCompass = !Cesium.defined(options.enableCompass) || options.enableCompass;
    this.navigationLocked = false;
    this.controls = options.controls;
    if (!Cesium.defined(this.controls)) {
      this.controls = [new ZoomNavigationControl(this.terria, true), new ResetViewNavigationControl(this.terria), new ZoomNavigationControl(this.terria, false)];
    }
    this.svgCompassOuterRing = "m 66.5625,0 0,15.15625 3.71875,0 0,-10.40625 5.5,10.40625 4.375,0 0,-15.15625 -3.71875,0 0,10.40625 L 70.9375,0 66.5625,0 z M 72.5,20.21875 c -28.867432,0 -52.28125,23.407738 -52.28125,52.28125 0,28.87351 23.413818,52.3125 52.28125,52.3125 28.86743,0 52.28125,-23.43899 52.28125,-52.3125 0,-28.873512 -23.41382,-52.28125 -52.28125,-52.28125 z m 0,1.75 c 13.842515,0 26.368948,5.558092 35.5,14.5625 l -11.03125,11 0.625,0.625 11.03125,-11 c 8.9199,9.108762 14.4375,21.579143 14.4375,35.34375 0,13.764606 -5.5176,26.22729 -14.4375,35.34375 l -11.03125,-11 -0.625,0.625 11.03125,11 c -9.130866,9.01087 -21.658601,14.59375 -35.5,14.59375 -13.801622,0 -26.321058,-5.53481 -35.4375,-14.5 l 11.125,-11.09375 c 6.277989,6.12179 14.857796,9.90625 24.3125,9.90625 19.241896,0 34.875,-15.629154 34.875,-34.875 0,-19.245847 -15.633104,-34.84375 -34.875,-34.84375 -9.454704,0 -18.034511,3.760884 -24.3125,9.875 L 37.0625,36.4375 C 46.179178,27.478444 58.696991,21.96875 72.5,21.96875 z m -0.875,0.84375 0,13.9375 1.75,0 0,-13.9375 -1.75,0 z M 36.46875,37.0625 47.5625,48.15625 C 41.429794,54.436565 37.65625,63.027539 37.65625,72.5 c 0,9.472461 3.773544,18.055746 9.90625,24.34375 L 36.46875,107.9375 c -8.96721,-9.1247 -14.5,-21.624886 -14.5,-35.4375 0,-13.812615 5.53279,-26.320526 14.5,-35.4375 z M 72.5,39.40625 c 18.297686,0 33.125,14.791695 33.125,33.09375 0,18.302054 -14.827314,33.125 -33.125,33.125 -18.297687,0 -33.09375,-14.822946 -33.09375,-33.125 0,-18.302056 14.796063,-33.09375 33.09375,-33.09375 z M 22.84375,71.625 l 0,1.75 13.96875,0 0,-1.75 -13.96875,0 z m 85.5625,0 0,1.75 14,0 0,-1.75 -14,0 z M 71.75,108.25 l 0,13.9375 1.71875,0 0,-13.9375 -1.71875,0 z";
    this.svgCompassGyro = "m 72.71875,54.375 c -0.476702,0 -0.908208,0.245402 -1.21875,0.5625 -0.310542,0.317098 -0.551189,0.701933 -0.78125,1.1875 -0.172018,0.363062 -0.319101,0.791709 -0.46875,1.25 -6.91615,1.075544 -12.313231,6.656514 -13,13.625 -0.327516,0.117495 -0.661877,0.244642 -0.9375,0.375 -0.485434,0.22959 -0.901634,0.471239 -1.21875,0.78125 -0.317116,0.310011 -0.5625,0.742111 -0.5625,1.21875 l 0.03125,0 c 0,0.476639 0.245384,0.877489 0.5625,1.1875 0.317116,0.310011 0.702066,0.58291 1.1875,0.8125 0.35554,0.168155 0.771616,0.32165 1.21875,0.46875 1.370803,6.10004 6.420817,10.834127 12.71875,11.8125 0.146999,0.447079 0.30025,0.863113 0.46875,1.21875 0.230061,0.485567 0.470708,0.870402 0.78125,1.1875 0.310542,0.317098 0.742048,0.5625 1.21875,0.5625 0.476702,0 0.876958,-0.245402 1.1875,-0.5625 0.310542,-0.317098 0.582439,-0.701933 0.8125,-1.1875 0.172018,-0.363062 0.319101,-0.791709 0.46875,-1.25 6.249045,-1.017063 11.256351,-5.7184 12.625,-11.78125 0.447134,-0.1471 0.86321,-0.300595 1.21875,-0.46875 0.485434,-0.22959 0.901633,-0.502489 1.21875,-0.8125 0.317117,-0.310011 0.5625,-0.710861 0.5625,-1.1875 l -0.03125,0 c 0,-0.476639 -0.245383,-0.908739 -0.5625,-1.21875 C 89.901633,71.846239 89.516684,71.60459 89.03125,71.375 88.755626,71.244642 88.456123,71.117495 88.125,71 87.439949,64.078341 82.072807,58.503735 75.21875,57.375 c -0.15044,-0.461669 -0.326927,-0.884711 -0.5,-1.25 -0.230061,-0.485567 -0.501958,-0.870402 -0.8125,-1.1875 -0.310542,-0.317098 -0.710798,-0.5625 -1.1875,-0.5625 z m -0.0625,1.40625 c 0.03595,-0.01283 0.05968,0 0.0625,0 0.0056,0 0.04321,-0.02233 0.1875,0.125 0.144288,0.147334 0.34336,0.447188 0.53125,0.84375 0.06385,0.134761 0.123901,0.309578 0.1875,0.46875 -0.320353,-0.01957 -0.643524,-0.0625 -0.96875,-0.0625 -0.289073,0 -0.558569,0.04702 -0.84375,0.0625 C 71.8761,57.059578 71.936151,56.884761 72,56.75 c 0.18789,-0.396562 0.355712,-0.696416 0.5,-0.84375 0.07214,-0.07367 0.120304,-0.112167 0.15625,-0.125 z m 0,2.40625 c 0.448007,0 0.906196,0.05436 1.34375,0.09375 0.177011,0.592256 0.347655,1.271044 0.5,2.03125 0.475097,2.370753 0.807525,5.463852 0.9375,8.9375 -0.906869,-0.02852 -1.834463,-0.0625 -2.78125,-0.0625 -0.92298,0 -1.802327,0.03537 -2.6875,0.0625 0.138529,-3.473648 0.493653,-6.566747 0.96875,-8.9375 0.154684,-0.771878 0.320019,-1.463985 0.5,-2.0625 0.405568,-0.03377 0.804291,-0.0625 1.21875,-0.0625 z m -2.71875,0.28125 c -0.129732,0.498888 -0.259782,0.987558 -0.375,1.5625 -0.498513,2.487595 -0.838088,5.693299 -0.96875,9.25 -3.21363,0.15162 -6.119596,0.480068 -8.40625,0.9375 -0.682394,0.136509 -1.275579,0.279657 -1.84375,0.4375 0.799068,-6.135482 5.504716,-11.036454 11.59375,-12.1875 z M 75.5,58.5 c 6.043169,1.18408 10.705093,6.052712 11.5,12.15625 -0.569435,-0.155806 -1.200273,-0.302525 -1.875,-0.4375 -2.262525,-0.452605 -5.108535,-0.783809 -8.28125,-0.9375 -0.130662,-3.556701 -0.470237,-6.762405 -0.96875,-9.25 C 75.761959,59.467174 75.626981,58.990925 75.5,58.5 z m -2.84375,12.09375 c 0.959338,0 1.895843,0.03282 2.8125,0.0625 C 75.48165,71.267751 75.5,71.871028 75.5,72.5 c 0,1.228616 -0.01449,2.438313 -0.0625,3.59375 -0.897358,0.0284 -1.811972,0.0625 -2.75,0.0625 -0.927373,0 -1.831062,-0.03473 -2.71875,-0.0625 -0.05109,-1.155437 -0.0625,-2.365134 -0.0625,-3.59375 0,-0.628972 0.01741,-1.232249 0.03125,-1.84375 0.895269,-0.02827 1.783025,-0.0625 2.71875,-0.0625 z M 68.5625,70.6875 c -0.01243,0.60601 -0.03125,1.189946 -0.03125,1.8125 0,1.22431 0.01541,2.407837 0.0625,3.5625 -3.125243,-0.150329 -5.92077,-0.471558 -8.09375,-0.90625 -0.784983,-0.157031 -1.511491,-0.316471 -2.125,-0.5 -0.107878,-0.704096 -0.1875,-1.422089 -0.1875,-2.15625 0,-0.115714 0.02849,-0.228688 0.03125,-0.34375 0.643106,-0.20284 1.389577,-0.390377 2.25,-0.5625 2.166953,-0.433487 4.97905,-0.75541 8.09375,-0.90625 z m 8.3125,0.03125 c 3.075121,0.15271 5.824455,0.446046 7.96875,0.875 0.857478,0.171534 1.630962,0.360416 2.28125,0.5625 0.0027,0.114659 0,0.228443 0,0.34375 0,0.735827 -0.07914,1.450633 -0.1875,2.15625 -0.598568,0.180148 -1.29077,0.34562 -2.0625,0.5 -2.158064,0.431708 -4.932088,0.754666 -8.03125,0.90625 0.04709,-1.154663 0.0625,-2.33819 0.0625,-3.5625 0,-0.611824 -0.01924,-1.185379 -0.03125,-1.78125 z M 57.15625,72.5625 c 0.0023,0.572772 0.06082,1.131112 0.125,1.6875 -0.125327,-0.05123 -0.266577,-0.10497 -0.375,-0.15625 -0.396499,-0.187528 -0.665288,-0.387337 -0.8125,-0.53125 -0.147212,-0.143913 -0.15625,-0.182756 -0.15625,-0.1875 0,-0.0047 -0.02221,-0.07484 0.125,-0.21875 0.147212,-0.143913 0.447251,-0.312472 0.84375,-0.5 0.07123,-0.03369 0.171867,-0.06006 0.25,-0.09375 z m 31.03125,0 c 0.08201,0.03503 0.175941,0.05872 0.25,0.09375 0.396499,0.187528 0.665288,0.356087 0.8125,0.5 0.14725,0.14391 0.15625,0.21405 0.15625,0.21875 0,0.0047 -0.009,0.04359 -0.15625,0.1875 -0.147212,0.143913 -0.416001,0.343722 -0.8125,0.53125 -0.09755,0.04613 -0.233314,0.07889 -0.34375,0.125 0.06214,-0.546289 0.09144,-1.094215 0.09375,-1.65625 z m -29.5,3.625 c 0.479308,0.123125 0.983064,0.234089 1.53125,0.34375 2.301781,0.460458 5.229421,0.787224 8.46875,0.9375 0.167006,2.84339 0.46081,5.433176 0.875,7.5 0.115218,0.574942 0.245268,1.063612 0.375,1.5625 -5.463677,-1.028179 -9.833074,-5.091831 -11.25,-10.34375 z m 27.96875,0 C 85.247546,81.408945 80.919274,85.442932 75.5,86.5 c 0.126981,-0.490925 0.261959,-0.967174 0.375,-1.53125 0.41419,-2.066824 0.707994,-4.65661 0.875,-7.5 3.204493,-0.15162 6.088346,-0.480068 8.375,-0.9375 0.548186,-0.109661 1.051942,-0.220625 1.53125,-0.34375 z M 70.0625,77.53125 c 0.865391,0.02589 1.723666,0.03125 2.625,0.03125 0.912062,0 1.782843,-0.0048 2.65625,-0.03125 -0.165173,2.736408 -0.453252,5.207651 -0.84375,7.15625 -0.152345,0.760206 -0.322989,1.438994 -0.5,2.03125 -0.437447,0.03919 -0.895856,0.0625 -1.34375,0.0625 -0.414943,0 -0.812719,-0.02881 -1.21875,-0.0625 -0.177011,-0.592256 -0.347655,-1.271044 -0.5,-2.03125 -0.390498,-1.948599 -0.700644,-4.419842 -0.875,-7.15625 z m 1.75,10.28125 c 0.284911,0.01545 0.554954,0.03125 0.84375,0.03125 0.325029,0 0.648588,-0.01171 0.96875,-0.03125 -0.05999,0.148763 -0.127309,0.31046 -0.1875,0.4375 -0.18789,0.396562 -0.386962,0.696416 -0.53125,0.84375 -0.144288,0.147334 -0.181857,0.125 -0.1875,0.125 -0.0056,0 -0.07446,0.02233 -0.21875,-0.125 C 72.355712,88.946416 72.18789,88.646562 72,88.25 71.939809,88.12296 71.872486,87.961263 71.8125,87.8125 z";
    this.svgCompassRotationMarker = "M 72.46875,22.03125 C 59.505873,22.050338 46.521615,27.004287 36.6875,36.875 L 47.84375,47.96875 C 61.521556,34.240041 83.442603,34.227389 97.125,47.90625 l 11.125,-11.125 C 98.401629,26.935424 85.431627,22.012162 72.46875,22.03125 z";
    this.showCompass = Cesium.defined(this.terria) && this.enableCompass;
    this.heading = this.showCompass ? this.terria.scene.camera.heading : 0;
    this.isOrbiting = false;
    this.orbitCursorAngle = 0;
    this.orbitCursorOpacity = 0;
    this.orbitLastTimestamp = 0;
    this.orbitFrame = void 0;
    this.orbitIsLook = false;
    this.orbitMouseMoveFunction = void 0;
    this.orbitMouseUpFunction = void 0;
    this.isRotating = false;
    this.rotateInitialCursorAngle = void 0;
    this.rotateFrame = void 0;
    this.rotateIsLook = false;
    this.rotateMouseMoveFunction = void 0;
    this.rotateMouseUpFunction = void 0;
    this._unsubcribeFromPostRender = void 0;
    Cesium.knockout.track(this, ["controls", "showCompass", "heading", "isOrbiting", "orbitCursorAngle", "isRotating"]);
    var that = this;
    NavigationViewModel.prototype.setNavigationLocked = function(canCreateDiscussions) {
      this.navigationLocked = canCreateDiscussions;
      if (this.controls && 1 < this.controls.length) {
        this.controls[1].setNavigationLocked(this.navigationLocked);
      }
    };
    this.EventHelper.add(this.terria.afterWidgetChanged, widgetChange, this);
    widgetChange();
  }
  function setup(DSWMan) {
    (function(pickedObject, options) {
      if (!Cesium.defined(pickedObject)) {
        throw new Cesium["DeveloperError"]("CesiumWidget or Viewer is required.");
      }
      var logsUI = Cesium.defined(pickedObject.cesiumWidget) ? pickedObject.cesiumWidget : pickedObject;
      var container = document.createElement("div");
      container.className = "cesium-widget-cesiumNavigationContainer";
      logsUI.container.appendChild(container);
      this.terria = pickedObject;
      this.terria.options = Cesium.defined(options) ? options : {};
      this.terria.afterWidgetChanged = new Cesium.Event;
      this.terria.beforeWidgetChanged = new Cesium.Event;
      this.container = container;
      Cesium.SvgPathBindingHandler.register(Cesium.knockout);
      factory(Cesium.knockout);
      register(Cesium.knockout);
      Cesium.knockout.bindingHandlers.embeddedComponent = {
        "init" : function(obj, valueAccessor, allBindingsAccessor, context, flightPhase) {
          return Cesium.knockout.unwrap(valueAccessor()).show(obj), {
            "controlsDescendantBindings" : true
          };
        },
        "update" : function(roles, position, html, post, fieldNames) {
        }
      };
      if (!(Cesium.defined(this.terria.options.enableDistanceLegend) && !this.terria.options.enableDistanceLegend)) {
        this.distanceLegendDiv = document.createElement("div");
        container.appendChild(this.distanceLegendDiv);
        this.distanceLegendDiv.setAttribute("id", "distanceLegendDiv");
        this.distanceLegendViewModel = DistanceLegendViewModel.create({
          "container" : this.distanceLegendDiv,
          "terria" : this.terria,
          "mapElement" : container,
          "enableDistanceLegend" : true
        });
      }
      if (Cesium.defined(this.terria.options.enableZoomControls) && !this.terria.options.enableZoomControls || Cesium.defined(this.terria.options.enableCompass) && !this.terria.options.enableCompass) {
        if (!Cesium.defined(this.terria.options.enableZoomControls) || this.terria.options.enableZoomControls || Cesium.defined(this.terria.options.enableCompass) && !this.terria.options.enableCompass) {
          if (Cesium.defined(this.terria.options.enableZoomControls) && !this.terria.options.enableZoomControls || !Cesium.defined(this.terria.options.enableCompass) || this.terria.options.enableCompass) {
            if (Cesium.defined(this.terria.options.enableZoomControls) && !this.terria.options.enableZoomControls && Cesium.defined(this.terria.options.enableCompass)) {
              this.terria.options.enableCompass;
            }
          } else {
            this.navigationDiv = document.createElement("div");
            this.navigationDiv.setAttribute("id", "navigationDiv");
            container.appendChild(this.navigationDiv);
            this.navigationViewModel = NavigationViewModel.create({
              "container" : this.navigationDiv,
              "terria" : this.terria,
              "enableZoomControls" : true,
              "enableCompass" : false
            });
          }
        } else {
          this.navigationDiv = document.createElement("div");
          this.navigationDiv.setAttribute("id", "navigationDiv");
          container.appendChild(this.navigationDiv);
          this.navigationViewModel = NavigationViewModel.create({
            "container" : this.navigationDiv,
            "terria" : this.terria,
            "enableZoomControls" : false,
            "enableCompass" : true
          });
        }
      } else {
        this.navigationDiv = document.createElement("div");
        this.navigationDiv.setAttribute("id", "navigationDiv");
        container.appendChild(this.navigationDiv);
        this.navigationViewModel = NavigationViewModel.create({
          "container" : this.navigationDiv,
          "terria" : this.terria,
          "enableZoomControls" : true,
          "enableCompass" : true
        });
      }
    }).apply(this, arguments);
    this._onDestroyListeners = [];
  }
  function indexOf(data, items) {
    if (!Cesium.defined(data)) {
      throw new Cesium["DeveloperError"]("viewer is required.");
    }
    var autoReview;
    items = each(data, items);
    return items.addOnDestroyListener((autoReview = data, function() {
      delete autoReview.cesiumNavigation;
    })), Object.defineProperties(data, {
      "cesiumNavigation" : {
        "configurable" : true,
        "get" : function() {
          return data.cesiumWidget.cesiumNavigation;
        }
      }
    }), items;
  }
  function WordpressArticlesController($state, wordpressService) {
    call(this, WordpressArticlesController);
    this.viewer = $state;
    this.map = wordpressService;
    this.activateContainer = void 0;
    this.initEvent();
    this.activate();
    this.addMapData();
  }
  function r(value) {
    call(this, r);
    this.viewer = value;
    this.createDom();
    this.initEvent();
  }
  function x(value) {
    call(this, x);
    this.viewer = value;
    this.initEvent();
  }
  function lock(name, obj) {
    call(this, lock);
    this.viewer1 = name;
    this.viewer2 = obj;
    this.focusIndex = 0;
  }
  function main(value, target) {
    var frontpageItems = this;
    call(this, main);
    this.viewer = value;
    this.style = target || {};
    this.container = document.createElement("div");
    this.container.classList.add("loading-mask");
    this.viewer.cesiumWidget.container.appendChild(this.container);
    this.container.onclick = function(branch) {
      var parseInt = hahaha;
      frontpageItems[parseInt(508)]();
    };
  }
  function _p(value) {
    call(this, _p);
    this.viewer = value;
  }
  function error(value) {
    call(this, error);
    this.viewer = value;
    this.init();
  }
  function HorizontalArranger(value) {
    call(this, HorizontalArranger);
    this.viewer = value;
  }
  function display(value, target) {
    call(this, display);
    this.viewer = value;
    this.bgUrl = target;
    this.init();
  }
  function prop(value) {
    call(this, prop);
    this.viewer = value;
  }
  function SpirographPositionProperty(options) {
    this._definitionChanged = new Cesium.Event;
    this.colorSubscription = void 0;
    this.color = options.color;
    this.duration = options.duration;
    this.url = options.imgUrl;
    this._time = (new Date).getTime();
  }
  function option(value, target) {
    call(this, option);
    this.viewer = value;
    this.options = target;
    this.addCloudEntity();
  }
  function defaults(value, target) {
    call(this, defaults);
    this.viewer = value;
    this.map = target;
    this.activateContainer = void 0;
    this.initEvent();
    this.activate();
  }
  function setPosition(value, transition) {
    call(this, setPosition);
    this.viewer = value;
    this.style = transition || {};
    this.container = document.createElement("div");
    this.container.classList.add("div-mask");
    this.viewer.cesiumWidget.container.appendChild(this.container);
    if (this.style.color) {
      this.container.style.boxShadow = "inset 1px 0px 500px 170px " + this.style.color;
      this.container.style.zIndex = this.style.zIndex || 999;
    }
  }
  function executeCommands(context, framebuffer, passState, index, name, callback) {
    function executeCommand(command, id, context, passState) {
      var parseInt = hahaha;
      var args;
      var i;
      var method;
      var obj;
      var singularityResult;
      var GET_AUTH_URL_TIMEOUT;
      var defined;
      if (!(callback && !callback(command, id))) {
        if (index && name) {
          args = command;
          i = index;
          method = name;
          obj = id;
          singularityResult = context;
          GET_AUTH_URL_TIMEOUT = passState;
          defined = Cesium[parseInt(1973)];
          id = obj[parseInt(389)];
          obj = args.derivedCommands;
          if (defined(obj)) {
            if (id.useLogDepth && defined(obj[parseInt(1142)])) {
              args = obj.logDepth[parseInt(2807)];
            }
            if (defined((obj = args[parseInt(1574)])[i])) {
              (args = obj[i][method])[parseInt(2405)](singularityResult, GET_AUTH_URL_TIMEOUT);
            }
          }
        } else {
          command.execute(context, passState);
        }
      }
    }
    var camera = Cesium;
    var Pass = camera.Pass;
    var defined = camera.defined;
    var viewOffsetY = camera.PerspectiveFrustum;
    var u = camera.PerspectiveOffCenterFrustum;
    var PluginProvider = camera.OrthographicFrustum;
    camera = camera.OrthographicOffCenterFrustum;
    date = date || new viewOffsetY;
    time = time || new u;
    pluginProvider = pluginProvider || new PluginProvider;
    cityCollection = cityCollection || new camera;
    var frustum;
    var j;
    var vertLen;
    var commands;
    var uniformState = context._us;
    camera = uniformState._frameState.camera;
    var scene = camera._scene;
    var frustumCommandsList = scene._view.frustumCommandsList;
    var length = frustumCommandsList.length;
    var material = scene._globeTranslucencyState;
    var uniforms = material.translucent;
    frustum = defined(camera.frustum.fov) ? camera.frustum.clone(date) : defined(camera.frustum.infiniteProjectionMatrix) ? camera.frustum.clone(time) : defined(camera.frustum.width) ? camera.frustum.clone(pluginProvider) : camera.frustum.clone(cityCollection);
    var written = 0;
    for (; written < length; ++written) {
      var i = length - written - 1;
      var frustumCommands = frustumCommandsList[i];
      var opaqueFramebuffer = passState.framebuffer;
      if (passState.framebuffer = framebuffer, frustum.near = 0 != i ? frustumCommands.near * scene.opaqueFrustumNearOffset : frustumCommands.near, frustum.far = frustumCommands.far, uniformState.updateFrustum(frustum), uniformState.updatePass(Pass.GLOBE), commands = frustumCommands.commands[Pass.GLOBE], vertLen = frustumCommands.indices[Pass.GLOBE], uniforms) {
        material.executeGlobeCommands(frustumCommands, executeCommand, globeTranslucencyFramebuffer, scene, passState);
      } else {
        j = 0;
        for (; j < vertLen; ++j) {
          executeCommand(commands[j], scene, context, passState);
        }
      }
      uniformState.updatePass(Pass.CESIUM_3D_TILE);
      commands = frustumCommands.commands[Pass.CESIUM_3D_TILE];
      vertLen = frustumCommands.indices[Pass.CESIUM_3D_TILE];
      j = 0;
      for (; j < vertLen; ++j) {
        executeCommand(commands[j], scene, context, passState);
      }
      uniformState.updatePass(Pass.OPAQUE);
      commands = frustumCommands.commands[Pass.OPAQUE];
      vertLen = frustumCommands.indices[Pass.OPAQUE];
      j = 0;
      for (; j < vertLen; ++j) {
        executeCommand(commands[j], scene, context, passState);
      }
      uniformState.updatePass(Pass.TRANSLUCENT);
      commands = frustumCommands.commands[Pass.TRANSLUCENT];
      vertLen = frustumCommands.indices[Pass.TRANSLUCENT];
      j = 0;
      for (; j < vertLen; ++j) {
        executeCommand(commands[j], scene, context, passState);
      }
      passState.framebuffer = opaqueFramebuffer;
    }
  }
  function create(options) {
    function bind(obj, data, width, height) {
      var parseInt = hahaha;
      var result = obj[parseInt(842)].getDerivedShaderProgram(data, locale);
      if (!defined(result)) {
        var passid = data[parseInt(1817)];
        var args = data[parseInt(1095)];
        var map = data[parseInt(2252)];
        var action = data._vertexShaderText;
        var value = args[parseInt(2377)];
        var i = value[parseInt(2189)];
        var b = !!values && function() {
          var round = parseInt;
          if (!values) {
            return;
          }
          var r = values.selected || values[round(1194)];
          if (r.length) {
            return r;
          }
        }();
        var source = packages;
        var a = /texture2Ds?(s?tile_pickTextures?,s?tile_featureSts?)/[parseInt(2059)](width);
        source = source + (parseInt(1770) != height || a ? parseInt(1833) + width + parseInt(2191) : parseInt(1722) + width + parseInt(1643));
        var current_action = packages + `\nvarying float me_isSelected;\nbool czm_selected(){\n    return czm_selected(` + width + parseInt(1642);
        var _0x505d4d = false;
        width = false;
        if (/attribute\s?vec3\s?normal\s?;/.test(action) || /\n\s?vec3\s?normal\s?;/.test(action) ? _0x505d4d = true : /varying\s?vec3\s?v_normal\s?;/[parseInt(2059)](action) && (width = true), disabled) {
          var selectable = false;
          j = 0;
          for (; j < i; ++j) {
            if (/vec4\s?packDepthToRGBA\s?\(/[parseInt(2059)](value[j])) {
              selectable = true;
              break;
            }
          }
          source = (selectable ? "" : none) + (b ? source : "") + list[parseInt(2848)](disabled, name) + `void main() \n{ \n` + ("replace" != type ? parseInt(545) + x + `(); \n` : "") + "    " + name + `(); \n} \n`;
          var data = new Array(i + 1);
          var j = 0;
          for (; j < i; ++j) {
            data[j] = list[parseInt(2848)](value[j], x);
          }
          data[i] = source;
          if (_0x505d4d) {
            args.defines[parseInt(2008)](parseInt(1837));
          } else {
            if (width) {
              args.defines[parseInt(2008)](parseInt(1823));
            }
          }
          args = new list({
            "sources" : data,
            "defines" : args[parseInt(2003)]
          });
        }
        if (checked || disabled) {
          i = (value = map[parseInt(2377)])[parseInt(2189)];
          selectable = false;
          j = 0;
          for (; j < i; ++j) {
            if (/vec4\s?packDepthToRGBA\s?\(/[parseInt(2059)](value[j])) {
              selectable = true;
              break;
            }
          }
          b = b && parseInt(1770) == height && !a;
          if (_0x505d4d) {
            map[parseInt(2003)][parseInt(2008)]("HAS_NORMAL");
          } else {
            if (width) {
              map[parseInt(2003)][parseInt(2008)](parseInt(1823));
            }
          }
          b = (selectable ? "" : none) + (b ? current_action : "") + list[parseInt(2848)](checked || "void main(){}", name) + parseInt(2955) + (parseInt(2101) != type ? parseInt(545) + x + parseInt(1853) : "") + (b ? parseInt(1226) : "") + parseInt(545) + name + parseInt(2886);
          data = new Array(i + 1);
          j = 0;
          for (; j < i; ++j) {
            data[j] = list.replaceMain(value[j], x);
          }
          data[i] = b;
          map = new list({
            "sources" : data,
            "defines" : map[parseInt(2003)]
          });
        }
        result = obj[parseInt(842)].createDerivedShaderProgram(data, locale, {
          "vertexShaderSource" : map,
          "fragmentShaderSource" : args,
          "attributeLocations" : passid
        });
      }
      return result;
    }
    function init(data, item, context) {
      var parseInt = hahaha;
      var llbb;
      var group;
      var value = data;
      var obj = item[parseInt(389)];
      var result = data[parseInt(1574)];
      if (defined(result)) {
        if (obj[parseInt(967)] && defined(result[parseInt(1142)])) {
          data = result[parseInt(1142)].command;
        }
        obj = (result = data[parseInt(1574)])[parseInt(1222)];
        if (!defined(result[parseInt(1222)])) {
          obj = result[parseInt(1222)] = {};
        }
        if (defined(obj[key])) {
          llbb = obj[key][parseInt(1501)];
          group = obj[key].renderState;
        }
        obj[key] = handlers[parseInt(2704)](data, obj[key]);
        if (defined(llbb) && obj.shaderProgramId === data[parseInt(1501)].id) {
          obj[key][parseInt(1501)] = llbb;
          obj[key][parseInt(2236)] = group;
        } else {
          group = data[parseInt(1501)];
          value = value[parseInt(2634)] = (new RegExp("uniforms?vec4s?" + data[parseInt(1375)], "g"))[parseInt(2059)](group[parseInt(2883)]) ? parseInt(2355) : parseInt(1770);
          obj[key].shaderProgram = bind(context, group, data[parseInt(1375)], value);
          obj[key][parseInt(2236)] = function(type, key) {
            var par = parseInt;
            type[par(1032)] = type[par(1032)] || {};
            type[par(1032)][target] = type[par(1032)][target] || {};
            var params = type[par(1032)][target];
            var callback = params[key.id];
            return defined(callback) || (type = event.getState(key), par(827) == typeof filter && filter[par(744)](result, type), callback = event[par(2520)](type), params[key.id] = callback), callback;
          }(item, data[parseInt(2236)]);
          obj[parseInt(1660)] = data[parseInt(1501)].id;
        }
        (function(data) {
          var String = parseInt;
          if (!data[String(1466)] && (data[String(2643)] = function() {
            return values._selectedIdTexture;
          }, data[String(697)] = function() {
            var parseInt = String;
            return values[parseInt(1994)] ? values[parseInt(1994)][parseInt(807)] : 0;
          }, data[String(919)] = function() {
            var Str = String;
            return values._selectedIdTexture ? 1 / values._selectedIdTexture[Str(807)] : -1;
          }, obj)) {
            var key;
            for (key in data[String(1466)] = true, obj) {
              var value;
              if (obj[String(2831)](key)) {
                if (String(827) != typeof obj[key]) {
                  data[key] = function(index) {
                    return function() {
                      var state = obj[index];
                      return "function" == typeof state ? state() : state;
                    };
                  }(key);
                } else {
                  data[key] = obj[key];
                }
                if (String(2583) == typeof(value = data[key]()) || value instanceof Texture || value instanceof HTMLImageElement || value instanceof HTMLCanvasElement || value instanceof HTMLVideoElement) {
                  data[key + String(479)] = function(service, name) {
                    return function() {
                      var vector = service[name]();
                      if (defined(vector)) {
                        return vector.dimensions;
                      }
                    };
                  }(data, key);
                }
              }
            }
          }
        })(obj[key].uniformMap);
      }
    }
    function create(fn, type, width) {
      var getRandomNumber = hahaha;
      var size = type[getRandomNumber(807)];
      type = type[getRandomNumber(1132)];
      if (!(texture && texture[getRandomNumber(807)] === size && texture[getRandomNumber(1132)] === type && width === constraint)) {
        constraint = width;
        if (texture) {
          texture.destroy();
          buffer[getRandomNumber(1701)]();
          texture = buffer = void 0;
        }
        if (chars) {
          chars[getRandomNumber(1701)]();
          chars = void 0;
        }
        texture = new Texture({
          "context" : fn,
          "width" : size,
          "height" : type,
          "pixelFormat" : defaultValue(message, defaults[getRandomNumber(1058)]),
          "pixelDatatype" : defaultValue(renderState, terrainProviderViewModels[getRandomNumber(1279)]),
          "sampler" : defaultValue(vertexFormat, tex[getRandomNumber(523)])
        });
        chars = new Texture({
          "context" : fn,
          "width" : size,
          "height" : type,
          "pixelFormat" : defaults[getRandomNumber(1551)],
          "pixelDatatype" : terrainProviderViewModels[getRandomNumber(1727)],
          "sampler" : tex.NEAREST
        });
        buffer = new Float32Array({
          "colorTextures" : [texture],
          "context" : fn,
          "destroyAttachments" : false,
          "depthTexture" : chars
        });
      }
    }
    function get(result) {
      var key = hahaha;
      return c || (t = task.clone(result[key(1145)], t), point ? (t.x = t[key(807)] * point.x, t.y = t.height * point.y, t[key(807)] *= point[key(807)], t.height *= point[key(1132)]) : (t.width *= scaleX, t[key(1132)] *= scaleX)), result = Object[key(988)]({}, result[key(2092)]), result[key(1145)] = t, result;
    }
    function update(callback, position) {
      var parseInt = hahaha;
      var button;
      var obj = callback[parseInt(1859)][parseInt(389)][parseInt(1306)][parseInt(1636)];
      var item = obj[parseInt(2993)];
      try {
        if (checked || disabled) {
          button = get(item);
          if ("function" == typeof r) {
            r.call(result, obj, position);
          }
          create(callback, t, obj[parseInt(1872)], item[parseInt(1098)]);
          (function(receiver) {
            var toPythonCase = parseInt;
            var i;
            var b = receiver[toPythonCase(2993)][toPythonCase(1634)];
            var clientHeight = b.length;
            var targetOffsetHeight = 0;
            for (; targetOffsetHeight < clientHeight; ++targetOffsetHeight) {
              var c = b[clientHeight - targetOffsetHeight - 1];
              var j = 0;
              for (; j < c[toPythonCase(2588)][toPythonCase(2189)]; j++) {
                var props = c[toPythonCase(2588)][j];
                var dependencyMod = c.indices[j];
                if (!values || j != receiver[toPythonCase(1895)]) {
                  i = 0;
                  for (; i < dependencyMod; ++i) {
                    init(props[i], receiver, receiver[toPythonCase(959)]);
                  }
                }
              }
            }
          })(obj);
          executeCommands(callback, buffer, button, parseInt(1222), key, parseInt(2774) != id && values && values[parseInt(1994)] ? render : null);
        } else {
          button = get(item);
          if (parseInt(827) == typeof r) {
            r[parseInt(744)](result, obj, position);
          }
          create(callback, t, obj[parseInt(1872)], item.sceneFramebuffer);
          executeCommands(callback, buffer, button);
        }
      } catch (previousState) {
        console[parseInt(2126)](previousState);
      }
    }
    function render(data, lagOffset) {
      var parseInt = hahaha;
      var crossfilterable_layers = values && (values[parseInt(872)] || values.parentSelected);
      if (!values || !crossfilterable_layers || !crossfilterable_layers.length) {
        return false;
      }
      if (!data[parseInt(1375)] || parseInt(2355) != data._pickIdQualifier) {
        return true;
      }
      var glNode = true;
      var dictionary = data[parseInt(414)];
      var res = "selected" == id;
      if (dictionary && dictionary[parseInt(2746)]) {
        var layer_i = 0;
        for (; layer_i < crossfilterable_layers.length; layer_i++) {
          if (crossfilterable_layers[layer_i] == dictionary) {
            return res;
          }
        }
        return !res;
      }
      var payload = data[parseInt(774)];
      if (payload[data[parseInt(1375)]]) {
        var color = payload[data.pickId]();
        glNode = !res;
        var layer_i = 0;
        for (; layer_i < crossfilterable_layers[parseInt(2189)]; layer_i++) {
          var frontpageItems = crossfilterable_layers[layer_i];
          var result = frontpageItems[parseInt(1375)] ? [frontpageItems[parseInt(1375)]] : frontpageItems[parseInt(906)] || frontpageItems[parseInt(400)];
          var i = 0;
          for (; i < result[parseInt(2189)]; i++) {
            var data = result[i];
            if (data.color == color || Color.equals(data[parseInt(2240)], color)) {
              return res;
            }
          }
        }
      }
      return glNode;
    }
    function start(obj) {
      var parseInt = hahaha;
      var variable;
      if (buffer) {
        variable = obj[parseInt(1859)][parseInt(389)][parseInt(1306)]._scene[parseInt(2993)];
        arr[parseInt(634)] = buffer;
        arr[parseInt(2405)](obj, variable[parseInt(2092)]);
        arr.framebuffer = void 0;
      }
    }
    var data = Cesium;
    var defaultValue = data.defaultValue;
    var task = data.BoundingRectangle;
    var receiver = data.Pass;
    var tex = data.Sampler;
    var handlers = data.DrawCommand;
    var Color = data.Color;
    var list = data.ShaderSource;
    var defined = data.defined;
    var ClearCommand = data.ClearCommand;
    var event = data.RenderState;
    var Texture = data.Texture;
    var terrainProviderViewModels = data.PixelDatatype;
    var defaults = data.PixelFormat;
    var Float32Array = data.Framebuffer;
    this._selectedIdTexture = null;
    data = options.name;
    var checked = options.vertexShader;
    var disabled = options.fragmentShader;
    var obj = options.uniforms;
    var filter = options.renderStateProcess;
    var r = options.beforeUpdate;
    var id = options.renderType;
    var scaleX = options.textureScale;
    var message = options.pixelFormat;
    var renderState = options.pixelDatatype;
    var vertexFormat = options.sampler;
    var point = options.viewportScale;
    var type = options.shaderRedefine;
    var c = options.overrideViewport;
    var locale = "renderPass_" + data.replace(/[.\/-]/g, "_");
    var x = "czm_non_" + locale + "_main";
    var name = "czm_" + locale + "_main";
    var target = "_cache_" + locale;
    var key = locale + "Command";
    var buffer = null;
    var texture = null;
    var chars = null;
    var values = null;
    var constraint = void 0;
    var arr = new ClearCommand({
      "color" : Color.TRANSPARENT,
      "depth" : 1
    });
    var t = new task;
    var result = this;
    if (c && task.clone(c, t), type = type || "add", id = id || "all", (scaleX = scaleX || 1) < 0 || 8 < scaleX) {
      throw new Cesium["DeveloperError"]("CesiumRenderPass\uff1atextureScale\u5fc5\u987b\u5927\u4e8e0\u5c0f\u4e8e\u7b49\u4e8e8");
    }
    this.update = update;
    this.clear = start;
    Object.defineProperties(this, {
      "texture" : {
        "get" : function() {
          return texture;
        }
      },
      "depthTexture" : {
        "get" : function() {
          return chars;
        }
      },
      "stage" : {
        "get" : function() {
          return values;
        },
        "set" : function(name) {
          var getIndex = hahaha;
          var _;
          if (values != name) {
            name = name;
            if (values && result.prevStageUpdate) {
              values[getIndex(553)] = result[getIndex(1422)];
              result.prevStageUpdate = null;
              result[getIndex(1802)] = null;
            }
            if (values = name) {
              _ = values[getIndex(553)];
              result[getIndex(1422)] = _;
              values[getIndex(553)] = function(name, value) {
                var removeKeyPrefix = getIndex;
                var typeEditors;
                start(name);
                _[removeKeyPrefix(744)](values, name, value);
                if (values[removeKeyPrefix(2622)] && (!checked && !disabled || (typeEditors = values.selected || values[removeKeyPrefix(1194)]) && typeEditors[removeKeyPrefix(2189)])) {
                  update(name, value);
                }
              };
            }
          }
        }
      }
    });
  }
  function out(name, shader, x, s) {
    var result = Cesium;
    var command = result.Cartesian2;
    var Shader = result.PostProcessStage;
    var courseSections = result.PostProcessStageComposite;
    var ctx = result.PostProcessStageSampleMode;
    result = new command(1, 0);
    command = new command(0, 1);
    shader = {
      "defines" : {
        "MAX_RADIUS" : shader
      },
      "fragmentShader" : basic_frag
    };
    return function(args) {
      var outToNewNodes = hahaha;
      var name;
      var baseProvider;
      var prefix = [];
      for (name in args.defines) {
        if (args[outToNewNodes(2003)][outToNewNodes(2831)](name)) {
          baseProvider = args.defines[name];
          prefix[outToNewNodes(2008)](outToNewNodes(1293) + name + " " + baseProvider);
        }
      }
      prefix = prefix[outToNewNodes(1778)](`\n`) + `\n`;
      if (args[outToNewNodes(1217)]) {
        args[outToNewNodes(1217)] = prefix + args.fragmentShader;
      }
      if (args.vertexShader) {
        args[outToNewNodes(2956)] = prefix + args.vertexShader;
      }
    }(shader), new courseSections({
      "name" : name,
      "stages" : [new Shader({
        "name" : name + "_x_direction",
        "fragmentShader" : shader.fragmentShader,
        "textureScale" : s,
        "forcePowerOfTwo" : true,
        "uniforms" : {
          "kernelRadius" : x,
          "direction" : result
        },
        "sampleMode" : ctx.LINEAR
      }), new Shader({
        "name" : name + "_y_direction",
        "fragmentShader" : shader.fragmentShader,
        "textureScale" : s,
        "forcePowerOfTwo" : true,
        "uniforms" : {
          "kernelRadius" : x,
          "direction" : command
        },
        "sampleMode" : ctx.LINEAR
      })],
      "inputPreviousStageTexture" : true
    });
  }
  function link(value, target) {
    call(this, link);
    this.viewer = value;
    this.viewer.postProcessStages.fxaa.enabled = true;
    this.viewer.scene.globe.depthTestAgainstTerrain = true;
    this.init();
  }
  function group(value) {
    call(this, group);
    this.viewer = value;
    this.stage = Cesium.PostProcessStageLibrary.createNightVisionStage();
    this.viewer.scene.postProcessStages.add(this.stage);
    this.stage.enabled = true;
  }
  function dragEnter(target) {
    call(this, dragEnter);
    this.viewer = target;
    this.stage = Cesium.PostProcessStageLibrary.createBlackAndWhiteStage();
    this.viewer.scene.postProcessStages.add(this.stage);
    this.stage.enabled = true;
  }
  function PlaneWizard(value) {
    call(this, PlaneWizard);
    this.viewer = value;
    this.stage = new Cesium["PostProcessStage"]({
      "fragmentShader" : "uniform sampler2D colorTexture; \n                                varying vec2 v_textureCoordinates; \n                                const int KERNEL_WIDTH=16; \n                                void main(void) \n                                { \n                                    vec2 step = 1.0 / czm_viewport.zw; \n                                    vec2 integralPos = v_textureCoordinates - mod(v_textureCoordinates, 8.0 * step); \n                                    vec3 averageValue = vec3(0.0); \n                                    for (int i = 0; i < KERNEL_WIDTH; i++) \n                                    { \n                                        for (int j = 0; j < KERNEL_WIDTH; j++) \n                                        { \n                                            averageValue += texture2D(colorTexture, integralPos + step * vec2(i, j)).rgb; \n                                        } \n                                    } \n                                    averageValue /= float(KERNEL_WIDTH * KERNEL_WIDTH); \n                                    gl_FragColor = vec4(averageValue, 1.0); \n                                } "
    });
    this.viewer.scene.postProcessStages.add(this.stage);
    this.stage.enabled = true;
  }
  function loop(obj) {
    call(this, loop);
    this.viewer = obj;
    this.stage = Cesium.PostProcessStageLibrary.createDepthOfFieldStage();
    this.viewer.scene.postProcessStages.add(this.stage);
    obj = this.stage.uniforms;
    obj.focalDistance = 87;
    obj.delta = 1;
    obj.sigma = 3.78;
    obj.stepSize = 2.46;
    this.stage.enabled = true;
  }
  function to(value, target, data) {
    call(this, to);
    this.viewer = value;
    this.position = target;
    var config = Cesium.Cartographic.fromCartesian(target);
    value = Cesium.Math.toDegrees(config.longitude);
    target = Cesium.Math.toDegrees(config.latitude);
    data = data || {};
    this.height = data.height || config.height;
    this.bottomRadius = data.bottomRadius || 0.3 * this.height;
    this.materialType = data.materialType || 1;
    this.lng = value;
    this.lat = target;
    this.addCylinder();
  }
  function build(value, obj, target) {
    call(this, build);
    this.viewer = value;
    this.position = obj;
    this.radii = target.radii || new Cesium["Cartesian3"](200, 200, 200);
    this.color = target.color || Cesium.Color.YELLOW.withAlpha(0.5);
    this.fanBladColor = target.fanBladColor || this.color;
    this.scanDirection = target.scanDirection || 1;
    this.scanSpeed = target.scanSpeed;
    this.addEllipsoid();
    this.addFanBlad();
  }
  function element(value, obj, target) {
    call(this, element);
    this.viewer = value;
    this.position = obj;
    this.radii = target.radii || new Cesium.Cartesian3(200, 200, 200);
    this.color = target.color || Cesium.Color.YELLOW.withAlpha(0.5);
    this.fanBladColor = target.fanBladColor || this.color;
    this.scanType = target.scanType || 1;
    this.scanDirection = target.scanDirection || 1;
    this.scanSpeed = target.scanSpeed;
    this.addEllipsoid();
    if (1 == this.scanType) {
      this.addScan1();
    } else {
      this.addScan2();
    }
  }
  function type(value, target, prop) {
    call(this, type);
    this.viewer = value;
    this.originPosition = target;
    this.targetPosition = this.originPosition;
    this.style = prop || {};
    this.far = 0.02;
    this.near = 0.01;
    this.fov = this.style.fov || 4;
    this.color = this.style.color || Cesium.Color.CYAN.withAlpha(0.4);
    this.outlineColor = this.style.outlineColor || Cesium.Color.YELLOW.withAlpha(0.5);
    this.createFrusum();
  }
  function traverse(value, source, target) {
    call(this, traverse);
    this.viewer = value;
    this.originPosition = source;
    this.targetPosition = this.originPosition;
    this.style = target || {};
    this.bottomRadius = this.style.bottomRadius || 18E3;
    this.color = this.style.color || Cesium.Color.RED.withAlpha(0.5);
    this.addCone();
  }
  function animate(value, target, params) {
    call(this, animate);
    this.viewer = value;
    this.position = target;
    params = params || {};
    target = Cesium.Cartographic.fromCartesian(target);
    this.far = params.far || 1.5 * target.height;
    this.near = 0.01;
    this.angle1 = params.angle1 || 20;
    this.angle2 = params.angle2 || 20;
    this.heading = params.heading || 0;
    this.pitch = params.pitch || -180;
    this.roll = params.roll || 0;
    this.color = params.color || Cesium.Color.CYAN.withAlpha(0.4);
    this.modelUrl = params.modelUrl;
    this.scale = params.scale || 60;
    this.outlineColor = params.outlineColor || Cesium.Color.YELLOW.withAlpha(0.5);
    this.addSatellite();
    this.createFrusum();
  }
  function size(value, obj, type) {
    call(this, size);
    this.viewer = value;
    this.position = obj;
    this.style = type || {};
    this.style.heading = this.style.heading || 0;
    this.style.horizontalAngle = this.style.horizontalAngle || 45;
    if (90 < this.style.horizontalAngle) {
      this.style.horizontalAngle = 90;
    }
    if (this.style.horizontalAngle < 20) {
      this.style.horizontalAngle = 20;
    }
    this.style.verticalAngle = this.style.verticalAngle || 10;
    if (50 < this.style.verticalAngle) {
      this.style.verticalAngle = 50;
    }
    if (this.style.verticalAngle < 5) {
      this.style.verticalAngle = 5;
    }
    this.style.hAngle = this.style.horizontalAngle / 2;
    this.style.vAngle = this.style.verticalAngle;
    this.hpr = new Cesium.HeadingPitchRoll(Cesium.Math.toRadians(this.style.heading), 0, 0);
    this.addEllipsoid();
    this.addScan();
  }
  function Component(name, obj, type) {
    call(this, Component);
    this.viewer = name;
    this.position = obj;
    this.style = type || {};
    this.style.heading = this.style.heading || 0;
    this.style.horizontalAngle = this.style.horizontalAngle || 45;
    if (90 < this.style.horizontalAngle) {
      this.style.horizontalAngle = 90;
    }
    if (this.style.horizontalAngle < 20) {
      this.style.horizontalAngle = 20;
    }
    this.style.bankAngle = this.style.bankAngle || 10;
    if (45 < this.style.bankAngle) {
      this.style.bankAngle = 45;
    }
    if (this.style.bankAngle < -45) {
      this.style.bankAngle = -45;
    }
    this.style.verticalAngle = this.style.verticalAngle || 10;
    if (50 < this.style.verticalAngle) {
      this.style.verticalAngle = 50;
    }
    if (this.style.verticalAngle < 5) {
      this.style.verticalAngle = 5;
    }
    this.style.hAngle = this.style.horizontalAngle / 2;
    this.style.vAngle = this.style.verticalAngle / 2;
    this.style.speed = this.style.speed || 5;
    this.hpr = new Cesium["HeadingPitchRoll"](Cesium.Math.toRadians(this.style.heading), 0, 0);
    this.addEllipsoid();
    this.addScan();
  }
  function process(value, target, properties) {
    call(this, process);
    this.viewer = value;
    this.property = target;
    this.style = properties || {};
    this.orientation = new Cesium.VelocityOrientationProperty(target);
    this.style.heading = this.style.heading || 0;
    this.style.horizontalAngle = this.style.horizontalAngle || 45;
    if (90 < this.style.horizontalAngle) {
      this.style.horizontalAngle = 90;
    }
    if (this.style.horizontalAngle < 20) {
      this.style.horizontalAngle = 20;
    }
    this.style.verticalAngle = this.style.verticalAngle || 10;
    if (50 < this.style.verticalAngle) {
      this.style.verticalAngle = 50;
    }
    if (this.style.verticalAngle < 5) {
      this.style.verticalAngle = 5;
    }
    this.style.hAngle = this.style.horizontalAngle / 2;
    this.style.vAngle = this.style.verticalAngle;
    this.addEllipsoid();
  }
  function animation(value, options, source) {
    call(this, animation);
    this.viewer = value;
    this.position = options;
    var target = Cesium.Cartographic.fromCartesian(options);
    value = Cesium.Math.toDegrees(target.longitude);
    options = Cesium.Math.toDegrees(target.latitude);
    source = source || {};
    this.height = source.height || target.height;
    this.bottomRadius = source.bottomRadius || 0.3 * this.height;
    this.materialType = source.materialType || 1;
    this.lng = value;
    this.lat = options;
    this.addCylinder();
  }
  function CustomSensorVolume(options) {
    var clone = this;
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    this.show = defaultValue(options.show, true);
    this.slice = defaultValue(options.slice, 32);
    this.modelMatrix = Matrix4.clone(options.modelMatrix, new Matrix4);
    this._modelMatrix = new Matrix4;
    this._computedModelMatrix = new Matrix4;
    this._computedScanPlaneModelMatrix = new Matrix4;
    this.radius = defaultValue(options.radius, Number.POSITIVE_INFINITY);
    this._radius = void 0;
    this.xHalfAngle = Cesium.Math.toRadians(defaultValue(options.xHalfAngle, 10));
    this._xHalfAngle = void 0;
    this.yHalfAngle = Cesium.Math.toRadians(defaultValue(options.yHalfAngle, 10));
    this._yHalfAngle = void 0;
    this.lineColor = defaultValue(options.lineColor, requestURL.WHITE);
    this.showSectorLines = defaultValue(options.showSectorLines, true);
    this.showSectorSegmentLines = defaultValue(options.showSectorSegmentLines, true);
    this.showLateralSurfaces = defaultValue(options.showLateralSurfaces, true);
    this.material = defined(options.material) ? options.material : Material.fromType(Material.ColorType);
    this._material = void 0;
    this._translucent = void 0;
    this.lateralSurfaceMaterial = defined(options.lateralSurfaceMaterial) ? options.lateralSurfaceMaterial : Material.fromType(Material.ColorType);
    this._lateralSurfaceMaterial = void 0;
    this._lateralSurfaceTranslucent = void 0;
    this.showDomeSurfaces = defaultValue(options.showDomeSurfaces, true);
    this.domeSurfaceMaterial = defined(options.domeSurfaceMaterial) ? options.domeSurfaceMaterial : Material.fromType(Material.ColorType);
    this._domeSurfaceMaterial = void 0;
    this.showDomeLines = defaultValue(options.showDomeLines, true);
    this.showIntersection = defaultValue(options.showIntersection, true);
    this.intersectionColor = defaultValue(options.intersectionColor, requestURL.WHITE);
    this.intersectionWidth = defaultValue(options.intersectionWidth, 5);
    this.showThroughEllipsoid = defaultValue(options.showThroughEllipsoid, false);
    this._showThroughEllipsoid = void 0;
    this.showScanPlane = defaultValue(options.showScanPlane, true);
    this.scanPlaneColor = defaultValue(options.scanPlaneColor, requestURL.WHITE);
    this.scanPlaneMode = defaultValue(options.scanPlaneMode, "horizontal");
    this.scanPlaneRate = defaultValue(options.scanPlaneRate, 10);
    this._scanePlaneXHalfAngle = 0;
    this._scanePlaneYHalfAngle = 0;
    this._time = JulianDate.now();
    this._boundingSphere = new BoundingSphere;
    this._boundingSphereWC = new BoundingSphere;
    this._sectorFrontCommand = new DrawCommand({
      "owner" : this,
      "primitiveType" : PrimitiveType.TRIANGLES,
      "boundingVolume" : this._boundingSphereWC
    });
    this._sectorBackCommand = new DrawCommand({
      "owner" : this,
      "primitiveType" : PrimitiveType.TRIANGLES,
      "boundingVolume" : this._boundingSphereWC
    });
    this._sectorVA = void 0;
    this._sectorLineCommand = new DrawCommand({
      "owner" : this,
      "primitiveType" : PrimitiveType.LINES,
      "boundingVolume" : this._boundingSphereWC
    });
    this._sectorLineVA = void 0;
    this._sectorSegmentLineCommand = new DrawCommand({
      "owner" : this,
      "primitiveType" : PrimitiveType.LINES,
      "boundingVolume" : this._boundingSphereWC
    });
    this._sectorSegmentLineVA = void 0;
    this._domeFrontCommand = new DrawCommand({
      "owner" : this,
      "primitiveType" : PrimitiveType.TRIANGLES,
      "boundingVolume" : this._boundingSphereWC
    });
    this._domeBackCommand = new DrawCommand({
      "owner" : this,
      "primitiveType" : PrimitiveType.TRIANGLES,
      "boundingVolume" : this._boundingSphereWC
    });
    this._domeVA = void 0;
    this._domeLineCommand = new DrawCommand({
      "owner" : this,
      "primitiveType" : PrimitiveType.LINES,
      "boundingVolume" : this._boundingSphereWC
    });
    this._domeLineVA = void 0;
    this._scanPlaneFrontCommand = new DrawCommand({
      "owner" : this,
      "primitiveType" : PrimitiveType.TRIANGLES,
      "boundingVolume" : this._boundingSphereWC
    });
    this._scanPlaneBackCommand = new DrawCommand({
      "owner" : this,
      "primitiveType" : PrimitiveType.TRIANGLES,
      "boundingVolume" : this._boundingSphereWC
    });
    this._scanRadialCommand = void 0;
    this._colorCommands = [];
    this._frontFaceRS = void 0;
    this._backFaceRS = void 0;
    this._sp = void 0;
    this._uniforms = {
      "u_type" : function() {
        return 0;
      },
      "u_xHalfAngle" : function() {
        var convertName = hahaha;
        return clone[convertName(1647)];
      },
      "u_yHalfAngle" : function() {
        return clone.yHalfAngle;
      },
      "u_radius" : function() {
        var convertName = hahaha;
        return clone[convertName(2423)];
      },
      "u_showThroughEllipsoid" : function() {
        return clone.showThroughEllipsoid;
      },
      "u_showIntersection" : function() {
        var convertName = hahaha;
        return clone[convertName(1947)];
      },
      "u_intersectionColor" : function() {
        var convertName = hahaha;
        return clone[convertName(2952)];
      },
      "u_intersectionWidth" : function() {
        var convertName = hahaha;
        return clone[convertName(2692)];
      },
      "u_normalDirection" : function() {
        return 1;
      },
      "u_lineColor" : function() {
        return clone.lineColor;
      }
    };
    this._scanUniforms = {
      "u_xHalfAngle" : function() {
        var convertName = hahaha;
        return clone[convertName(1294)];
      },
      "u_yHalfAngle" : function() {
        var convertName = hahaha;
        return clone[convertName(667)];
      },
      "u_radius" : function() {
        return clone.radius;
      },
      "u_color" : function() {
        return clone.scanPlaneColor;
      },
      "u_showThroughEllipsoid" : function() {
        var convertName = hahaha;
        return clone[convertName(671)];
      },
      "u_showIntersection" : function() {
        var convertName = hahaha;
        return clone[convertName(1947)];
      },
      "u_intersectionColor" : function() {
        var convertName = hahaha;
        return clone[convertName(2952)];
      },
      "u_intersectionWidth" : function() {
        var convertName = hahaha;
        return clone[convertName(2692)];
      },
      "u_normalDirection" : function() {
        return 1;
      },
      "u_lineColor" : function() {
        var convertName = hahaha;
        return clone[convertName(1204)];
      }
    };
  }
  function zoom(val, x, v) {
    var n = val.slice;
    var b = round(v);
    val = abs(v);
    v = round(x);
    x = abs(x);
    var lineStart = parseInt(v * val);
    var duration = parseInt(b * x);
    var solutions = [];
    var hits = 0;
    for (; hits < n; hits++) {
      var end = 2 * lineStart * hits / (n - 1) - lineStart;
      solutions.push(new Cartesian3(0, sin(end), round(end)));
    }
    var positions = [];
    var i = 0;
    for (; i < n; i++) {
      var delta = 2 * duration * i / (n - 1) - duration;
      positions.push(new Cartesian3(sin(delta), 0, round(delta)));
    }
    return {
      "zoy" : solutions,
      "zox" : positions
    };
  }
  function createVertexArray(context, vertices) {
    var numCurves = vertices.length - 1;
    var positions = new Float32Array(9 * numCurves);
    var index = 0;
    var j = 0;
    for (; j < numCurves; j++) {
      positions[index++] = 0;
      positions[index++] = 0;
      positions[index++] = 0;
      positions[index++] = vertices[j].x;
      positions[index++] = vertices[j].y;
      positions[index++] = vertices[j].z;
      positions[index++] = vertices[j + 1].x;
      positions[index++] = vertices[j + 1].y;
      positions[index++] = vertices[j + 1].z;
    }
    var vertexBuffer = Buffer.createVertexBuffer({
      "context" : context,
      "typedArray" : positions,
      "usage" : BufferUsage.STATIC_DRAW
    });
    var strideInBytes = 3 * Float32Array.BYTES_PER_ELEMENT;
    strideInBytes = [{
      "index" : attributeLocations.position,
      "vertexBuffer" : vertexBuffer,
      "componentsPerAttribute" : 3,
      "componentDatatype" : ComponentDatatype.FLOAT,
      "offsetInBytes" : 0,
      "strideInBytes" : strideInBytes
    }];
    return new VertexArray({
      "context" : context,
      "attributes" : strideInBytes
    });
  }
  function createCommandLists(lobj, drawCommand, command, commands, context, renderState, vertexArray, frameState, modelMatrix, renderPass, uniformMap, zoomAware) {
    if (renderPass && command) {
      command.vertexArray = vertexArray;
      command.renderState = context;
      command.shaderProgram = renderState;
      command.uniformMap = combine(frameState, lobj._material._uniforms);
      command.uniformMap.u_normalDirection = function() {
        return -1;
      };
      command.pass = uniformMap;
      command.modelMatrix = modelMatrix;
      lobj._colorCommands.push(command);
    }
    drawCommand.vertexArray = vertexArray;
    drawCommand.renderState = commands;
    drawCommand.shaderProgram = renderState;
    drawCommand.uniformMap = combine(frameState, lobj._material._uniforms);
    if (zoomAware) {
      drawCommand.uniformMap.u_type = function() {
        return 1;
      };
    }
    drawCommand.pass = uniformMap;
    drawCommand.modelMatrix = modelMatrix;
    lobj._colorCommands.push(drawCommand);
  }
  function last(value, target, options) {
    call(this, last);
    this.viewer = value;
    this.position = target;
    this.options = options;
    this.initPrimitive();
  }
  function line(value, target, s) {
    call(this, line);
    if (target) {
      this.viewer = value;
      this.style = s;
      this.position = target;
      this.addModels();
    }
  }
  function object(value, obj, prop) {
    call(this, object);
    this.viewer = value;
    this.position = obj;
    this.style = prop || {};
    this.addModel();
  }
  function model(value) {
    call(this, model);
    this.viewer = value;
    this.initEvents();
  }
  function left(value, target) {
    call(this, left);
    this.viewer = value;
    this.gltfPlotLayer = target;
    this.registerMouseEvents();
  }
  function _update(v, data) {
    call(this, _update);
    this.viewer = v;
    this.properties = data.properties;
    this.coordinates = data.geometry.coordinates;
    this.properties.plotType = "Gltf";
    this.properties.plotName = "Gltf";
    this.style = this.properties.style;
    data = new Cesium["HeadingPitchRoll"](Cesium.Math.toRadians(this.style.heading), Cesium.Math.toRadians(0), Cesium.Math.toRadians(0));
    this.position = Cesium.Cartesian3.fromDegrees(this.coordinates[0], this.coordinates[1], this.coordinates[2]);
    this.orientation = Cesium.Transforms.headingPitchRollQuaternion(this.position, data);
    this.addGltfEntity();
  }
  function ContributorList(value) {
    return call(this, ContributorList), value = getPrototypeOf(this, (ContributorList.__proto__ || Object.getPrototypeOf(ContributorList)).call(this, value)), value.viewer.selectedEntityChanged.addEventListener(value.selectedEntityChanged, value), value.selectedPlotChanged = new Cesium.Event, value;
  }
  function offset(target, value, obj, n) {
    call(this, offset);
    this.viewer = target;
    this.degreesArray = value;
    this.height = obj;
    this.style = n || {};
    this.init();
  }
  function u(name) {
    call(this, u);
    this.viewer = name;
    this.viewer.cesiumWidget.screenSpaceEventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);
    this.initEvents();
  }
  function pattern(value) {
    call(this, pattern);
    this.viewer = value;
    this.viewer.cesiumWidget.screenSpaceEventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);
    this.initEvents();
  }
  function cycle(elems, options) {
    call(this, cycle);
    this.viewer = elems;
    this.viewPosition = options.viewPosition;
    this.viewPositionEnd = options.viewPositionEnd;
    this.viewDistance = this.getDistance();
    this.viewHeading = this.getViewHeading();
    this.viewPitch = this.getViewPitch();
    this.horizontalViewAngle = options.horizontalViewAngle || 90;
    this.verticalViewAngle = options.verticalViewAngle || 60;
    this.drawSketch();
    this.drawFrustumOutline();
  }
  function setValue(value, options) {
    call(this, setValue);
    this.viewer = value;
    this.viewPosition = options.viewPosition;
    this.viewPositionEnd = options.viewPositionEnd;
    this.viewDistance = options.viewDistance;
    console.log(options.viewHeading);
    this.viewHeading = options.viewHeading;
    if (this.viewHeading < 0) {
      this.viewHeading += 360;
    }
    this.viewPitch = options.viewPitch;
    this.horizontalViewAngle = options.horizontalViewAngle || 90;
    this.verticalViewAngle = options.verticalViewAngle || 90;
    this.visibleAreaColor = options.visibleAreaColor || Cesium.Color.LIME;
    this.invisibleAreaColor = options.invisibleAreaColor || Cesium.Color.RED;
    this.enabled = "boolean" != typeof options.enabled || options.enabled;
    this.softShadows = "boolean" != typeof options.softShadows || options.softShadows;
    this.size = options.size || 2048;
    this.add();
  }
  function response(value) {
    call(this, response);
    this.viewer = value;
    this.viewer.cesiumWidget.screenSpaceEventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);
    this.initEvents();
  }
  function Example(value, options) {
    call(this, Example);
    this.viewer = value;
    this.options = options;
    this.viewer.terrainShadows = Cesium.ShadowMode.ENABLED;
    this.cameraPosition = options.cameraPosition;
    this.viewPosition = options.viewPosition;
    this._horizontalAngle = Cesium.defaultValue(options.horizontalAngle, 60);
    this._verticalAngle = Cesium.defaultValue(options.verticalAngle, 30);
    this._visibleAreaColor = Cesium.defaultValue(options.visibleAreaColor, new Cesium["Color"](0, 1, 0));
    this._hiddenAreaColor = Cesium.defaultValue(options.hiddenAreaColor, new Cesium["Color"](1, 0, 0));
    this._alpha = Cesium.defaultValue(options.alpha, 0.5);
    this._distance = Cesium.defaultValue(options.distance, 100);
    this._maximumDistance = Cesium.defaultValue(options.maximumDistance, 5E3);
    this._offsetHeight = Cesium.defaultValue(options.offsetHeight, 1.5);
    this._debugFrustum = Cesium.defaultValue(options.showFrustum, true);
    this._show = Cesium.defaultValue(options.show, true);
    this.init();
  }
  function Model(value, type) {
    call(this, Model);
    this.viewer = value;
    this.style = Cesium.defaultValue(type, {});
    this.tjxWidth = Cesium.defaultValue(this.style.tjxWidth, 2);
    this.strokeType = Cesium.defaultValue(this.style.strokeType, new Cesium["Cartesian3"](true, false, false));
    this.tjxColor = Cesium.defaultValue(this.style.tjxColor, new Cesium.Color(1, 0, 0));
    this.bjColor = Cesium.defaultValue(this.style.bjColor, new Cesium["Color"](0, 0, 1));
    this.mbDis = Cesium.defaultValue(this.style.mbDis, 500);
    this.addPostProcess();
  }
  function render(value) {
    var options = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {
      "autoMaxMin" : true,
      "data" : []
    };
    var x = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : [-180, -90, 180, 90];
    var streamSize2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : {
      "enabled" : true,
      "min" : 6375E3,
      "max" : 1E7,
      "maxRadius" : 40,
      "minRadius" : 10
    };
    var rpm_traffic = this;
    var config = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : {};
    var settings = 5 < arguments.length && void 0 !== arguments[5] ? arguments[5] : {
      "totalArea" : 1036800,
      "autoResize" : true
    };
    if (call(this, render), "undefined" != typeof window) {
      this.viewer = value;
      this.bbox = x;
      this.autoRadiusConfig = streamSize2;
      this.max = 1;
      this.min = 0.01;
      var pos = clone(x, 4);
      var p = pos[0];
      value = pos[1];
      x = pos[2];
      pos = pos[3];
      value = pos - value;
      x = x - p;
      if (this.boxMeta = {
        "top" : pos,
        "left" : p,
        "height" : value,
        "width" : x
      }, settings.autoResize) {
        if (!settings.totalArea) {
          throw "specify totalArea if auto resize";
        }
        p = Math.floor(Math.sqrt(value * settings.totalArea));
        value = Math.floor(p * x / value);
        this.canvasConfig = assign({}, settings, {
          "width" : value,
          "height" : p
        });
      } else {
        if (!settings.width || !settings.height) {
          throw "specify width and height if not auto resize";
        }
        this.canvasConfig = settings;
      }
      config = assign({}, config);
      if (!config.container) {
        this.mountPoint = this.newDiv({
          "position" : "absolute",
          "top" : 0,
          "left" : 0,
          "z-index" : -100,
          "overflow" : "hidden",
          "width" : 0,
          "height" : 0
        }, document.body);
        config.container = this.newDiv({
          "width" : this.canvasConfig.width,
          "height" : this.canvasConfig.height
        }, this.mountPoint);
      }
      this.heatmapConfig = config;
      this.heatmap = h337.create(config);
      config = void 0;
      if (!(config = Array.isArray(options) ? {
        "autoMaxMin" : true,
        "data" : options
      } : assign({}, options)).autoMaxMin) {
        if (!config.min || !config.max) {
          throw "need max and min when not auto";
        }
        this.min = config.min;
        this.max = config.max;
      }
      options = config.data.map(function(backboneScreen) {
        var now = hahaha;
        return rpm_traffic[now(2246)](backboneScreen.z), rpm_traffic[now(2821)](backboneScreen);
      });
      delete config.data;
      this.dataConfig = config;
      this.data = options;
      options = {
        "max" : this.max,
        "min" : this.min,
        "data" : options
      };
      this.heatmap.setData(options);
      this.updateCesium(streamSize2.enabled);
      this.cameraMoveEnd = function() {
        var now = hahaha;
        return rpm_traffic[now(1732)](true);
      };
      if (streamSize2.enabled) {
        this.viewer.camera.moveEnd.addEventListener(this.cameraMoveEnd);
      }
      this.rectangleEntity = this.viewer.entities.add({
        "polygon" : {
          "material" : this.heatmap.getDataURL(),
          "hierarchy" : Cesium.Cartesian3.fromDegreesArray(this.recToPolygon())
        }
      });
    }
  }
  function verify(value, target, data) {
    call(this, verify);
    this.viewer = value;
    this.tileset = target;
    this.params = data || {
      "scale" : 1,
      "longitude" : 0,
      "latitude" : 0,
      "height" : 0,
      "rx" : 0,
      "ry" : 0,
      "rz" : 0
    };
    data = Cesium.Cartographic.fromCartesian(this.tileset.boundingSphere.center);
    this.params.longitude = Cesium.Math.toDegrees(data.longitude);
    this.params.latitude = Cesium.Math.toDegrees(data.latitude);
    this.params.height = data.height;
    this.highlightAxis = {};
    this.activate();
  }
  function Server(name) {
    call(this, Server);
    this.viewer = name;
  }
  function results(value, target) {
    call(this, results);
    this.viewer = value;
    this.positions = target;
    this.primitives = [];
    this.invisibleColor = new Cesium.Color(0.25, 0.25, 0.25, 1);
  }
  function destroy(value, target) {
    call(this, destroy);
    this.viewer = value;
    this.style = target;
    this.initEvents();
  }
  function timeout(value, data, target) {
    call(this, timeout);
    this.viewer = value;
    this.positions = data;
    this.style = target || {};
    this.RoamEndEvent = new Cesium.Event;
  }
  function move(value, source, target) {
    call(this, move);
    this.viewer = value;
    this.positions = source;
    this.style = target || {};
  }
  function Class(name, obj, data) {
    call(this, Class);
    this.viewer = name;
    this.position = obj;
    this.videoInfo = data;
    this.init();
  }
  function position(value, obj, type) {
    call(this, position);
    this.viewer = value;
    this.position = obj;
    this.videoInfo = type;
    this.isDestroy = false;
    this.init();
  }
  function max(value, obj, data) {
    call(this, max);
    this.viewer = value;
    this.position = obj;
    this.videoInfo = data;
    this.isDestroy = false;
    this.init();
  }
  function Matrix2D() {
    this.PI = 3.141592653589793;
    this.a = 6378137;
    this.b = 6356752.3142;
    this.f = (this.a - this.b) / this.a;
    this.e_sq = this.f * (2 - this.f);
    this.ee = 0.00669437999013;
    this.WGSF = 1 / 298.257223563;
    this.WGSe2 = this.WGSF * (2 - this.WGSF);
    this.WGSa = 6378137;
    this.EPSILON = 1e-12;
  }
  function reviewFeature(value, feature) {
    call(this, reviewFeature);
    this.viewer = value;
    this.properties = feature.properties;
    this.properties.plotBase = "VideoWallPlot";
    this.geometry = feature.geometry;
    this.coordinates = feature.geometry.coordinates;
    this.generatePositions();
  }
  function LeanKitNotifier(client, self) {
    return call(this, LeanKitNotifier), self = getPrototypeOf(this, (LeanKitNotifier.__proto__ || Object.getPrototypeOf(LeanKitNotifier)).call(this, client, self)), self.properties.plotName = "\u7acb\u4f53\u89c6\u9891\u5899", self.properties.plotType = T.WALL, self.fixPositionCount = 2, self.style = self.properties.style || self.getDefaultStyle(), self.properties.style = self.style, self.createEntity(), self.playVideo(), self;
  }
  function AudioStyleControls(base) {
    return call(this, AudioStyleControls), base = getPrototypeOf(this, (AudioStyleControls.__proto__ || Object.getPrototypeOf(AudioStyleControls)).call(this, base)), base.initEvent(), base.selectedPlotChanged = new Cesium.Event, base;
  }
  function iframe(value, target) {
    call(this, iframe);
    this.viewer = value;
    this.textMapPlotLayer = target;
    this.initEventHandler();
  }
  function d(value) {
    call(this, d);
    this.viewer = value;
    this.viewer.cesiumWidget.screenSpaceEventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);
    this.initEvents();
  }
  function _getMatrixAsString() {
    this.PI = 3.141592653589793;
    this.a = 6378137;
    this.b = 6356752.3142;
    this.f = (this.a - this.b) / this.a;
    this.e_sq = this.f * (2 - this.f);
    this.ee = 0.00669437999013;
    this.WGSF = 1 / 298.257223563;
    this.WGSe2 = this.WGSF * (2 - this.WGSF);
    this.WGSa = 6378137;
    this.EPSILON = 1e-12;
  }
  function Camera(name, data, options) {
    call(this, Camera);
    this.viewer = name;
    this.position = data;
    this.videoElement = options.videoElement;
    this.rotation = options.rotation || {
      "heading" : 0,
      "pitch" : 0,
      "roll" : 0
    };
    this.fov = options.fov || 10;
    this.near = options.near || 0.1;
    this.far = options.far || 100;
    this.aspectRatio = options.aspectRatio || 1;
    this.debugFrustum = Cesium.defaultValue(options.debugFrustum, true);
    this.stRotation = options.stRotation || 0;
    this.createVideoFrustum(this.position, this.videoElement);
    this.createVideoPolygon();
  }
  function status(value, target, config) {
    call(this, status);
    this.viewer = value;
    config = config || {};
    this.wallHeight = config.wallHeight || 200;
    this.speed = config.speed || 0.004;
    this.wallColor = config.wallColor || Cesium.Color.RED;
    this.setPositions(target);
    this.createEntity();
  }
  function Color(color) {
    call(this, Color);
    this._definitionChanged = new Cesium.Event;
    this._color = void 0;
    this._colorSubscription = void 0;
    this.color = color;
  }
  function f(value) {
    call(this, f);
    this._definitionChanged = new Cesium.Event;
    this._color = void 0;
    this._colorSubscription = void 0;
    value = value || [{
      "stop" : 0,
      "color" : "rgba(238,103,98,0.5)"
    }, {
      "stop" : 1,
      "color" : "rgba(32,153,230,0.5)"
    }];
    this.image = function(trytes) {
      var hcanvas = document.createElement("canvas");
      hcanvas.height = 100;
      hcanvas.width = 200;
      var ctx = hcanvas.getContext("2d");
      var parBgColor = ctx.createLinearGradient(200, 50, 0, 50);
      return trytes.forEach(function(myPreferences) {
        var getPreferenceKey = hahaha;
        parBgColor[getPreferenceKey(1506)](myPreferences[getPreferenceKey(1682)], myPreferences.color);
      }), ctx.fillStyle = parBgColor, ctx.fillRect(0, 0, 200, 100), ctx.restore(), hcanvas.toDataURL("image/png").replace("image/png", "image/octet-stream");
    }(value);
    this.color = Cesium.Color.RED.withAlpha(0.2);
  }
  function PolylineGlowMaterialProperty(options) {
    call(this, PolylineGlowMaterialProperty);
    this._definitionChanged = new Cesium.Event;
    this._color = void 0;
    this._colorSubscription = void 0;
    this.color = options.color;
    this.duration = options.duration;
    this._time = (new Date).getTime();
  }
  function fn(options) {
    call(this, fn);
    this._definitionChanged = new Cesium.Event;
    this._color = void 0;
    this._colorSubscription = void 0;
    this.color = options.color;
    this.duration = options.duration;
    this.count = options.count;
    this._time = (new Date).getTime();
  }
  function action(value, className, config) {
    if (call(this, action), this.viewer = value, config = config || {}, this.radius = config.radius || 100, this.wallHeight = config.wallHeight || 200, config.materialType = config.materialType || 1, this.generatePositions(className), config.materialType == user_info.LINEFLOW) {
      return this.flowWallMaterial = res.createMaterial(config.materialType, {
        "color" : config.wallColor || Cesium.Color.RED,
        "duration" : config.duration || 1E3
      }), this.addFlowWall(), this.wallMaterial = res.createMaterial(user_info.BASEGRADIENT, {
        "color" : config.wallColor || Cesium.Color.RED
      }), void this.addWall();
    }
    this.wallMaterial = res.createMaterial(config.materialType, {
      "color" : config.wallColor || Cesium.Color.RED,
      "duration" : config.duration || 1E3,
      "count" : config.count || 2,
      "colorStops" : config.colorStops
    });
    this.addWall();
  }
  function success(value, type, config) {
    call(this, success);
    this.viewer = value;
    config = config || {};
    this.wallHeight = config.wallHeight || 200;
    this.radius = config.radius || 100;
    this.wallMaterial = res.createMaterial(user_info.BASEGRADIENT, {
      "color" : config.wallColor || Cesium.Color.RED
    });
    this.speed = config.speed || 5;
    this.init(type);
    this.createEntity();
  }
  function _init(value, config) {
    call(this, _init);
    this._position = value;
    this.primitive = void 0;
    this._height = config.wallHeight;
    this.radius = config.radius;
    this._slices = config.slices || 280;
    this._speed = config.speed || 20;
    this.currentHeight = config.wallHeight;
    this.currentRadius = config.minRadius || 0.1;
    this.minRadius = config.minRadius || 0.1;
    this.minHeight = config.minHeight || 1;
    this.color = config.wallColor || Cesium.Color.YELLOW;
    this.baseHeight = Cesium.Cartographic.fromCartesian(value).height;
  }
  function _record(value, target, config) {
    if (call(this, _record), this.viewer = value, config = config || {}, this.wallHeight = config.wallHeight || 200, config.materialType = config.materialType || 1, this.setPositions(target), config.materialType == user_info.LINEFLOW) {
      return this.flowWallMaterial = res.createMaterial(config.materialType, {
        "color" : config.wallColor || Cesium.Color.RED,
        "duration" : config.duration || 1E3
      }), this.addFlowWall(), this.wallMaterial = res.createMaterial(user_info.BASEGRADIENT, {
        "color" : config.wallColor || Cesium.Color.RED
      }), void this.addWall();
    }
    this.wallMaterial = res.createMaterial(config.materialType, {
      "color" : config.wallColor || Cesium.Color.RED,
      "duration" : config.duration || 1E3,
      "count" : config.count || 2,
      "colorStops" : config.colorStops
    });
    this.addWall();
  }
  function Graph(value, target, config) {
    if (call(this, Graph), this.viewer = value, this.radius = config.radius || 100, this.wallHeight = config.wallHeight || 200, config.materialType = config.materialType || 1, this.edgeCount = config.edgeCount || 5, config.edgeCount < 3 && (this.edgeCount = 3), 12 < config.edgeCount && (this.edgeCount = 12), this.generatePositions(target), config.materialType == user_info.LINEFLOW) {
      return this.flowWallMaterial = res.createMaterial(config.materialType, {
        "color" : config.wallColor || Cesium.Color.RED,
        "duration" : config.duration || 1E3
      }), this.addFlowWall(), this.wallMaterial = res.createMaterial(user_info.BASEGRADIENT, {
        "color" : config.wallColor || Cesium.Color.RED
      }), void this.addWall();
    }
    this.wallMaterial = res.createMaterial(config.materialType, {
      "color" : config.wallColor || Cesium.Color.RED,
      "duration" : config.duration || 1E3,
      "count" : config.count || 2,
      "colorStops" : config.colorStops
    });
    this.addWall();
  }
  function renderFunction(value, item, config) {
    call(this, renderFunction);
    this.viewer = value;
    config = config || {};
    this.wallHeight = config.wallHeight || 200;
    this.radius = config.radius || 100;
    this.wallMaterial = res.createMaterial(user_info.BASEGRADIENT, {
      "color" : config.wallColor || Cesium.Color.RED
    });
    this.edgeCount = config.edgeCount || 5;
    if (config.edgeCount < 3) {
      this.edgeCount = 3;
    }
    if (12 < config.edgeCount) {
      this.edgeCount = 12;
    }
    this.init(item);
    this.createEntity();
  }
  function instance(value, type, options) {
    call(this, instance);
    this.viewer = value;
    options = options || {};
    this.wallHeight = options.wallHeight || 200;
    options.direction = options.direction || 1;
    options.speed = options.speed || 600;
    this.height = Cesium.defaultValue(options.wallHeight, 500);
    this.color = Cesium.defaultValue(options.color, Cesium.Color.YELLOW);
    this.speed = Cesium.defaultValue(options.speed, 600);
    this.direction = Cesium.defaultValue(options.direction, -1);
    this.addPrimitive(type);
  }
  function Base(value, target, options) {
    call(this, Base);
    this.viewer = value;
    this.positions = target;
    this.options = options || {};
    this.increment = this.options.speed / 1E3;
    this.StartEvent = new Cesium.Event;
    this.EndEvent = new Cesium.Event;
    this.HeightChangeEvent = new Cesium.Event;
  }
  function component(value, obj, name) {
    call(this, component);
    this.viewer = value;
    this.position = obj;
    this.style = name || this.getDefaultStyle();
    this.init();
  }
  function route(name, options) {
    return call(this, route), this.positions = name, this.options = options, this.createPrimitive();
  }
  function attach(name, data, options) {
    call(this, attach);
    this.viewer = name;
    this.positions = data;
    this.style = options || {};
    this.image = Cesium.defaultValue(options.image, null);
    this.flipY = Cesium.defaultValue(options.flipY, false);
    this.width = Cesium.defaultValue(options.width, 10);
    this.height = Cesium.defaultValue(options.height, 0);
    this.alpha = Cesium.defaultValue(options.alpha, 0.5);
    this.speed = Cesium.defaultValue(options.speed, 1);
    this.move = Cesium.defaultValue(options.move, true);
    this.moveDir = Cesium.defaultValue(options.moveDir, true);
    this.moveVar = Cesium.defaultValue(options.moveVar, new Cesium.Cartesian3(50, 1, 100));
    this.resetPos();
  }
  function _possibleConstructorReturn(self, value) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return !value || "object" !== (void 0 === value ? "undefined" : loadImage(value)) && "function" != typeof value ? self : value;
  }
  function watch(type, prop) {
    var j = 0;
    for (; j < prop.length; j++) {
      var value = prop[j];
      value.enumerable = value.enumerable || false;
      value.configurable = true;
      if ("value" in value) {
        value.writable = true;
      }
      Object.defineProperty(type, value.key, value);
    }
  }
  function _get(obj, name, callback) {
    if (null === obj) {
      obj = Function.prototype;
    }
    var output = Object.getOwnPropertyDescriptor(obj, name);
    if (void 0 !== output) {
      if ("value" in output) {
        return output.value;
      }
      return output = output.get, void 0 !== output ? output.call(callback) : void 0;
    }
    if (obj = Object.getPrototypeOf(obj), null !== obj) {
      return _get(obj, name, callback);
    }
  }
  function Table(model, name, options, chart) {
    !function(value) {
      if (!(value instanceof Table)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }(this);
    var self = _possibleConstructorReturn(this, (Table.__proto__ || Object.getPrototypeOf(Table)).call(this, model, name, options));
    return args ? (self.map = model, self.scene = model.scene, self.dataSet = name, options = options || {}, self.init(options), self.argCheck(options), self.initDevicePixelRatio(), self.canvasLayer = chart, self.stopAniamation = false, self.animation = options.animation, self.clickEvent = self.clickEvent.bind(self), self.mousemoveEvent = self.mousemoveEvent.bind(self), self.bindEvent(), self) : _possibleConstructorReturn(self);
  }
  function defineProperties(o, props) {
    var i = 0;
    for (; i < props.length; i++) {
      var value = props[i];
      value.enumerable = value.enumerable || false;
      value.configurable = true;
      if ("value" in value) {
        value.writable = true;
      }
      Object.defineProperty(o, value.key, value);
    }
  }
  function run(config, options, callback, container) {
    publish(this, run);
    this.map = config;
    this.scene = config.scene;
    this.mapvBaseLayer = new Board(config, options, callback, this);
    this.mapVOptions = callback;
    this.initDevicePixelRatio();
    this.canvas = this._createCanvas();
    this.render = this.render.bind(this);
    if (container) {
      (this.container = container).appendChild(this.canvas);
    } else {
      this.container = config.container;
      this.addInnerContainer();
    }
    this.bindEvent();
    this._reset();
  }
  function right() {
    call(this, right);
  }
  function urlChanged(value, index) {
    call(this, urlChanged);
    if (isNaN(value)) {
      value = isNaN(value) ? 0 : value;
    }
    if (encode(value)) {
      value = parseFloat(value);
    }
    if (isNaN(index)) {
      index = isNaN(index) ? 0 : index;
    }
    if (encode(index)) {
      index = parseFloat(index);
    }
    this.lng = value;
    this.lat = index;
  }
  function encode(s) {
    return "string" == typeof s;
  }
  function expandmove(i, d) {
    call(this, expandmove);
    this.x = i || 0;
    this.y = d || 0;
  }
  function t() {
    return call(this, t), getPrototypeOf(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  function WebMercatorTilingScheme(options) {
    call(this, WebMercatorTilingScheme);
    var Rectangle = Cesium;
    var defaultValue = Rectangle.defaultValue;
    var sw = Rectangle.Ellipsoid;
    var ne = Rectangle.WebMercatorProjection;
    var Cartesian2 = Rectangle.Cartesian2;
    var rectangle = Rectangle.Cartographic;
    var CesiumMath = Rectangle.Math;
    Rectangle = Rectangle.Rectangle;
    options = options || {};
    this._ellipsoid = defaultValue(options.ellipsoid, sw.WGS84);
    this._projection = new ne(this._ellipsoid);
    var projection = new helpers;
    this._projection.project = function(position, value) {
      return value = value || {}, (value = options.toWGS84 ? (value = me.wgs84togcj02(CesiumMath.toDegrees(position.longitude), CesiumMath.toDegrees(position.latitude)), me.gcj02tobd09(value[0], value[1])) : me.gcj02tobd09(CesiumMath.toDegrees(position.longitude), CesiumMath.toDegrees(position.latitude)))[0] = Math.min(value[0], 180), value[0] = Math.max(value[0], -180), value[1] = Math.min(value[1], 74.000022), value[1] = Math.max(value[1], -71.988531), value = projection.lngLatToPoint(new Point(value[0], 
      value[1])), new Cartesian2(value.x, value.y);
    };
    this._projection.unproject = function(point, result) {
      return result = result || {}, (result = projection.mercatorToLngLat(new Point(point.x, point.y)))[0] = (result[0] + 180) % 360 - 180, result = options.toWGS84 ? (result = me.bd09togcj02(result.lng, result.lat), me.gcj02towgs84(result[0], result[1])) : me.bd09togcj02(result.lng, result.lat), new rectangle(Cesium.Math.toRadians(result[0]), Cesium.Math.toRadians(result[1]));
    };
    this._rectangleSouthwestInMeters = new Cartesian2(-20037726.37, -12474104.17);
    this._rectangleNortheastInMeters = new Cartesian2(20037726.37, 12474104.17);
    sw = this._projection.unproject(this._rectangleSouthwestInMeters);
    ne = this._projection.unproject(this._rectangleNortheastInMeters);
    this._rectangle = new Rectangle(sw.longitude, sw.latitude, ne.longitude, ne.latitude);
    this.resolutions = [];
    var i = 0;
    for (; i < 19; i++) {
      this.resolutions[i] = 256 * Math.pow(2, 18 - i);
    }
  }
  function expect(obj) {
    call(this, expect);
    var options = Cesium;
    var name = options.Resource;
    var defaultValue = options.defaultValue;
    var Name = options.Credit;
    var callback = options.when;
    options = options.Event;
    var url = obj.url;
    if (Cesium.defined(obj.layer)) {
      switch(obj.layer) {
        case "vec":
          url = "https://maponline1.bdimg.com/tile/?qt=vtile&x={x}&y={y}&z={z}&styles=pl&scaler=2&udt=&from=jsapi2_0";
          break;
        case "img_d":
          url = "http://shangetu1.map.bdimg.com/it/u=x={x};y={y};z={z};v=009;type=sate&fm=46";
          break;
        case "img_z":
          url = "http://online1.map.bdimg.com/tile/?qt=tile&x={x}&y={y}&z={z}&styles=" + (obj.bigfont ? "sh" : "sl") + "&v=020";
          break;
        case "custom":
          obj.customid = obj.customid || "midnight";
          url = "http://api1.map.bdimg.com/customimage/tile?&x={x}&y={y}&z={z}&scale=1&customid=" + obj.customid;
          break;
        case "time":
          url = "http://its.map.baidu.com:8002/traffic/TrafficTileService?x={x}&y={y}&level={z}&time=" + (new Date).getTime() + "&label=web2D&v=017";
      }
    }
    this._url = url;
    name = name.createIfNeeded(this._url);
    name.appendForwardSlash();
    this._ready = false;
    this._resource = name;
    this._tileDiscardPolicy = obj.tileDiscardPolicy;
    this._tileWidth = 256;
    this._tileHeight = 256;
    this._minimumLevel = obj.maximumLevel || 0;
    this._maximumLevel = obj.maximumLevel || 18;
    this._tilingScheme = new Assertion(obj);
    this._rectangle = defaultValue(obj.rectangle, this._tilingScheme.rectangle);
    name = obj.credit;
    if ("string" == typeof name) {
      name = new Name(name);
    }
    this._credit = name;
    this.enablePickFeatures = defaultValue(obj.enablePickFeatures, false);
    this._hasAlphaChannel = defaultValue(obj.hasAlphaChannel, true);
    this._subdomains = defaultValue(obj.subdomains, ["online0", "online1", "online2", "online3", "online4", "online5", "online6", "online7", "online8", "online9"]);
    this._errorEvent = new options;
    this._readyPromise = callback.defer();
    this._ready = true;
    this._readyPromise.resolve(true);
  }
  obj = obj && obj.hasOwnProperty("default") ? obj.default : obj;
  definition = definition && definition.hasOwnProperty("default") ? definition.default : definition;
  foo = foo && foo.hasOwnProperty("default") ? foo.default : foo;
  appendCSS(`.cesium-widget-credits {\n    display: none !important;\n}\n\n.xt3d-logo-container {\n    position: absolute;\n    left: 10px;\n    bottom: 10px;\n    user-select: none;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n}\n\n.xt3d-logo-img {\n    height: 34px;\n    width: 34px;\n}\n\n.xt3d-logo-text {\n    font-size: 22px;\n    color: white;\n}`, {});
  if (!window.xt3d) {
    window.xt3d = {
      "uuid" : "20220407",
      "v" : `2.02`,
      "r" : "\u5728\u7ebf\u9884\u89c8"
    };
    output = document.title;
    location = window.location;
    if (output.indexOf(`xt3d`) < 0) {
      window.xt3d = void 0;
      location.href = `http://www.xtgis.cc/`;
    }
  }
  xt3d.xt3dInfo = function(canCreateDiscussions) {
  };
  xt3d.xt3dInfo(window.console);
  xt3d.xt3dLogo = function() {
    var waitClFile = document.getElementsByClassName("xt3d-logo-container");
    var i = 0;
    for (; i < waitClFile.length; i++) {
      waitClFile[i].remove();
    }
    var crossfilterable_layers = document.getElementsByClassName("cesium-widget");
    var layer_i = 0;
    for (; layer_i < crossfilterable_layers.length; layer_i++) {
      var contentContainerLayer = crossfilterable_layers[layer_i];
      var layer = document.createElement("div");
      layer.classList.add("xt3d-logo-container");
      var tofItemTextSpan = document.createElement("img");
      tofItemTextSpan.classList.add("xt3d-logo-img");
      tofItemTextSpan.src = "data:image/png;base64,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";
      contentContainerLayer.appendChild(layer);
      layer.appendChild(tofItemTextSpan);
      layer.onclick = function(branch) {
        window.open("http://211.149.185.229:8080/");
      };
      tofItemTextSpan = document.createElement("span");
      tofItemTextSpan.classList.add("xt3d-logo-text");
      tofItemTextSpan.innerHTML = "xt3d";
      layer.appendChild(tofItemTextSpan);
    }
  };
  setTimeout(function() {
    xt3d.xt3dInfo(window.console);
    xt3d.xt3dLogo();
  }, 1E3);
  setInterval(function() {
    xt3d.xt3dInfo(window.console);
    xt3d.xt3dLogo();
  }, 1E4);
  var call = _interopRequireWildcard(__webpack_require__(function(canCreateDiscussions, exports) {
    exports.__esModule = true;
    exports.default = function(type, obj) {
      if (!(type instanceof obj)) {
        throw new TypeError("Cannot call a class as a function");
      }
    };
  }));
  var global = __webpack_require__(function(module) {
    module = module.exports = "undefined" != typeof window && window.Math == Math ? window : "undefined" != typeof self && self.Math == Math ? self : Function("return this")();
    if ("number" == typeof __g) {
      __g = module;
    }
  });
  var core = __webpack_require__(function(module) {
    module = module.exports = {
      "version" : "2.6.12"
    };
    if ("number" == typeof __e) {
      __e = module;
    }
  });
  var es5 = (core.version, !processResource(function() {
    return 7 != Object.defineProperty({}, "a", {
      "get" : function() {
        return 7;
      }
    }).a;
  }));
  var document = global.document;
  var isFile = isObject(document) && isObject(document.createElement);
  var _0x5c8815 = !es5 && !processResource(function() {
    return 7 != Object.defineProperty(createElement("div"), "a", {
      "get" : function() {
        return 7;
      }
    }).a;
  });
  var defineProp = Object.defineProperty;
  var $ = {
    "f" : es5 ? Object.defineProperty : function(target, key, desc) {
      if (resolve(target), key = hash(key, true), resolve(desc), _0x5c8815) {
        try {
          return defineProp(target, key, desc);
        } catch (_0x4612c8) {
        }
      }
      if ("get" in desc || "set" in desc) {
        throw TypeError("Accessors not supported!");
      }
      return "value" in desc && (target[key] = desc.value), target;
    }
  };
  var hide = es5 ? function(name, key, value) {
    return $.f(name, key, createDesc(1, value));
  } : function(obj, key, name) {
    return obj[key] = name, obj;
  };
  var hasOwn = {}.hasOwnProperty;
  var fnName = "prototype";
  var $def = function(type, name, source) {
    var key;
    var own;
    var out;
    var IS_FORCED = type & $def.F;
    var IS_GLOBAL = type & $def.G;
    var IS_STATIC = type & $def.S;
    var IS_PROTO = type & $def.P;
    var IS_BIND = type & $def.B;
    var IS_WRAP = type & $def.W;
    var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
    var e = exports[fnName];
    var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[fnName];
    for (key in IS_GLOBAL && (source = name), source) {
      if (!((own = !IS_FORCED && target && void 0 !== target[key]) && has(exports, key))) {
        out = (own ? target : source)[key];
        exports[key] = IS_GLOBAL && "function" != typeof target[key] ? source[key] : IS_BIND && own ? ctx(out, global) : IS_WRAP && target[key] == out ? function(Promise) {
          function model(callback, name, opts) {
            if (this instanceof Promise) {
              switch(arguments.length) {
                case 0:
                  return new Promise;
                case 1:
                  return new Promise(callback);
                case 2:
                  return new Promise(callback, name);
              }
              return new Promise(callback, name, opts);
            }
            return Promise.apply(this, arguments);
          }
          return model[fnName] = Promise[fnName], model;
        }(out) : IS_PROTO && "function" == typeof out ? ctx(Function.call, out) : out;
        if (IS_PROTO) {
          (exports.virtual || (exports.virtual = {}))[key] = out;
          if (type & $def.R && e && !e[key]) {
            hide(e, key, out);
          }
        }
      }
    }
  };
  $def.F = 1;
  $def.G = 2;
  $def.S = 4;
  $def.P = 8;
  $def.B = 16;
  $def.W = 32;
  $def.U = 64;
  $def.R = 128;
  var $export = $def;
  $export($export.S + $export.F * !es5, `Object`, {
    "defineProperty" : $.f
  });
  var utils = core.Object;
  var _Pharmacode = __webpack_require__(function(module) {
    module.exports = {
      "default" : setProp,
      "__esModule" : true
    };
  });
  _interopRequireWildcard(_Pharmacode);
  expect = _interopRequireWildcard(__webpack_require__(function(canCreateDiscussions, exports) {
    function get(type, props) {
      var i = 0;
      for (; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) {
          descriptor.writable = true;
        }
        (0, node.default)(type, descriptor.key, descriptor);
      }
    }
    exports.__esModule = true;
    var data;
    var node = (data = _Pharmacode) && data.__esModule ? data : {
      "default" : data
    };
    exports.default = function(type, value, data) {
      return value && get(type.prototype, value), data && get(type, data), type;
    };
  }));
  Object.defineProperties(ColorMaterialProperty.prototype, {
    "isConstant" : {
      "get" : function() {
        return false;
      }
    },
    "definitionChanged" : {
      "get" : function() {
        return this._definitionChanged;
      }
    },
    "color" : Cesium.createPropertyDescriptor("color")
  });
  ColorMaterialProperty.prototype.getType = function(original_full_html) {
    return "ConeGlowBottomCircle";
  };
  ColorMaterialProperty.prototype.getValue = function(time, result) {
    return Cesium.defined(result) || (result = {}), result.color = Cesium.Property.getValueOrClonedDefault(this._color, time, Cesium.Color.WHITE, result.color), result.image = Cesium.Material.ConeGlowBottomCircleImage, result;
  };
  ColorMaterialProperty.prototype.equals = function(other) {
    return this === other || other instanceof ColorMaterialProperty && Cesium.Property.equals(this._color, other._color);
  };
  Cesium.ConeGlowBottomCircleMaterialProperty = ColorMaterialProperty;
  Cesium.Material.ConeGlowBottomCircleType = `ConeGlowBottomCircle`;
  Cesium.Material.ConeGlowBottomCircleImage = function() {
    var hcanvas = document.createElement("canvas");
    hcanvas.width = 512;
    hcanvas.height = 512;
    var ctx = hcanvas.getContext("2d");
    var linGrad = ctx.createRadialGradient(256, 256, 0, 256, 256, 256);
    return linGrad.addColorStop(0.1, "rgba(255, 255, 255, 1.0)"), linGrad.addColorStop(0.2, "rgba(255, 255, 255, 0.0)"), linGrad.addColorStop(0.3, "rgba(255, 255, 255, 0.9)"), linGrad.addColorStop(0.5, "rgba(255, 255, 255, 0.0)"), linGrad.addColorStop(0.9, "rgba(255, 255, 255, 0.2)"), linGrad.addColorStop(1, "rgba(255, 255, 255, 1.0)"), ctx.clearRect(0, 0, 512, 512), ctx.beginPath(), ctx.arc(256, 256, 256, 0, 2 * Math.PI, true), ctx.fillStyle = linGrad, ctx.fill(), ctx.restore(), hcanvas.toDataURL("image/png").replace("image/png", 
    "image/octet-stream");
  }();
  Cesium.Material.ConeGlowBottomCircleSource = `czm_material czm_getMaterial(czm_materialInput materialInput)\n{\n     czm_material material = czm_getDefaultMaterial(materialInput);\n     vec2 st = materialInput.st;\n     vec4 colorImage = texture2D(image,  vec2(st ));\n     material.alpha = colorImage.a * color.a;\n     material.diffuse =  1.5* color.rgb  ;\n     return material;\n }`;
  Cesium.Material._materialCache.addMaterial(Cesium.Material.ConeGlowBottomCircleType, {
    "fabric" : {
      "type" : Cesium.Material.ConeGlowBottomCircleType,
      "uniforms" : {
        "color" : new Cesium.Color(1, 0, 0, 0.5),
        "image" : Cesium.Material.ConeGlowBottomCircleImage,
        "time" : 0
      },
      "source" : Cesium.Material.ConeGlowBottomCircleSource
    },
    "translucent" : function(material) {
      return true;
    }
  });
  Object.defineProperties(PolylineArrowMaterialProperty.prototype, {
    "isConstant" : {
      "get" : function() {
        return false;
      }
    },
    "definitionChanged" : {
      "get" : function() {
        return this._definitionChanged;
      }
    },
    "color" : Cesium.createPropertyDescriptor(`color`)
  });
  PolylineArrowMaterialProperty.prototype.getType = function(original_full_html) {
    return "ConeGlowBottomRotateCircle";
  };
  PolylineArrowMaterialProperty.prototype.getValue = function(time, result) {
    return Cesium.defined(result) || (result = {}), result.color = Cesium.Property.getValueOrClonedDefault(this._color, time, Cesium.Color.WHITE, result.color), result.image = Cesium.Material.ConeGlowBottomRotateCircleImage, result;
  };
  PolylineArrowMaterialProperty.prototype.equals = function(other) {
    return this === other || other instanceof PolylineArrowMaterialProperty && Cesium.Property.equals(this._color, other._color);
  };
  Cesium.ConeGlowBottomRotateCircleMaterialProperty = PolylineArrowMaterialProperty;
  Cesium.Material.ConeGlowBottomRotateCircleType = `ConeGlowBottomRotateCircle`;
  Cesium.Material.ConeGlowBottomRotateCircleImage = function() {
    var hcanvas = document.createElement("canvas");
    hcanvas.width = 512;
    hcanvas.height = 512;
    var ctx = hcanvas.getContext("2d");
    return ctx.clearRect(0, 0, 512, 512), ctx.strokeStyle = "rgb(255, 255, 0)", ctx.setLineDash([80, 80]), ctx.lineWidth = 30, ctx.arc(256, 256, 241, 0, 2 * Math.PI, true), ctx.stroke(), hcanvas.toDataURL("image/png").replace("image/png", "image/octet-stream");
  }();
  Cesium.Material.ConeGlowBottomRotateCircleSource = `czm_material czm_getMaterial(czm_materialInput materialInput)\n{\n     czm_material material = czm_getDefaultMaterial(materialInput);\n     vec2 st = materialInput.st;\n     vec4 colorImage = texture2D(image, vec2(st ));\n     material.diffuse = 2.5 * color.rgb  ;\n     material.alpha = colorImage.a ;\n     return material;\n }`;
  Cesium.Material._materialCache.addMaterial(Cesium.Material.ConeGlowBottomRotateCircleType, {
    "fabric" : {
      "type" : Cesium.Material.ConeGlowBottomRotateCircleType,
      "uniforms" : {
        "color" : new Cesium[`Color`](1, 0, 0, 0.5),
        "image" : Cesium.Material.ConeGlowBottomRotateCircleImage,
        "time" : 0
      },
      "source" : Cesium.Material.ConeGlowBottomRotateCircleSource
    },
    "translucent" : function(material) {
      return true;
    }
  });
  var data = (expect(parseNode, [{
    "key" : "addCone",
    "value" : function() {
      var modelMatrix = Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(this.position), new Cesium["Cartesian3"](0, 0, 0.5 * this.height), new Cesium["Matrix4"]);
      var D_geometry = new Cesium["CylinderGeometry"]({
        "length" : this.height,
        "topRadius" : 0,
        "bottomRadius" : 0.7 * this.bottomRadius,
        "vertexFormat" : Cesium.MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat
      });
      modelMatrix = new Cesium["GeometryInstance"]({
        "geometry" : D_geometry,
        "modelMatrix" : modelMatrix
      });
      this.cylinderPrimitive = this.viewer.scene.primitives.add(new Cesium["Primitive"]({
        "geometryInstances" : [modelMatrix],
        "appearance" : new Cesium.MaterialAppearance({
          "material" : new Cesium["Material"]({
            "fabric" : {
              "type" : "VtxfShader1",
              "uniforms" : {
                "color" : this.color,
                "alpha" : 2
              },
              "source" : `\n                                uniform vec4 color;   \n                                czm_material czm_getMaterial(czm_materialInput materialInput)\n                                {\n                                    czm_material material = czm_getDefaultMaterial(materialInput);\n                                    vec2 st = materialInput.st;\n                                    float dis = distance(st, vec2(0.5)); \n                                    material.diffuse =2.9 * color.rgb;\n                                    material.alpha = color.a * dis * alpha ;\n                                    return material;\n                                }\n                            `
            },
            "translucent" : false
          }),
          "faceForward" : false,
          "closed" : true
        })
      }));
      this.viewer.scene.preUpdate.addEventListener(this.preUpdateHandle, this);
    }
  }, {
    "key" : `preUpdateHandle`,
    "value" : function() {
      this.cylinderPrimitive.appearance.material.uniforms.alpha += 0.05;
      if (2.5 < this.cylinderPrimitive.appearance.material.uniforms.alpha) {
        this.cylinderPrimitive.appearance.material.uniforms.alpha = 2;
      }
    }
  }, {
    "key" : `addBottomCircle`,
    "value" : function() {
      this.bottomCircle = this.viewer.entities.add({
        "position" : this.position,
        "ellipse" : {
          "semiMinorAxis" : 2 * this.bottomRadius,
          "semiMajorAxis" : 2 * this.bottomRadius,
          "height" : this.circleHeight,
          "material" : new Cesium["ConeGlowBottomCircleMaterialProperty"](this.color)
        }
      });
    }
  }, {
    "key" : `addBottomRotateCircle`,
    "value" : function() {
      var artistTrack = 360;
      this.bottomRotateCircle = this.viewer.entities.add({
        "position" : this.position,
        "ellipse" : {
          "semiMinorAxis" : 1.45 * this.bottomRadius,
          "semiMajorAxis" : 1.45 * this.bottomRadius,
          "height" : this.circleHeight,
          "material" : new Cesium.ConeGlowBottomRotateCircleMaterialProperty(this.color),
          "stRotation" : new Cesium.CallbackProperty(function(canCreateDiscussions) {
            var put_rows = hahaha;
            return --artistTrack < 0 && (artistTrack = 360), Cesium[put_rows(2090)][put_rows(1544)](artistTrack);
          }, false)
        }
      });
    }
  }, {
    "key" : "remove",
    "value" : function() {
      this.viewer.scene.preUpdate.removeEventListener(this.preUpdateHandle, this);
      this.viewer.entities.remove(this.bottomRotateCircle);
      this.viewer.entities.remove(this.bottomCircle);
      this.viewer.scene.primitives.remove(this.cylinderPrimitive);
    }
  }]), parseNode);
  Object.defineProperties(ReferenceProperty.prototype, {
    "isConstant" : {
      "get" : function() {
        return false;
      }
    },
    "definitionChanged" : {
      "get" : function() {
        return this._definitionChanged;
      }
    },
    "color" : Cesium.createPropertyDescriptor(`color`)
  });
  ReferenceProperty.prototype.getType = function(original_full_html) {
    return "Scanline";
  };
  ReferenceProperty.prototype.getValue = function(time, result) {
    return Cesium.defined(result) || (result = {}), result.color = Cesium.Property.getValueOrClonedDefault(this.color, time, Cesium.Color.WHITE, result.color), result.speed = this.speed, result;
  };
  ReferenceProperty.prototype.equals = function(options) {
    return this === options || options instanceof ReferenceProperty && Cesium.Property.equals(this.color, options.color) && Cesium.Property.equals(this.speed, options.speed);
  };
  Cesium.ScanlineMaterialProperty = ReferenceProperty;
  Cesium.Material.ScanlineType = `Scanline`;
  Cesium.Material.ScanlineSource = `uniform vec4 color;\nuniform float speed;\nfloat circle(vec2 uv, float r, float blur) {\n  float d = length(uv) * 2.0;\n  float c = smoothstep(r+blur, r, d);\n  return c;\n}\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n  czm_material material = czm_getDefaultMaterial(materialInput);\n  vec2 st = materialInput.st - 0.5;\n  material.diffuse =2.8 * color.rgb;\n  material.emission = vec3(0);\n  float t =fract(czm_frameNumber * speed / 1000.0);\n  float s = 0.3;\n  float radius1 = smoothstep(.0, s, t) * 0.5;\n  float alpha1 = circle(st, radius1, 0.01) * circle(st, radius1, -0.01);\n  float alpha2 = circle(st, radius1, 0.01 - radius1) * circle(st, radius1, 0.01);\n  float radius2 = 0.5 + smoothstep(s, 1.0, t) * 0.5;\n  float alpha3 = circle(st, radius1, radius2 + 0.01 - radius1) * circle(st, radius1, -0.01);\n  material.alpha = smoothstep(1.0, s, t) * (alpha1 + alpha2*0.1 + alpha3*0.1);\n  material.alpha *=color.a ;\n  return material;\n} `;
  Cesium.Material._materialCache.addMaterial(Cesium.Material.ScanlineType, {
    "fabric" : {
      "type" : Cesium.Material.ScanlineType,
      "uniforms" : {
        "color" : new Cesium[`Color`](1, 0, 0, 0.5),
        "time" : 0,
        "speed" : 10
      },
      "source" : Cesium.Material.ScanlineSource
    },
    "translucent" : function(material) {
      return true;
    }
  });
  var descriptor = (expect(updateObject, [{
    "key" : `addEnt`,
    "value" : function() {
      this.ent = this.viewer.entities.add({
        "position" : this.position,
        "ellipse" : {
          "semiMinorAxis" : this.radius,
          "semiMajorAxis" : this.radius,
          "material" : new Cesium["ScanlineMaterialProperty"](this.color, this.speed),
          "classificationType" : Cesium.ClassificationType.BOTH
        }
      });
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.viewer.remove(this.ent);
    }
  }]), updateObject);
  var _inherits = (expect(redraw, [{
    "key" : `addEntities`,
    "value" : function() {
      var data = this;
      var _0x4ba36b = 0;
      var pipelets = [{
        "range" : this.radius,
        "url" : this.textureUrl + "/kedu.png",
        "color" : new Cesium["Color"](0.4, 0.4, 0.4, 0.8)
      }, {
        "range" : 0.92 * this.radius,
        "url" : this.textureUrl + "/fangxiang.png",
        "st" : -0.05,
        "color" : new Cesium.Color(0.4, 0.4, 0.4, 0.8)
      }, {
        "range" : 0.85 * this.radius,
        "url" : this.textureUrl + "/keduzhi.png",
        "color" : new Cesium["Color"](1, 1, 1, 0.2)
      }, {
        "range" : this.radius,
        "url" : this.textureUrl + "/faguang.png",
        "color" : new Cesium["Color"](1, 1, 1, 0.5)
      }];
      var ent = void 0;
      pipelets.forEach(function(item) {
        var getTemplatesKey = hahaha;
        ent = data[getTemplatesKey(2276)][getTemplatesKey(1319)][getTemplatesKey(3010)]({
          "position" : data[getTemplatesKey(586)],
          "ellipse" : {
            "height" : data[getTemplatesKey(1132)],
            "semiMajorAxis" : item[getTemplatesKey(1747)],
            "semiMinorAxis" : item[getTemplatesKey(1747)],
            "material" : new Cesium.ImageMaterialProperty({
              "image" : item[getTemplatesKey(649)],
              "transparent" : true,
              "color" : item[getTemplatesKey(2240)] || new (Cesium[getTemplatesKey(2292)])(1, 1, 1, 0.7)
            }),
            "stRotation" : item.st || 0
          }
        });
        data[getTemplatesKey(1319)][getTemplatesKey(2008)](ent);
      });
      ent = this.viewer.entities.add({
        "position" : this.position,
        "ellipse" : {
          "height" : this.height,
          "semiMajorAxis" : 0.9 * this.radius,
          "semiMinorAxis" : 0.9 * this.radius,
          "material" : new Cesium["ImageMaterialProperty"]({
            "image" : this.textureUrl + "/banyuan.png",
            "transparent" : true,
            "color" : new Cesium.Color(0.4, 0.4, 0.4, 0.4)
          }),
          "stRotation" : new Cesium["CallbackProperty"](function() {
            return _0x4ba36b = _0x4ba36b + 0.005;
          }, false)
        }
      });
      this.entities.push(ent);
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      var same = this;
      this.entities.forEach(function(tObject3d) {
        var rel2Mstr = hahaha;
        same[rel2Mstr(2276)][rel2Mstr(1319)].remove(tObject3d);
      });
      this.entities = void 0;
    }
  }]), redraw);
  var IS_INCLUDES;
  var ceil = Math.ceil;
  var floor = Math.floor;
  var redefine = hide;
  var Iterators = {};
  var objectToString$2 = {}.toString;
  var exists = Object("z").propertyIsEnumerable(0) ? Object : function(key) {
    return "String" == lookup(key) ? key.split("") : Object(key);
  };
  var $min = Math.min;
  var mmax = Math.max;
  var min = Math.min;
  var shared = __webpack_require__(function(mixin) {
    var SHARED = "__core-js_shared__";
    var params = global[SHARED] || (global[SHARED] = {});
    (mixin.exports = function(name, value) {
      return params[name] || (params[name] = void 0 !== value ? value : {});
    })("versions", []).push({
      "version" : core.version,
      "mode" : "pure",
      "copyright" : "\u00a9 2020 Denis Pushkarev (zloirock.ru)"
    });
  });
  var _idx = 0;
  var num = Math.random();
  var o = shared("keys");
  var init = function(key) {
    return o[key] || (o[key] = uid(key));
  };
  var iteratee = (IS_INCLUDES = false, function(x, el, b) {
    var item;
    var items = find(x);
    var length = toLength(items.length);
    var index = (x = length, (b = Number(b = b)) < 0 ? mmax(b + x, 0) : min(b, x));
    if (IS_INCLUDES && el != el) {
      for (; index < length;) {
        if ((item = items[index++]) != item) {
          return true;
        }
      }
    } else {
      for (; index < length; index++) {
        if ((IS_INCLUDES || index in items) && items[index] === el) {
          return IS_INCLUDES || index || 0;
        }
      }
    }
    return !IS_INCLUDES && -1;
  });
  var active = init(`IE_PROTO`);
  var value = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
  var flatten = Object.keys || function(obj) {
    return pick(obj, value);
  };
  var isArray = es5 ? Object.defineProperties : function(name, obj) {
    resolve(name);
    var P;
    var keys = flatten(obj);
    var l = keys.length;
    var i = 0;
    for (; i < l;) {
      $.f(name, P = keys[i++], obj[P]);
    }
    return name;
  };
  var doc = global.document;
  var docElem = doc && doc.documentElement;
  var alias = init(`IE_PROTO`);
  var j = "prototype";
  var createDict = function() {
    var iframe = createElement("iframe");
    var i = value.length;
    iframe.style.display = "none";
    docElem.appendChild(iframe);
    iframe.src = "javascript:";
    (iframe = iframe.contentWindow.document).open();
    iframe.write("<script>document.F=Object\x3c/script>");
    iframe.close();
    createDict = iframe.F;
    for (; i--;) {
      delete createDict[j][value[i]];
    }
    return createDict();
  };
  var _create = Object.create || function(name, string) {
    var data;
    return null !== name ? (modules[j] = resolve(name), data = new modules, modules[j] = null, data[alias] = name) : data = createDict(), void 0 === string ? data : isArray(data, string);
  };
  var jQuery = __webpack_require__(function(mixin) {
    var store = shared("wks");
    var Symbol = global.Symbol;
    var USE_SYMBOL = "function" == typeof Symbol;
    (mixin.exports = function(name) {
      var spaces = hahaha;
      return store[name] || (store[name] = USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)(spaces(1109) + name));
    }).store = store;
  });
  var def = $.f;
  var method = jQuery(`toStringTag`);
  var body = {};
  hide(body, jQuery(`iterator`), function() {
    return this;
  });
  var isTalmud;
  var key = init(`IE_PROTO`);
  var ObjectProto = Object.prototype;
  var toIObject = Object.getPrototypeOf || function(obj) {
    return obj = toObject(obj), has(obj, key) ? obj[key] : "function" == typeof obj.constructor && obj instanceof obj.constructor ? obj.constructor.prototype : obj instanceof Object ? ObjectProto : null;
  };
  var ITERATOR = jQuery(`iterator`);
  var BUGGY = !([].keys && "next" in [].keys());
  var VALUES = `values`;
  exports = function(target, type, data, next, DEFAULT, IS_SET, FORCED) {
    function getMethod(kind) {
      if (!BUGGY && kind in proto) {
        return proto[kind];
      }
      switch(kind) {
        case "keys":
        case VALUES:
          return function() {
            return new data(this, kind);
          };
      }
      return function() {
        return new data(this, kind);
      };
    }
    obj = type;
    value = next;
    (parsed = data).prototype = _create(body, {
      "next" : createDesc(1, value)
    });
    setToStringTag(parsed, obj + " Iterator");
    var methods;
    var key;
    var P;
    var TAG = type + " Iterator";
    var DEF_VALUES = DEFAULT == VALUES;
    next = false;
    var proto = target.prototype;
    var $native = proto[ITERATOR] || proto["@@iterator"] || DEFAULT && proto[DEFAULT];
    var value = $native || getMethod(DEFAULT);
    var parsed = DEFAULT ? DEF_VALUES ? getMethod("entries") : value : void 0;
    var obj = "Array" == type && proto.entries || $native;
    if (obj && (P = toIObject(obj.call(new target))) !== Object.prototype && P.next && setToStringTag(P, TAG, true), DEF_VALUES && $native && $native.name !== VALUES && (next = true, value = function() {
      return $native.call(this);
    }), FORCED && (BUGGY || next || !proto[ITERATOR]) && hide(proto, ITERATOR, value), Iterators[type] = value, Iterators[TAG] = returnThis, DEFAULT) {
      if (methods = {
        "values" : DEF_VALUES ? value : getMethod(VALUES),
        "keys" : IS_SET ? value : getMethod("keys"),
        "entries" : parsed
      }, FORCED) {
        for (key in methods) {
          if (!(key in proto)) {
            redefine(proto, key, methods[key]);
          }
        }
      } else {
        $export($export.P + $export.F * (BUGGY || next), type, methods);
      }
    }
    return methods;
  };
  var matchIdentifier = (isTalmud = true, function(len, name) {
    var _0x21b8fb;
    var hexii = String(assertDefined(len));
    var i = Number(name);
    len = hexii.length;
    return i < 0 || len <= i ? isTalmud ? "" : void 0 : (name = hexii.charCodeAt(i)) < 55296 || 56319 < name || i + 1 === len || (_0x21b8fb = hexii.charCodeAt(i + 1)) < 56320 || 57343 < _0x21b8fb ? isTalmud ? hexii.charAt(i) : name : isTalmud ? hexii.slice(i, i + 2) : _0x21b8fb - 56320 + (name - 55296 << 10) + 65536;
  });
  exports(String, `String`, function(iterated) {
    this._t = String(iterated);
    this._i = 0;
  }, function() {
    var text = this._t;
    var i = this._i;
    return i >= text.length ? {
      "value" : void 0,
      "done" : true
    } : (i = matchIdentifier(text, i), this._i += i.length, {
      "value" : i,
      "done" : false
    });
  });
  var src = jQuery(`iterator`);
  var proto = Array.prototype;
  var b = jQuery(`toStringTag`);
  var valueMightNeedDecoding = "Arguments" == lookup(function() {
    return arguments;
  }());
  var description = jQuery(`iterator`);
  var getProperty = core.getIteratorMethod = function(it) {
    if (null != it) {
      return it[description] || it["@@iterator"] || Iterators[recurse(it)];
    }
  };
  var code = jQuery("iterator");
  var targetMultiple = false;
  try {
    [7][code]().return = function() {
      targetMultiple = true;
    };
  } catch (_0x502b31) {
  }
  $export($export.S + $export.F * !function(assertContainsGame, sourceMultiple) {
    if (!sourceMultiple && !targetMultiple) {
      return false;
    }
    var safe = false;
    try {
      var list = [7];
      var deletedChar = list[code]();
      deletedChar.next = function() {
        return {
          "done" : safe = true
        };
      };
      list[code] = function() {
        return deletedChar;
      };
      assertContainsGame(list);
    } catch (_0x27232e) {
    }
    return safe;
  }(function(arrMethod) {
  }), `Array`, {
    "from" : function(value) {
      var length;
      var result;
      var step;
      var context;
      var object = toObject(value);
      var C = "function" == typeof this ? this : Array;
      var cb = arguments.length;
      var mapfn = 1 < cb ? arguments[1] : void 0;
      var mapping = void 0 !== mapfn;
      var i = 0;
      value = getProperty(object);
      if (mapping && (mapfn = ctx(mapfn, 2 < cb ? arguments[2] : void 0, 2)), null != value && (C != Array || (void 0 === (cb = value) || Iterators.Array !== cb && proto[src] !== cb))) {
        context = value.call(object);
        result = new C;
        for (; !(step = context.next()).done; i++) {
          defineProperty(result, i, mapping ? function(obj, fn, value, err) {
            var fn = hahaha;
            try {
              return err ? fn(resolve(value)[0], value[1]) : fn(value);
            } catch (_0x4659bc) {
              var format = obj[fn(1078)];
              throw void 0 !== format && resolve(format[fn(744)](obj)), _0x4659bc;
            }
          }(context, mapfn, [step.value, i], true) : step.value);
        }
      } else {
        result = new C(length = toLength(object.length));
        for (; i < length; i++) {
          defineProperty(result, i, mapping ? mapfn(object[i], i) : object[i]);
        }
      }
      return result.length = i, result;
    }
  });
  var CFV = core.Array.from;
  var _propertyEntry = __webpack_require__(function(module) {
    module.exports = {
      "default" : CFV,
      "__esModule" : true
    };
  });
  _interopRequireWildcard(_propertyEntry);
  var array = _interopRequireWildcard(__webpack_require__(function(canCreateDiscussions, exports) {
    exports.__esModule = true;
    var obj;
    var scene = (obj = _propertyEntry) && obj.__esModule ? obj : {
      "default" : obj
    };
    exports.default = function(obj) {
      if (Array.isArray(obj)) {
        var i = 0;
        var result = Array(obj.length);
        for (; i < obj.length; i++) {
          result[i] = obj[i];
        }
        return result;
      }
      return (0, scene.default)(obj);
    };
  }));
  var view = (expect(report, [{
    "key" : "multipleRingBuffer",
    "value" : function(obj, val, type) {
      var data = [obj];
      var x = 1;
      for (; x <= val; x++) {
        var s = turf.buffer(obj, x * type, {
          "units" : "meters"
        });
        s.properties.opacity = (val - x) / val;
        data.push(s);
      }
      var key = data.length - 1;
      for (; 0 < key; key--) {
        var d = data[key];
        data[key] = turf.difference(d, data[key - 1]);
        data[key].properties.opt = d.properties.opacity;
      }
      return data = data.slice(-(data.length - 1)), turf.featureCollection([].concat(array(data)));
    }
  }, {
    "key" : `addRegionData`,
    "value" : function(obj, val) {
      var rx;
      var map = this;
      obj = Cesium.GeoJsonDataSource.load(obj);
      obj.then(function(e) {
        var parseInt = hahaha;
        map[parseInt(2276)][parseInt(2657)][parseInt(3010)](e);
        var _overlays = e.entities[parseInt(944)];
        var i = 0;
        for (; i < _overlays.length; i++) {
          var o = _overlays[i];
          o.polygon[parseInt(2281)] = false;
          rx = (val - i) / val * 0.8;
          o[parseInt(2544)][parseInt(1187)] = map[parseInt(1724)].color[parseInt(2265)](rx);
          o.alpha = rx;
        }
        map[parseInt(712)] = e;
      }).otherwise(function(body) {
        var put_rows = hahaha;
        console[put_rows(1012)](body);
      });
    }
  }, {
    "key" : `changeColor`,
    "value" : function(value) {
      var entities = this.dataSource.entities.values;
      var i = 0;
      for (; i < entities.length; i++) {
        var entity = entities[i];
        entity.polygon.material = value.withAlpha(entity.alpha);
      }
    }
  }, {
    "key" : "remove",
    "value" : function() {
      this.viewer.dataSources.remove(this.dataSource);
    }
  }]), report);
  var mode = (expect(Link, [{
    "key" : `createMaterialAppearance`,
    "value" : function(name) {
      return new Cesium.MaterialAppearance({
        "material" : new Cesium["Material"]({
          "fabric" : {
            "uniforms" : {
              "color" : name,
              "image" : "data:image/png;base64,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",
              "time" : 0
            },
            "source" : "  czm_material czm_getMaterial(czm_materialInput materialInput) \n                        { \n                             czm_material material = czm_getDefaultMaterial(materialInput); \n                             vec2 st = materialInput.st; \n                             vec4 colorImage = texture2D(image, vec2(fract(st.t - time), st.t)); \n                             float powerRatio = fract(czm_frameNumber / 30.0) + 1.0; \n                             float alpha = pow(1.0 -  st.t, powerRatio);\n                             material.alpha = colorImage.a * color.a *alpha; \n                             material.diffuse =  1.5 * color.rgb  ; \n                             return material; \n                         } "
          },
          "translucent" : true
        }),
        "faceForward" : false,
        "closed" : false
      });
    }
  }]), Link);
  var anim = Object.freeze({
    "generateCirclePoints" : val,
    "getCirclePoint" : gen,
    "getSceneImage" : function(that, notThat, __i) {
      var canvas = that.canvas;
      var a = new Image;
      return a.src = canvas.toDataURL("image/png"), new Promise(function(saveNotifs, canCreateDiscussions) {
        var getSymbolIterator = hahaha;
        a[getSymbolIterator(2887)] = function() {
          var prefixed = getSymbolIterator;
          (canvas = document[prefixed(1442)](prefixed(2818)))[prefixed(807)] = __i;
          canvas[prefixed(1132)] = notThat;
          canvas[prefixed(1714)]("2d")[prefixed(3E3)](a, 0, 0, canvas[prefixed(807)], canvas[prefixed(1132)]);
          saveNotifs(canvas[prefixed(555)](prefixed(777)));
        };
      });
    },
    "pickCamera" : function(message) {
      return {
        "heading" : message.camera.heading,
        "pitch" : message.camera.pitch,
        "roll" : message.camera.roll,
        "x" : message.camera.position.x,
        "y" : message.camera.position.y,
        "z" : message.camera.position.z
      };
    },
    "cartesian3ToCoordinates" : function(position) {
      return position = Cesium.Cartographic.fromCartesian(position), [Cesium.Math.toDegrees(position.longitude), Cesium.Math.toDegrees(position.latitude), position.height];
    },
    "cartesian3ToLonLat" : function(position) {
      return position = Cesium.Cartographic.fromCartesian(position), [Cesium.Math.toDegrees(position.longitude), Cesium.Math.toDegrees(position.latitude)];
    },
    "parabola" : function(a, b, x, t) {
      var bookIdIndex;
      var bookIDs = function(range2_min, range1_min, range2_max, range1_max, Px, isBgroundImg) {
        var bookIdIndex;
        var bookIDs = function(ecf_array, match, profilePoint, isBgroundImg) {
          return function(height, m_total_iterations) {
            var newNodeLists = [];
            var m_iterations_done = 0;
            for (; m_iterations_done < m_total_iterations; m_iterations_done++) {
              var sparkline = function(array, time1) {
                var l = array.length;
                var tick_x = 0;
                var totalPass = 0;
                var push = function(x, y) {
                  var z = 1;
                  var w = 1;
                  for (; 0 < y;) {
                    z = z * x;
                    w = w * y;
                    x--;
                    y--;
                  }
                  return z / w;
                };
                var i = 0;
                for (; i < l; i++) {
                  var oa = array[i];
                  tick_x = tick_x + oa.x * Math.pow(1 - time1, l - 1 - i) * Math.pow(time1, i) * push(l - 1, i);
                  totalPass = totalPass + oa.y * Math.pow(1 - time1, l - 1 - i) * Math.pow(time1, i) * push(l - 1, i);
                }
                return {
                  "x" : tick_x,
                  "y" : totalPass
                };
              }(height, m_iterations_done / m_total_iterations);
              newNodeLists.push([sparkline.x, sparkline.y]);
            }
            return newNodeLists;
          }([{
            "x" : ecf_array[0],
            "y" : ecf_array[1]
          }, {
            "x" : match[0],
            "y" : match[1]
          }, {
            "x" : profilePoint[0],
            "y" : profilePoint[1]
          }], isBgroundImg || 100);
        }([range1_min, 0], [(range1_max + range1_min) / 2, Px], [range1_max, 0], isBgroundImg);
        var aPositions = [];
        for (bookIdIndex in bookIDs) {
          var iStart = (range2_max - range2_min) * (bookIDs[bookIdIndex][0] - range1_min) / (range1_max - range1_min) + range2_min;
          aPositions.push([iStart, bookIDs[bookIdIndex][0], bookIDs[bookIdIndex][1]]);
        }
        return aPositions;
      }(a[0], a[1], b[0], b[1], x, t);
      var newNodeLists = [];
      for (bookIdIndex in bookIDs) {
        newNodeLists.push(bookIDs[bookIdIndex][0]);
        newNodeLists.push(bookIDs[bookIdIndex][1]);
        newNodeLists.push(bookIDs[bookIdIndex][2]);
      }
      return Cesium.Cartesian3.fromDegreesArrayHeights(newNodeLists);
    },
    "gradientColor" : function(data, color, delta) {
      var padding = (data = parser(data))[0];
      var blue = data[1];
      var green = data[2];
      var qrsize = ((color = parser(color))[0] - padding) / delta;
      var avgSpeed = (color[1] - blue) / delta;
      var c = (color[2] - green) / delta;
      var newNodeLists = [];
      var dotsize = 0;
      for (; dotsize < delta; dotsize++) {
        var itemNodeList = function(selector) {
          {
            if (/^(rgb|RGB)/.test(selector)) {
              var SMPTE = selector.replace(/(?:(|)|rgb|RGB)*/g, "").split(",");
              var s = "#";
              var i = 0;
              for (; i < SMPTE.length; i++) {
                var d = Number(SMPTE[i]).toString(16);
                if ("0" === (d = d < 10 ? "0" + d : d)) {
                  d = d + d;
                }
                s = s + d;
              }
              return 7 !== s.length && (s = selector), s;
            }
            if (!/^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/.test(selector)) {
              return selector;
            }
            var b = selector.replace(/#/, "").split("");
            if (6 === b.length) {
              return selector;
            }
            if (3 === b.length) {
              var pix_color = "#";
              i = 0;
              for (; i < b.length; i = i + 1) {
                pix_color = pix_color + (b[i] + b[i]);
              }
              return pix_color;
            }
          }
        }("rgb(" + parseInt(qrsize * dotsize + padding) + "," + parseInt(avgSpeed * dotsize + blue) + "," + parseInt(c * dotsize + green) + ")");
        newNodeLists.push(itemNodeList);
      }
      return newNodeLists;
    }
  });
  var Location = function callback(options) {
    call(this, callback);
    this._definitionChanged = new Cesium.Event;
    this._color = void 0;
    this._colorSubscription = void 0;
    this.color = options.color;
    this.img = options.img;
  };
  Object.defineProperties(Location.prototype, {
    "isConstant" : {
      "get" : function() {
        return false;
      }
    },
    "definitionChanged" : {
      "get" : function() {
        return this._definitionChanged;
      }
    },
    "color" : Cesium.createPropertyDescriptor("color")
  });
  Location.prototype.getType = function(original_full_html) {
    return "CylinderGlowGradientWall";
  };
  Location.prototype.getValue = function(time, result) {
    return Cesium.defined(result) || (result = {}), result.color = Cesium.Property.getValueOrClonedDefault(this._color, time, Cesium.Color.WHITE, result.color), result.image = this.img, result;
  };
  Location.prototype.equals = function(other) {
    return this === other || other instanceof Location && Cesium.Property.equals(this._color, other._color);
  };
  Cesium.Material.CylinderGlowGradientWallType = `CylinderGlowGradientWall`;
  Cesium.Material.CylinderGlowGradientWallSource = `czm_material czm_getMaterial(czm_materialInput materialInput)\n {\n      czm_material material = czm_getDefaultMaterial(materialInput);\n      vec2 st = materialInput.st;\n      vec4 colorImage = texture2D(image, vec2(fract(st.t - time), st.t));\n      material.alpha = colorImage.a * color.a;\n      material.diffuse =  1.9 * color.rgb  ;\n      return material;\n  }`;
  Cesium.Material._materialCache.addMaterial(Cesium.Material.CylinderGlowGradientWallType, {
    "fabric" : {
      "type" : Cesium.Material.CylinderGlowGradientWallType,
      "uniforms" : {
        "color" : new Cesium[`Color`](1, 0, 0, 0.5),
        "image" : "",
        "time" : 0
      },
      "source" : Cesium.Material.CylinderGlowGradientWallSource
    },
    "translucent" : function(material) {
      return true;
    }
  });
  var DataString = function set(options) {
    call(this, set);
    this._definitionChanged = new Cesium.Event;
    this._color = void 0;
    this._colorSubscription = void 0;
    this.color = options.color;
    this.duration = options.duration;
    this._time = (new Date).getTime();
    this.img = options.img;
  };
  Object.defineProperties(DataString.prototype, {
    "isConstant" : {
      "get" : function() {
        return false;
      }
    },
    "definitionChanged" : {
      "get" : function() {
        return this._definitionChanged;
      }
    },
    "color" : Cesium.createPropertyDescriptor(`color`)
  });
  DataString.prototype.getType = function(original_full_html) {
    return "CylinderGlowFlowWall";
  };
  DataString.prototype.getValue = function(time, result) {
    return Cesium.defined(result) || (result = {}), result.color = Cesium.Property.getValueOrClonedDefault(this._color, time, Cesium.Color.WHITE, result.color), result.time = ((new Date).getTime() - this._time) % this.duration / this.duration, result.image = this.img, result;
  };
  DataString.prototype.equals = function(object) {
    return this === object || object instanceof DataString && Cesium.Property.equals(this._color, object._color) && this.duration == object.duration;
  };
  Cesium.Material.CylinderGlowFlowWallType = `CylinderGlowFlowWall`;
  Cesium.Material.CylinderGlowFlowWallSource = `czm_material czm_getMaterial(czm_materialInput materialInput)\n{\n     czm_material material = czm_getDefaultMaterial(materialInput);\n     vec2 st = materialInput.st;\n     vec4 colorImage = texture2D(image, vec2(fract(st.t - time), st.t));\n     material.alpha = colorImage.a * color.a;\n     material.diffuse =  1.9 * color.rgb  ;\n     return material;\n }`;
  Cesium.Material._materialCache.addMaterial(Cesium.Material.CylinderGlowFlowWallType, {
    "fabric" : {
      "type" : Cesium.Material.CylinderGlowFlowWallType,
      "uniforms" : {
        "color" : new Cesium.Color(1, 0, 0, 0.5),
        "image" : "",
        "time" : 0
      },
      "source" : Cesium.Material.CylinderGlowFlowWallSource
    },
    "translucent" : function(material) {
      return true;
    }
  });
  var Range = function callback(options) {
    call(this, callback);
    this._definitionChanged = new Cesium.Event;
    this._color = void 0;
    this._colorSubscription = void 0;
    this.color = options.color;
    this.img = options.img;
  };
  Object.defineProperties(Range.prototype, {
    "isConstant" : {
      "get" : function() {
        return false;
      }
    },
    "definitionChanged" : {
      "get" : function() {
        return this._definitionChanged;
      }
    },
    "color" : Cesium.createPropertyDescriptor(`color`)
  });
  Range.prototype.getType = function(original_full_html) {
    return "CylinderGlowCircle";
  };
  Range.prototype.getValue = function(time, result) {
    return Cesium.defined(result) || (result = {}), result.color = Cesium.Property.getValueOrClonedDefault(this._color, time, Cesium.Color.WHITE, result.color), result.image = this.img, result;
  };
  Range.prototype.equals = function(other) {
    return this === other || other instanceof Range && Cesium.Property.equals(this._color, other._color);
  };
  Cesium.Material.CylinderGlowCircleType = `CylinderGlowCircle`;
  Cesium.Material.CylinderGlowCircleSource = `czm_material czm_getMaterial(czm_materialInput materialInput)\n{\n     czm_material material = czm_getDefaultMaterial(materialInput);\n     vec2 st = materialInput.st;\n     vec4 colorImage = texture2D(image,  vec2(st ));\n     material.alpha = colorImage.a * color.a;\n     material.diffuse =  1.5* color.rgb  ;\n     return material;\n }`;
  Cesium.Material._materialCache.addMaterial(Cesium.Material.CylinderGlowCircleType, {
    "fabric" : {
      "type" : Cesium.Material.CylinderGlowCircleType,
      "uniforms" : {
        "color" : new Cesium[`Color`](1, 0, 0, 0.5),
        "image" : "",
        "time" : 0
      },
      "source" : Cesium.Material.CylinderGlowCircleSource
    },
    "translucent" : function(material) {
      return true;
    }
  });
  var k = (expect(replace, [{
    "key" : `generatePositions`,
    "value" : function(type) {
      var result = Cesium.Cartographic.fromCartesian(type);
      if (result.height < 0) {
        result.height = 0;
      }
      type = [Cesium.Math.toDegrees(result.longitude), Cesium.Math.toDegrees(result.latitude), result.height];
      result = val([type[0], type[1]], this.radius);
      type = this.pointsToPositions(result, type[2]);
      this.setPositions(type);
    }
  }, {
    "key" : "pointsToPositions",
    "value" : function(type, target) {
      var connectHandles = [];
      return type.map(function(tmp) {
        connectHandles.push(Cesium.Cartesian3.fromDegrees(tmp[0], tmp[1], target));
      }), connectHandles;
    }
  }, {
    "key" : "setPositions",
    "value" : function(name) {
      this.positions = name || [];
      this.initHeights();
    }
  }, {
    "key" : `initHeights`,
    "value" : function() {
      var dragScroller = this;
      var primaryReplicas = [];
      var rpm_traffic = [];
      this.positions.forEach(function(position) {
        var stringify = hahaha;
        position = Cesium[stringify(1543)].fromCartesian(position);
        primaryReplicas[stringify(2008)](position[stringify(1132)]);
        rpm_traffic[stringify(2008)](position[stringify(1132)] + dragScroller.cylinderHeight);
      });
      this.minimumHeights = primaryReplicas;
      this.maximumHeights = rpm_traffic;
    }
  }, {
    "key" : "addWall",
    "value" : function() {
      this.cylinderEntity = this.viewer.entities.add({
        "wall" : {
          "positions" : this.positions,
          "minimumHeights" : this.minimumHeights,
          "maximumHeights" : this.maximumHeights,
          "material" : this.wallMaterial
        }
      });
    }
  }, {
    "key" : `addFlowWall`,
    "value" : function() {
      this.cylinderEntity1 = this.viewer.entities.add({
        "wall" : {
          "positions" : this.positions,
          "minimumHeights" : this.minimumHeights,
          "maximumHeights" : this.maximumHeights,
          "material" : this.flowWallMaterial
        }
      });
    }
  }, {
    "key" : "addInnerCircle",
    "value" : function(obj) {
      this.innerCircle = this.viewer.entities.add({
        "position" : obj,
        "ellipse" : {
          "semiMinorAxis" : 1.65 * this.radius,
          "semiMajorAxis" : 1.65 * this.radius,
          "height" : this.bottomCircleHeight,
          "material" : this.innerCircleMaterial
        }
      });
    }
  }, {
    "key" : "addOuterCircle",
    "value" : function(obj) {
      var rotation = 360;
      this.outerCircle = this.viewer.entities.add({
        "position" : obj,
        "ellipse" : {
          "semiMinorAxis" : 1.65 * this.radius,
          "semiMajorAxis" : 1.65 * this.radius,
          "height" : this.bottomCircleHeight,
          "material" : this.outerrCircleMaterial,
          "stRotation" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
            return ++rotation < 0 && (rotation = 360), Cesium.Math.toRadians(rotation);
          }, false)
        }
      });
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.viewer.entities.remove(this.cylinderEntity);
      this.viewer.entities.remove(this.cylinderEntity1);
      this.viewer.entities.remove(this.innerCircle);
      this.viewer.entities.remove(this.outerCircle);
    }
  }]), replace);
  appendCSS(`.xt-animation-point,\n.xt-animation-point:after,\n.xt-animation-point:before,\n.xt-animation-point p,\n.xt-animation-point p:after,\n.xt-animation-point p:before {\n    margin: 0;\n    padding: 0;\n    -webkit-box-sizing: border-box;\n    -moz-box-sizing: border-box;\n    -o-box-sizing: border-box;\n    -ms-box-sizing: border-box;\n    box-sizing: border-box\n}\n\n.xt-animation-point {\n    width: 10px;\n    height: 10px;\n    border-radius: 50%;\n    /* border: 1px solid hsla(0, 0%, 100%, .5); */\n    cursor: pointer;\n    color: #0ff;\n    background: currentColor;\n    z-index: 3;\n    left: 50%;\n    top: 50%;\n    -webkit-transform: translate(-50%, -50%);\n    -moz-transform: translate(-50%, -50%);\n    -o-transform: translate(-50%, -50%);\n    -ms-transform: translate(-50%, -50%);\n    transform: translate(-50%, -50%);\n    box-shadow: 0 0 2em currentColor, 0 0 .5em currentColor;\n    position: absolute\n}\n\n.xt-animation-point:after,\n.xt-animation-point:before,\n.xt-animation-point p:after,\n.xt-animation-point p:before {\n    content: "";\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    left: 50%;\n    top: 50%;\n    border-radius: 50%;\n    -webkit-transform: translate(-50%, -50%);\n    -moz-transform: translate(-50%, -50%);\n    -o-transform: translate(-50%, -50%);\n    -ms-transform: translate(-50%, -50%);\n    transform: translate(-50%, -50%)\n}\n\n.xt-animation-point:after,\n.xt-animation-point:before {\n    border: 1px solid;\n    -webkit-animation: xt-mapAni 1s ease infinite;\n    -moz-animation: xt-mapAni 1s ease infinite;\n    -o-animation: xt-mapAni 1s ease infinite;\n    -ms-animation: xt-mapAni 1s ease infinite;\n    animation: xt-mapAni 1s ease infinite\n}\n\n.xt-animation-point p:before {\n    border: 1px solid\n}\n\n.xt-animation-point p {\n    position: absolute;\n    left: 50%;\n    top: 50%;\n    width: 0;\n    height: 0;\n    border-radius: 50%;\n    -webkit-transform: translate(-50%, -50%);\n    -moz-transform: translate(-50%, -50%);\n    -o-transform: translate(-50%, -50%);\n    -ms-transform: translate(-50%, -50%);\n    transform: translate(-50%, -50%);\n    -webkit-animation: xt-mapAni 2s ease infinite;\n    -moz-animation: xt-mapAni 2s ease infinite;\n    -o-animation: xt-mapAni 2s ease infinite;\n    -ms-animation: xt-mapAni 2s ease infinite;\n    animation: xt-mapAni 2s ease infinite\n}\n\n@-webkit-keyframes xt-mapAni {\n    0% {\n        width: 0;\n        height: 0;\n        opacity: 1;\n        filter: alpha(opacity=1)\n    }\n    25% {\n        width: 12px;\n        height: 12px;\n        opacity: .7;\n        filter: alpha(opacity=70)\n    }\n    50% {\n        width: 20px;\n        height: 20px;\n        opacity: .5;\n        filter: alpha(opacity=50)\n    }\n    75% {\n        width: 30px;\n        height: 30px;\n        opacity: .2;\n        filter: alpha(opacity=20)\n    }\n    to {\n        width: 40px;\n        height: 40px;\n        opacity: 0;\n        filter: alpha(opacity=0)\n    }\n}\n\n@-moz-keyframes xt-mapAni {\n    0% {\n        width: 0;\n        height: 0;\n        opacity: 1;\n        filter: alpha(opacity=1)\n    }\n    25% {\n        width: 12px;\n        height: 12px;\n        opacity: .7;\n        filter: alpha(opacity=70)\n    }\n    50% {\n        width: 20px;\n        height: 20px;\n        opacity: .5;\n        filter: alpha(opacity=50)\n    }\n    75% {\n        width: 30px;\n        height: 30px;\n        opacity: .2;\n        filter: alpha(opacity=20)\n    }\n    to {\n        width: 40px;\n        height: 40px;\n        opacity: 0;\n        filter: alpha(opacity=0)\n    }\n}\n\n@-o-keyframes xt-mapAni {\n    0% {\n        width: 0;\n        height: 0;\n        opacity: 1;\n        filter: alpha(opacity=1)\n    }\n    25% {\n        width: 12px;\n        height: 12px;\n        opacity: .7;\n        filter: alpha(opacity=70)\n    }\n    50% {\n        width: 20px;\n        height: 20px;\n        opacity: .5;\n        filter: alpha(opacity=50)\n    }\n    75% {\n        width: 30px;\n        height: 30px;\n        opacity: .2;\n        filter: alpha(opacity=20)\n    }\n    to {\n        width: 40px;\n        height: 40px;\n        opacity: 0;\n        filter: alpha(opacity=0)\n    }\n}\n\n@-ms-keyframes xt-mapAni {\n    0% {\n        width: 0;\n        height: 0;\n        opacity: 1;\n        filter: alpha(opacity=1)\n    }\n    25% {\n        width: 12px;\n        height: 12px;\n        opacity: .7;\n        filter: alpha(opacity=70)\n    }\n    50% {\n        width: 20px;\n        height: 20px;\n        opacity: .5;\n        filter: alpha(opacity=50)\n    }\n    75% {\n        width: 30px;\n        height: 30px;\n        opacity: .2;\n        filter: alpha(opacity=20)\n    }\n    to {\n        width: 40px;\n        height: 40px;\n        opacity: 0;\n        filter: alpha(opacity=0)\n    }\n}\n\n@keyframes xt-mapAni {\n    0% {\n        width: 0;\n        height: 0;\n        opacity: 1;\n        filter: alpha(opacity=1)\n    }\n    25% {\n        width: 12px;\n        height: 12px;\n        opacity: .7;\n        filter: alpha(opacity=70)\n    }\n    50% {\n        width: 20px;\n        height: 20px;\n        opacity: .5;\n        filter: alpha(opacity=50)\n    }\n    75% {\n        width: 30px;\n        height: 30px;\n        opacity: .2;\n        filter: alpha(opacity=20)\n    }\n    to {\n        width: 40px;\n        height: 40px;\n        opacity: 0;\n        filter: alpha(opacity=0)\n    }\n}`, 
  {});
  var entryToSend = (expect(buildLightbox, [{
    "key" : `initDom`,
    "value" : function() {
      this.$htmlContainer = document.createElement("div");
      this.$htmlContainer.style = "position:absolute;left:0px;bottom:0px;pointer-events: none";
      var o = document.createElement("div");
      o.classList.add("xt-animation-point");
      o.style = "color:" + this.cssColor || "red";
      var myP = document.createElement("p");
      o.appendChild(myP);
      this.$htmlContainer.appendChild(o);
      this.viewer.cesiumWidget.container.appendChild(this.$htmlContainer);
      this.viewer.scene.postRender.addEventListener(this.postRenderEvent, this);
    }
  }, {
    "key" : `initEvent`,
    "value" : function() {
      this.viewer.scene.postRender.addEventListener(this.postRenderEventHandle, this);
    }
  }, {
    "key" : "postRenderEventHandle",
    "value" : function() {
      var value = this.viewer.scene.canvas.height;
      var t = new Cesium["Cartesian2"];
      Cesium.SceneTransforms.wgs84ToWindowCoordinates(this.viewer.scene, this.position, t);
      this.$htmlContainer.style.bottom = value - t.y + "px";
      var i = this.$htmlContainer.offsetWidth;
      this.$htmlContainer.style.left = t.x - i / 2 + "px";
      value = this.viewer.camera.position;
      t = this.viewer.scene.globe.ellipsoid.cartesianToCartographic(value).height;
      i = t;
      t = t + this.viewer.scene.globe.ellipsoid.maximumRadius;
      if (Cesium.Cartesian3.distance(value, this.position) > t) {
        this.$htmlContainer.style.display = "none";
      } else {
        this.$htmlContainer.style.display = "block";
        this.$htmlContainer.style.display = i < 8E4 ? "block" : "none";
      }
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.viewer.scene.postRender.removeEventListener(this.postRenderEventHandle, this);
      this.$htmlContainer.remove();
    }
  }]), buildLightbox);
  var forced = (expect(Label, [{
    "key" : `draw`,
    "value" : function() {
      var primaryReplicas = this;
      this.getParticleImage(function() {
        var stringify = hahaha;
        primaryReplicas[stringify(2519)]();
      });
      this.addInner();
      this.addCircle();
      this.addRing();
    }
  }, {
    "key" : `addOuter`,
    "value" : function() {
      var instance = update(this.outer_controlPoints, this.circular_clone_topPoints, {
        "height" : this.extrudedHeight,
        "distanceDisplayCondition" : this._distanceDisplayCondition
      });
      this.primitive1 = new Cesium.Primitive({
        "geometryInstances" : instance,
        "appearance" : new Cesium["EllipsoidSurfaceAppearance"]({
          "material" : new Cesium.Material({
            "fabric" : {
              "uniforms" : {
                "u_color" : this.u_color,
                "image" : this.image
              },
              "source" : "uniform vec4 u_color;\nczm_material czm_getMaterial(czm_materialInput materialInput){\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    vec2 st = materialInput.st;\n    float time = fract(czm_frameNumber / 90.) ;\n    vec2 new_st = fract(st-vec2(time,time));\n    vec4 color = texture2D(image,new_st);\n\n    vec3 diffuse = color.rgb;\n    float alpha = color.a;\n    diffuse *= u_color.rgb;\n    alpha *= u_color.a;\n    alpha *= u_color.a;\n    material.diffuse = diffuse;\n    material.alpha = alpha * pow(1. - st.t,u_color.a);\n    return material;\n}"
            }
          })
        }),
        "asynchronous" : false
      });
      this.viewer.scene.primitives.add(this.primitive1);
    }
  }, {
    "key" : `addInner`,
    "value" : function() {
      var instance = update(this.inner_controlPoints, this.circular_clone_topPoints, {
        "height" : this.extrudedHeight,
        "color" : this.v_color,
        "distanceDisplayCondition" : this._distanceDisplayCondition
      });
      var appearance = new Cesium.EllipsoidSurfaceAppearance({
        "material" : new Cesium.Material({
          "fabric" : {
            "uniforms" : {
              "u_color" : this.u_color
            },
            "source" : `uniform vec4 u_color;\nczm_material czm_getMaterial(czm_materialInput materialInput){\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    vec2 st = materialInput.st;\n    float powerRatio = 1./(fract(czm_frameNumber / 30.0) +  1.) ;\n    float alpha = pow(1. - st.t,powerRatio);\n    vec4 color = vec4(u_color.rgb, alpha*u_color.a);\n    material.diffuse = color.rgb;\n    material.alpha = color.a;\n    return material;\n}`
          }
        })
      });
      this.primitive2 = new Cesium["Primitive"]({
        "geometryInstances" : instance,
        "appearance" : appearance,
        "asynchronous" : false
      });
      this.viewer.scene.primitives.add(this.primitive2);
    }
  }, {
    "key" : `addCircle`,
    "value" : function() {
      var geometry = Cesium.Cartographic.fromCartesian(this.position);
      geometry = createGeometry(this.circlePoints_2, {
        "perPositionHeight" : 1 <= geometry.height,
        "distanceDisplayCondition" : this._distanceDisplayCondition
      });
      this.primitive3 = new Cesium["Primitive"]({
        "geometryInstances" : geometry,
        "appearance" : new Cesium["EllipsoidSurfaceAppearance"]({
          "material" : new Cesium["Material"]({
            "fabric" : {
              "uniforms" : {
                "u_color" : this.u_color,
                "image" : this.gradientCircleCanvas
              },
              "source" : "czm_material czm_getMaterial(czm_materialInput materialInput){\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    vec4 tColor = u_color;\n    vec2 st = materialInput.st;\n    vec2 center = st - vec2(0.5,0.5);\n    float length = length(center)/0.5;\n    float time = 1. - abs(czm_frameNumber / 360. - 0.5);\n\n    float param = 1. - step(length, 0.6);//\u5927\u4e8e0.6\u6a21\u7cca\uff0crate = 0.6\n    float scale = param * length;// 0.6< length \u8fd4\u56de0\uff0c\u53cd\u4e4b\u8fd4\u56de1.\n    float alpha = param * (1.0 - abs(scale - 0.8) / 0.2);// 0.8 < length \u8fd4\u56de0\uff0c\u53cd\u4e4b\u8fd4\u56de1.\n\n    float param1 = step(length, 0.7);//\u5c0f\u4e8e0.5\u6a21\u7cca\n    float scale1 = param1 * length;// 0.6< length \u8fd4\u56de0\uff0c\u53cd\u4e4b\u8fd4\u56de1.\n    alpha += param1 * (1.0 - abs(scale1 - 0.35) / 0.35);// 0.8 < length \u8fd4\u56de0\uff0c\u53cd\u4e4b\u8fd4\u56de1.\n\n    material.diffuse = u_color.rgb * vec3(u_color.a);\n    material.alpha = pow(alpha, 4.0);\n    return material;\n}"
            }
          })
        }),
        "asynchronous" : false
      });
      this.viewer.scene.primitives.add(this.primitive3);
    }
  }, {
    "key" : "addRing",
    "value" : function() {
      var geometry = Cesium.Cartographic.fromCartesian(this.position);
      geometry = createGeometry(this.circlePoints_2, {
        "perPositionHeight" : 1 <= geometry.height,
        "distanceDisplayCondition" : this._distanceDisplayCondition
      });
      this.primitive4 = new Cesium["Primitive"]({
        "geometryInstances" : geometry,
        "appearance" : new Cesium.EllipsoidSurfaceAppearance({
          "material" : new Cesium["Material"]({
            "fabric" : {
              "uniforms" : {
                "u_color" : this.u_color,
                "image" : this.ringCanvas
              },
              "source" : "czm_material czm_getMaterial(czm_materialInput materialInput){\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    vec2 st = materialInput.st;\n    vec2 center = st - vec2(0.5,0.5);\n    float time = -czm_frameNumber * 3.1415926 / 180.;//\u626b\u63cf\u901f\u5ea61\u5ea6\n    float sin_t = sin(time);\n    float cos_t = cos(time);\n    vec2 center_rotate = vec2(center.s*cos_t-center.t*sin_t+0.5,center.s*sin_t+center.t*cos_t+0.5);\n    vec4 color = texture2D(image,center_rotate);\n    vec3 tColor = color.rgb * u_color.rgb;\n    tColor *= u_color.a;\n    material.diffuse = tColor;\n    float length = 2. - length(center)/0.5;\n    material.alpha = color.a * pow(length, 0.5);//color.r = 0 \u62161\n    return material;\n}"
            }
          })
        }),
        "asynchronous" : false
      });
      this.viewer.scene.primitives.add(this.primitive4);
    }
  }, {
    "key" : "destroy",
    "value" : function() {
      if (this.primitive1) {
        this.viewer.scene.primitives.remove(this.primitive1);
      }
      if (this.primitive2) {
        this.viewer.scene.primitives.remove(this.primitive2);
      }
      if (this.primitive3) {
        this.viewer.scene.primitives.remove(this.primitive3);
      }
      if (this.primitive4) {
        this.viewer.scene.primitives.remove(this.primitive4);
      }
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.destroy();
    }
  }, {
    "key" : `getParticleImage`,
    "value" : function(value) {
      var textureimg = new Image;
      textureimg.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAEACAYAAADSoXR2AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTQ1IDc5LjE2MzQ5OSwgMjAxOC8wOC8xMy0xNjo0MDoyMiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTkgKFdpbmRvd3MpIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjExQTg0NDEyMDEzQjExRUFBNDhBRjhGMUMzOUUyNTU0IiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjExQTg0NDEzMDEzQjExRUFBNDhBRjhGMUMzOUUyNTU0Ij4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6MTFBODQ0MTAwMTNCMTFFQUE0OEFGOEYxQzM5RTI1NTQiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6MTFBODQ0MTEwMTNCMTFFQUE0OEFGOEYxQzM5RTI1NTQiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz41vRwAAAAE90lEQVR42uydyW4UMRCG3T2dgYSAEGs4sp44cCJBcGUJbwCvALwWPAI8ABwAiUVwgLBdkEikJEiAGMhkZqhfU1aa1sy0g+yaJPyWSupOpPjz0uVyucrJer2eG2fJ3ZgLAQhAgC0PgN8XIlkqgGLE75oih0WmRVZEvop0rHog18rnRe6IzInsthyCXFt+TuSKyGmRXZZDgK5eFrkv8l7kiUhrxN/JSo3pigSvcNmI1bCh3b5LK2+NqHyvyEF9x3z5HgqRRViOAXhW5JrCoNdei/y20gMYxhmRSyIXRY6JTMT4DENLW+SdyD19x/NajDmwmYIW79Hnn+MA4GJEAAIQgABJbMJB+n5Sl9zWZvR9DABUfkJkVt8fi3zUldAEoKl24Y2S1fPZEmBdZFHkkb4vxTLRQ5djbyUf0ncYrD/UADUB8MZno2Q19yx7gIqIAAQgAAEIQIAtYZT+85LvRnjQCoPKR3rQUgN4Y3ZeK30g8qps0qeeAzDn4TWD9+ySG+BBS90DaGnVg9a2tgnR4il9/jkOACoiAhCAAASIZpAAFl6yulO0JACo/IDrn6CedP1zxOciv6wAYNnAP3RVBeWtJQCWzG8iL/X9g4vkqNzMctzUXtintt2KM/aS+bmQaY90rb8CF6tSKiICEIAABCAAAQiwbfcFIWVCbUcc9bZDLKiYAKj4uOv7Bb+ILLj+8W7PCgC7Jhzv44Qdh9yrru8V61jPgd645gD2io+15RiC5ZA5ENNPmGmDmtrta9YAVEQE2FlrQUM/J6efU8cSAD87ojodBaccS6kgiiErGiq/qe93XT+3oGU5BJnbyKrIUs6BQZoQUEcrQ7CYagiGqeKiMgnXLXsg5uJUm/RQJKy8fGS7PMw6SgVQPrJFGZr0kCfUL/7IFjIzrLGpemBQ0kPbehL6I9vMjUh6oEVEAAIQgAAEIAABdpyj0qcK71YrqGUJANNrv+sHOcAiRpDDM1cTY1BEHk7kqyP/2Ac5vLEEQEG8aDnIoTb5ObZRWg5ywG5o1dX4ClNYxT7IISgJPsXGpLut9MCWU0S5bqkmdAa3LQEwcZDAfkZ3tthQfkwNkVeeD6kiuaUabcp6DpS9YyalrAdQ8bT1EFQVUabarND9fNuyB2gREYAABCAAAQhAAAIQoM770UgBXARCIr/koDogVlzgrWuxemBKd0m4JnBed0+5ZQ9gn3BK5LK+P4y5ewoB8DFiKO91COLFfwVuTCZV1hSoYw1APZCsFIkbN1Haaa87wwiKQe6eT27AEX6esPVVd8/kOOdAz/oz9FE0p+uGIKUeqE5C8xgSKiICEIAABCAAAQhAAAIQgAAEIAABCECA6AA+sbkREyDUUYlKD6ggZwzRkr8tewBhusisv+0in5qE/hFchoZTE0TL4p8sTbtIpyahQ4Ag5fKpSVBmfdDECvQTZjoM0U9N6KgkwH9xY7PXpPiCmq5yuaLVldHIO7jgNi5XfOEhCqNh9udHV/RnC5YAUDTftdV4/ivvwEoRVS9XXPWa1FIT5ird8jpSB+BDN3rO8AaGMnGy0I0QRYTvdk6NkOsucuhGCMAgI8Q0isaHbmAevNMhiD4P6iZhstANGiQE2PEGCRo2NcgAsQDwKnxWFdlT17/duWU1BJmuHz6A5bwbEsCScgh+qAHit3Jr1oooOPExdRBLbeJjSpuwuy30AAH+CDAAPH5ltESNYl4AAAAASUVORK5CYII=";
      textureimg.onload = function() {
        var put_rows = hahaha;
        this[put_rows(1603)] = this[put_rows(534)](textureimg);
        if (value) {
          value();
        }
      }.bind(this);
    }
  }, {
    "key" : `drawCanvas`,
    "value" : function(name) {
      var textedCanvas = document.createElement("canvas");
      textedCanvas.width = 64;
      textedCanvas.height = 256;
      var counts = textedCanvas.getContext("2d");
      return counts.clearRect(0, 0, 64, 256), counts.drawImage(name, 0, 0), counts.drawImage(name, 33, 0), textedCanvas;
    }
  }, {
    "key" : "drawRingCanvas",
    "value" : function() {
      var textedCanvas = document.createElement("canvas");
      textedCanvas.width = 512;
      textedCanvas.height = 512;
      var ctx = textedCanvas.getContext("2d");
      return ctx.fillStyle = "rgba(255,255,255,0)", ctx.strokeStyle = "rgba(255, 255, 255,255)", ctx.setLineDash([50, 50]), ctx.lineWidth = 30, ctx.beginPath(), ctx.arc(256, 256, 150, 0, 2 * Math.PI, true), ctx.stroke(), ctx.restore(), textedCanvas;
    }
  }, {
    "key" : `cirdrawGradientCircleCanvas`,
    "value" : function() {
      var textedCanvas = document.createElement("canvas");
      textedCanvas.width = 512;
      textedCanvas.height = 512;
      var ctx = textedCanvas.getContext("2d");
      var linGrad = ctx.createRadialGradient(256, 256, 0, 256, 256, 256);
      return linGrad.addColorStop(0.1, "rgba(255, 255, 255, 1.0)"), linGrad.addColorStop(0.2, "rgba(255, 255, 255, 0.0)"), linGrad.addColorStop(0.3, "rgba(255, 255, 255, 0.9)"), linGrad.addColorStop(0.5, "rgba(255, 255, 255, 0.0)"), linGrad.addColorStop(0.9, "rgba(255, 255, 255, 0.2)"), linGrad.addColorStop(1, "rgba(255, 255, 255, 1.0)"), ctx.clearRect(0, 0, 512, 512), ctx.beginPath(), ctx.arc(256, 256, 256, 0, 2 * Math.PI, true), ctx.fillStyle = linGrad, ctx.fill(), ctx.restore(), textedCanvas;
    }
  }, {
    "key" : `show`,
    "get" : function() {
      return this._show;
    },
    "set" : function(value) {
      this._show = value;
      if (this.primitive1) {
        this.primitive1.show = value;
      }
      if (this.primitive2) {
        this.primitive2.show = value;
      }
      if (this.primitive3) {
        this.primitive3.show = value;
      }
      if (this.primitive4) {
        this.primitive4.show = value;
      }
    }
  }]), Label);
  xt3d.AdvancedPlugin = {
    "ConeGlow" : data,
    "ConeGlowExt" : forced,
    "Scanline" : descriptor,
    "RotatingDial" : _inherits,
    "HighlightBoundary" : view,
    "BreathingWallPrimitive" : mode,
    "CylinderGlow" : k,
    "AnimatePoint" : entryToSend
  };
  name = (expect(World, [{
    "key" : `addEvent`,
    "value" : function() {
      var obj = this;
      this.tileset.tileVisible.addEventListener(this.tileVisibleEventHandler, this);
      this.handler = new Cesium["ScreenSpaceEventHandler"](this.viewer.scene.canvas);
      this.handler.setInputAction(function(currentItems) {
        var parseInt = hahaha;
        if (obj[parseInt(3055)]) {
          currentItems = obj[parseInt(2276)][parseInt(2758)][parseInt(1708)](currentItems[parseInt(586)]);
          if (obj[parseInt(3035)].feature) {
            obj[parseInt(3035)][parseInt(1566)].color = obj[parseInt(3035)][parseInt(2240)];
            obj[parseInt(3035)].feature = void 0;
          }
          if (currentItems) {
            obj[parseInt(3035)][parseInt(1566)] = currentItems;
            obj.selctedFeature[parseInt(2240)] = currentItems[parseInt(2240)];
            obj[parseInt(3035)].feature[parseInt(2240)] = Cesium[parseInt(2292)][parseInt(2537)];
          }
        }
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
    }
  }, {
    "key" : "tileVisibleEventHandler",
    "value" : function(type) {
      var aggregate = this;
      var that = type.content;
      var malakh = that.featuresLength;
      var $li = 0;
      for (; $li < malakh; $li = $li + 2) {
        !function() {
          var model = that.getFeature($li).content._model;
          if (model && model._sourcePrograms && model._rendererResources) {
            Object.keys(model._sourcePrograms).forEach(function(username) {
              var customMapper = hahaha;
              username = model[customMapper(726)][username];
              if (!aggregate[customMapper(2478)]) {
                aggregate[customMapper(2478)] = model[customMapper(1673)].sourceShaders[username[customMapper(1217)]];
              }
              model[customMapper(1673)][customMapper(1231)][username[customMapper(1217)]] = aggregate[customMapper(1507)];
            });
            model._shouldRegenerateShaders = true;
          }
        }();
      }
    }
  }, {
    "key" : "updateStyle",
    "value" : function(object) {
      this.clickHighlight = object.clickHighlight;
      this.color = object.color || "0.2, 0.5, 1.0, 1.0";
      this.glowRange = object.glowRange;
      this.glowRangeHeight = object.glowRangeHeight || "100.0";
      this.shader = object.shader || this.getShader();
    }
  }, {
    "key" : `getShader`,
    "value" : function() {
      return this.glowRange ? "varying vec3 v_positionEC;\n            void main(void){\n            vec4 position = czm_inverseModelView * vec4(v_positionEC,1); // \u4f4d\u7f6e\n            float glowRange =" + this.glowRangeHeight + "; // \u5149\u73af\u7684\u79fb\u52a8\u8303\u56f4(\u9ad8\u5ea6)\n            gl_FragColor = vec4(" + this.color + "); // \u989c\u8272\n            gl_FragColor *= vec4(vec3(position.z / 100.0), 1.0); // \u6e10\u53d8\n            // \u52a8\u6001\u5149\u73af\n            float time = fract(czm_frameNumber / 360.0);\n            time = abs(time - 0.5) * 2.0;\n            float diff = step(0.005, abs( clamp(position.z / glowRange, 0.0, 1.0) - time));\n            gl_FragColor.rgb += gl_FragColor.rgb * (1.0 - diff);\n        }\n       " : 
      "varying vec3 v_positionEC;\n            void main(void){\n                vec4 position = czm_inverseModelView * vec4(v_positionEC,1); // \u4f4d\u7f6e \n                gl_FragColor = vec4(" + this.color + `); // \u989c\u8272\n                gl_FragColor *= vec4(vec3(position.z / 100.0), 1.0); // \u6e10\u53d8  \n            }\n           `;
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.shader = this.originalShader;
      this.viewer.scene.requestRender();
      if (this.selctedFeature.feature) {
        this.selctedFeature.feature.color = this.selctedFeature.color;
        this.selctedFeature.feature = void 0;
      }
      this.handler.destroy();
    }
  }]), World);
  var pos = (expect(Box, [{
    "key" : "createPrimitive",
    "value" : function(obj) {
      return obj = new Cesium["PolygonGeometry"]({
        "polygonHierarchy" : new Cesium["PolygonHierarchy"](obj),
        "extrudedHeight" : this.style.extrudedHeight || 20
      }), obj = new Cesium["GeometryInstance"]({
        "geometry" : obj
      }), new Cesium["Primitive"]({
        "geometryInstances" : [obj],
        "appearance" : this.getAppear(),
        "releaseGeometryInstances" : false,
        "compressVertices" : false
      });
    }
  }, {
    "key" : `getAppear`,
    "value" : function() {
      return new Cesium.MaterialAppearance({
        "material" : new Cesium["Material"]({
          "fabric" : {
            "type" : "BuildGradientPrimitive",
            "uniforms" : {
              "color" : this.style.color || new Cesium["Color"](0.2, 1, 0, 0.6)
            },
            "source" : "\n                   uniform vec4 color; \n                   czm_material czm_getMaterial(czm_materialInput materialInput)\n                   {\n                       czm_material material = czm_getDefaultMaterial(materialInput); \n                       vec2 st = materialInput.st;  \n                       material.diffuse = color.rgb; \n                       float alpha = pow(st.t,1.0); \n                       material.alpha = color.a  * alpha;                            \n                       return material;\n                   }\n                   "
          },
          "translucent" : true
        }),
        "faceForward" : false,
        "closed" : false
      });
    }
  }]), Box);
  var meta = (expect(copy, [{
    "key" : `addPyramidModel`,
    "value" : function() {
      var primaryReplicas = this;
      var heading = new Cesium["HeadingPitchRoll"](Cesium.Math.toRadians(0), Cesium.Math.toRadians(0), Cesium.Math.toRadians(0));
      var shareWith = Cesium.Math.toRadians(2);
      this.modelEntity = this.viewer.entities.add({
        "position" : this.position,
        "orientation" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
          var stringify = hahaha;
          return heading.heading += shareWith, Cesium[stringify(942)].headingPitchRollQuaternion(primaryReplicas[stringify(586)], heading);
        }, false),
        "model" : {
          "uri" : this.style.modelUrl || "static/glb/pyramid.glb",
          "scale" : this.style.scale || 80,
          "color" : Cesium.Color.YELLOW.withAlpha(0.8),
          "colorBlendMode" : Cesium.ColorBlendMode.MIX
        }
      });
    }
  }, {
    "key" : `addCilcle`,
    "value" : function() {
      var _0x3ade5c = 0;
      this.circle = this.viewer.entities.add({
        "position" : this.position,
        "ellipse" : {
          "height" : this.style.circleHeight || 0,
          "semiMinorAxis" : this.style.circleRadius || 300,
          "semiMajorAxis" : this.style.circleRadius || 300,
          "material" : new Cesium["ImageMaterialProperty"]({
            "image" : this.style.circleImage || "static/images/circle/circular_03.png",
            "transparent" : 0.1
          }),
          "stRotation" : new Cesium.CallbackProperty(function(canCreateDiscussions) {
            return _0x3ade5c = _0x3ade5c - 0.002;
          }, false)
        }
      });
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.viewer.entities.remove(this.modelEntity);
      this.viewer.entities.remove(this.circle);
    }
  }]), copy);
  xt3d.BuildingEffects = {
    "CustomShaderEffect" : name,
    "GradientBuilding" : pos,
    "RotatingPyramid" : meta
  };
  Object.defineProperties(Node.prototype, {
    "isConstant" : {
      "get" : function() {
        return false;
      }
    },
    "definitionChanged" : {
      "get" : function() {
        return this._definitionChanged;
      }
    },
    "color" : Cesium.createPropertyDescriptor(`color`)
  });
  Node.prototype.getType = function(original_full_html) {
    return "DiffCircleMaterial1";
  };
  Node.prototype.getValue = function(time, result) {
    return Cesium.defined(result) || (result = {}), result.color = Cesium.Property.getValueOrClonedDefault(this._color, time, Cesium.Color.WHITE, result.color), result.time = ((new Date).getTime() - this._time) % this.duration / this.duration, result;
  };
  Node.prototype.equals = function(other) {
    return this === other || other instanceof Node && Cesium.Property.equals(this._color, other._color);
  };
  Cesium.Material.DiffCircleMaterial1Type = `DiffCircleMaterial1`;
  Cesium.Material.DiffCircleMaterial1Source = `czm_material czm_getMaterial(czm_materialInput materialInput)\n{\nczm_material material = czm_getDefaultMaterial(materialInput);\nmaterial.diffuse = 1.8 * color.rgb;\nvec2 st = materialInput.st;\nfloat dis = distance(st, vec2(0.5, 0.5));\nfloat per = fract(time);\nif(dis > per * 0.5){\nmaterial.alpha = 0.0;\ndiscard;\n}else {\nmaterial.alpha = color.a  * dis / per / 1.0;\n}\nreturn material;\n}`;
  Cesium.Material._materialCache.addMaterial(Cesium.Material.DiffCircleMaterial1Type, {
    "fabric" : {
      "type" : Cesium.Material.DiffCircleMaterial1Type,
      "uniforms" : {
        "color" : new Cesium[`Color`](1, 0, 0, 1),
        "time" : 0
      },
      "source" : Cesium.Material.DiffCircleMaterial1Source
    },
    "translucent" : function(material) {
      return true;
    }
  });
  var frame = (expect(getDimensions, [{
    "key" : `createEntity`,
    "value" : function() {
      this.circleEntity = this.viewer.entities.add({
        "position" : this.position,
        "ellipse" : {
          "semiMinorAxis" : this.style.radius,
          "semiMajorAxis" : this.style.radius,
          "material" : new Node(this.style)
        }
      });
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.viewer.entities.remove(this.circleEntity);
    }
  }]), getDimensions);
  Object.defineProperties(PolylineGlowProperty.prototype, {
    "isConstant" : {
      "get" : function() {
        return false;
      }
    },
    "definitionChanged" : {
      "get" : function() {
        return this._definitionChanged;
      }
    },
    "color" : Cesium.createPropertyDescriptor(`color`)
  });
  PolylineGlowProperty.prototype.getType = function(original_full_html) {
    return "DiffCircle2Material";
  };
  PolylineGlowProperty.prototype.getValue = function(time, result) {
    return Cesium.defined(result) || (result = {}), result.color = Cesium.Property.getValueOrClonedDefault(this._color, time, Cesium.Color.WHITE, result.color), result.image = this.url, result;
  };
  PolylineGlowProperty.prototype.equals = function(other) {
    return this === other || other instanceof PolylineGlowProperty && Cesium.Property.equals(this._color, other._color);
  };
  Cesium.Material.DiffCircle2MaterialType = `DiffCircle2Material`;
  Cesium.Material.DiffCircle2MaterialSource = `czm_material czm_getMaterial(czm_materialInput materialInput)\n{\n     czm_material material = czm_getDefaultMaterial(materialInput);\n     vec2 st = materialInput.st;\n     vec4 colorImage = texture2D(image,  vec2(st ));\n     material.alpha = colorImage.a * color.a*0.6;\n     material.diffuse =  2.2* color.rgb  ;\n     return material;\n }`;
  Cesium.Material._materialCache.addMaterial(Cesium.Material.DiffCircle2MaterialType, {
    "fabric" : {
      "type" : Cesium.Material.DiffCircle2MaterialType,
      "uniforms" : {
        "color" : new Cesium[`Color`](1, 0, 0, 0.5),
        "image" : "",
        "time" : 0
      },
      "source" : Cesium.Material.DiffCircle2MaterialSource
    },
    "translucent" : function(material) {
      return true;
    }
  });
  var state = (expect(source, [{
    "key" : `createEntity`,
    "value" : function() {
      var same = this;
      var att = 0.1;
      this.circleEntity = this.viewer.entities.add({
        "position" : this.position,
        "ellipse" : {
          "semiMinorAxis" : new Cesium.CallbackProperty(function(canCreateDiscussions) {
            var rel2Mstr = hahaha;
            return (att = att + (same[rel2Mstr(1998)][rel2Mstr(895)] || 8)) > same.maxRadius && (att = 0.1), att;
          }, false),
          "semiMajorAxis" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
            return att;
          }, false),
          "material" : new PolylineGlowProperty(this.style)
        }
      });
    }
  }, {
    "key" : "remove",
    "value" : function() {
      this.viewer.entities.remove(this.circleEntity);
    }
  }]), source);
  Object.defineProperties(GridMaterialProperty.prototype, {
    "isConstant" : {
      "get" : function() {
        return false;
      }
    },
    "definitionChanged" : {
      "get" : function() {
        return this._definitionChanged;
      }
    },
    "color" : Cesium.createPropertyDescriptor(`color`)
  });
  GridMaterialProperty.prototype.getType = function(original_full_html) {
    return "ScanCircle";
  };
  GridMaterialProperty.prototype.getValue = function(time, result) {
    return Cesium.defined(result) || (result = {}), result.color = Cesium.Property.getValueOrClonedDefault(this._color, time, Cesium.Color.WHITE, result.color), result.image = this.url, result;
  };
  GridMaterialProperty.prototype.equals = function(other) {
    return this === other || other instanceof GridMaterialProperty && Cesium.Property.equals(this._color, other._color);
  };
  Cesium.Material.ScanCircleType = "ScanCircle";
  Cesium.Material.ScanCircleSource = `czm_material czm_getMaterial(czm_materialInput materialInput)\n{\n   czm_material material = czm_getDefaultMaterial(materialInput);\n   vec2 st = materialInput.st;\n   vec4 colorImage = texture2D(image,  vec2(st ));\n   material.alpha = colorImage.a * color.a;\n   material.diffuse =  1.5* color.rgb  ;\n   return material;\n}`;
  Cesium.Material._materialCache.addMaterial(Cesium.Material.ScanCircleType, {
    "fabric" : {
      "type" : Cesium.Material.ScanCircleType,
      "uniforms" : {
        "color" : new Cesium[`Color`](1, 0, 0, 0.5),
        "image" : "",
        "time" : 0
      },
      "source" : Cesium.Material.ScanCircleSource
    },
    "translucent" : function(material) {
      return true;
    }
  });
  var ID = (expect(inject, [{
    "key" : `addCircle`,
    "value" : function() {
      var same = this;
      var artistTrack = 360;
      this.circleEntity = this.viewer.entities.add({
        "position" : this.position,
        "ellipse" : {
          "semiMinorAxis" : this.radius,
          "semiMajorAxis" : this.radius,
          "material" : new GridMaterialProperty(this.style),
          "classificationType" : Cesium.ClassificationType.BOTH,
          "stRotation" : new Cesium.CallbackProperty(function(canCreateDiscussions) {
            var rel2Mstr = hahaha;
            return same[rel2Mstr(1998)][rel2Mstr(1119)] ? artistTrack++ : artistTrack--, artistTrack < 0 && (artistTrack = 360), Cesium.Math[rel2Mstr(1544)](artistTrack);
          }, false)
        }
      });
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.viewer.remove(this.circleEntity);
    }
  }]), inject);
  var tel = (expect(parseModel, [{
    "key" : `addRadarScan`,
    "value" : function(name, target, source, value) {
      name = Cesium.Cartographic.fromCartesian(name);
      value = this.createPostStage(this.viewer, name, target, source, value);
      this.viewer.scene.postProcessStages.add(value);
      this.scanPostStage = value;
    }
  }, {
    "key" : `createPostStage`,
    "value" : function(type, value, source, gl, size) {
      var pt = Cesium.Cartographic.toCartesian(value);
      var map__7885__$1 = new Cesium["Cartesian4"](pt.x, pt.y, pt.z, 1);
      pt = new Cesium["Cartographic"](value.longitude, value.latitude, value.height + 500);
      pt = Cesium.Cartographic.toCartesian(pt);
      var computeBoundingRectangleCartesian3 = new Cesium["Cartesian4"](pt.x, pt.y, pt.z, 1);
      value = new Cesium["Cartographic"](value.longitude + Cesium.Math.toRadians(0.001), value.latitude, value.height);
      value = Cesium.Cartographic.toCartesian(value);
      var vertpos = new Cesium["Cartesian4"](value.x, value.y, value.z, 1);
      var g = new Cesium["Quaternion"];
      var __NPO__ = new Cesium.Matrix3;
      var idx = (new Date).getTime();
      var scratchCartesian4Origin = new Cesium["Cartesian4"];
      var _bySchema = new Cesium["Cartesian4"];
      var arc_radius = new Cesium["Cartesian4"];
      var a = new Cesium["Cartesian3"];
      var positionToOccluder = new Cesium["Cartesian3"];
      return new Cesium["PostProcessStage"]({
        "fragmentShader" : this.getScanSegmentShader(),
        "uniforms" : {
          "u_scanCenterEC" : function() {
            var getRandomNumber = hahaha;
            return Cesium[getRandomNumber(1030)][getRandomNumber(1159)](type[getRandomNumber(1306)][getRandomNumber(779)], map__7885__$1, scratchCartesian4Origin);
          },
          "u_scanPlaneNormalEC" : function() {
            var getRandomNumber = hahaha;
            var origin = Cesium[getRandomNumber(1030)].multiplyByVector(type[getRandomNumber(1306)][getRandomNumber(779)], map__7885__$1, scratchCartesian4Origin);
            var p = Cesium[getRandomNumber(1030)][getRandomNumber(1159)](type[getRandomNumber(1306)][getRandomNumber(779)], computeBoundingRectangleCartesian3, _bySchema);
            return a.x = p.x - origin.x, a.y = p.y - origin.y, a.z = p.z - origin.z, Cesium[getRandomNumber(3131)][getRandomNumber(1251)](a, a), a;
          },
          "u_radius" : source,
          "u_scanLineNormalEC" : function() {
            var getRandomNumber = hahaha;
            var origin = Cesium[getRandomNumber(1030)].multiplyByVector(type[getRandomNumber(1306)][getRandomNumber(779)], map__7885__$1, scratchCartesian4Origin);
            var p = Cesium[getRandomNumber(1030)][getRandomNumber(1159)](type[getRandomNumber(1306)]._viewMatrix, computeBoundingRectangleCartesian3, _bySchema);
            var pos = Cesium[getRandomNumber(1030)][getRandomNumber(1159)](type[getRandomNumber(1306)][getRandomNumber(779)], vertpos, arc_radius);
            return a.x = p.x - origin.x, a.y = p.y - origin.y, a.z = p.z - origin.z, Cesium[getRandomNumber(3131)][getRandomNumber(1251)](a, a), positionToOccluder.x = pos.x - origin.x, positionToOccluder.y = pos.y - origin.y, positionToOccluder.z = pos.z - origin.z, origin = ((new Date)[getRandomNumber(3111)]() - idx) % size / size, Cesium.Quaternion[getRandomNumber(1050)](a, origin * Cesium[getRandomNumber(2090)].PI * 2, g), Cesium[getRandomNumber(582)][getRandomNumber(729)](g, __NPO__), Cesium.Matrix3[getRandomNumber(1159)](__NPO__, 
            positionToOccluder, positionToOccluder), Cesium[getRandomNumber(3131)].normalize(positionToOccluder, positionToOccluder), positionToOccluder;
          },
          "u_scanColor" : gl
        }
      });
    }
  }, {
    "key" : "getScanSegmentShader",
    "value" : function() {
      return "uniform sampler2D colorTexture;uniform sampler2D depthTexture;varying vec2 v_textureCoordinates;uniform vec4 u_scanCenterEC;uniform vec3 u_scanPlaneNormalEC;uniform vec3 u_scanLineNormalEC;uniform float u_radius;uniform vec4 u_scanColor;vec4 toEye(in vec2 uv, in float depth) { vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0)); vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0); posInCamera =posInCamera / posInCamera.w; return posInCamera; }bool isPointOnLineRight(in vec3 ptOnLine, in vec3 lineNormal, in vec3 testPt){vec3 v01 = testPt - ptOnLine;normalize(v01);vec3 temp = cross(v01, lineNormal);float d = dot(temp, u_scanPlaneNormalEC);return d > 0.5;}vec3 pointProjectOnPlane(in vec3 planeNormal, in vec3 planeOrigin, in vec3 point){vec3 v01 = point -planeOrigin;float d = dot(planeNormal, v01) ;return (point - planeNormal * d);}float distancePointToLine(in vec3 ptOnLine, in vec3 lineNormal, in vec3 testPt){vec3 tempPt = pointProjectOnPlane(lineNormal, ptOnLine, testPt);return length(tempPt - ptOnLine);}float getDepth(in vec4 depth){float z_window = czm_unpackDepth(depth);z_window = czm_reverseLogDepth(z_window);float n_range = czm_depthRange.near;float f_range = czm_depthRange.far;return (2.0 * z_window - n_range - f_range) / (f_range - n_range);}void main(){gl_FragColor = texture2D(colorTexture, v_textureCoordinates);float depth = getDepth( texture2D(depthTexture, v_textureCoordinates));vec4 viewPos = toEye(v_textureCoordinates, depth);vec3 prjOnPlane = pointProjectOnPlane(u_scanPlaneNormalEC.xyz, u_scanCenterEC.xyz, viewPos.xyz);float dis = length(prjOnPlane.xyz - u_scanCenterEC.xyz);float twou_radius = u_radius * 2.0;if(dis < u_radius){float f0 = 1.0 -abs(u_radius - dis) / u_radius;f0 = pow(f0, 64.0);vec3 lineEndPt = vec3(u_scanCenterEC.xyz) + u_scanLineNormalEC * u_radius;float f = 0.0;if(isPointOnLineRight(u_scanCenterEC.xyz, u_scanLineNormalEC.xyz, prjOnPlane.xyz)){float dis1= length(prjOnPlane.xyz - lineEndPt);f = abs(twou_radius -dis1) / twou_radius;f = pow(f, 3.0);}gl_FragColor = mix(gl_FragColor, u_scanColor, f + f0);}}";
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.viewer.scene.postProcessStages.remove(this.scanPostStage);
    }
  }]), parseModel);
  Object.defineProperties(Animation.prototype, {
    "isConstant" : {
      "get" : function() {
        return false;
      }
    },
    "definitionChanged" : {
      "get" : function() {
        return this._definitionChanged;
      }
    },
    "color" : Cesium.createPropertyDescriptor(`color`)
  });
  Animation.prototype.getType = function(original_full_html) {
    return Cesium.Material.WaveCircleMaterialType;
  };
  Animation.prototype.getValue = function(time, result) {
    return Cesium.defined(result) || (result = {}), result.color = Cesium.Property.getValueOrClonedDefault(this._color, time, Cesium.Color.WHITE, result.color), result.time = ((new Date).getTime() - this._time) % this.duration / this.duration, result.count = this.count, result.gradient = 1 + 10 * (1 - this.gradient), result;
  };
  Animation.prototype.equals = function(other) {
    return this === other || other instanceof Animation && Cesium.Property.equals(this._color, other._color);
  };
  Cesium.Material.WaveCircleMaterialType = `CircleWaveMaterial`;
  Cesium.Material.CircleWaveSource = `czm_material czm_getMaterial(czm_materialInput materialInput)\n \n       {\n \n          czm_material material = czm_getDefaultMaterial(materialInput);\n \n           material.diffuse = 1.5 * color.rgb;\n\n           vec2 st = materialInput.st;\n\n           vec3 str = materialInput.str;\n\n           float dis = distance(st, vec2(0.5, 0.5));\n\n           float per = fract(time);\n\n           if (abs(str.z) > 0.001) {\n\n            discard;\n\n        }\n\n        if (dis > 0.5) { \n\n            discard; \n\n        } else { \n\n            float perDis = 0.5 / count;\n\n            float disNum; \n\n            float bl = .0; \n\n            for (int i = 0; i <= 999; i++) { \n\n                if (float(i) <= count) { \n\n                    disNum = perDis *float(i) - dis + per / count; \n\n                    if (disNum > 0.0) { \n \n                        if (disNum < perDis) { \n\n                            bl = 1.0 - disNum / perDis;\n\n                        }\n  \n                        else if(disNum - perDis < perDis) { \n \n                            bl = 1.0 - abs(1.0 - disNum / perDis); \n\n                        } \n  \n                        material.alpha = pow(bl, gradient); \n\n                    } \n\n                } \n\n            } \n\n        } \n\n        return material; \n\n    } \n`;
  Cesium.Material._materialCache.addMaterial(Cesium.Material.WaveCircleMaterialType, {
    "fabric" : {
      "type" : Cesium.Material.WaveCircleMaterialType,
      "uniforms" : {
        "color" : new Cesium[`Color`](1, 0, 0, 1),
        "time" : 1,
        "count" : 1,
        "gradient" : 0.1
      },
      "source" : Cesium.Material.CircleWaveSource
    },
    "translucent" : function(material) {
      return true;
    }
  });
  Cesium.WaveCircleMaterialProperty = Animation;
  output = (expect(attribute, [{
    "key" : `addCircle`,
    "value" : function() {
      this.circleEntity = this.viewer.entities.add({
        "position" : this.position,
        "ellipse" : {
          "height" : this.style.height || 0,
          "semiMinorAxis" : this.radius,
          "semiMajorAxis" : this.radius,
          "material" : new Animation(this.style)
        }
      });
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.viewer.remove(this.circleEntity);
    }
  }]), attribute);
  xt3d.CircleObject = {
    "DiffCircle1" : frame,
    "DiffCircle2" : state,
    "ScanCircle" : ID,
    "ScanRadar" : tel,
    "WaveCircle" : output
  };
  var location = (expect(v, [{
    "key" : `activate`,
    "value" : function() {
      var same = this;
      if (this.entity) {
        this.deactivate();
      }
      this.heading = 0;
      this.offset = new Cesium.HeadingPitchRange(Cesium.Math.toRadians(this.heading), Cesium.Math.toRadians(-45), 2E3);
      this.entity = this.viewer.entities.add({
        "position" : this.position,
        "point" : {
          "pixelSize" : 10,
          "color" : Cesium.Color.RED.withAlpha(0.01)
        }
      });
      this.viewer.zoomTo(this.entity, this.offset).then(function() {
        var rel2Mstr = hahaha;
        same[rel2Mstr(2276)][rel2Mstr(2758)].screenSpaceCameraController[rel2Mstr(2010)] = false;
        same[rel2Mstr(2276)][rel2Mstr(617)].onTick[rel2Mstr(448)](same[rel2Mstr(3071)], same);
      });
    }
  }, {
    "key" : "postRenderEvent",
    "value" : function() {
      this.heading -= this.rAngle;
      this.offset = new Cesium["HeadingPitchRange"](Cesium.Math.toRadians(this.heading), Cesium.Math.toRadians(-45), 2E3);
      this.viewer.zoomTo(this.entity, this.offset);
    }
  }, {
    "key" : "deactivate",
    "value" : function() {
      this.viewer.clock.onTick.removeEventListener(this.postRenderEvent, this);
      this.viewer.scene.screenSpaceCameraController.enableInputs = true;
      this.viewer.entities.remove(this.entity);
      this.entity = void 0;
    }
  }]), v);
  expect(selected, [{
    "key" : `addBookmark`,
    "value" : function(name) {
      this.bookmarkList.push(name);
    }
  }, {
    "key" : `getBookmarkList`,
    "value" : function() {
      return this.bookmarkList;
    }
  }, {
    "key" : `getSceneImage`,
    "value" : function(name, obj) {
      var data = this.viewer.scene.canvas;
      var img = new Image;
      return img.src = data.toDataURL("image/png"), new Promise(function(saveNotifs, canCreateDiscussions) {
        var put_rows = hahaha;
        img[put_rows(2887)] = function() {
          var getRefreshTokenKey = put_rows;
          (data = document[getRefreshTokenKey(1442)](getRefreshTokenKey(2818)))[getRefreshTokenKey(807)] = obj;
          data[getRefreshTokenKey(1132)] = name;
          data[getRefreshTokenKey(1714)]("2d").drawImage(img, 0, 0, data[getRefreshTokenKey(807)], data[getRefreshTokenKey(1132)]);
          saveNotifs(data[getRefreshTokenKey(555)](getRefreshTokenKey(777)));
        };
      });
    }
  }, {
    "key" : `createBookmark`,
    "value" : function(name, target, source) {
      var channel = this;
      var obj = this.viewer.scene;
      return new Promise(function(onSuccess, canCreateDiscussions) {
        var put_rows = hahaha;
        channel[put_rows(3170)](target, source)[put_rows(862)](function(thumb) {
          var parseInt = put_rows;
          onSuccess({
            "id" : (new Date)[parseInt(3111)](),
            "img" : thumb,
            "name" : name,
            "cameraView" : {
              "destination" : {
                "x" : obj[parseInt(1306)].position.x,
                "y" : obj[parseInt(1306)][parseInt(586)].y,
                "z" : obj[parseInt(1306)][parseInt(586)].z
              },
              "orientation" : {
                "heading" : obj[parseInt(1306)][parseInt(1604)],
                "pitch" : obj[parseInt(1306)].pitch,
                "roll" : obj.camera[parseInt(453)]
              }
            }
          });
        });
      });
    }
  }, {
    "key" : `getBookmark`,
    "value" : function(name) {
      var i = 0;
      for (; i < this.bookmarkList.length; i++) {
        if (this.bookmarkList[i].id == name) {
          return this.bookmarkList[i];
        }
      }
    }
  }, {
    "key" : `removeBookmark`,
    "value" : function(name) {
      var i = 0;
      for (; i < this.bookmarkList.length; i++) {
        if (this.bookmarkList[i].id == name) {
          this.bookmarkList.splice(i, 1);
          break;
        }
      }
    }
  }]);
  doc = selected;
  expect(emit, [{
    "key" : "initLimit",
    "value" : function() {
      this.addLimitEllipsoid(this.position, this.options.radius || 1E3);
      this.viewer.camera.moveEnd.addEventListener(this.cameraMoveEndEventHnadle, this);
    }
  }, {
    "key" : "cameraMoveEndEventHnadle",
    "value" : function() {
      var v = this.viewer.camera.position;
      if (2E3 < Cesium.Cartesian3.distance(v, Cesium.Cartesian3.fromDegrees(108, 25, 0))) {
        this.viewer.camera.flyTo(this.defaultView);
      } else {
        this.defaultView = {
          "destination" : Cesium.Cartesian3.clone(this.viewer.camera.position),
          "orientation" : {
            "heading" : this.viewer.camera.heading,
            "pitch" : this.viewer.camera.pitch,
            "roll" : this.viewer.camera.roll
          },
          "duration" : 1
        };
      }
    }
  }, {
    "key" : `addLimitEllipsoid`,
    "value" : function(value, target) {
      this.ellipsoid = this.viewer.entities.add({
        "position" : value,
        "show" : this.options.debugExtent,
        "ellipsoid" : {
          "radii" : new Cesium["Cartesian3"](target, target, target),
          "maximumCone" : Cesium.Math.toRadians(90),
          "material" : Cesium.Color.RED.withAlpha(0.1),
          "subdivisions" : 128,
          "stackPartitions" : 32,
          "slicePartitions" : 32,
          "outline" : true,
          "outlineColor" : Cesium.Color.AQUA.withAlpha(1)
        }
      });
    }
  }, {
    "key" : `destroy`,
    "value" : function() {
      this.viewer.camera.moveEnd.removeEventListener(this.cameraMoveEndEventHnadle, this);
      this.viewer.entities.remove(this.ellipsoid);
    }
  }]);
  init = emit;
  expect(path, [{
    "key" : `activate`,
    "value" : function() {
      if (this.removeEvent) {
        this.deactivate();
      }
      this.removeEvent = this.viewer.scene.postRender.addEventListener(this.postRenderEvent, this);
    }
  }, {
    "key" : `postRenderEvent`,
    "value" : function() {
      this.viewer.scene.camera.rotate(Cesium.Cartesian3.UNIT_Z, this.rAngle);
    }
  }, {
    "key" : `deactivate`,
    "value" : function() {
      this.viewer.scene.postRender.removeEventListener(this.postRenderEvent, this);
      this.removeEvent = void 0;
    }
  }]);
  data = path;
  expect(fullName, [{
    "key" : "getValue",
    "value" : function() {
      var e = new Cesium["Cartesian2"](this.viewer.canvas.clientWidth / 2, this.viewer.canvas.clientHeight / 2);
      var point = this.viewer.camera.pickEllipsoid(e);
      if (point = point || this.viewer.scene.pickPosition(e)) {
        var latlng = Cesium.Ellipsoid.WGS84.cartesianToCartographic(point);
        e = 180 * latlng.longitude / Math.PI;
        point = 180 * latlng.latitude / Math.PI;
        return Cesium.Cartesian3.fromDegrees(e, point, latlng.height);
      }
    }
  }]);
  forced = fullName;
  expect(label, [{
    "key" : "activate",
    "value" : function() {
      var options = this.opts || {};
      var rpm_traffic = this;
      var self = this.viewer;
      var point = options.center || this.getCameraView(this.viewer);
      this._isFlyAnimation = true;
      self.camera.setView({
        "destination" : Cesium.Cartesian3.fromDegrees(-85.16, 13.71, 23E6)
      });
      self.camera.flyTo({
        "destination" : Cesium.Cartesian3.fromDegrees(point.x, point.y, 23E6),
        "duration" : options.duration1 || 2,
        "easingFunction" : Cesium.EasingFunction.LINEAR_NONE,
        "complete" : function() {
          var start = hahaha;
          var height = Cesium[start(1367)](point.z, 9E4);
          if (height < 2E5 && -90 != point[start(2420)]) {
            height = 1.2 * height + 8E3;
            self[start(1306)].flyTo({
              "destination" : Cesium[start(3131)][start(2770)](point.x, point.y, height),
              "duration" : options[start(2706)] || 2,
              "easingFunction" : options[start(2463)],
              "complete" : function() {
                var now = start;
                rpm_traffic[now(1037)](point, {
                  "duration" : options[now(980)] || 2,
                  "easingFunction" : options[now(850)],
                  "complete" : function() {
                    var max = now;
                    rpm_traffic._isFlyAnimation = false;
                    if (options.callback) {
                      options[max(3100)]();
                    }
                  }
                });
              }
            });
          } else {
            rpm_traffic[start(1037)](point, {
              "duration" : options[start(980)] || 2,
              "easingFunction" : options[start(850)],
              "complete" : function() {
                var state = start;
                rpm_traffic._isFlyAnimation = false;
                if (options[state(3100)]) {
                  options[state(3100)]();
                }
              }
            });
          }
        }
      });
    }
  }, {
    "key" : `getCameraView`,
    "value" : function(obj) {
      var camera = obj.camera;
      var position = camera.positionCartographic;
      obj = {};
      return obj.y = Cesium.Math.toDegrees(position.latitude), obj.x = Cesium.Math.toDegrees(position.longitude), obj.z = position.height, obj.heading = Cesium.Math.toDegrees(camera.heading || 0) % 360, obj.pitch = Cesium.Math.toDegrees(camera.pitch || 0) % 360, obj.roll = Cesium.Math.toDegrees(camera.roll || 0) % 360, obj;
    }
  }, {
    "key" : `centerAt`,
    "value" : function(e, options) {
      if (null == options && (options = {}), null == e && (options.isWgs84 = true, e = this.config.extent || this.config.center), null != e) {
        var name;
        var a;
        var y;
        var output;
        var timeDefaults;
        var x;
        var w;
        var self = {};
        for (name in options) {
          self[name] = options[name];
        }
        if (e.xmin && e.xmax && e.ymin && e.ymax) {
          output = ((a = e.xmin) + (x = e.xmax)) / 2;
          timeDefaults = ((y = e.ymin) + (w = e.ymax)) / 2;
          x = Cesium.Rectangle.fromDegrees(a, y, x, w);
          w = Math.max(x.height, x.width);
          x = Cesium.Math.chordLength(w, this.viewer.scene.globe.ellipsoid.maximumRadius);
          if (0 == (w = Cesium.defaultValue(e.height, 0))) {
            w = point.getSurfaceHeight(this.viewer.scene, Cesium.Cartesian3.fromDegrees(output, timeDefaults));
          }
          self.destination = Cesium.Cartesian3.fromDegrees(output, timeDefaults, x + w);
        } else {
          w = Cesium.defaultValue(self.minz, 2500);
          if (this.viewer.camera.positionCartographic.height < w) {
            w = this.viewer.camera.positionCartographic.height;
          }
          if (null != e.z && 0 != e.z) {
            w = e.z;
          }
          self.destination = Cesium.Cartesian3.fromDegrees(e.x, e.y, w);
        }
        self.orientation = {
          "heading" : Cesium.Math.toRadians(Cesium.defaultValue(e.heading, 0)),
          "pitch" : Cesium.Math.toRadians(Cesium.defaultValue(e.pitch, -90)),
          "roll" : Cesium.Math.toRadians(Cesium.defaultValue(e.roll, 0))
        };
        this.viewer.camera.flyTo(self);
      }
    }
  }, {
    "key" : `deactivate`,
    "value" : function() {
      this.viewer.camera.cancelFlight();
    }
  }]);
  descriptor = label;
  expect(getResult, [{
    "key" : "activate",
    "value" : function() {
      if (this.isStart) {
        this.deactivate();
      }
      var self = this.viewer;
      this.angle = 360 / this.totalTime;
      this.time = self.clock.currentTime.clone();
      this.heading = self.camera.heading;
      this.pitch = self.camera.pitch;
      this.viewer.clock.shouldAnimate = true;
      this.viewer.clock.onTick.addEventListener(this.clock_onTickHandler, this);
      this.isStart = true;
    }
  }, {
    "key" : `clock_onTickHandler`,
    "value" : function() {
      var i = Cesium.JulianDate.secondsDifference(this.viewer.clock.currentTime, this.time);
      i = Cesium.Math.toRadians(i * this.angle) + this.heading;
      this.viewer.scene.camera.setView({
        "orientation" : {
          "heading" : i,
          "pitch" : this.pitch
        }
      });
    }
  }, {
    "key" : `deactivate`,
    "value" : function() {
      if (this.isStart) {
        this.viewer.clock.onTick.removeEventListener(this.clock_onTickHandler, this);
        this.isStart = false;
      }
    }
  }]);
  _inherits = getResult;
  xt3d.CameraDominate = {
    "WindingPoint" : location,
    "BookmarkManager" : doc,
    "CameraLimit" : init,
    "GlobeRotate" : data,
    "CenterPosition" : forced,
    "StartAnimation" : descriptor,
    "AroundPoint" : _inherits
  };
  expect(selector, [{
    "key" : `initEvents`,
    "value" : function() {
      var map = this;
      (new Cesium["ScreenSpaceEventHandler"](this.viewer.scene.canvas)).setInputAction(function(result) {
        var parseInt = hahaha;
        if (map[parseInt(2535)]) {
          map[parseInt(607)][parseInt(2477)](void 0);
          if (result = map[parseInt(2276)].scene.pickPosition(result[parseInt(586)])) {
            map[parseInt(1462)] = result;
            result = Cesium[parseInt(1543)][parseInt(2206)](result);
            result = [Cesium[parseInt(2090)].toDegrees(result[parseInt(2596)]), Cesium[parseInt(2090)][parseInt(1611)](result[parseInt(480)])];
            map[parseInt(1234)](result);
          }
        }
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
    }
  }, {
    "key" : `queryByPoint`,
    "value" : function(target) {
      var completer = this;
      target = this.fdDataServerBaseUrl + '&filter=<Filter xmlns="http://www.opengis.net/ogc" xmlns:gml="http://www.opengis.net/gml"><Intersects><PropertyName>the_geom</PropertyName><gml:Point><gml:coordinates>' + target[0] + "," + target[1] + "</gml:coordinates></gml:Point></Intersects></Filter>";
      fetch(target).then(function(primaryReplicas) {
        var stringify = hahaha;
        return primaryReplicas[stringify(696)]();
      }).then(function(strategies) {
        completer.handleQueryResult(strategies);
      }).catch(function(body) {
        var put_rows = hahaha;
        console[put_rows(1012)](body);
      });
    }
  }, {
    "key" : `handleQueryResult`,
    "value" : function(target) {
      this.clearQueryResult();
      var entity = target.features[0];
      if (entity) {
        target = entity.geometry;
        entity = entity.properties;
        this.BuildingSelectedEvent.raiseEvent(entity, this.mouseClickPosition);
        var crossfilterable_layers = void 0;
        var layerList = [];
        if ("MultiPolygon" == target.type) {
          crossfilterable_layers = target.coordinates[0][0];
        } else {
          if ("Polygon" == target.type) {
            crossfilterable_layers = target.coordinates[0];
          }
        }
        var layer_i = 0;
        for (; layer_i < crossfilterable_layers.length; layer_i++) {
          var layer = crossfilterable_layers[layer_i];
          layerList.push(layer[0]);
          layerList.push(layer[1]);
          layerList.push(0);
        }
        this.addClampFeature(layerList);
      }
    }
  }, {
    "key" : `addClampFeature`,
    "value" : function(name) {
      this.clampFeature = this.viewer.entities.add({
        "polygon" : {
          "hierarchy" : new Cesium.PolygonHierarchy(Cesium.Cartesian3.fromDegreesArrayHeights(name)),
          "classificationType" : Cesium.ClassificationType.CESIUM_3D_TILE,
          "material" : Cesium.Color.RED.withAlpha(0.5)
        }
      });
    }
  }, {
    "key" : `clearQueryResult`,
    "value" : function() {
      if (this.clampFeature) {
        this.viewer.entities.remove(this.clampFeature);
        this.clampFeature = void 0;
      }
    }
  }, {
    "key" : `activate`,
    "value" : function() {
      this.isActivate = true;
    }
  }, {
    "key" : `deactivate`,
    "value" : function() {
      this.isActivate = false;
    }
  }]);
  view = selector;
  expect(addEvent, [{
    "key" : `initEvents`,
    "value" : function() {
      var o = this;
      (new Cesium["ScreenSpaceEventHandler"](this.viewer.scene.canvas)).setInputAction(function(options) {
        var camelize = hahaha;
        if (o[camelize(2535)]) {
          o[camelize(2739)][camelize(2477)](void 0);
          var element = o.viewer[camelize(2758)].pick(options[camelize(586)]);
          if (element) {
            if (element[camelize(1023)] && element[camelize(1023)] instanceof Cesium[camelize(1092)]) {
              return void o[camelize(492)](element);
            }
            if (element.id && camelize(2735) == element.id[camelize(1720)]) {
              return;
            }
          }
          options = o[camelize(2276)].scene[camelize(1238)](options[camelize(586)]);
          if (options) {
            options = Cesium.Cartographic[camelize(2206)](options);
            options = [Cesium[camelize(2090)][camelize(1611)](options.longitude), Cesium[camelize(2090)].toDegrees(options[camelize(480)])];
            o[camelize(1234)](options);
          }
        }
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
    }
  }, {
    "key" : `queryByPoint`,
    "value" : function(target) {
      var primaryReplicas = this;
      target = this.fcDataServerBaseUrl + '&filter=<Filter xmlns="http://www.opengis.net/ogc" xmlns:gml="http://www.opengis.net/gml"><Intersects><PropertyName>the_geom</PropertyName><gml:Point><gml:coordinates>' + target[0] + "," + target[1] + "</gml:coordinates></gml:Point></Intersects></Filter>";
      fetch(target).then(function(rawResp) {
        return rawResp.json();
      }).then(function(data) {
        var stringify = hahaha;
        primaryReplicas[stringify(736)](data);
      }).catch(function(body) {
        var put_rows = hahaha;
        console[put_rows(1012)](body);
      });
    }
  }, {
    "key" : "handleQueryResult",
    "value" : function(target) {
      var geom = this;
      this.clearPrimitives();
      if (!(target.features.length < 1)) {
        this.queryResultFeatures = target.features;
        target.features.forEach(function(primitive) {
          geom.addPrimitive(primitive);
        });
      }
    }
  }, {
    "key" : `addPrimitive`,
    "value" : function(value) {
      var meta = value.properties;
      value = turf.buffer(value, 0.8, {
        "units" : "meters"
      });
      value = this.getDegreesArrayHeights(value);
      value = new Cesium["PolygonGeometry"]({
        "polygonHierarchy" : new Cesium["PolygonHierarchy"](Cesium.Cartesian3.fromDegreesArrayHeights(value)),
        "perPositionHeight" : true,
        "extrudedHeight" : meta.BaseHeight + meta.FloorHeigh
      });
      meta = meta.BuildCode + meta.FloorNumbe;
      value = this.createExtrudedPolygon(meta, value);
      this.fcPrimitives.push(value);
    }
  }, {
    "key" : `clearPrimitives`,
    "value" : function() {
      var same = this;
      this.fcPrimitives.forEach(function(mmCoreSplitViewBlock) {
        var rel2Mstr = hahaha;
        same[rel2Mstr(2276)][rel2Mstr(2758)][rel2Mstr(2798)][rel2Mstr(508)](mmCoreSplitViewBlock);
      });
      this.fcPrimitives = [];
      this.viewer.entities.remove(this.highlightFloorEntity);
    }
  }, {
    "key" : `createExtrudedPolygon`,
    "value" : function(name, options) {
      return this.viewer.scene.primitives.add(new Cesium.ClassificationPrimitive({
        "geometryInstances" : new Cesium["GeometryInstance"]({
          "geometry" : Cesium.PolygonGeometry.createGeometry(options),
          "attributes" : {
            "color" : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.fromRandom({
              "alpha" : 0.8
            })),
            "show" : new Cesium["ShowGeometryInstanceAttribute"](true)
          },
          "id" : name
        }),
        "classificationType" : Cesium.ClassificationType.CESIUM_3D_TILE
      }));
    }
  }, {
    "key" : `getDegreesArrayHeights`,
    "value" : function(obj) {
      var indexesOfNeedle = [];
      var crossfilterable_layers = void 0;
      if ("MultiPolygon" == obj.geometry.type) {
        crossfilterable_layers = obj.geometry.coordinates[0][0];
      } else {
        if ("Polygon" == obj.geometry.type) {
          crossfilterable_layers = obj.geometry.coordinates[0];
        }
      }
      var layer_i = 0;
      for (; layer_i < crossfilterable_layers.length; layer_i++) {
        var layer = crossfilterable_layers[layer_i];
        indexesOfNeedle.push(layer[0]);
        indexesOfNeedle.push(layer[1]);
        indexesOfNeedle.push(obj.properties.BaseHeight);
      }
      return indexesOfNeedle;
    }
  }, {
    "key" : `handlePickFloor`,
    "value" : function(obj) {
      if (this.clickHighlightPrimitive) {
        this.clickHighlightPrimitive.show = true;
      }
      obj.primitive.show = false;
      this.clickHighlightPrimitive = obj.primitive;
      var result = this.getFeatureByPrimitiveId(obj.id);
      this.FloorSelectedEvent.raiseEvent(result);
      result = turf.buffer(result, 1, {
        "units" : "meters"
      });
      this.viewer.entities.remove(this.highlightFloorEntity);
      obj = this.getDegreesArrayHeights(result);
      this.highlightFloorEntity = this.viewer.entities.add({
        "type" : "highlightFloorEntity",
        "polygon" : {
          "hierarchy" : new Cesium.PolygonHierarchy(Cesium.Cartesian3.fromDegreesArrayHeights(obj)),
          "perPositionHeight" : true,
          "extrudedHeight" : result.properties.BaseHeight + result.properties.FloorHeigh,
          "material" : Cesium.Color.RED.withAlpha(0.7)
        }
      });
    }
  }, {
    "key" : "getFeatureByPrimitiveId",
    "value" : function(name) {
      var i = 0;
      for (; i < this.queryResultFeatures.length; i++) {
        var tags = this.queryResultFeatures[i].properties;
        if (tags.BuildCode + tags.FloorNumbe == name) {
          return this.queryResultFeatures[i];
        }
      }
    }
  }, {
    "key" : "activate",
    "value" : function() {
      this.isActivate = true;
    }
  }, {
    "key" : `deactivate`,
    "value" : function() {
      this.isActivate = false;
    }
  }]);
  mode = addEvent;
  expect(fireEvent, [{
    "key" : `initEvents`,
    "value" : function() {
      var same = this;
      (new Cesium["ScreenSpaceEventHandler"](this.viewer.scene.canvas)).setInputAction(function(result) {
        var rel2Mstr = hahaha;
        if (same[rel2Mstr(2535)]) {
          var el = same[rel2Mstr(2276)][rel2Mstr(2758)][rel2Mstr(1708)](result[rel2Mstr(586)]);
          if (el) {
            if (el[rel2Mstr(1023)] && el[rel2Mstr(1023)] instanceof Cesium.ClassificationPrimitive) {
              return void same[rel2Mstr(1843)](el);
            }
            if (el.id && rel2Mstr(2735) == el.id[rel2Mstr(1720)]) {
              return;
            }
          }
          el = same[rel2Mstr(2276)].scene[rel2Mstr(1238)](result.position);
          if (el) {
            result = Cesium[rel2Mstr(1543)][rel2Mstr(2206)](el);
            el = [Cesium[rel2Mstr(2090)][rel2Mstr(1611)](result.longitude), Cesium.Math[rel2Mstr(1611)](result[rel2Mstr(480)])];
            same[rel2Mstr(1234)](el, result[rel2Mstr(1132)]);
          }
        }
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
    }
  }, {
    "key" : `queryByPoint`,
    "value" : function(value, target) {
      var primaryReplicas = this;
      this.mouseClickHeight = target;
      value = this.fcDataServerBaseUrl + '&filter=<Filter xmlns="http://www.opengis.net/ogc" xmlns:gml="http://www.opengis.net/gml"><Intersects><PropertyName>the_geom</PropertyName><gml:Point><gml:coordinates>' + value[0] + "," + value[1] + "</gml:coordinates></gml:Point></Intersects></Filter>";
      fetch(value).then(function(primaryReplicas) {
        var stringify = hahaha;
        return primaryReplicas[stringify(696)]();
      }).then(function(data) {
        var stringify = hahaha;
        primaryReplicas[stringify(2421)](data);
      }).catch(function(body) {
        var put_rows = hahaha;
        console[put_rows(1012)](body);
      });
    }
  }, {
    "key" : "handleFcQueryResult",
    "value" : function(target) {
      if (this.clearPrimitives(), this.HouseSelectedEvent.raiseEvent(void 0), !(target.features.length < 1)) {
        var artistTrack;
        var GET_AUTH_URL_TIMEOUT;
        var current = void 0;
        var i = 0;
        for (; i < target.features.length; i++) {
          var group = target.features[i];
          if (this.mouseClickHeight >= group.properties.BaseHeight && this.mouseClickHeight <= group.properties.TopHeight) {
            current = group;
            break;
          }
        }
        if (current) {
          artistTrack = current.properties.BuildCode;
          GET_AUTH_URL_TIMEOUT = current.properties.FloorNumbe;
          this.queryBySQL(artistTrack, GET_AUTH_URL_TIMEOUT);
        }
      }
    }
  }, {
    "key" : `queryBySQL`,
    "value" : function(name, value) {
      var primaryReplicas = this;
      value = this.fhDataServerBaseUrl + "&cql_filter=BuildCode=" + name + " and FloorNumbe=" + value;
      fetch(value).then(function(primaryReplicas) {
        var stringify = hahaha;
        return primaryReplicas[stringify(696)]();
      }).then(function(data) {
        var stringify = hahaha;
        primaryReplicas[stringify(1867)](data);
      }).catch(function(body) {
        var put_rows = hahaha;
        console[put_rows(1012)](body);
      });
    }
  }, {
    "key" : `handleFhQueryResult`,
    "value" : function(target) {
      var primaryReplicas = this;
      if (!(target.features.length < 1)) {
        this.queryResultFeatures = target.features;
        target.features.forEach(function(data) {
          var stringify = hahaha;
          primaryReplicas[stringify(922)](data);
        });
      }
    }
  }, {
    "key" : `addPrimitive`,
    "value" : function(value) {
      var meta = value.properties;
      value = turf.buffer(value, 0.8, {
        "units" : "meters"
      });
      value = this.getDegreesArrayHeights(value);
      value = new Cesium["PolygonGeometry"]({
        "polygonHierarchy" : new Cesium.PolygonHierarchy(Cesium.Cartesian3.fromDegreesArrayHeights(value)),
        "perPositionHeight" : true,
        "extrudedHeight" : meta.BaseHeight + meta.FloorHeigh
      });
      meta = meta.BuildCode + meta.FloorNumbe + meta.HouseCode;
      value = this.createExtrudedPolygon(meta, value);
      this.fhPrimitives.push(value);
    }
  }, {
    "key" : "clearPrimitives",
    "value" : function() {
      var lithe = this;
      this.fhPrimitives.forEach(function(mmCoreSplitViewBlock) {
        var resolve = hahaha;
        lithe.viewer[resolve(2758)][resolve(2798)][resolve(508)](mmCoreSplitViewBlock);
      });
      this.fhPrimitives = [];
      this.viewer.entities.remove(this.highlightFloorEntity);
    }
  }, {
    "key" : `createExtrudedPolygon`,
    "value" : function(name, options) {
      return this.viewer.scene.primitives.add(new Cesium["ClassificationPrimitive"]({
        "geometryInstances" : new Cesium["GeometryInstance"]({
          "geometry" : Cesium.PolygonGeometry.createGeometry(options),
          "attributes" : {
            "color" : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.fromRandom({
              "alpha" : 0.8
            })),
            "show" : new Cesium["ShowGeometryInstanceAttribute"](true)
          },
          "id" : name
        }),
        "classificationType" : Cesium.ClassificationType.CESIUM_3D_TILE
      }));
    }
  }, {
    "key" : `getDegreesArrayHeights`,
    "value" : function(obj) {
      var indexesOfNeedle = [];
      var crossfilterable_layers = void 0;
      if ("MultiPolygon" == obj.geometry.type) {
        crossfilterable_layers = obj.geometry.coordinates[0][0];
      } else {
        if ("Polygon" == obj.geometry.type) {
          crossfilterable_layers = obj.geometry.coordinates[0];
        }
      }
      var layer_i = 0;
      for (; layer_i < crossfilterable_layers.length; layer_i++) {
        var layer = crossfilterable_layers[layer_i];
        indexesOfNeedle.push(layer[0]);
        indexesOfNeedle.push(layer[1]);
        indexesOfNeedle.push(obj.properties.BaseHeight);
      }
      return indexesOfNeedle;
    }
  }, {
    "key" : `handlePickHouse`,
    "value" : function(obj) {
      if (this.clickHighlightPrimitive) {
        this.clickHighlightPrimitive.show = true;
      }
      obj.primitive.show = false;
      this.clickHighlightPrimitive = obj.primitive;
      var result = this.getFeatureByPrimitiveId(obj.id);
      this.HouseSelectedEvent.raiseEvent(result);
      result = turf.buffer(result, 1, {
        "units" : "meters"
      });
      this.viewer.entities.remove(this.highlightFloorEntity);
      obj = this.getDegreesArrayHeights(result);
      this.highlightFloorEntity = this.viewer.entities.add({
        "type" : "highlightFloorEntity",
        "polygon" : {
          "hierarchy" : new Cesium.PolygonHierarchy(Cesium.Cartesian3.fromDegreesArrayHeights(obj)),
          "perPositionHeight" : true,
          "extrudedHeight" : result.properties.BaseHeight + result.properties.FloorHeigh,
          "material" : Cesium.Color.RED.withAlpha(0.7)
        }
      });
    }
  }, {
    "key" : `getFeatureByPrimitiveId`,
    "value" : function(name) {
      var i = 0;
      for (; i < this.queryResultFeatures.length; i++) {
        var tags = this.queryResultFeatures[i].properties;
        if (tags.BuildCode + tags.FloorNumbe + tags.HouseCode == name) {
          return this.queryResultFeatures[i];
        }
      }
    }
  }, {
    "key" : `activate`,
    "value" : function() {
      this.isActivate = true;
    }
  }, {
    "key" : "deactivate",
    "value" : function() {
      this.isActivate = false;
    }
  }]);
  k = fireEvent;
  appendCSS(`.MultiFieldAdaptWindow-container {\n    position: absolute;\n    left: 0px;\n    bottom: 0px;\n    min-width: 350px;\n    min-height: 200px;\n    color: white;\n}\n\n.MultiFieldAdaptWindow-container::before {\n    position: absolute;\n    content: "";\n    top: 100%;\n    left: calc(50% - 20px);\n    border: 20px solid transparent;\n    border-top: 40px solid rgba(30, 32, 42, 0.5);\n}\n\n.MultiFieldAdaptWindow-header {\n    height: 30px;\n    line-height: 30px;\n    color: white;\n    min-width: 200px;\n    padding: 0px 10px;\n    background: #1a4879;\n    border-top-right-radius: 4px;\n    border-top-left-radius: 4px;\n    position: relative;\n    user-select: none;\n}\n\n.MultiFieldAdaptWindow-close {\n    position: absolute;\n    right: 1px;\n    font-size: 25px;\n    cursor: pointer;\n    width: 29px;\n    text-align: center;\n}\n\n.MultiFieldAdaptWindow-close:hover {\n    background: #dc2929b9;\n}\n\n.MultiFieldAdaptWindow-body {\n    padding: 5px;\n    background: linear-gradient( 0deg, rgba(30, 32, 42, 0.5), rgba(13, 16, 19, 0.7));\n    border: 1px solid rgb(29, 26, 26);\n    border-top: 0px;\n    border-bottom-right-radius: 4px;\n    border-bottom-left-radius: 4px;\n}\n\n.MultiFieldAdaptWindow-info-item {\n    margin: 14px 0px;\n    max-width: 350px;\n}\n\n.MultiFieldAdaptWindow-ifno-label {\n    display: inline-block;\n    min-width: 60px;\n    text-align: justify;\n    text-align-last: justify;\n    background: #fff6f625;\n}\n\n.MultiFieldAdaptWindow-ifno-text {\n    background: #fff6f60e;\n}`, 
  {});
  expect(initialize, [{
    "key" : `createDom`,
    "value" : function() {
      this.container = document.createElement("div");
      this.container.innerHTML = '  <div class="MultiFieldAdaptWindow-container" v-if="show">\n          <div class="MultiFieldAdaptWindow-header">\n            <span class="MultiFieldAdaptWindow-title">  ' + this.title + '</span>\n            <span class="MultiFieldAdaptWindow-close" title="\u5173\u95ed"  >\u00d7</span>\n          </div>\n          <div class="MultiFieldAdaptWindow-body">\n           \x3c!-- <div v-for="(field,index) in fields" :key="index" class="MultiFieldAdaptWindow-info-item">\n              <span class="MultiFieldAdaptWindow-ifno-label" :style="getFieldStyle()">{{field}}\uff1a</span>\n              <span class="MultiFieldAdaptWindow-ifno-text">{{formatValue(values[index])}}</span>\n            </div>--\x3e\n          </div>\n        </div>';
    }
  }, {
    "key" : `initDom`,
    "value" : function() {
      var i = 0;
      for (; i < this.values.length; i++) {
        var bezierPreviewContainer = document.createElement("div");
        bezierPreviewContainer.classList.add("MultiFieldAdaptWindow-info-item");
        var item = document.createElement("span");
        item.classList.add("MultiFieldAdaptWindow-ifno-label");
        item.innerHTML = this.fields[i] + "\uff1a";
        bezierPreviewContainer.appendChild(item);
        (item = document.createElement("span")).classList.add("MultiFieldAdaptWindow-ifno-text");
        item.innerHTML = this.values[i];
        bezierPreviewContainer.appendChild(item);
        this.container.getElementsByClassName("MultiFieldAdaptWindow-body")[0].appendChild(bezierPreviewContainer);
      }
    }
  }, {
    "key" : `initEvent`,
    "value" : function() {
      var frontpageItems = this;
      this.container.getElementsByClassName("MultiFieldAdaptWindow-close")[0].onclick = function(branch) {
        var parseInt = hahaha;
        frontpageItems[parseInt(1471)]();
      };
    }
  }, {
    "key" : `addPostRender`,
    "value" : function() {
      this.viewer.scene.postRender.addEventListener(this.postRender, this);
    }
  }, {
    "key" : `postRender`,
    "value" : function() {
      var item;
      var width;
      if (this.container && this.container.style) {
        width = this.viewer.scene.canvas.height;
        item = new Cesium["Cartesian2"];
        Cesium.SceneTransforms.wgs84ToWindowCoordinates(this.viewer.scene, this.position, item);
        this.container.style.position = "absolute";
        this.container.style.bottom = width - item.y + 80 + "px";
        width = this.container.scrollWidth;
        this.container.style.left = item.x - width / 2 + "px";
      }
    }
  }, {
    "key" : "close",
    "value" : function() {
      this.container.remove();
      this.viewer.scene.postRender.removeEventListener(this.postRender, this);
    }
  }]);
  entryToSend = initialize;
  xt3d.DTH = {
    "FD" : view,
    "FC" : mode,
    "FH" : k,
    "BuildInfoWindow" : entryToSend
  };
  expect(name, [{
    "key" : `add`,
    "value" : function() {
      this.cylinderEntity = new Cesium["Entity"]({
        "name" : "cylinder",
        "position" : this.position,
        "html" : this.options.html || "",
        "cylinder" : new Cesium["CylinderGraphics"]({
          "topRadius" : this.options.topRadius,
          "bottomRadius" : this.options.bottomRadius,
          "length" : this.options.length,
          "material" : this.options.color
        })
      });
      this.viewer.entities.add(this.cylinderEntity);
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.viewer.entities.remove(this.cylinderEntity);
    }
  }]);
  name = name;
  expect(index, [{
    "key" : `add`,
    "value" : function() {
      this.cylinderEntity = new Cesium.Entity({
        "position" : this.position,
        "label" : {
          "text" : this.text,
          "fillColor" : this.options.color,
          "scale" : 0.5,
          "font" : this.options.font || "normal 42px MicroSoft YaHei",
          "distanceDisplayCondition" : new Cesium["DistanceDisplayCondition"](0, 7E6),
          "scaleByDistance" : new Cesium["NearFarScalar"](5E4, 1, 5E5, 0.5),
          "verticalOrigin" : Cesium.VerticalOrigin.BOTTOM,
          "style" : Cesium.LabelStyle.FILL_AND_OUTLINE,
          "pixelOffset" : new Cesium["Cartesian2"](0, -15),
          "outlineWidth" : 5,
          "outlineColor" : Cesium.Color.BLACK,
          "disableDepthTestDistance" : 5E5
        }
      });
      this.viewer.entities.add(this.cylinderEntity);
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.viewer.entities.remove(this.cylinderEntity);
    }
  }]);
  pos = index;
  expect(node, [{
    "key" : `addEntity`,
    "value" : function() {
      var primaryReplicas = this;
      var inside = val(this.point, this.options.radius || 20);
      var expansions = [];
      inside.forEach(function(shortcut) {
        var stringify = hahaha;
        expansions[stringify(2008)](shortcut[0]);
        expansions[stringify(2008)](shortcut[1]);
        expansions.push(primaryReplicas[stringify(1621)][2] || 0);
      });
      var h = this.point[2] || 0;
      var to_currentmenuelement_h = this.options.height || 200;
      var oTableTR = to_currentmenuelement_h / 60;
      this.extrudedPolygonE = this.viewer.entities.add({
        "polygon" : {
          "hierarchy" : new Cesium["PolygonHierarchy"](Cesium.Cartesian3.fromDegreesArrayHeights(expansions)),
          "perPositionHeight" : true,
          "extrudedHeight" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
            return h < to_currentmenuelement_h ? h = h + oTableTR : h = to_currentmenuelement_h, h;
          }),
          "material" : this.options.color || Cesium.Color.RED
        }
      });
    }
  }, {
    "key" : `addLabel`,
    "value" : function() {
      var primaryReplicas = this;
      var MIN_UNIT = this.options.height || 200;
      var blockHeightEstimate = MIN_UNIT / 60;
      var height = this.point[2] || 0;
      this.textEntity = this.viewer.entities.add({
        "position" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
          var stringify = hahaha;
          return height < MIN_UNIT ? height = height + blockHeightEstimate : height = MIN_UNIT, Cesium[stringify(3131)].fromDegrees(primaryReplicas[stringify(1621)][0], primaryReplicas[stringify(1621)][1], height);
        }, false),
        "label" : {
          "text" : this.options.label,
          "fillColor" : Cesium.Color.WHITE,
          "scale" : 0.5,
          "font" : "normal 60px MicroSoft YaHei",
          "distanceDisplayCondition" : new Cesium["DistanceDisplayCondition"](0, 9E5),
          "scaleByDistance" : new Cesium["NearFarScalar"](5E4, 1, 5E5, 0.5),
          "verticalOrigin" : Cesium.VerticalOrigin.BOTTOM,
          "style" : Cesium.LabelStyle.FILL_AND_OUTLINE,
          "pixelOffset" : new Cesium.Cartesian2(0, -10),
          "outlineWidth" : 20,
          "outlineColor" : Cesium.Color.BLACK
        }
      });
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.viewer.entities.remove(this.textEntity);
      this.viewer.entities.remove(this.extrudedPolygonE);
    }
  }]);
  meta = node;
  appendCSS(`.chart-popup3d-container {\n    background: #14193399;\n    position: absolute;\n    left: 0px;\n    bottom: 0px;\n    cursor: default;\n}\n\n.chart-popup3d-container::before {\n    content: "";\n    width: calc(100% + 22px);\n    height: 39px;\n    position: absolute;\n    bottom: -39px;\n    left: -22px;\n    background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAB4AAAAAlCAYAAACj1PQVAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyhpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTQ1IDc5LjE2MzQ5OSwgMjAxOC8wOC8xMy0xNjo0MDoyMiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTkgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MTJFMTU1RjExN0UzMTFFOTg3RTBFODdGNTY0NThGQkUiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MTJFMTU1RjIxN0UzMTFFOTg3RTBFODdGNTY0NThGQkUiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDoxMkUxNTVFRjE3RTMxMUU5ODdFMEU4N0Y1NjQ1OEZCRSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDoxMkUxNTVGMDE3RTMxMUU5ODdFMEU4N0Y1NjQ1OEZCRSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pj97JFoAAAV9SURBVHja7N1faJ1nHQfw33nzpuekaZfWNFmbLHXWdf7DWgvebF4M0SEZhTG8mKvFyzG9UJFKh9peVGnd0DkE/10Ic6s6BBEGbshggho3BVGnRnC2s1n/ras2J2uzc05PXp+3yZzSm7XJkvfi84HveZ9z3ve8F7/bL8/71oqiiMs8NhCLsCllfcpfAwAAAAAAAIDlsXM68jfgtl9K2Z3Sa8IAAAAAAAAAb7hjKW8uF9kS3/jdKR9PaZkxAAAAAAAAwPJa6h3A96X0pBxK+bLxAgAAAAAAACyfpSyAP5jy4ZQXUh747687p00ZAAAAAAAAYBlkS3if+xfW+1MuGC0AAAAAAADA8lqqAnh3yvaUZ1MeMlYAAAAAAACA5bcUBXBfyoGF9edSusYKAAAAAAAAsPyWogD+VMpYypMpTxgpAAAAAAAAwMpYbAG8IWVvylzKHuMEAAAAAAAAWDmLLYC/mDKQ8nDKH4wTAAAAAAAAYOUspgC+IeWelNmYL4IBAAAAAAAAWEGLKYAPpfSmfD1lyigBAAAAAAAAVtbVFsA3pdyR8lLMF8EAAAAAAAAArLCrKYBrKfcvHA+kNI0RAAAAAAAAYOVdTQFc7vwtdwA/l/ItIwQAAAAAAACohistgMt3/h5cWO9N6RghAAAAAAAAQDVcaQF8d8rWlImUnxgfAAAAAAAAQHVcSQF8Tcq+lCJlz8IRAAAAAAAAgIq4kgK4fOTzUMzv/J0wOgAAAAAAAIBqeb0F8FjKp2P+nb97jQ0AAAAAAACgel5vAXwgpS/l2ynPGRsAAAAAAABA9eSjd370sh+P7/q/r9tTdqc0Y74IBgAAAAAAAKCC8v9Zl7uB6yn9o4fHG+lYS2n/867Hv5bXivLcoZQzRgYAAAAAAABQTfnw5nvjxWMHe9N6cP+OyVtv2nj2ruFG6209WbGqM5c181rx9m5RO/ngn2/4zlf/tLV2fNfPCmMDAAAAAAAAqJ68LH+HGq2xRz7wu2+8a31zvCgiLs5FlC3vqp4YKS8638mzqZf7tqXlb1MuGBsAAAAAAABA9ZSPdh58tfyd7UScOh9xYjqLszNZlGVwN6U/71z7hR1/e/g9g9NbRg+P9xobAAAAAAAAQPVk+3ZMfujV8vf0TC3WXWzE9ZveHyNjt0UxOxCnp7NotiPWr2pfl67dk/6zxtgAAAAAAAAAqie7eePZXeVO33OtiOGsHqtvfjDi1scibnkkesafipHVI3HuQi3a3Yh3rpsZT/+5ZvTweM3oAAAAAAAAAKolH2q0byzf+dtuZ9G/8b0RW+587ezat0a84xPR+8z+aHU7MVDvbLhl05lrf3FyaGr08Hj5muA4/qMfmiIAAAAAAABABWS1KPJLTW75UR+8/Ir6uksvCi6K+a/Dfa26sQEAAAAAAABUT/ZyJz+Z19IiL6J7eiLi/NRrZ4tuxNEfRzvmorcnoj2XvfL41MZTMV8XAwAAAAAAAFAh2eS5tU9kWcRAo4ipC9MRP98ZMfnNiH/8IOLJO+LMC7+ORl83Gj0RR5r9z8x08nOhAAYAAAAAAAConPyzT2976H1D//7YYL21ZW5NN442n4/ep/ddeuxzK+air68bb2pEdCN75dEj192Xfp4xNgAAAAAAAIDqyWY6+akHnt16d7Oz6uRAPWJkoIi1azuxek0nhge6MdQXUatlrZ8+P/L5706+ZSLKXhgAAAAAAACAyik3+s5+/++bJ+751fbbfv/S+kc7c/l0WQSva0TUe2rtIzNrJr7yxxs/8pnfbPteurY5vPlej38GAAAAAAAAqKC8LHRfPHZw9penNvwl5ZP1nrmB268/MdafX+x96sTQ8aMz/f9K102ntJS/AAAAAAAAANX1HwEGAM75MhcANnAkAAAAAElFTkSuQmCC) 0px 0px no-repeat;\n    background-position: 0px 0px;\n}\n\n.chart-popup3d-header {\n    height: 30px;\n    color: white;\n    background: #1f3f8e;\n    line-height: 30px;\n}\n\n.chart-popup3d-header-title {\n    display: inline-block;\n    height: 100%;\n    margin-left: 5px;\n}\n\n.chart-popup3d-close {\n    position: absolute;\n    right: 1px;\n    font-size: 25px;\n    cursor: pointer;\n    width: 29px;\n    text-align: center;\n}\n\n.chart-popup3d-close:hover {\n    background: #dc2929b9;\n}\n\n\n/* .chart-popup3d-body {\n    height: 300px;\n    width: 500px;\n} */`, 
  {});
  expect(open, [{
    "key" : `init`,
    "value" : function() {
      this.createDom();
      this.addEvent();
    }
  }, {
    "key" : "createDom",
    "value" : function() {
      var frontpageItems = this;
      var node = document.createElement("div");
      node.classList.add("chart-popup3d-container");
      var container = document.createElement("div");
      container.classList.add("chart-popup3d-header");
      node.appendChild(container);
      var button = document.createElement("span");
      button.innerHTML = this.title;
      button.classList.add("chart-popup3d-header-title");
      container.appendChild(button);
      button = document.createElement("span");
      button.innerHTML = "\u00d7";
      button.classList.add("chart-popup3d-close");
      container.appendChild(button);
      container = document.createElement("div");
      container.classList.add("chart-popup3d-body");
      node.appendChild(container);
      this.$container = node;
      this.$body = container;
      this.viewer.cesiumWidget.container.append(node);
      button.onclick = function(branch) {
        var parseInt = hahaha;
        frontpageItems[parseInt(1471)]();
      };
      this.createchart();
    }
  }, {
    "key" : `createchart`,
    "value" : function() {
      var data = document.createElement("div");
      data.classList.add("chart-body");
      this.$body.appendChild(data);
      this.chart = Highcharts.chart(data, this.options);
    }
  }, {
    "key" : `addEvent`,
    "value" : function() {
      this.viewer.scene.postRender.addEventListener(this.postRenderEvent, this);
    }
  }, {
    "key" : `postRenderEvent`,
    "value" : function() {
      var len = this.viewer.scene.canvas.height;
      var result = new Cesium["Cartesian2"];
      Cesium.SceneTransforms.wgs84ToWindowCoordinates(this.viewer.scene, this.position, result);
      this.$container.style.bottom = len - result.y + 40 + "px";
      this.$container.style.left = result.x + 20 + "px";
    }
  }, {
    "key" : `close`,
    "value" : function() {
      this.viewer.scene.postRender.removeEventListener(this.postRenderEvent, this);
      this.$container.remove();
    }
  }]);
  frame = open;
  appendCSS(`.stack-graphic-popup {\n    --padding-width: 10px;\n    text-align: center;\n    position: absolute;\n    pointer-events: none;\n}\n\n.stack-graphic-popup .stack-graphic-popup-panel {\n    padding: 10px 15px;\n    background-color: rgba(54, 54, 54, 0.6);\n    color: #fff;\n}\n\n.stack-graphic-popup .stack-graphic-popup-bottom {\n    width: 0;\n    height: 0;\n    border-top: 10px solid rgba(54, 54, 54, 0.6);\n    border-right: 10px solid transparent;\n    border-bottom: 10px solid transparent;\n    border-left: 10px solid transparent;\n    margin: auto;\n}`, 
  {});
  expect(scroll, [{
    "key" : `createDom`,
    "value" : function() {
      var div = document.createElement("div");
      div.classList.add("stack-graphic-popup");
      var container = document.createElement("div");
      container.className = "stack-graphic-popup-panel";
      container.innerHTML = this.html;
      var whiteBox = document.createElement("div");
      whiteBox.className = "stack-graphic-popup-bottom";
      div.appendChild(container);
      div.appendChild(whiteBox);
      this.container = div;
      this.viewer.container.appendChild(div);
    }
  }, {
    "key" : `initEvent`,
    "value" : function() {
      var len = this.viewer.scene.canvas.height;
      var result = new Cesium["Cartesian2"];
      Cesium.SceneTransforms.wgs84ToWindowCoordinates(this.viewer.scene, this.position, result);
      this.container.style.bottom = len - result.y + 20 + "px";
      len = this.container.offsetWidth;
      this.container.style.left = result.x - len / 2 + "px";
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.container.remove();
    }
  }]);
  state = scroll;
  xt3d.DataStatistics = {
    "CylinderEntity" : name,
    "LabelEntity" : pos,
    "GrowthCylinder" : meta,
    "ChartWindow" : frame,
    "Popup" : state
  };
  expect(url, [{
    "key" : "addPosition",
    "value" : function(value, x) {
      var expires = this.viewer.clock.currentTime.clone();
      if (!this.property) {
        this.createPositionProperty(expires);
      }
      var time = new Cesium["JulianDate"];
      Cesium.JulianDate.addSeconds(expires, x, time);
      this.property.addSample(time, value);
    }
  }, {
    "key" : `createPositionProperty`,
    "value" : function(name) {
      this.property = new Cesium["SampledPositionProperty"];
      this.property.addSample(name.clone(), this.modelPositon);
      this.animateEntity.position = this.property;
      this.animateEntity.orientation = new Cesium["VelocityOrientationProperty"](this.property);
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      if (this.animateEntity) {
        this.viewer.entities.remove(this.animateEntity);
        this.animateEntity = void 0;
      }
    }
  }]);
  ID = url;
  expect(Notification, [{
    "key" : `addPosition`,
    "value" : function(value, x) {
      var expires = this.viewer.clock.currentTime.clone();
      if (!this.property) {
        this.createPositionProperty(expires);
      }
      var time = new Cesium["JulianDate"];
      Cesium.JulianDate.addSeconds(expires, x, time);
      this.property.addSample(time, value);
    }
  }, {
    "key" : `createPositionProperty`,
    "value" : function(name) {
      this.property = new Cesium["SampledPositionProperty"];
      this.property.addSample(name.clone(), this.modelPositon);
      this.animateEntity.position = this.property;
      this.animateEntity.orientation = new Cesium["VelocityOrientationProperty"](this.property);
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      if (this.animateEntity) {
        this.viewer.entities.remove(this.animateEntity);
        this.animateEntity = void 0;
      }
    }
  }]);
  tel = Notification;
  appendCSS(`.is-shulie {\n    width: 15px;\n    text-align: center;\n    background: transparent;\n    font-size: 9px;\n    font-weight: 600;\n    color: white;\n    font-family: "Microsoft YaHei", "Helvetica Neue For Number", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Hiragino Sans GB", "PingFang SC", "Helvetica Neue", Helvetica, Arial, sans-serif !important;\n    position: absolute;\n    display: block;\n    box-sizing: border-box;\n    pointer-events: none;\n}\n\n.is-shulie-item {\n    writing-mode: vertical-lr;\n    font-size: 16px;\n    letter-spacing: 4px;\n}\n\n.pre-topCard-list-item-line {\n    display: block;\n    height: 40px;\n    width: 1px;\n    margin-left: calc(50% + 2px);\n    margin-top: 3px;\n    background-color: #fff;\n}\n\n.pre-topCard-list-item-circle {\n    width: 10px;\n    height: 10px;\n    background-color: #fff;\n    border-radius: 50%;\n    margin-left: 5px;\n    margin-top: -10px;\n}`, 
  {});
  expect(list, [{
    "key" : `addPosition`,
    "value" : function(value, x) {
      var expires = this.viewer.clock.currentTime.clone();
      if (!this.property) {
        this.createPositionProperty(expires);
      }
      var time = new Cesium["JulianDate"];
      Cesium.JulianDate.addSeconds(expires, x, time);
      this.property.addSample(time, value);
    }
  }, {
    "key" : "createPositionProperty",
    "value" : function(name) {
      this.property = new Cesium["SampledPositionProperty"];
      this.property.addSample(name.clone(), this.position);
      this.animateEntity.position = this.property;
      this.animateEntity.orientation = new Cesium["VelocityOrientationProperty"](this.property);
    }
  }, {
    "key" : "addPostRender",
    "value" : function() {
      this.viewer.scene.postRender.addEventListener(this.postRender, this);
    }
  }, {
    "key" : "postRender",
    "value" : function() {
      var item;
      var cw;
      if (this.container && this.container.style) {
        if (this.property) {
          this.position = this.animateEntity.position.getValue(this.viewer.clock.currentTime);
        }
        cw = this.viewer.scene.canvas.height;
        item = new Cesium["Cartesian2"];
        Cesium.SceneTransforms.wgs84ToWindowCoordinates(this.viewer.scene, this.position, item);
        this.container.style.bottom = cw - item.y + 10 + "px";
        cw = this.container.offsetWidth;
        this.container.style.left = item.x - cw / 2 + "px";
      }
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.viewer.scene.postRender.removeEventListener(this.postRender, this);
      this.viewer.cesiumWidget.container.removeChild(this.container);
    }
  }, {
    "key" : `createDom`,
    "value" : function() {
      this.container = document.createElement("div");
      this.container.classList.add("is-shulie");
      var label = document.createElement("div");
      label.innerHTML = this.label;
      label.classList.add("is-shulie-item");
      this.container.appendChild(label);
      label = document.createElement("div");
      label.classList.add("pre-topCard-list-item-line");
      this.container.appendChild(label);
      label = document.createElement("div");
      label.classList.add("pre-topCard-list-item-circle");
      this.container.appendChild(label);
      this.viewer.cesiumWidget.container.appendChild(this.container);
    }
  }]);
  output = list;
  xt3d.DynamicGraphic = {
    "DynamicModel" : ID,
    "DynamicBillboard" : tel,
    "DynamicLabel" : output
  };
  expect(options, [{
    "key" : `init`,
    "value" : function(name, obj) {
      this.setBaseViewer(name);
      this.createLayer();
    }
  }, {
    "key" : `setBaseViewer`,
    "value" : function(name) {
      this._viewer = name;
    }
  }, {
    "key" : `setChartOption`,
    "value" : function(name) {
      this.chartOption = name;
      this.setCharts();
    }
  }, {
    "key" : `setVisible`,
    "value" : function(value) {
      if (this.box && this.visible !== value) {
        this.box.hidden = !value;
        if (true === (this.visible = value)) {
          setCharts();
        }
      }
    }
  }, {
    "key" : `refreshBegin`,
    "value" : function() {
      this.box.hidden = true;
    }
  }, {
    "key" : `refreshing`,
    "value" : function() {
      this.setCharts();
    }
  }, {
    "key" : `refreshEnd`,
    "value" : function() {
      this.box.hidden = false;
    }
  }, {
    "key" : "on",
    "value" : function(name, options, data) {
      this.chart.on(name, options, data);
    }
  }, {
    "key" : `off`,
    "value" : function(name, obj, data) {
      this.chart.off(name, obj, data);
    }
  }, {
    "key" : `setCharts`,
    "value" : function() {
      if (this.visible && null != this.chartOption && "undefined" != this.chartOption) {
        this.chart.setOption(this.chartOption);
        this.chartOption.animation = false;
      }
    }
  }, {
    "key" : `createLayer`,
    "value" : function() {
      var data = this._viewer.scene;
      data.canvas.setAttribute("tabIndex", 0);
      var container = document.createElement("div");
      container.style.position = "absolute";
      container.style.top = "0px";
      container.style.left = "0px";
      container.style.width = data.canvas.width + "px";
      container.style.height = data.canvas.height + "px";
      container.style.pointerEvents = "none";
      container.setAttribute("class", "echartMap");
      this.box = container;
      this._viewer.container.appendChild(container);
      this.chart = echarts.init(container);
      this.startSceneEventListeners();
    }
  }, {
    "key" : "removeLayer",
    "value" : function() {
      this.box.outerHTML = "";
      this.box = null;
      this.chart = null;
      this.chartOption = null;
      this._viewer.scene.postRender.removeEventListener(this.moveHandler, this);
      this._viewer = void 0;
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.removeLayer();
    }
  }, {
    "key" : `startSceneEventListeners`,
    "value" : function() {
      this._viewer.scene.postRender.addEventListener(this.moveHandler, this);
    }
  }, {
    "key" : `moveHandler`,
    "value" : function() {
      if (this.visible) {
        this.setCharts();
        this.chart.resize({
          "width" : this._viewer.canvas.width,
          "height" : this._viewer.canvas.height
        });
        this.box.hidden = false;
      }
    }
  }, {
    "key" : `getE3CoordinateSystem`,
    "value" : function(target) {
      function BMapCoordSys(viewer) {
        this._viewer = viewer;
        this._mapOffset = [0, 0];
      }
      return BMapCoordSys.create = function(obj) {
        obj.eachSeries(function(seriesModel) {
          if ("cesium" === seriesModel.get("coordinateSystem")) {
            seriesModel.coordinateSystem = new BMapCoordSys(target);
          }
        });
      }, BMapCoordSys.getDimensionsInfo = function() {
        return ["x", "y"];
      }, BMapCoordSys.dimensions = ["x", "y"], BMapCoordSys.prototype.dimensions = ["x", "y"], BMapCoordSys.prototype.setMapOffset = function(mapOffset) {
        this._mapOffset = mapOffset;
      }, BMapCoordSys.prototype.dataToPoint = function(x) {
        var scene = this._viewer.scene;
        var NaN = [0, 0];
        x = Cesium.Cartesian3.fromDegrees(x[0], x[1]);
        if (!x) {
          return NaN;
        }
        if (scene.mode === Cesium.SceneMode.SCENE3D && Cesium.Cartesian3.angleBetween(scene.camera.position, x) > Cesium.Math.toRadians(80)) {
          return false;
        }
        return x = scene.cartesianToCanvasCoordinates(x), x ? [x.x - this._mapOffset[0], x.y - this._mapOffset[1]] : NaN;
      }, BMapCoordSys.prototype.pointToData = function(clamp) {
        var result = this._mapOffset;
        var ellipsoid = target.scene.globe.ellipsoid;
        result = new Cesium["cartesian3"](clamp[1] + result[1], clamp[2] + result[2], 0);
        result = ellipsoid.cartesianToCartographic(result);
        return result ? [result.lng, result.lat] : [0, 0];
      }, BMapCoordSys.prototype.getviewerRect = function() {
        var cachedCanvas = this._viewer.canvas;
        return new echarts["graphic"]["BoundingRect"](0, 0, cachedCanvas.width, cachedCanvas.height);
      }, BMapCoordSys.prototype.getRoamTransform = function() {
        return matrix.create();
      }, BMapCoordSys;
    }
  }]);
  location = options;
  xt3d.EchartsLayer = location;
  Object.defineProperties(Timer.prototype, {
    "isConstant" : {
      "get" : function() {
        return false;
      }
    },
    "definitionChanged" : {
      "get" : function() {
        return this._definitionChanged;
      }
    },
    "color" : Cesium.createPropertyDescriptor("color")
  });
  Timer.prototype.getType = function(original_full_html) {
    return "EllipsoidStripeVertical";
  };
  Timer.prototype.getValue = function(time, result) {
    return Cesium.defined(result) || (result = {}), result.color = Cesium.Property.getValueOrClonedDefault(this._color, time, Cesium.Color.WHITE, result.color), result.image = Cesium.Material.EllipsoidStripeVerticalImage, result.time = ((new Date).getTime() - this._time) % this.duration / this.duration, result.count = this.count, result;
  };
  Timer.prototype.equals = function(other) {
    return this === other || other instanceof Timer && Cesium.Property.equals(this._color, other._color) && this.duration == other.duration && this.count == other.count;
  };
  Cesium.Material.EllipsoidStripeVerticalType = "EllipsoidStripeVertical";
  Cesium.Material.EllipsoidStripeVerticalImage = `data:image/octet-stream;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAUCAYAAAB7wJiVAAACgklEQVRoQ9WZi27DIAxFIeGX9n53//9FBTy5rSNESDC2U2mVqkQRgc7X1wczDwC/zrmQUgrzPM+3a3DOzeVzvL99L89zzmGapss953k5pnG/rAcAwXuP83rH+AAAeO+Tc27km3POaZqmRNfB9/G9rHmf1osx5hDC8ts9AJzqoHKD1xm3Eos7/iYKSxDnHBTBzKOBbYxXz5FSypjbkt/iz+fzKYSwCh45pifWqFO2xhfOIMdNDIPQkO4fDwAZnaR0htpZJFaMMZXOIPHQIT/czKUyxnXQVvCZ62GScD+arNa8WyaCyTwoyDcGKMYYNE4hsbgiNBxxcWn1XCwIOQIAkoAxS6BrVgiZk1NK6Yro63WrnKEgX0VZWuBaZjG3fDEdtMUWMdgrjnTL1y0YFhltMUcqwU6CjAJ4CZ4VQ+oyJgW7kTPMWMF1RsmQT2ZNb7qnB32la0zB7pyzyOhD50CHfBzAkK6DmAxhg13pDLUjqAzWjOkxo2YJCTJasqzG77mO1hCD3cgRSxMo6StGeyQU5L0sK1sA33o+yhDulnm0Y5eCXdmXmHfsKMibkCGc7FaNkYLdyBmHsmJv2/tqwRArp9yrY6eASPsKrbO2OnZ0CApixYRyni7Ymc5kg13pDAtHYA+0bBAkzEFBXsrAjHbsWmcwd1tisNe7L2nnfq+OHQV53jsOZ2axihWVQ1tzSU5+/13Hju5CQZ72mrvOsUm3LHHPtkiU2jFSsCv7EhJzVX5GmUOs4HbsJIgVQ5pOGRWl4UrTjp3EktT40b6is8aKWyjIo4Yh3L5i4P8grVNfNtiVzjisY+eKj4I8HHwexXEfh0FisCt3X6ujeG5wN8bt7ub+ANZIqbIlvAh5AAAAAElFTkSuQmCC`;
  Cesium.Material.EllipsoidStripeVerticalSource = `czm_material czm_getMaterial(czm_materialInput materialInput)\n    {\n         czm_material material = czm_getDefaultMaterial(materialInput);\n         vec2 st = materialInput.st;\n         vec4 colorImage = texture2D(image, vec2(fract(count*st.t + time), fract(st.s)));\n         material.alpha = colorImage.a * color.a;\n         material.diffuse =  1.5* color.rgb  ;\n         return material;\n     }`;
  Cesium.Material._materialCache.addMaterial(Cesium.Material.EllipsoidStripeVerticalType, {
    "fabric" : {
      "type" : Cesium.Material.EllipsoidStripeVerticalType,
      "uniforms" : {
        "color" : new Cesium[`Color`](1, 0, 0, 0.5),
        "image" : Cesium.Material.EllipsoidStripeVerticalImage,
        "time" : 0,
        "count" : 1
      },
      "source" : Cesium.Material.EllipsoidStripeVerticalSource
    },
    "translucent" : function(material) {
      return true;
    }
  });
  expect(comment, [{
    "key" : `addPrimitive`,
    "value" : function() {
      var radius = this.style.radius || 100;
      radius = new Cesium["EllipsoidGeometry"]({
        "radii" : new Cesium["Cartesian3"](radius, radius, radius)
      });
      radius = Cesium.EllipsoidGeometry.createGeometry(radius);
      radius = new Cesium.GeometryInstance({
        "geometry" : radius,
        "modelMatrix" : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(this.position), new Cesium["Cartesian3"](0, 0, 0), new Cesium["Matrix4"])
      });
      this.primitive = this.viewer.scene.primitives.add(new Cesium["Primitive"]({
        "geometryInstances" : radius,
        "asynchronous" : false,
        "appearance" : new Cesium["MaterialAppearance"]({
          "fragmentShaderSource" : `varying vec3 v_positionEC;\n                varying vec3 v_normalEC;\n                varying vec2 v_st;\n                void main()\n                {\n                   vec3 positionToEyeEC = -v_positionEC;\n                   vec3 normalEC = normalize(v_normalEC);\n                   #ifdef FACE_FORWARD\n                   normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\n                   #endif\n                   czm_materialInput materialInput;\n                   materialInput.normalEC = normalEC;\n                   materialInput.positionToEyeEC = positionToEyeEC;\n                   materialInput.st = v_st;\n                   czm_material material = czm_getMaterial(materialInput);\n                   #ifdef FLAT\n                   gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n                   #else\n                   gl_FragColor = czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);\n                   #endif\n                }\n                `,
          "vertexShaderSource" : `attribute vec3 position3DHigh;\n                   attribute vec3 position3DLow;\n                   attribute vec3 normal;\n                   attribute vec2 st;\n                   attribute float batchId;\n                   varying vec3 v_positionEC;\n                   varying vec3 v_normalEC;\n                   varying vec2 v_st;\n                   void main()\n                   {\n                      vec4 p = czm_computePosition();\n                      v_positionEC = (czm_modelViewRelativeToEye * p).xyz;\n                      v_normalEC = czm_normal * normal;\n                      v_st = st;\n                      gl_Position = czm_modelViewProjectionRelativeToEye * p;\n                   }\n                `,
          "material" : new Cesium["Material"]({
            "fabric" : {
              "type" : "VtxfShader1",
              "uniforms" : {
                "color" : this.style.color || new Cesium["Color"](0.2, 1, 0, 1),
                "speed_1" : 5
              },
              "source" : `uniform vec4 color;\n                                            uniform float speed_1;\n\n                                            #define pi 3.1415926535\n                                            #define PI2RAD 0.01745329252\n                                            #define TWO_PI (2. * PI)\n\n                                            float rands(float p){\n                                            return fract(sin(p) * 10000.0);\n                                            }\n\n                                            float noise(vec2 p){\n                                            float time = fract( czm_frameNumber * speed_1 / 1000.0);\n                                            float t = time / 20000.0;\n                                            if(t > 1.0) t -= floor(t);\n                                            return rands(p.x * 14. + p.y * sin(t) * 0.5);\n                                            }\n\n                                            vec2 sw(vec2 p){\n                                            return vec2(floor(p.x), floor(p.y));\n                                            }\n\n                                            vec2 se(vec2 p){\n                                            return vec2(ceil(p.x), floor(p.y));\n                                            }\n\n                                            vec2 nw(vec2 p){\n                                            return vec2(floor(p.x), ceil(p.y));\n                                            }\n\n                                            vec2 ne(vec2 p){\n                                            return vec2(ceil(p.x), ceil(p.y));\n                                            }\n\n                                            float smoothNoise(vec2 p){\n                                            vec2 inter = smoothstep(0.0, 1.0, fract(p));\n                                            float s = mix(noise(sw(p)), noise(se(p)), inter.x);\n                                            float n = mix(noise(nw(p)), noise(ne(p)), inter.x);\n                                            return mix(s, n, inter.y);\n                                            }\n\n                                            float fbm(vec2 p){\n                                            float z = 2.0;\n                                            float rz = 0.0;\n                                            vec2 bp = p;\n                                            for(float i = 1.0; i < 6.0; i++){\n                                                rz += abs((smoothNoise(p) - 0.5)* 2.0) / z;\n                                                z *= 2.0;\n                                                p *= 2.0;\n                                            }\n                                            return rz;\n                                            }\n\n                                            czm_material czm_getMaterial(czm_materialInput materialInput)\n                                            {\n                                            czm_material material = czm_getDefaultMaterial(materialInput);\n                                            vec2 st = materialInput.st;\n                                            vec2 st2 = materialInput.st;\n                                            float time = fract( czm_frameNumber * speed_1 / 1000.0);\n                                            if (st.t < 0.5) {\n                                                discard;\n                                            }\n                                            st *= 4.;\n                                            float rz = fbm(st);\n                                            st /= exp(mod( time * 2.0, pi));\n                                            rz *= pow(15., 0.9);\n                                            vec4 temp = vec4(0);\n                                            temp = mix( color  / rz, vec4(color.rgb, 0.1), 0.2);\n                                            if (st2.s < 0.05) {\n                                                temp = mix(vec4(color.rgb, 0.1), temp, st2.s / 0.05);\n                                            }\n                                            if (st2.s > 0.95){\n                                                temp = mix(temp, vec4(color.rgb, 0.1), (st2.s - 0.95) / 0.05);\n                                            }\n                                            material.diffuse = temp.rgb;\n                                            material.alpha = temp.a * 2.0;\n                                            return material;\n                                            }`
            },
            "translucent" : false
          }),
          "faceForward" : false,
          "closed" : true
        })
      }));
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.viewer.scene.primitives.remove(this.primitive);
      this.primitive = void 0;
    }
  }]);
  doc = comment;
  expect(step, [{
    "key" : `addPrimitive`,
    "value" : function() {
      var radius = this.style.radius || 100;
      radius = new Cesium["EllipsoidGeometry"]({
        "radii" : new Cesium["Cartesian3"](radius, radius, radius),
        "maximumCone" : Cesium.Math.PI_OVER_TWO
      });
      radius = Cesium.EllipsoidGeometry.createGeometry(radius);
      radius = new Cesium["GeometryInstance"]({
        "geometry" : radius,
        "modelMatrix" : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(this.position), new Cesium["Cartesian3"](0, 0, 0), new Cesium["Matrix4"])
      });
      this.primitive = this.viewer.scene.primitives.add(new Cesium["Primitive"]({
        "geometryInstances" : radius,
        "asynchronous" : false,
        "appearance" : new Cesium.MaterialAppearance({
          "material" : new Cesium["Material"]({
            "fabric" : {
              "type" : "VtxfShader1",
              "uniforms" : {
                "color_0" : this.style.color || new Cesium["Color"](0.2, 1, 0, 1),
                "totoalFrameCount_1" : 500
              },
              "source" : `uniform float totoalFrameCount_1;\n                    uniform vec4 color_0; \n                    czm_material czm_getMaterial(czm_materialInput materialInput)\n                    {\n                        czm_material material = czm_getDefaultMaterial(materialInput);\n                        vec2 st = materialInput.st;  \n                        float t = mod(czm_frameNumber, totoalFrameCount_1) / totoalFrameCount_1; \n                        t *= 1.03;\n                        float alpha = smoothstep(t- 0.03, t, st.s) * step(-t, -st.s); \n                        alpha += 0.1;\n                        alpha *= step(-0.5, -abs(0.5-st.t));                             \n                        material.diffuse = color_0.rgb;\n                        material.alpha = alpha;\n                        return material;\n                    }  `
            },
            "translucent" : false
          }),
          "faceForward" : false,
          "closed" : true
        })
      }));
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.viewer.scene.primitives.remove(this.primitive);
      this.primitive = void 0;
    }
  }]);
  init = step;
  xt3d.EllipsoidObject = {
    "EllipsoidMaterial" : Timer,
    "ElectricEllipsoid" : doc,
    "ScanEllipsoid" : init
  };
  expect(target, [{
    "key" : "add",
    "value" : function(value, obj) {
      obj = obj || {};
      this.excavateDepth = obj.excavateDepth || 200;
      this.bottomImage = obj.bottomImage || "static/images/excavate/excavate_bottom_min.jpg";
      this.sideImage = obj.sideImage || "static/images/excavate/excavate_side_min.jpg";
      this.clear();
      if (render_glance(value)) {
        value = value.reverse();
      }
      obj = createPath3D(value);
      this.viewer.scene.globe.clippingPlanes = new Cesium["ClippingPlaneCollection"]({
        "planes" : obj,
        "edgeWidth" : 1,
        "edgeColor" : Cesium.Color.WHITE
      });
      this.addBottomPolygon(value);
      this.addSideWall(value);
    }
  }, {
    "key" : "addBottomPolygon",
    "value" : function(name) {
      this.bottomPolygon = this.viewer.entities.add({
        "polygon" : {
          "hierarchy" : name,
          "material" : this.bottomImage,
          "height" : -this.excavateDepth
        }
      });
    }
  }, {
    "key" : `addSideWall`,
    "value" : function(target) {
      target.push(target[0]);
      var minHeights = (new Array(target.length)).fill(-this.excavateDepth);
      this.sideWall = this.viewer.entities.add({
        "wall" : {
          "positions" : target,
          "minimumHeights" : minHeights,
          "material" : this.sideImage
        }
      });
    }
  }, {
    "key" : "clear",
    "value" : function() {
      this.viewer.scene.globe.clippingPlanes = void 0;
      this.viewer.entities.remove(this.bottomPolygon);
      this.viewer.entities.remove(this.sideWall);
    }
  }]);
  data = target;
  expect(current, [{
    "key" : `add`,
    "value" : function(name, value) {
      var onDemandLoader = this;
      value = value || {};
      this.excavateDepth = value.excavateDepth || 200;
      this.bottomImage = value.bottomImage || "static/images/excavate/excavate_bottom_min.jpg";
      this.sideImage = value.sideImage || "static/images/excavate/excavate_side_min.jpg";
      this.clear();
      if (render_glance(name)) {
        name = name.reverse();
      }
      var bppmask;
      var altprefixlen;
      var constructor = (altprefixlen = 1E6, name.map(function(ldata) {
        bppmask = func(ldata);
        if (altprefixlen > bppmask[2]) {
          altprefixlen = bppmask[2];
        }
      }), altprefixlen) - this.excavateDepth;
      value = this.interpolationPostions(name);
      this.setPositionsHeight(value).then(function(data) {
        var put_rows = hahaha;
        onDemandLoader[put_rows(2930)](name);
        onDemandLoader[put_rows(589)](name, constructor);
        onDemandLoader[put_rows(1290)](data, constructor);
      });
    }
  }, {
    "key" : `addClippingPlanes`,
    "value" : function(name) {
      name = createPath3D(name);
      this.viewer.scene.globe.clippingPlanes = new Cesium["ClippingPlaneCollection"]({
        "planes" : name,
        "edgeWidth" : 1,
        "edgeColor" : Cesium.Color.WHITE
      });
    }
  }, {
    "key" : `addBottomPolygon`,
    "value" : function(name, value) {
      this.bottomPolygon = this.viewer.entities.add({
        "polygon" : {
          "hierarchy" : name,
          "material" : this.bottomImage,
          "height" : value
        }
      });
    }
  }, {
    "key" : "addSideWall",
    "value" : function(target, value) {
      target.push(target[0]);
      value = (new Array(target.length)).fill(value);
      this.sideWall = this.viewer.entities.add({
        "wall" : {
          "positions" : target,
          "minimumHeights" : value,
          "material" : this.sideImage
        }
      });
    }
  }, {
    "key" : `interpolationPostions`,
    "value" : function(obj) {
      var ret = [];
      var i = 0;
      for (; i < obj.length; ++i) {
        var prop = (i + 1) % obj.length;
        var v = obj[i];
        var val = obj[prop];
        var max = 0.1 * Cesium.Cartesian3.distance(v, val);
        max = Math.floor(max);
        ret = ret.concat(this.getInterpolationValues(v, val, max));
      }
      return ret;
    }
  }, {
    "key" : `getInterpolationValues`,
    "value" : function(name, value, prop) {
      var indexesOfNeedle = [];
      var quantizedHeight = 0;
      for (; quantizedHeight <= prop; quantizedHeight++) {
        var index = Cesium.Cartesian3.lerp(name, value, quantizedHeight / prop, new Cesium["Cartesian3"]);
        indexesOfNeedle.push(index);
      }
      return indexesOfNeedle;
    }
  }, {
    "key" : `setPositionsHeight`,
    "value" : function(type) {
      var rpm_traffic = this;
      return new Promise(function(func, canCreateDiscussions) {
        var a = [];
        type.map(function(text) {
          a.push(func(text));
        });
        type.map(function(mmCoreSplitViewBlock, howMany) {
          var now = hahaha;
          mmCoreSplitViewBlock = rpm_traffic[now(2276)].scene[now(2359)].getHeight(Cesium.Cartographic[now(2206)](mmCoreSplitViewBlock));
          if (mmCoreSplitViewBlock) {
            a[howMany][2] = mmCoreSplitViewBlock;
          }
        });
        var key = [];
        a.forEach(function(canCreateDiscussions) {
          var lowbits = hahaha;
          key[lowbits(2008)](Cesium.Cartesian3[lowbits(2770)](canCreateDiscussions[0], canCreateDiscussions[1], canCreateDiscussions[2]));
        });
        func(key);
      });
    }
  }, {
    "key" : `clear`,
    "value" : function() {
      this.viewer.scene.globe.clippingPlanes = void 0;
      this.viewer.entities.remove(this.bottomPolygon);
      this.viewer.entities.remove(this.sideWall);
    }
  }]);
  forced = current;
  xt3d.ExcavateAnalysis = {
    "SurfaceExcavate" : data,
    "TerrainExcavate" : forced
  };
  descriptor = {
    "pointQueryPoly" : function(position, key) {
      position = Cesium.Cartographic.fromCartesian(position);
      var nameValues = [Cesium.Math.toDegrees(position.longitude), Cesium.Math.toDegrees(position.latitude)];
      return new Promise(function(saveNotifs, expect) {
        var getStringValueForObject = hahaha;
        fetch(encodeURI(key + getStringValueForObject(734) + nameValues[0] + "," + nameValues[1] + "</gml:coordinates></gml:Point></Intersects></Filter>")).then(function(myPreferences) {
          var getPreferenceKey = getStringValueForObject;
          return myPreferences[getPreferenceKey(696)]();
        }).then(function(notifications) {
          saveNotifs(notifications);
        })[getStringValueForObject(596)](function(body) {
          var getConsoleMethod = getStringValueForObject;
          console[getConsoleMethod(1012)](body);
          expect(body);
        });
      });
    },
    "polyQueryPoint" : function(positions, dash_on) {
      return new Promise(function(obtainGETData, saveNotifs) {
        var drilldownLevelLabels = [];
        positions.push(positions[0]);
        var i = 0;
        for (; i < positions.length; i++) {
          var position = positions[i];
          position = Cesium.Cartographic.fromCartesian(position);
          position = [Cesium.Math.toDegrees(position.longitude), Cesium.Math.toDegrees(position.latitude)];
          drilldownLevelLabels.push(position.join(","));
        }
        var dash_off = drilldownLevelLabels.join(" ");
        fetch(encodeURI(dash_on + '&filter=<Filter xmlns="http://www.opengis.net/ogc" xmlns:gml="http://www.opengis.net/gml"><Intersects><PropertyName>the_geom</PropertyName><gml:Polygon><gml:outerBoundaryIs><gml:LinearRing><gml:coordinates>' + dash_off + "</gml:coordinates></gml:LinearRing></gml:outerBoundaryIs></gml:Polygon></Intersects></Filter>")).then(function(myPreferences) {
          var getPreferenceKey = hahaha;
          return myPreferences[getPreferenceKey(696)]();
        }).then(function(val) {
          obtainGETData(val);
        }).catch(function(notifications) {
          console.log(notifications);
          saveNotifs(notifications);
        });
      });
    },
    "sqlQuery" : function(dash_on, dash_off) {
      var email = dash_on + "&" + dash_off;
      return new Promise(function(obtainGETData, saveNotifs) {
        fetch(encodeURI(email)).then(function(rawResp) {
          return rawResp.json();
        }).then(function(val) {
          obtainGETData(val);
        }).catch(function(notifications) {
          console.log(notifications);
          saveNotifs(notifications);
        });
      });
    }
  };
  xt3d.GeoServerPlugin = descriptor;
  expect(values, [{
    "key" : `activate`,
    "value" : function() {
      this.isActivate = true;
    }
  }, {
    "key" : `initKeyEvent`,
    "value" : function() {
      var t = this;
      var canvas = this.viewer.canvas;
      canvas.setAttribute("tabindex", "0");
      canvas.focus();
      var ns = {
        "looking" : !(canvas.onclick = function() {
          var acceptTheCall = hahaha;
          canvas[acceptTheCall(595)]();
        }),
        "moveForward" : false,
        "moveBackward" : false,
        "moveUp" : false,
        "moveDown" : false,
        "moveLeft" : false,
        "moveRight" : false
      };
      canvas.addEventListener("keydown", function(event) {
        var put_rows = hahaha;
        event = t.getFlagForKeyCode(event[put_rows(413)]);
        if (void 0 !== event) {
          ns[event] = true;
        }
      }, false);
      canvas.addEventListener("keyup", function(event) {
        event = t.getFlagForKeyCode(event.keyCode);
        if (void 0 !== event) {
          ns[event] = false;
        }
      }, false);
      var ms = this.viewer.camera;
      var _onDelete = this.viewer.scene.globe.ellipsoid;
      this.viewer.clock.onTick.addEventListener(function(canCreateDiscussions) {
        var put_rows = hahaha;
        if (t[put_rows(2535)]) {
          t[put_rows(2151)](ns, ms, _onDelete);
        }
      });
    }
  }, {
    "key" : `setCamera`,
    "value" : function(name, scope, obj) {
      obj = obj.cartesianToCartographic(scope.position).height / 100;
      if (name.moveForward) {
        scope.moveForward(obj);
      }
      if (name.moveBackward) {
        scope.moveBackward(obj);
      }
      if (name.moveUp) {
        scope.moveUp(obj);
      }
      if (name.moveDown) {
        scope.moveDown(obj);
      }
      if (name.moveLeft) {
        scope.moveLeft(obj);
      }
      if (name.moveRight) {
        scope.moveRight(obj);
      }
    }
  }, {
    "key" : `getFlagForKeyCode`,
    "value" : function(name) {
      switch(name) {
        case "W".charCodeAt(0):
          return "moveForward";
        case "S".charCodeAt(0):
          return "moveBackward";
        case "Q".charCodeAt(0):
          return "moveUp";
        case "E".charCodeAt(0):
          return "moveDown";
        case "D".charCodeAt(0):
          return "moveRight";
        case "A".charCodeAt(0):
          return "moveLeft";
        default:
          return;
      }
    }
  }, {
    "key" : "deactivate",
    "value" : function() {
      this.isActivate = false;
    }
  }]);
  _inherits = values;
  expect(tick, [{
    "key" : `activate`,
    "value" : function() {
      var canvas = this.viewer.canvas;
      canvas.setAttribute("tabindex", "0");
      canvas.focus();
      if (!this.enable) {
        this.hpRoll = new Cesium["HeadingPitchRoll"];
        this.fixedFrameTransforms = Cesium.Transforms.localFrameToFixedFrameGenerator("north", "west");
        this.addModelPrimitive();
        this.registerEvens();
        this.enable = true;
      }
    }
  }, {
    "key" : "addModelPrimitive",
    "value" : function() {
      this.moveModel = this.viewer.scene.primitives.add(Cesium.Model.fromGltf({
        "url" : this.modelUrl,
        "modelMatrix" : Cesium.Transforms.headingPitchRollToFixedFrame(this.position, this.hpRoll, Cesium.Ellipsoid.WGS84, this.fixedFrameTransforms),
        "scale" : this.options.scale,
        "minimumPixelSize" : this.options.minimumPixelSize
      }));
    }
  }, {
    "key" : `registerEvens`,
    "value" : function() {
      var bonusTraitModifiers = this;
      var canvas = this.viewer.canvas;
      canvas.addEventListener("keydown", function(person) {
        var put_rows = hahaha;
        bonusTraitModifiers[put_rows(2650)](person, true);
      }, false);
      canvas.addEventListener("keyup", function(person) {
        var put_rows = hahaha;
        bonusTraitModifiers[put_rows(2650)](person, false);
      }, false);
      this.viewer.clock.onTick.addEventListener(this.tickEventHandler, this);
    }
  }, {
    "key" : `tickEventHandler`,
    "value" : function() {
      var that = this.flag;
      var shipBody = this.hpRoll;
      var shipTurnSpeed = this.radian;
      if (that.moveUp) {
        if (that.moveLeft) {
          shipBody.heading -= shipTurnSpeed;
        }
        if (that.moveRight) {
          shipBody.heading += shipTurnSpeed;
        }
        this.moveModelByKey(true);
      }
      if (that.moveDown) {
        if (that.moveLeft) {
          shipBody.heading -= shipTurnSpeed;
        }
        if (that.moveRight) {
          shipBody.heading += shipTurnSpeed;
        }
        this.moveModelByKey(false);
      }
      if (!(!that.moveLeft || that.moveDown || that.moveUp || that.moveRight)) {
        shipBody.heading -= shipTurnSpeed;
        Cesium.Transforms.headingPitchRollToFixedFrame(this.position, shipBody, Cesium.Ellipsoid.WGS84, this.fixedFrameTransforms, this.moveModel.modelMatrix);
      }
      if (!(!that.moveRight || that.moveDown || that.moveUp || that.moveLeft)) {
        shipBody.heading += shipTurnSpeed;
        Cesium.Transforms.headingPitchRollToFixedFrame(this.position, shipBody, Cesium.Ellipsoid.WGS84, this.fixedFrameTransforms, this.moveModel.modelMatrix);
      }
    }
  }, {
    "key" : `moveModelByKey`,
    "value" : function(name) {
      this.speedVector = 0 < name ? Cesium.Cartesian3.multiplyByScalar(Cesium.Cartesian3.UNIT_X, this.speed, this.speedVector) : Cesium.Cartesian3.multiplyByScalar(Cesium.Cartesian3.UNIT_X, -this.speed, this.speedVector);
      name = Cesium.Matrix4.multiplyByPoint(this.moveModel.modelMatrix, this.speedVector, this.position);
      Cesium.Transforms.headingPitchRollToFixedFrame(name, this.hpRoll, Cesium.Ellipsoid.WGS84, this.fixedFrameTransforms, this.moveModel.modelMatrix);
    }
  }, {
    "key" : `setFlagStatus`,
    "value" : function(value, target) {
      switch(value.keyCode) {
        case 65:
          this.flag.moveLeft = target;
          break;
        case 87:
          this.flag.moveUp = target;
          break;
        case 68:
          this.flag.moveRight = target;
          break;
        case 83:
          this.flag.moveDown = target;
      }
    }
  }, {
    "key" : `deactivate`,
    "value" : function() {
      this.unRegisterEvents();
      this.reomveModelPrimitive();
      this.enable = false;
    }
  }, {
    "key" : `reomveModelPrimitive`,
    "value" : function() {
      this.viewer.scene.primitives.remove(this.moveModel);
    }
  }, {
    "key" : `unRegisterEvents`,
    "value" : function() {
      this.viewer.clock.onTick.removeEventListener(this.tickEventHandler, this);
    }
  }]);
  view = tick;
  expect(prepare, [{
    "key" : `activate`,
    "value" : function() {
      var canvas = this.viewer.canvas;
      canvas.setAttribute("tabindex", "0");
      canvas.focus();
      if (!this.enable) {
        this.hpRoll = new Cesium["HeadingPitchRoll"];
        this.fixedFrameTransforms = Cesium.Transforms.localFrameToFixedFrameGenerator("north", "west");
        this.addModelPrimitive();
        this.registerEvens();
        this.enable = true;
      }
    }
  }, {
    "key" : "addModelPrimitive",
    "value" : function() {
      this.moveModel = this.viewer.scene.primitives.add(Cesium.Model.fromGltf({
        "url" : this.modelUrl,
        "modelMatrix" : Cesium.Transforms.headingPitchRollToFixedFrame(this.position, this.hpRoll, Cesium.Ellipsoid.WGS84, this.fixedFrameTransforms),
        "scale" : this.options.scale,
        "minimumPixelSize" : this.options.minimumPixelSize
      }));
    }
  }, {
    "key" : `registerEvens`,
    "value" : function() {
      var foreignControls = this;
      var canvas = this.viewer.canvas;
      canvas.addEventListener("keydown", function(data) {
        var put_rows = hahaha;
        foreignControls[put_rows(2650)](data, true);
      }, false);
      canvas.addEventListener("keyup", function(reverseControl) {
        foreignControls.setFlagStatus(reverseControl, false);
      }, false);
      this.viewer.clock.onTick.addEventListener(this.tickEventHandler, this);
    }
  }, {
    "key" : `tickEventHandler`,
    "value" : function() {
      var controls = this.flag;
      var shipBody = this.hpRoll;
      var shipTurnSpeed = this.radian;
      if (controls.moveUp) {
        if (controls.moveLeft) {
          shipBody.heading -= shipTurnSpeed;
        }
        if (controls.moveRight) {
          shipBody.heading += shipTurnSpeed;
        }
        this.moveModelByKey(true);
      }
      if (controls.moveDown) {
        if (controls.moveLeft) {
          shipBody.heading -= shipTurnSpeed;
        }
        if (controls.moveRight) {
          shipBody.heading += shipTurnSpeed;
        }
        this.moveModelByKey(false);
      }
      if (!(!controls.moveLeft || controls.moveDown || controls.moveUp || controls.moveRight)) {
        shipBody.heading -= shipTurnSpeed;
        Cesium.Transforms.headingPitchRollToFixedFrame(this.position, shipBody, Cesium.Ellipsoid.WGS84, this.fixedFrameTransforms, this.moveModel.modelMatrix);
      }
      if (!(!controls.moveRight || controls.moveDown || controls.moveUp || controls.moveLeft)) {
        shipBody.heading += shipTurnSpeed;
        Cesium.Transforms.headingPitchRollToFixedFrame(this.position, shipBody, Cesium.Ellipsoid.WGS84, this.fixedFrameTransforms, this.moveModel.modelMatrix);
      }
      if (controls.moveLeft || controls.moveDown || controls.moveUp || controls.moveRight) {
        this.lookAt();
      } else {
        this.viewer.camera.lookAtTransform(Cesium.Matrix4.IDENTITY);
      }
    }
  }, {
    "key" : `lookAt`,
    "value" : function() {
      var _0x2bc09a;
      var right;
      if (this.role) {
        _0x2bc09a = 2 * Math.max(this.moveModel.boundingSphere.radius, this.viewer.camera.frustum.near);
        right = new Cesium.Cartesian3;
        Cesium.Matrix4.multiplyByPoint(this.moveModel.modelMatrix, right, this.position);
        this.hpRange.heading = this.hpRoll.heading;
        this.hpRange.pitch = this.hpRoll.pitch - Cesium.Math.toRadians(30);
        this.hpRange.range = 5 * _0x2bc09a;
        this.viewer.camera.lookAt(this.position, this.hpRange);
      }
    }
  }, {
    "key" : `moveModelByKey`,
    "value" : function(name) {
      this.speedVector = 0 < name ? Cesium.Cartesian3.multiplyByScalar(Cesium.Cartesian3.UNIT_X, this.speed, this.speedVector) : Cesium.Cartesian3.multiplyByScalar(Cesium.Cartesian3.UNIT_X, -this.speed, this.speedVector);
      name = Cesium.Matrix4.multiplyByPoint(this.moveModel.modelMatrix, this.speedVector, this.position);
      if (this.options.aotuPickHeight) {
        name = this.getPositionByHeight(name);
      }
      Cesium.Transforms.headingPitchRollToFixedFrame(name, this.hpRoll, Cesium.Ellipsoid.WGS84, this.fixedFrameTransforms, this.moveModel.modelMatrix);
    }
  }, {
    "key" : "getPositionByHeight",
    "value" : function(value) {
      var c = Cesium.Cartographic.fromCartesian(value);
      value = this.viewer.scene.sampleHeight(c, [this.moveModel]);
      return c.height = value, Cesium.Cartographic.toCartesian(c, Cesium.Ellipsoid.WGS84);
    }
  }, {
    "key" : `setFlagStatus`,
    "value" : function(value, target) {
      switch(value.keyCode) {
        case 65:
          this.flag.moveLeft = target;
          break;
        case 87:
          this.flag.moveUp = target;
          break;
        case 68:
          this.flag.moveRight = target;
          break;
        case 83:
          this.flag.moveDown = target;
      }
    }
  }, {
    "key" : `deactivate`,
    "value" : function() {
      this.unRegisterEvents();
      this.reomveModelPrimitive();
      this.enable = false;
    }
  }, {
    "key" : `reomveModelPrimitive`,
    "value" : function() {
      this.viewer.scene.primitives.remove(this.moveModel);
    }
  }, {
    "key" : `unRegisterEvents`,
    "value" : function() {
      this.viewer.clock.onTick.removeEventListener(this.tickEventHandler, this);
    }
  }]);
  mode = prepare;
  xt3d.KeyboardDominate = {
    "KeyboardCamera" : _inherits,
    "KeyboardModel" : view,
    "KeyboardModelExt" : mode
  };
  expect(tabs, [{
    "key" : "activate",
    "value" : function(type) {
      this.deactivate();
      this.clear();
      this.drawType = type;
      this.positions = [];
      this.tempPositions = [];
      this.registerEvents();
      this.viewer.enableCursorStyle = false;
      this.viewer._element.style.cursor = "default";
    }
  }, {
    "key" : `deactivate`,
    "value" : function() {
      this.unRegisterEvents();
      this.drawType = void 0;
      this.drawEntity = void 0;
      this.viewer._element.style.cursor = "pointer";
      this.viewer.enableCursorStyle = true;
    }
  }, {
    "key" : `clear`,
    "value" : function() {
      if (this.drawEntity) {
        this.viewer.entities.remove(this.drawEntity);
        this.drawEntity = void 0;
      }
    }
  }, {
    "key" : `initEvents`,
    "value" : function() {
      this.handler = new Cesium["ScreenSpaceEventHandler"](this.viewer.scene.canvas);
      this.DrawStartEvent = new Cesium.Event;
      this.DrawEndEvent = new Cesium.Event;
    }
  }, {
    "key" : `registerEvents`,
    "value" : function() {
      this.leftClickEvent();
      this.rightClickEvent();
      this.mouseMoveEvent();
    }
  }, {
    "key" : "leftClickEvent",
    "value" : function() {
      var o = this;
      this.handler.setInputAction(function(store) {
        var camelize = hahaha;
        o[camelize(2276)][camelize(2530)][camelize(1998)][camelize(737)] = "default";
        var artistTrack = o[camelize(2276)][camelize(2758)][camelize(1238)](store[camelize(586)]);
        if (artistTrack = artistTrack || o.viewer[camelize(2758)].camera[camelize(1080)](store.position, o[camelize(2276)][camelize(2758)][camelize(2359)][camelize(1923)])) {
          o.positions[camelize(2008)](artistTrack);
          if (1 == o.positions[camelize(2189)]) {
            o[camelize(2724)]();
          }
        }
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
    }
  }, {
    "key" : `handleFirstPosition`,
    "value" : function() {
      switch(this.drawType) {
        case "Point":
          this.generatePoint();
          this.drawEnd();
          break;
        case "Polyline":
          this.generatePolyline();
          break;
        case "Polygon":
          this.generatePolygon();
      }
    }
  }, {
    "key" : `generatePoint`,
    "value" : function() {
      this.drawEntity = this.viewer.entities.add({
        "position" : this.positions[0],
        "point" : {
          "pixelSize" : 4,
          "color" : Cesium.Color.RED
        }
      });
    }
  }, {
    "key" : `generatePolyline`,
    "value" : function() {
      var primaryReplicas = this;
      this.drawEntity = this.viewer.entities.add({
        "polyline" : {
          "positions" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
            var stringify = hahaha;
            return primaryReplicas[stringify(3119)];
          }, false),
          "width" : 2,
          "material" : new Cesium["PolylineDashMaterialProperty"]({
            "color" : Cesium.Color.YELLOW
          }),
          "depthFailMaterial" : new Cesium["PolylineDashMaterialProperty"]({
            "color" : Cesium.Color.YELLOW
          })
        }
      });
    }
  }, {
    "key" : `generatePolygon`,
    "value" : function() {
      var same = this;
      this.drawEntity = this.viewer.entities.add({
        "polygon" : {
          "hierarchy" : new Cesium.CallbackProperty(function(canCreateDiscussions) {
            var put_rows = hahaha;
            return new (Cesium[put_rows(1433)])(same[put_rows(3119)]);
          }, false),
          "material" : Cesium.Color.RED.withAlpha(0.4),
          "perPositionHeight" : true
        },
        "polyline" : {
          "positions" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
            var rel2Mstr = hahaha;
            return same[rel2Mstr(3119)][rel2Mstr(439)](same[rel2Mstr(3119)][0]);
          }, false),
          "width" : 1,
          "material" : new Cesium["PolylineDashMaterialProperty"]({
            "color" : Cesium.Color.YELLOW
          }),
          "depthFailMaterial" : new Cesium.PolylineDashMaterialProperty({
            "color" : Cesium.Color.YELLOW
          })
        }
      });
    }
  }, {
    "key" : `mouseMoveEvent`,
    "value" : function() {
      var obj = this;
      this.handler.setInputAction(function(result) {
        var parseInt = hahaha;
        obj[parseInt(2276)]._element[parseInt(1998)][parseInt(737)] = "default";
        var member = obj[parseInt(2276)].scene[parseInt(1238)](result.endPosition);
        if ((member = member || obj[parseInt(2276)][parseInt(2758)].camera.pickEllipsoid(result[parseInt(1108)], obj.viewer[parseInt(2758)][parseInt(2359)][parseInt(1923)])) && obj[parseInt(2280)]) {
          obj[parseInt(3119)] = obj[parseInt(1707)][parseInt(439)]([member]);
        }
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
    }
  }, {
    "key" : `rightClickEvent`,
    "value" : function() {
      var obj = this;
      this.handler.setInputAction(function(canCreateDiscussions) {
        var parseInt = hahaha;
        if (obj[parseInt(2280)]) {
          switch(obj.drawType) {
            case parseInt(1811):
              obj[parseInt(2280)][parseInt(1562)][parseInt(1707)] = obj[parseInt(1707)];
              obj[parseInt(3107)] = 2;
              break;
            case parseInt(1195):
              obj.drawEntity[parseInt(2544)].hierarchy = obj[parseInt(1707)];
              obj[parseInt(2280)][parseInt(1562)][parseInt(1707)] = obj.positions[parseInt(439)](obj[parseInt(1707)][0]);
              obj[parseInt(3107)] = 3;
          }
          if (obj[parseInt(1707)][parseInt(2189)] < obj.minPositionCount) {
            return obj[parseInt(2822)](), void obj[parseInt(1983)]();
          }
          obj[parseInt(2788)]();
        } else {
          obj.deactivate();
        }
      }, Cesium.ScreenSpaceEventType.RIGHT_CLICK);
    }
  }, {
    "key" : "unRegisterEvents",
    "value" : function() {
      this.handler.removeInputAction(Cesium.ScreenSpaceEventType.RIGHT_CLICK);
      this.handler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_CLICK);
      this.handler.removeInputAction(Cesium.ScreenSpaceEventType.MOUSE_MOVE);
      this.handler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);
    }
  }, {
    "key" : `drawEnd`,
    "value" : function() {
      var map = this;
      this.drawEntity.remove = function() {
        var parseInt = hahaha;
        map[parseInt(2276)][parseInt(1319)].remove(map[parseInt(2280)]);
      };
      this.DrawEndEvent.raiseEvent(this.drawEntity, this.positions, this.drawType);
      this.deactivate();
    }
  }]);
  k = tabs;
  expect(entry, [{
    "key" : `initEventHandler`,
    "value" : function() {
      this.eventHandler = new Cesium["ScreenSpaceEventHandler"](this.viewer.scene.canvas);
      this.EditEndEvent = new Cesium.Event;
    }
  }, {
    "key" : `activate`,
    "value" : function() {
      this.deactivate();
      this.initLeftClickEventHandler();
    }
  }, {
    "key" : `deactivate`,
    "value" : function() {
      this.eventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_CLICK);
      this.unRegisterEvents();
      this.clearAllEditVertex();
    }
  }, {
    "key" : "clearAllEditVertex",
    "value" : function() {
      this.clearEditVertex();
      this.clearMidVertex();
    }
  }, {
    "key" : `initLeftClickEventHandler`,
    "value" : function() {
      var values = this;
      this.eventHandler.setInputAction(function(s) {
        var parseInt = hahaha;
        s = values[parseInt(2276)][parseInt(2758)][parseInt(1708)](s.position);
        if (s && s.id) {
          if (s.id && s.id[parseInt(2245)]) {
            if (!(values[parseInt(1652)] && values[parseInt(1652)].id == s.id.id)) {
              values[parseInt(905)]();
              values[parseInt(834)](s.id);
            }
          }
        } else {
          values[parseInt(905)]();
        }
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
    }
  }, {
    "key" : `handleEditEntity`,
    "value" : function() {
      this.unRegisterEvents();
      this.clearAllEditVertex();
      var result = this.editEntity;
      if (result) {
        this.closeEntityEditMode();
        this.editEntity = void 0;
        if (this.isEdited) {
          this.EditEndEvent.raiseEvent(result);
          this.isEdited = false;
          this.isEditing = false;
        }
      }
    }
  }, {
    "key" : "handlePickEditEntity",
    "value" : function(type) {
      if (-1 != ["EditableMarker", "EditablePolyline", "EditablePolygon"].indexOf(type.Type)) {
        this.editEntity = type;
        this.isEditing = false;
        this.isEdited = false;
        this.editPositions = this.getEditEntityPositions();
        this.EditMoveCenterPositoin = this.getCenterPosition();
        this.openEntityEditModel();
        this.clearAllEditVertex();
        this.unRegisterEvents();
        this.createEditVertex();
        this.createMidVertex();
        this.registerEvents();
      }
    }
  }, {
    "key" : `openEntityEditModel`,
    "value" : function() {
      var primaryReplicas = this;
      switch(this.editEntity.Type) {
        case "EditableMarker":
          this.editEntity.position = new Cesium.CallbackProperty(function(canCreateDiscussions) {
            return primaryReplicas.editPositions[0];
          }, false);
          break;
        case "EditablePolyline":
          this.editEntity.polyline.positions = new Cesium["CallbackProperty"](function(canCreateDiscussions) {
            var stringify = hahaha;
            return primaryReplicas[stringify(1484)];
          }, false);
          break;
        case "EditablePolygon":
          this.editEntity.polygon.hierarchy = new Cesium.CallbackProperty(function(canCreateDiscussions) {
            var stringify = hahaha;
            return new (Cesium[stringify(1433)])(primaryReplicas[stringify(1484)]);
          }, false);
          if (this.editEntity.polyline) {
            this.editEntity.polyline.positions = new Cesium["CallbackProperty"](function(canCreateDiscussions) {
              var stringify = hahaha;
              return primaryReplicas[stringify(1484)].concat(primaryReplicas[stringify(1484)][0]);
            }, false);
          }
      }
    }
  }, {
    "key" : `closeEntityEditMode`,
    "value" : function() {
      switch(this.editEntity.Type) {
        case "EditableMarker":
          this.editEntity.position = this.editPositions[0];
          break;
        case "EditablePolyline":
          this.editEntity.polyline.positions = this.editPositions;
          break;
        case "EditablePolygon":
          this.editEntity.polygon.hierarchy = this.editPositions;
          if (this.editEntity.polyline) {
            this.editEntity.polyline.positions = this.editPositions.concat(this.editPositions[0]);
          }
      }
    }
  }, {
    "key" : `getEditEntityPositions`,
    "value" : function() {
      switch(this.editEntity.Type) {
        case "EditableMarker":
          return [this.editEntity.position._value];
        case "EditablePolyline":
          return this.editEntity.polyline.positions._value;
        case "EditablePolygon":
          return this.editEntity.polygon.hierarchy._value.positions;
      }
    }
  }, {
    "key" : `registerEvents`,
    "value" : function() {
      this.initLeftDownEventHandler();
      this.initMouseMoveEventHandler();
      this.initLeftUpEventHandler();
    }
  }, {
    "key" : "unRegisterEvents",
    "value" : function() {
      this.eventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOWN);
      this.eventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_UP);
      this.eventHandler.removeInputAction(Cesium.ScreenSpaceEventType.MOUSE_MOVE);
    }
  }, {
    "key" : `initLeftDownEventHandler`,
    "value" : function() {
      var data = this;
      this.eventHandler.setInputAction(function(track) {
        var getRefreshTokenKey = hahaha;
        track = data.viewer.scene[getRefreshTokenKey(1708)](track.position);
        if (track && track.id && track.id.type) {
          if (getRefreshTokenKey(2919) == track.id.type || "EditMove" == track.id[getRefreshTokenKey(1720)]) {
            data[getRefreshTokenKey(3088)] = true;
            data[getRefreshTokenKey(2276)].scene[getRefreshTokenKey(2190)].enableRotate = false;
            data[getRefreshTokenKey(2276)].enableCursorStyle = false;
            data[getRefreshTokenKey(2276)][getRefreshTokenKey(2530)][getRefreshTokenKey(1998)].cursor = "";
            document.body.style.cursor = getRefreshTokenKey(367);
            data.editVertext = track.id;
            data[getRefreshTokenKey(1670)][getRefreshTokenKey(2752)] = false;
            data.clearMidVertex();
          } else {
            if (getRefreshTokenKey(2487) == track.id[getRefreshTokenKey(1720)]) {
              data[getRefreshTokenKey(1484)].splice(track.id[getRefreshTokenKey(1593)], 0, track.id[getRefreshTokenKey(586)][getRefreshTokenKey(2041)]);
              data[getRefreshTokenKey(3070)]();
              data[getRefreshTokenKey(1779)]();
              data.createMidVertex();
              data.isEdited = true;
            }
          }
        }
      }, Cesium.ScreenSpaceEventType.LEFT_DOWN);
    }
  }, {
    "key" : `initLeftUpEventHandler`,
    "value" : function() {
      var self = this;
      this.eventHandler.setInputAction(function(canCreateDiscussions) {
        if (self.isEditing) {
          self.viewer.enableCursorStyle = true;
          document.body.style.cursor = "default";
          self.viewer.scene.screenSpaceCameraController.enableRotate = true;
          self.editVertext.show = true;
          self.isEditing = false;
          self.clearMidVertex();
          self.createMidVertex();
        }
      }, Cesium.ScreenSpaceEventType.LEFT_UP);
    }
  }, {
    "key" : `initMouseMoveEventHandler`,
    "value" : function() {
      var data = this;
      this.eventHandler.setInputAction(function(notes) {
        var String = hahaha;
        var email = (email = data[String(2276)].scene[String(1238)](notes[String(2840)])) || data.viewer[String(2758)].camera[String(1080)](notes[String(2840)], data[String(2276)].scene.globe[String(1923)]);
        if (email && data.isEditing) {
          if (String(1786) == data[String(1670)][String(1720)]) {
            notes = data.EditMoveCenterPositoin;
            if (!notes) {
              return;
            }
            data.moveEntityByOffset(notes, email);
          } else {
            data[String(1484)][data.editVertext.vertexIndex] = email;
          }
          data[String(581)] = true;
          data[String(1054)] = data.getCenterPosition();
        }
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
    }
  }, {
    "key" : `getCenterPosition`,
    "value" : function() {
      var primaryReplicas = this;
      var line = [];
      var z = 0;
      if ("EditableMarker" == this.editEntity.Type) {
        return this.editPositions[0];
      }
      this.editPositions.forEach(function(data) {
        var stringify = hahaha;
        data = primaryReplicas[stringify(1028)](data);
        line[stringify(2008)]([data.x, data.y]);
        if (z < data.z) {
          z = data.z;
        }
      });
      var tmp = turf.lineString(line);
      tmp = turf.bbox(tmp);
      tmp = turf.bboxPolygon(tmp);
      tmp = turf.center(tmp).geometry.coordinates;
      return Cesium.Cartesian3.fromDegrees(tmp[0], tmp[1], z);
    }
  }, {
    "key" : `moveEntityByOffset`,
    "value" : function(target, object) {
      target = this.cartesian3ToPoint3D(target);
      object = this.cartesian3ToPoint3D(object);
      var mergeAxisLength = object.x - target.x;
      var SHIP_SPEED = object.y - target.y;
      var json = void 0;
      var layer_i = 0;
      for (; layer_i < this.editPositions.length; layer_i++) {
        (json = this.cartesian3ToPoint3D(this.editPositions[layer_i])).x += mergeAxisLength;
        json.y += SHIP_SPEED;
        this.editPositions[layer_i] = Cesium.Cartesian3.fromDegrees(json.x, json.y, json.z);
      }
    }
  }, {
    "key" : "createEditVertex",
    "value" : function() {
      var DBase = this;
      this.vertexEntities = [];
      this.editPositions.forEach(function(canCreateDiscussions, key) {
        var type = hahaha;
        var falseySection = DBase[type(2276)][type(1319)][type(3010)]({
          "position" : new (Cesium[type(1679)])(function(canCreateDiscussions) {
            var norm = type;
            return DBase[norm(1484)][key];
          }, false),
          "type" : type(2919),
          "vertexIndex" : key,
          "point" : {
            "color" : Cesium[type(2292)][type(3198)][type(2265)](0.4),
            "pixelSize" : 10,
            "outlineColor" : Cesium.Color.YELLOW[type(2265)](0.4),
            "outlineWidth" : 3,
            "disableDepthTestDistance" : 2E3
          }
        });
        DBase[type(1220)].push(falseySection);
      });
      if (1 != this.editPositions.length) {
        this.createEditMoveCenterEntity();
      }
    }
  }, {
    "key" : `createEditMoveCenterEntity`,
    "value" : function() {
      var primaryReplicas = this;
      this.EditMoveCenterEntity = this.viewer.entities.add({
        "position" : new Cesium.CallbackProperty(function(canCreateDiscussions) {
          var stringify = hahaha;
          return primaryReplicas[stringify(1054)];
        }, false),
        "type" : "EditMove",
        "point" : {
          "color" : Cesium.Color.RED.withAlpha(0.4),
          "pixelSize" : 10,
          "outlineColor" : Cesium.Color.WHITE.withAlpha(0.3),
          "outlineWidth" : 3,
          "disableDepthTestDistance" : 2E3
        }
      });
    }
  }, {
    "key" : `clearEditVertex`,
    "value" : function() {
      var same = this;
      if (this.vertexEntities) {
        this.vertexEntities.forEach(function(mmCoreSplitViewBlock) {
          var rel2Mstr = hahaha;
          same[rel2Mstr(2276)][rel2Mstr(1319)][rel2Mstr(508)](mmCoreSplitViewBlock);
        });
      }
      this.vertexEntities = [];
      this.viewer.entities.remove(this.EditMoveCenterEntity);
    }
  }, {
    "key" : "createMidVertex",
    "value" : function() {
      this.midVertexEntities = [];
      var layer_i = 0;
      for (; layer_i < this.editPositions.length; layer_i++) {
        var layer = this.editPositions[layer_i];
        var where = this.editPositions[layer_i + 1];
        where = this.midPosition(layer, where);
        where = this.viewer.entities.add({
          "position" : where,
          "type" : "EditMidVertex",
          "vertexIndex" : layer_i + 1,
          "point" : {
            "color" : Cesium.Color.LIMEGREEN.withAlpha(0.4),
            "pixelSize" : 10,
            "outlineColor" : Cesium.Color.YELLOW.withAlpha(0.4),
            "outlineWidth" : 3,
            "disableDepthTestDistance" : 2E3
          }
        });
        this.midVertexEntities.push(where);
      }
    }
  }, {
    "key" : "clearMidVertex",
    "value" : function() {
      var lithe = this;
      if (this.midVertexEntities) {
        this.midVertexEntities.forEach(function(mmCoreSplitViewBlock) {
          var resolve = hahaha;
          lithe.viewer[resolve(1319)][resolve(508)](mmCoreSplitViewBlock);
        });
      }
      this.midVertexEntities = [];
    }
  }, {
    "key" : `cartesian3ToPoint3D`,
    "value" : function(target) {
      return target = Cesium.Cartographic.fromCartesian(target), {
        "x" : Cesium.Math.toDegrees(target.longitude),
        "y" : Cesium.Math.toDegrees(target.latitude),
        "z" : target.height
      };
    }
  }, {
    "key" : `midPosition`,
    "value" : function(object, target) {
      if (!object || !target) {
        return null;
      }
      return object = this.cartesian3ToPoint3D(object), target = this.cartesian3ToPoint3D(target), target = {
        "x" : (object.x + target.x) / 2,
        "y" : (object.y + target.y) / 2,
        "z" : (object.z + target.z) / 2
      }, Cesium.Cartesian3.fromDegrees(target.x, target.y, target.z);
    }
  }]);
  entryToSend = entry;
  appendCSS(`.moveAnimation {\n    position: absolute;\n    left: 0px;\n    bottom: 0px;\n    animation: moveTo 1.5s infinite;\n    backface-visibility: hidden;\n    -webkit-backface-visibility: hidden;\n    -webkit-animation-style: preserve-3d;\n}\n\n@keyframes moveTo {\n    0% {\n        transform: translate3d(0, 0px, 0);\n    }\n    25% {\n        transform: translate3d(0, -6px, 0);\n    }\n    50% {\n        transform: translate3d(0, -4px, 0);\n    }\n    75% {\n        transform: translate3d(0, -2px, 0);\n    }\n    100% {\n        transform: translate3d(0, 0px, 0);\n    }\n}\n\n.is-shulie-item1 {\n    color: rgb(240, 111, 7);\n    font-size: 14px;\n    font-weight: bold;\n    font-family: "\u5e7c\u5706";\n    width: 100px;\n    text-align: center;\n}\n\n.sanjiao_arrow {\n    width: 12px;\n    height: 12px;\n    border-width: 15px;\n    border-color: transparent;\n    border-top-color: rgb(240, 111, 7);\n    border-style: solid;\n    position: relative;\n    left: 28px;\n    top: 15px;\n    border-radius: 100px 100px 90px 90px;\n}\n\n.pre-topCard-list-item-line1 {\n    display: block;\n    height: 30px;\n    width: 2px;\n    margin-left: 49%;\n    margin-top: -3px;\n    background: linear-gradient(rgb(240, 111, 7), #838B8B, #333);\n}`, 
  {});
  expect(constructor, [{
    "key" : `initDom`,
    "value" : function() {
      this.$htmlContainer = document.createElement("div");
      this.$htmlContainer.classList.add("moveAnimation");
      var label = document.createElement("div");
      label.classList.add("is-shulie-item1");
      label.innerHTML = this.label;
      this.$htmlContainer.appendChild(label);
      label = document.createElement("div");
      label.classList.add("sanjiao_arrow");
      this.$htmlContainer.appendChild(label);
      label = document.createElement("div");
      label.classList.add("pre-topCard-list-item-line1");
      this.$htmlContainer.appendChild(label);
      this.viewer.cesiumWidget.container.appendChild(this.$htmlContainer);
      this.viewer.scene.postRender.addEventListener(this.postRenderEvent, this);
    }
  }, {
    "key" : `initEvent`,
    "value" : function() {
      this.viewer.scene.postRender.addEventListener(this.postRenderEventHandle, this);
    }
  }, {
    "key" : "postRenderEventHandle",
    "value" : function() {
      var h = this.viewer.scene.canvas.height;
      var p = new Cesium["Cartesian2"];
      Cesium.SceneTransforms.wgs84ToWindowCoordinates(this.viewer.scene, this.position, p);
      this.$htmlContainer.style.bottom = h + 30 - p.y + "px";
      h = this.$htmlContainer.offsetWidth;
      this.$htmlContainer.style.left = p.x - h / 2 + "px";
      p = this.viewer.camera.position;
      h = this.viewer.scene.globe.ellipsoid.cartesianToCartographic(p).height;
      h = h + this.viewer.scene.globe.ellipsoid.maximumRadius;
      if (Cesium.Cartesian3.distance(p, this.position) > h) {
        this.$htmlContainer.style.display = "none";
      } else {
        this.$htmlContainer.style.display = "block";
        if (6E3 < this.viewer.camera.positionCartographic.height) {
          this.$htmlContainer.style.display = "none";
        } else {
          this.$htmlContainer.style.display = "block";
        }
      }
    }
  }, {
    "key" : "remove",
    "value" : function() {
      this.viewer.scene.postRender.removeEventListener(this.postRenderEventHandle, this);
    }
  }]);
  name = constructor;
  appendCSS(`@charset "UTF-8";\n\n@font-face {\n  font-family: "LED";\n  src: url("LED.woff2") format("woff2"),\n       url("LED.woff") format("woff"),\n       url("LED.ttf") format("truetype"),\n       url("LED.eot") format("embedded-opentype"),\n       url("LED.svg") format("svg");\n  font-weight: normal;\n  font-style: normal;\n}`, {});
  appendCSS(`.label-led-container {\n    position: absolute;\n    left: 0px;\n    bottom: 0px;\n    text-align: center;\n    font-family: 'LED';\n    font-size: 24px;\n    font-weight: 100;\n    margin: 0px;\n    pointer-events: none;\n    background-image: -webkit-linear-gradient(bottom, red, #fd8403, yellow);\n    /* background-image: -webkit-linear-gradient(bottom, yellow, #ffeb3b, #fdfdfc); */\n    -webkit-background-clip: text;\n    -webkit-text-fill-color: transparent;\n}`, {});
  expect(count, [{
    "key" : `initDom`,
    "value" : function() {
      this.$htmlContainer = document.createElement("h3");
      this.$htmlContainer.classList.add("label-led-container");
      this.$htmlContainer.innerHTML = this.label;
      this.viewer.cesiumWidget.container.appendChild(this.$htmlContainer);
      this.viewer.scene.postRender.addEventListener(this.postRenderEvent, this);
    }
  }, {
    "key" : "initEvent",
    "value" : function() {
      this.viewer.scene.postRender.addEventListener(this.postRenderEventHandle, this);
    }
  }, {
    "key" : "postRenderEventHandle",
    "value" : function() {
      var h = this.viewer.scene.canvas.height;
      var p = new Cesium.Cartesian2;
      Cesium.SceneTransforms.wgs84ToWindowCoordinates(this.viewer.scene, this.position, p);
      this.$htmlContainer.style.bottom = h + 30 - p.y + "px";
      h = this.$htmlContainer.offsetWidth;
      this.$htmlContainer.style.left = p.x - h / 2 + "px";
      p = this.viewer.camera.position;
      h = this.viewer.scene.globe.ellipsoid.cartesianToCartographic(p).height;
      h = h + this.viewer.scene.globe.ellipsoid.maximumRadius;
      if (Cesium.Cartesian3.distance(p, this.position) > h) {
        this.$htmlContainer.style.display = "none";
      } else {
        this.$htmlContainer.style.display = "block";
        if (4E5 < this.viewer.camera.positionCartographic.height) {
          this.$htmlContainer.style.display = "none";
        } else {
          this.$htmlContainer.style.display = "block";
        }
      }
    }
  }, {
    "key" : "remove",
    "value" : function() {
      this.viewer.scene.postRender.removeEventListener(this.postRenderEventHandle, this);
    }
  }]);
  pos = count;
  appendCSS(` .plot-draw-tip-container {\n     position: absolute;\n     background: rgba(0, 0, 0, 0.637);\n     padding: 6px;\n     color: white;\n     pointer-events: none;\n }\n \n .plot-draw-tip-container::before {\n     position: absolute;\n     content: "";\n     top: calc(50% - 10px);\n     left: -10px;\n     border-bottom: 10px solid transparent;\n     border-top: 10px solid transparent;\n     border-right: 10px solid rgba(0, 0, 0, 0.637);\n }`, {});
  var Map = (expect(renderer, [{
    "key" : `setContent`,
    "value" : function(name) {
      var artistTrack;
      var same = this;
      if (name) {
        this.removeAllChild();
        artistTrack = void 0;
        name.forEach(function(canCreateDiscussions) {
          var rel2Mstr = hahaha;
          (artistTrack = document[rel2Mstr(1442)](rel2Mstr(889)))[rel2Mstr(3008)] = canCreateDiscussions;
          same[rel2Mstr(2226)][rel2Mstr(1545)](artistTrack);
        });
      }
    }
  }, {
    "key" : `updatePosition`,
    "value" : function(obj) {
      this.position = obj;
    }
  }, {
    "key" : "addPostRender",
    "value" : function() {
      this.viewer.scene.postRender.addEventListener(this.postRender, this);
    }
  }, {
    "key" : `postRender`,
    "value" : function() {
      var scrollHeight;
      var target;
      if (this.container && this.container.style && this.position) {
        scrollHeight = this.viewer.scene.canvas.height;
        target = new Cesium["Cartesian2"];
        Cesium.SceneTransforms.wgs84ToWindowCoordinates(this.viewer.scene, this.position, target);
        this.container.style.bottom = scrollHeight - target.y - 20 + "px";
        this.container.offsetWidth;
        this.container.style.left = target.x + 50 + "px";
      }
    }
  }, {
    "key" : "remove",
    "value" : function() {
      this.viewer.cesiumWidget.container.removeChild(this.container);
      this.viewer.scene.postRender.removeEventListener(this.postRender, this);
    }
  }, {
    "key" : `createDom`,
    "value" : function() {
      this.container = document.createElement("div");
      this.container.classList.add("plot-draw-tip-container");
      this.viewer.cesiumWidget.container.appendChild(this.container);
    }
  }, {
    "key" : `removeAllChild`,
    "value" : function() {
      for (; this.container.hasChildNodes();) {
        this.container.removeChild(this.container.firstChild);
      }
    }
  }]), renderer);
  var Date = (expect(anonymous, [{
    "key" : `addPoint`,
    "value" : function() {
      this.mousePointEntity = this.viewer.entities.add({
        "point" : {
          "pixelSize" : 8,
          "color" : Cesium.Color.AQUA,
          "outlineWidth" : 1,
          "outlineColor" : Cesium.Color.WHITE
        }
      });
    }
  }, {
    "key" : `updatePosition`,
    "value" : function(name) {
      this.mousePointEntity.position = name;
    }
  }, {
    "key" : "remove",
    "value" : function() {
      this.viewer.entities.remove(this.mousePointEntity);
    }
  }]), anonymous);
  var IPTYPE = {
    "ARC" : `arc`,
    "ELLIPSE" : "ellipse",
    "CURVE" : `curve`,
    "CLOSED_CURVE" : "closedcurve",
    "LUNE" : `lune`,
    "SECTOR" : "sector",
    "GATHERING_PLACE" : `gatheringplace`,
    "STRAIGHT_ARROW" : "straightarrow",
    "ASSAULT_DIRECTION" : `assaultdirection`,
    "ATTACK_ARROW" : `attackarrow`,
    "TAILED_ATTACK_ARROW" : `tailedattackarrow`,
    "SQUAD_COMBAT" : `squadcombat`,
    "TAILED_SQUAD_COMBAT" : `tailedsquadcombat`,
    "FINE_ARROW" : `finearrow`,
    "CIRCLE" : `circle`,
    "DOUBLE_ARROW" : "doublearrow",
    "POLYLINE" : "polyline",
    "FREEHAND_LINE" : `freehandline`,
    "POLYGON" : `polygon`,
    "FREEHAND_POLYGON" : `freehandpolygon`,
    "RECTANGLE" : `rectangle`,
    "MARKER" : `marker`,
    "TRIANGLE" : `triangle`
  };
  exports(Array, `Array`, function(iterated, kind) {
    this._t = find(iterated);
    this._i = 0;
    this._k = kind;
  }, function() {
    var O = this._t;
    var undefined = this._k;
    var index = this._i++;
    return !O || index >= O.length ? (this._t = void 0, addFile(1)) : addFile(0, "keys" == undefined ? index : "values" == undefined ? O[index] : [index, O[index]]);
  }, `values`);
  Iterators.Arguments = Iterators.Array;
  var tag = jQuery(`toStringTag`);
  var collections = `CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,TextTrackList,TouchList`.split(",");
  var ii = 0;
  for (; ii < collections.length; ii++) {
    var NAME = collections[ii];
    var options = global[NAME];
    options = options && options.prototype;
    if (options && !options[tag]) {
      hide(options, tag, NAME);
    }
    Iterators[NAME] = Iterators.Array;
  }
  var ret = {
    "f" : jQuery
  };
  var id = ret.f("iterator");
  var _prepareStyleProperties = __webpack_require__(function(module) {
    module.exports = {
      "default" : id,
      "__esModule" : true
    };
  });
  _interopRequireWildcard(_prepareStyleProperties);
  meta = __webpack_require__(function(module) {
    function setMeta(it) {
      setDesc(it, key, {
        "value" : {
          "i" : "O" + ++id,
          "w" : {}
        }
      });
    }
    var key = uid("meta");
    var setDesc = $.f;
    var id = 0;
    var isExtensible = Object.isExtensible || function() {
      return true;
    };
    var FREEZE = !processResource(function() {
      return isExtensible(Object.preventExtensions({}));
    });
    var meta = module.exports = {
      "KEY" : key,
      "NEED" : false,
      "fastKey" : function(it, create) {
        if (!isObject(it)) {
          return "symbol" == typeof it ? it : ("string" == typeof it ? "S" : "P") + it;
        }
        if (!has(it, key)) {
          if (!isExtensible(it)) {
            return "F";
          }
          if (!create) {
            return "E";
          }
          setMeta(it);
        }
        return it[key].i;
      },
      "getWeak" : function(it, create) {
        if (!has(it, key)) {
          if (!isExtensible(it)) {
            return true;
          }
          if (!create) {
            return false;
          }
          setMeta(it);
        }
        return it[key].w;
      },
      "onFreeze" : function(it) {
        return FREEZE && meta.NEED && isExtensible(it) && !has(it, key) && setMeta(it), it;
      }
    };
  });
  var maybeDefine = (meta.KEY, meta.NEED, meta.fastKey, meta.getWeak, meta.onFreeze, $.f);
  var req = {
    "f" : Object.getOwnPropertySymbols
  };
  var pIE = {
    "f" : {}.propertyIsEnumerable
  };
  var insertElement = Array.isArray || function(val) {
    return "Array" == lookup(val);
  };
  var keys2 = value.concat("length", "prototype");
  frame = {
    "f" : Object.getOwnPropertyNames || function(name) {
      return pick(name, keys2);
    }
  };
  var when = frame.f;
  var fnToStr = {}.toString;
  var converter = `object` == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
  state = {
    "f" : function(value) {
      return converter && "[object Window]" == fnToStr.call(value) ? function($Symbol) {
        try {
          return when($Symbol);
        } catch (_0x363607) {
          return converter.slice();
        }
      }(value) : when(find(value));
    }
  };
  var gOPD = Object.getOwnPropertyDescriptor;
  var obj1 = {
    "f" : es5 ? gOPD : function(value, key) {
      if (value = find(value), key = hash(key, true), _0x5c8815) {
        try {
          return gOPD(value, key);
        } catch (_0x478fca) {
        }
      }
      if (has(value, key)) {
        return createDesc(!pIE.f.call(value, key), value[key]);
      }
    }
  };
  var keyPath = meta.KEY;
  var read = obj1.f;
  var setDesc = $.f;
  var gOPN = state.f;
  var $Symbol = global.Symbol;
  var $JSON = global.JSON;
  var _stringify = $JSON && $JSON.stringify;
  var PROTOTYPE = "prototype";
  var a = jQuery(`_hidden`);
  ID = jQuery(`toPrimitive`);
  var isEnum = {}.propertyIsEnumerable;
  var SymbolRegistry = shared(`symbol-registry`);
  var AllSymbols = shared("symbols");
  var OPSymbols = shared(`op-symbols`);
  var undefined = Object[PROTOTYPE];
  tel = `function` == typeof $Symbol && !!req.f;
  output = global.QObject;
  var _0x1e6505 = !output || !output[PROTOTYPE] || !output[PROTOTYPE].findChild;
  var setSymbolDesc = es5 && processResource(function() {
    return 7 != _create(setDesc({}, "a", {
      "get" : function() {
        return setDesc(this, "a", {
          "value" : 7
        }).a;
      }
    })).a;
  }) ? function(type, key, o) {
    var value = read(undefined, key);
    if (value) {
      delete undefined[key];
    }
    setDesc(type, key, o);
    if (value && type !== undefined) {
      setDesc(undefined, key, value);
    }
  } : setDesc;
  var isSymbol = tel && `symbol` == typeof $Symbol.iterator ? function(x) {
    return "symbol" == typeof x;
  } : function(it) {
    return it instanceof $Symbol;
  };
  var set = function(value, key, obj) {
    return value === undefined && set(OPSymbols, key, obj), resolve(value), key = hash(key, true), resolve(obj), has(AllSymbols, key) ? (obj.enumerable ? (has(value, a) && value[a][key] && (value[a][key] = false), obj = _create(obj, {
      "enumerable" : createDesc(0, false)
    })) : (has(value, a) || setDesc(value, a, createDesc(1, {})), value[a][key] = true), setSymbolDesc(value, key, obj)) : setDesc(value, key, obj);
  };
  location = function(key) {
    var _0x5eccff = isEnum.call(this, key = hash(key, true));
    return !(this === undefined && has(AllSymbols, key) && !has(OPSymbols, key)) && (!(_0x5eccff || !has(this, key) || !has(AllSymbols, key) || has(this, a) && this[a][key]) || _0x5eccff);
  };
  doc = function(obj, value) {
    if (obj = find(obj), value = hash(value, true), obj !== undefined || !has(AllSymbols, value) || has(OPSymbols, value)) {
      var actual = read(obj, value);
      return !actual || !has(AllSymbols, value) || has(obj, a) && obj[a][value] || (actual.enumerable = true), actual;
    }
  };
  init = function(name) {
    var key;
    var names = gOPN(find(name));
    var folderPathClone = [];
    var i = 0;
    for (; names.length > i;) {
      if (!(has(AllSymbols, key = names[i++]) || key == a || key == keyPath)) {
        folderPathClone.push(key);
      }
    }
    return folderPathClone;
  };
  data = function(name) {
    var key;
    var IS_OP = name === undefined;
    var names = gOPN(IS_OP ? OPSymbols : find(name));
    var result = [];
    var i = 0;
    for (; names.length > i;) {
      if (!(!has(AllSymbols, key = names[i++]) || IS_OP && !has(undefined, key))) {
        result.push(AllSymbols[key]);
      }
    }
    return result;
  };
  if (!tel) {
    redefine(($Symbol = function() {
      if (this instanceof $Symbol) {
        throw TypeError("Symbol is not a constructor!");
      }
      var key = uid(0 < arguments.length ? arguments[0] : void 0);
      var $set = function(value) {
        if (this === undefined) {
          $set.call(OPSymbols, value);
        }
        if (has(this, a) && has(this[a], key)) {
          this[a][key] = false;
        }
        setSymbolDesc(this, key, createDesc(1, value));
      };
      return es5 && _0x1e6505 && setSymbolDesc(undefined, key, {
        "configurable" : true,
        "set" : $set
      }), wrap(key);
    })[PROTOTYPE], `toString`, function() {
      return this._k;
    });
    obj1.f = doc;
    $.f = set;
    frame.f = state.f = init;
    pIE.f = location;
    req.f = data;
    ret.f = function(name) {
      return wrap(jQuery(name));
    };
  }
  $export($export.G + $export.W + $export.F * !tel, {
    "Symbol" : $Symbol
  });
  var superUnique = `hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables`.split(",");
  var uniqueLength = 0;
  for (; superUnique.length > uniqueLength;) {
    jQuery(superUnique[uniqueLength++]);
  }
  var urls = flatten(jQuery.store);
  var simultaneousness = 0;
  for (; urls.length > simultaneousness;) {
    onLoad(urls[simultaneousness++]);
  }
  $export($export.S + $export.F * !tel, "Symbol", {
    "for" : function(key) {
      return has(SymbolRegistry, key = key + "") ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
    },
    "keyFor" : function(key) {
      if (!isSymbol(key)) {
        throw TypeError(key + " is not a symbol!");
      }
      var attrText;
      for (attrText in SymbolRegistry) {
        if (SymbolRegistry[attrText] === key) {
          return attrText;
        }
      }
    },
    "useSetter" : function() {
      _0x1e6505 = true;
    },
    "useSimple" : function() {
      _0x1e6505 = false;
    }
  });
  $export($export.S + $export.F * !tel, `Object`, {
    "create" : function(obj, string) {
      return void 0 === string ? _create(obj) : check(_create(obj), string);
    },
    "defineProperty" : set,
    "defineProperties" : check,
    "getOwnPropertyDescriptor" : doc,
    "getOwnPropertyNames" : init,
    "getOwnPropertySymbols" : data
  });
  forced = processResource(function() {
    req.f(1);
  });
  $export($export.S + $export.F * forced, `Object`, {
    "getOwnPropertySymbols" : function(target) {
      return req.f(toObject(target));
    }
  });
  if ($JSON) {
    $export($export.S + $export.F * (!tel || processResource(function() {
      var S = $Symbol();
      return "[null]" != _stringify([S]) || "{}" != _stringify({
        "a" : S
      }) || "{}" != _stringify(Object(S));
    })), `JSON`, {
      "stringify" : function(it) {
        var e;
        var t;
        var args = [it];
        var i = 1;
        for (; i < arguments.length;) {
          args.push(arguments[i++]);
        }
        if (t = e = args[1], (isObject(e) || void 0 !== it) && !isSymbol(it)) {
          return insertElement(e) || (e = function(item, value) {
            if ("function" == typeof t && (value = t.call(this, item, value)), !isSymbol(value)) {
              return value;
            }
          }), args[1] = e, _stringify.apply($JSON, args);
        }
      }
    });
  }
  if (!$Symbol[PROTOTYPE][ID]) {
    hide($Symbol[PROTOTYPE], ID, $Symbol[PROTOTYPE].valueOf);
  }
  setToStringTag($Symbol, `Symbol`);
  setToStringTag(Math, "Math", true);
  setToStringTag(global.JSON, "JSON", true);
  onLoad(`asyncIterator`);
  onLoad(`observable`);
  var Wrapper = core.Symbol;
  var _symbol = __webpack_require__(function(module) {
    module.exports = {
      "default" : Wrapper,
      "__esModule" : true
    };
  });
  _interopRequireWildcard(_symbol);
  var _domHtml = __webpack_require__(function(canCreateDiscussions, exports) {
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default" : obj
      };
    }
    exports.__esModule = true;
    var _prepareStyleProperties2 = _interopRequireDefault(_prepareStyleProperties);
    var _symbol2 = _interopRequireDefault(_symbol);
    var indexOfIt = "function" == typeof _symbol2.default && "symbol" == typeof _prepareStyleProperties2.default ? function(objOrTsid) {
      return typeof objOrTsid;
    } : function(obj) {
      return obj && "function" == typeof _symbol2.default && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj;
    };
    exports.default = "function" == typeof _symbol2.default && "symbol" === indexOfIt(_prepareStyleProperties2.default) ? function(obj) {
      return void 0 === obj ? "undefined" : indexOfIt(obj);
    } : function(obj) {
      return obj && "function" == typeof _symbol2.default && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : void 0 === obj ? "undefined" : indexOfIt(obj);
    };
  });
  var loadImage = _interopRequireWildcard(_domHtml);
  var getPrototypeOf = _interopRequireWildcard(__webpack_require__(function(canCreateDiscussions, exports) {
    exports.__esModule = true;
    var obj;
    var scene = (obj = _domHtml) && obj.__esModule ? obj : {
      "default" : obj
    };
    exports.default = function(name, value) {
      if (!name) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return !value || "object" !== (void 0 === value ? "undefined" : (0, scene.default)(value)) && "function" != typeof value ? name : value;
    };
  }));
  descriptor = {
    "set" : Object.setPrototypeOf || ("__proto__" in {} ? function(pos, err, fn) {
      try {
        (fn = ctx(Function.call, obj1.f(Object.prototype, "__proto__").set, 2))(pos, []);
        err = !(pos instanceof Array);
      } catch (_0xa74afb) {
        err = true;
      }
      return function(res, app) {
        return respond(res, app), err ? res.__proto__ = app : fn(res, app), res;
      };
    }({}, false) : void 0),
    "check" : respond
  };
  $export($export.S, `Object`, {
    "setPrototypeOf" : descriptor.set
  });
  var sPO = core.Object.setPrototypeOf;
  var _WebAPI = __webpack_require__(function(module) {
    module.exports = {
      "default" : sPO,
      "__esModule" : true
    };
  });
  _interopRequireWildcard(_WebAPI);
  $export($export.S, `Object`, {
    "create" : _create
  });
  var map = core.Object;
  var _constants = __webpack_require__(function(module) {
    module.exports = {
      "default" : Variable,
      "__esModule" : true
    };
  });
  _interopRequireWildcard(_constants);
  _inherits = _interopRequireWildcard(__webpack_require__(function(canCreateDiscussions, exports) {
    function _interopRequireWildcard(obj) {
      return obj && obj.__esModule ? obj : {
        "default" : obj
      };
    }
    exports.__esModule = true;
    var WebAPI = _interopRequireWildcard(_WebAPI);
    var _constants2 = _interopRequireWildcard(_constants);
    var html = _interopRequireWildcard(_domHtml);
    exports.default = function(target, value) {
      if ("function" != typeof value && null !== value) {
        throw new TypeError("Super expression must either be null or a function, not " + (void 0 === value ? "undefined" : (0, html.default)(value)));
      }
      target.prototype = (0, _constants2.default)(value && value.prototype, {
        "constructor" : {
          "value" : target,
          "enumerable" : false,
          "writable" : true,
          "configurable" : true
        }
      });
      if (value) {
        if (WebAPI.default) {
          (0, WebAPI.default)(target, value);
        } else {
          target.__proto__ = value;
        }
      }
    };
  }));
  expect(table, [{
    "key" : `initConsts`,
    "value" : function() {
    }
  }, {
    "key" : `openEditMode`,
    "value" : function(name) {
    }
  }, {
    "key" : "setHeight",
    "value" : function(value) {
      this.style.height = value;
    }
  }, {
    "key" : "getHeight",
    "value" : function() {
      return this.style.height;
    }
  }, {
    "key" : `setPoints`,
    "value" : function(name) {
      this.coordinates[0] = name || [];
      if (1 <= this.coordinates[0].length) {
        this.generate();
      }
    }
  }, {
    "key" : `getPoints`,
    "value" : function() {
      return this.coordinates[0].slice(0);
    }
  }, {
    "key" : "getPointCount",
    "value" : function() {
      return this.coordinates[0].length;
    }
  }, {
    "key" : `generate`,
    "value" : function() {
    }
  }, {
    "key" : `generatePositions`,
    "value" : function(name) {
      this.positions = loadModel(name, this.getHeight());
    }
  }]);
  view = table;
  var Controller = (_inherits(TacoTableCell, view), expect(TacoTableCell, [{
    "key" : `generateEntity`,
    "value" : function() {
      this.polygonEntity = this.viewer.entities.add({
        "plotType" : this.properties.plotBase,
        "plotCode" : this.properties.plotCode,
        "polygon" : {
          "hierarchy" : new Cesium["PolygonHierarchy"](this.positions || []),
          "material" : Cesium.Color.YELLOW.withAlpha(0.6),
          "classificationType" : Cesium.ClassificationType.BOTH
        }
      });
    }
  }, {
    "key" : `setSelected`,
    "value" : function(name) {
      this.polygonEntity.polygon.material = name ? Cesium.Color.RED.withAlpha(0.6) : Cesium.Color.YELLOW.withAlpha(0.8);
    }
  }, {
    "key" : "generate",
    "value" : function() {
      if (!(this.getPointCount() < 2)) {
        this.generatePositions(this.coordinates[0]);
      }
    }
  }, {
    "key" : `openEditMode`,
    "value" : function(name) {
      var same = this;
      if (name) {
        this.polygonEntity.polygon.hierarchy = new Cesium["CallbackProperty"](function(canCreateDiscussions) {
          var put_rows = hahaha;
          return new (Cesium[put_rows(1433)])(same[put_rows(1707)] || []);
        }, false);
        this.polygonEntity.polyline = {
          "positions" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
            var rel2Mstr = hahaha;
            return same[rel2Mstr(1707)] && 0 < same[rel2Mstr(1707)][rel2Mstr(2189)] ? same[rel2Mstr(1707)][rel2Mstr(439)](same[rel2Mstr(1707)][0]) : [];
          }, false),
          "width" : 2,
          "clampToGround" : true,
          "material" : new Cesium["PolylineDashMaterialProperty"]({
            "color" : Cesium.Color.YELLOW
          }),
          "depthFailMaterial" : new Cesium.PolylineDashMaterialProperty({
            "color" : Cesium.Color.YELLOW
          })
        };
      } else {
        this.polygonEntity.polygon.hierarchy = new Cesium.PolygonHierarchy(this.positions || []);
        if (this.polygonEntity.polyline) {
          this.polygonEntity.polyline.width = 0;
        }
      }
    }
  }, {
    "key" : `toGeoJson`,
    "value" : function() {
      return {
        "type" : "Feature",
        "properties" : this.properties,
        "geometry" : {
          "type" : "Polygon",
          "coordinates" : this.coordinates
        }
      };
    }
  }, {
    "key" : "remove",
    "value" : function() {
      this.viewer.entities.remove(this.polygonEntity);
    }
  }]), TacoTableCell);
  var width = Math.PI / 2;
  var fillCorner = (Math.PI, function(a, d, s) {
    var b = a[0] - d[0];
    var c = a[1] - d[1];
    a = Math.sqrt(b * b + c * c);
    return b = b / a, c = c / a, a = s[0] - d[0], s = s[1] - d[1], d = Math.sqrt(a * a + s * s), [b + (a = a / d), c + (s = s / d)];
  });
  var pow = function(n, x) {
    return factorial(n) / (factorial(x) * factorial(n - x));
  };
  var calculate = function(r, x) {
    var n = 0;
    return 0 === r ? n = Math.pow(x - 1, 2) / 2 : 1 === r ? n = (-2 * Math.pow(x, 2) + 2 * x + 1) / 2 : 2 === r && (n = Math.pow(x, 2) / 2), n;
  };
  var Mix = (_inherits(StarRatingComponent, Controller), expect(StarRatingComponent, [{
    "key" : `initConsts`,
    "value" : function() {
      this.t = 0.3;
    }
  }, {
    "key" : `generate`,
    "value" : function() {
      if (!((len = this.getPointCount()) < 2)) {
        if (2 == len) {
          this.generatePositions(this.coordinates[0]);
        } else {
          var data = this.getPoints();
          data.push(data[0], data[1]);
          var len;
          var x = [];
          var j = 0;
          for (; j < data.length - 2; j++) {
            var d = debug(this.t, data[j], data[j + 1], data[j + 2]);
            x = x.concat(d);
          }
          x = [x[(len = x.length) - 1]].concat(x.slice(0, len - 1));
          var results = [];
          j = 0;
          for (; j < data.length - 2; j++) {
            var relation = data[j];
            var file = data[j + 1];
            results.push(relation);
            var _0x2116b1 = 0;
            for (; _0x2116b1 <= 100; _0x2116b1++) {
              var result = filter(_0x2116b1 / 100, relation, x[2 * j], x[2 * j + 1], file);
              results.push(result);
            }
            results.push(file);
          }
          this.generatePositions(results);
        }
      }
    }
  }]), StarRatingComponent);
  var ProxyProperty = (_inherits(FormTextInput, Controller), expect(FormTextInput, [{
    "key" : `generate`,
    "value" : function() {
      var a;
      var d;
      if (!(this.getPointCount() < 2)) {
        a = this.coordinates[0][0];
        d = this.distance(a, this.coordinates[0][1]);
        this.generatePositions(val(a, d));
      }
    }
  }, {
    "key" : `distance`,
    "value" : function(value, x) {
      var radLat1 = value[1] * Math.PI / 180;
      var radLat2 = x[1] * Math.PI / 180;
      var deltaLat = radLat1 - radLat2;
      x = value[0] * Math.PI / 180 - x[0] * Math.PI / 180;
      x = 2 * Math.asin(Math.sqrt(Math.pow(Math.sin(deltaLat / 2), 2) + Math.cos(radLat1) * Math.cos(radLat2) * Math.pow(Math.sin(x / 2), 2)));
      return x = x * 6378.137, x = Math.round(1E4 * x) / 10;
    }
  }]), FormTextInput);
  var Resource = (_inherits(ShareCollection, Controller), expect(ShareCollection, [{
    "key" : `initConsts`,
    "value" : function() {
      this.fixPointCount = 2;
    }
  }, {
    "key" : `generate`,
    "value" : function() {
      var rec;
      var result;
      var artistTrack;
      var NAME;
      if (!(this.getPointCount() < 2)) {
        rec = this.coordinates[0][0];
        NAME = this.coordinates[0][1];
        result = format(rec, NAME);
        artistTrack = Math.abs((rec[0] - NAME[0]) / 2);
        NAME = Math.abs((rec[1] - NAME[1]) / 2);
        this.generatePositions(this.generatePoints(result, artistTrack, NAME));
      }
    }
  }, {
    "key" : `generatePoints`,
    "value" : function(name, target, uri) {
      var a;
      var end;
      var array = [];
      var _0xf9030e = 0;
      for (; _0xf9030e <= 100; _0xf9030e++) {
        end = 2 * Math.PI * _0xf9030e / 100;
        a = name[0] + target * Math.cos(end);
        end = name[1] + uri * Math.sin(end);
        array.push([a, end]);
      }
      return array;
    }
  }]), ShareCollection);
  var ObserverProperty = (_inherits(RemoveStyleControls, Controller), expect(RemoveStyleControls, [{
    "key" : `initConsts`,
    "value" : function() {
      this.fixPointCount = 3;
    }
  }, {
    "key" : `generate`,
    "value" : function() {
      var b;
      var points;
      var a;
      var result;
      if (!(this.getPointCount() < 2)) {
        if (2 == this.getPointCount()) {
          this.generatePositions(this.coordinates[0]);
        } else {
          b = (points = this.getPoints())[0];
          a = points[1];
          result = points[2];
          cb(a, b);
          points = 180 * getValue(a, b) / 3.14;
          result = 180 * getValue(result, b) / 3.14;
          a = this.distance(a, b);
          (result = this.generatSectorPoints(b, a, points, result)).push(b, result[0]);
          this.generatePositions(result);
        }
      }
    }
  }, {
    "key" : `distance`,
    "value" : function(value, x) {
      var radLat1 = value[1] * Math.PI / 180;
      var radLat2 = x[1] * Math.PI / 180;
      var deltaLat = radLat1 - radLat2;
      x = value[0] * Math.PI / 180 - x[0] * Math.PI / 180;
      x = 2 * Math.asin(Math.sqrt(Math.pow(Math.sin(deltaLat / 2), 2) + Math.cos(radLat1) * Math.cos(radLat2) * Math.pow(Math.sin(x / 2), 2)));
      return x = x * 6378.137, x = Math.round(1E4 * x) / 10;
    }
  }, {
    "key" : `generatSectorPoints`,
    "value" : function(name, value, x, y) {
      var result = [];
      if ((x = 90 - x) < (y = 90 - y)) {
        var j = x;
        for (; j < y; j = j + 2) {
          result.push(this.getCirclePoint(name[0], name[1], j, value));
        }
      } else {
        var i = x;
        for (; y < i; i = i - 2) {
          result.push(this.getCirclePoint(name[0], name[1], i, value));
        }
      }
      return result;
    }
  }, {
    "key" : `getCirclePoint`,
    "value" : function(value, obj, x, y) {
      var parallaxY = y * Math.sin(x * Math.PI / 180);
      y = y * Math.cos(x * Math.PI / 180);
      x = 6356725 + 21412 * (90 - obj) / 90;
      return [180 * (parallaxY / (x * Math.cos(obj * Math.PI / 180)) + value * Math.PI / 180) / Math.PI, 180 * (y / x + obj * Math.PI / 180) / Math.PI];
    }
  }]), RemoveStyleControls);
  var ViewModel = (_inherits(Scene3DViewer, Controller), expect(Scene3DViewer, [{
    "key" : `initConsts`,
    "value" : function() {
      this.fixPointCount = 2;
    }
  }, {
    "key" : `generate`,
    "value" : function() {
      var V1;
      var zoomLimits;
      var size;
      var x;
      var m;
      if (!(this.getPointCount() < 2)) {
        size = this.coordinates[0][0];
        zoomLimits = this.coordinates[0][1];
        V1 = Math.min(size[0], zoomLimits[0]);
        x = Math.max(size[0], zoomLimits[0]);
        m = Math.min(size[1], zoomLimits[1]);
        zoomLimits = [V1, size = Math.max(size[1], zoomLimits[1])];
        size = [x, size];
        x = [x, m];
        m = [V1, m];
        this.generatePositions([zoomLimits, size, x, m]);
      }
    }
  }]), Scene3DViewer);
  var Promise = (_inherits(TopSelect, Controller), expect(TopSelect, [{
    "key" : `initConsts`,
    "value" : function() {
      this.tailWidthFactor = 0.1;
      this.neckWidthFactor = 0.2;
      this.headWidthFactor = 0.25;
      this.headAngle = Math.PI / 8.5;
      this.neckAngle = Math.PI / 13;
      this.fixPointCount = 2;
    }
  }, {
    "key" : `generate`,
    "value" : function() {
      var content;
      var i;
      var result;
      var data;
      var source;
      var height;
      var value;
      if (!(this.getPointCount() < 2)) {
        content = (data = this.getPoints())[0];
        i = data[1];
        source = (value = merge(data)) * this.tailWidthFactor;
        result = value * this.neckWidthFactor;
        height = value * this.headWidthFactor;
        data = callback(i, content, width, source, true);
        value = callback(i, content, width, source, false);
        source = callback(content, i, this.headAngle, height, false);
        height = callback(content, i, this.headAngle, height, true);
        value = [data, callback(content, i, this.neckAngle, result, false), source, i, height, callback(content, i, this.neckAngle, result, true), value];
        this.generatePositions(value);
      }
    }
  }]), TopSelect);
  var HtmlAttribute = (_inherits(FastArray, Promise), expect(FastArray, [{
    "key" : `initConsts`,
    "value" : function() {
      this.tailWidthFactor = 0.2;
      this.neckWidthFactor = 0.25;
      this.headWidthFactor = 0.3;
      this.headAngle = Math.PI / 4;
      this.neckAngle = 0.17741 * Math.PI;
      this.fixPointCount = 2;
    }
  }]), FastArray);
  var Thing = (_inherits(PatternMask, Controller), expect(PatternMask, [{
    "key" : `initConsts`,
    "value" : function() {
      this.headHeightFactor = 0.18;
      this.headWidthFactor = 0.3;
      this.neckHeightFactor = 0.85;
      this.neckWidthFactor = 0.15;
      this.headTailFactor = 0.8;
    }
  }, {
    "key" : `generate`,
    "value" : function() {
      var v;
      var p;
      var fullscreenElement;
      var n;
      var a;
      var b;
      var l;
      if (!(this.getPointCount() < 2)) {
        if (2 != this.getPointCount()) {
          b = (l = this.getPoints())[0];
          v = l[1];
          if (transform(l[0], l[1], l[2])) {
            b = l[1];
            v = l[0];
          }
          a = [format(b, v)].concat(l.slice(2));
          fullscreenElement = (p = this.getArrowHeadPoints(a, b, v))[0];
          n = p[4];
          l = cb(b, v) / merge(a);
          l = (a = this.getArrowBodyPoints(a, fullscreenElement, n, l)).length;
          (b = [b].concat(a.slice(0, l / 2))).push(fullscreenElement);
          (l = [v].concat(a.slice(l / 2, l))).push(n);
          b = clamp(b);
          l = clamp(l);
          this.generatePositions(b.concat(p, l.reverse()));
        } else {
          this.generatePositions(this.coordinates[0]);
        }
      }
    }
  }, {
    "key" : "getArrowHeadPoints",
    "value" : function(obj, index, value) {
      var i = (result = merge(obj)) * this.headHeightFactor;
      var item = obj[obj.length - 1];
      var result = cb(item, obj[obj.length - 2]);
      index = cb(index, value);
      return i > index * this.headTailFactor && (i = index * this.headTailFactor), value = i * this.headWidthFactor, index = i * this.neckWidthFactor, result = (i = result < i ? result : i) * this.neckHeightFactor, i = callback(obj[obj.length - 2], item, 0, i, true), obj = callback(obj[obj.length - 2], item, 0, result, true), result = callback(item, i, width, value, false), value = callback(item, i, width, value, true), [callback(item, obj, width, index, false), result, item, value, callback(item, 
      obj, width, index, true)];
    }
  }, {
    "key" : `getArrowBodyPoints`,
    "value" : function(obj, val, type, size) {
      var props = keys(obj);
      var height = merge(obj) * size;
      var magnitude = (height - cb(val, type)) / 2;
      var html = 0;
      var result = [];
      var beforeGroupFooterItems = [];
      var i = 1;
      for (; i < obj.length - 1; i++) {
        var d = print(obj[i - 1], obj[i], obj[i + 1]) / 2;
        var value = (height / 2 - (html = html + cb(obj[i - 1], obj[i])) / props * magnitude) / Math.sin(d);
        var ret = callback(obj[i - 1], obj[i], Math.PI - d, value, true);
        value = callback(obj[i - 1], obj[i], d, value, false);
        result.push(ret);
        beforeGroupFooterItems.push(value);
      }
      return result.concat(beforeGroupFooterItems);
    }
  }]), PatternMask);
  var RemoteCreateEvent = (_inherits(ReactGoogleAutocomplete, Thing), expect(ReactGoogleAutocomplete, [{
    "key" : `initConsts`,
    "value" : function() {
      this.headHeightFactor = 0.18;
      this.headWidthFactor = 0.3;
      this.neckHeightFactor = 0.85;
      this.neckWidthFactor = 0.15;
      this.tailWidthFactor = 0.1;
      this.headTailFactor = 0.8;
      this.swallowTailFactor = 1;
      this.swallowTailPnt = null;
    }
  }, {
    "key" : `generate`,
    "value" : function() {
      var c;
      var json;
      var a;
      var falseySection;
      var ext;
      var result;
      var p;
      var value;
      var b;
      var index = this.getPointCount();
      if (!(index < 2)) {
        if (2 != this.getPointCount()) {
          b = (p = this.getPoints())[0];
          c = p[1];
          if (transform(p[0], p[1], p[2])) {
            b = p[1];
            c = p[0];
          }
          json = [format(b, c)].concat(p.slice(2));
          falseySection = (a = this.getArrowHeadPoints(json, b, c))[0];
          ext = a[4];
          result = cb(b, c);
          p = (value = merge(json)) * this.tailWidthFactor * this.swallowTailFactor;
          this.swallowTailPnt = callback(json[1], json[0], 0, p, true);
          value = result / value;
          index = (value = this.getArrowBodyPoints(json, falseySection, ext, value)).length;
          (b = [b].concat(value.slice(0, index / 2))).push(falseySection);
          (index = [c].concat(value.slice(index / 2, index))).push(ext);
          b = clamp(b);
          index = clamp(index);
          this.generatePositions(b.concat(a, index.reverse(), [this.swallowTailPnt, b[0]]));
        } else {
          this.generatePositions(this.coordinates[0]);
        }
      }
    }
  }]), ReactGoogleAutocomplete);
  var RemoteUpdateEvent = (_inherits(ColorControls, Controller), expect(ColorControls, [{
    "key" : `initConsts`,
    "value" : function() {
      this.headHeightFactor = 0.25;
      this.headWidthFactor = 0.3;
      this.neckHeightFactor = 0.85;
      this.neckWidthFactor = 0.15;
      this.connPoint = null;
      this.tempPoint4 = null;
      this.fixPointCount = 4;
    }
  }, {
    "key" : `generate`,
    "value" : function() {
      var str;
      var i;
      var index;
      var data;
      var end;
      var val;
      var value;
      var s = this.getPointCount();
      if (!(s < 2)) {
        if (2 != s) {
          val = this.coordinates[0][0];
          index = this.coordinates[0][1];
          value = this.coordinates[0][2];
          s = this.getPointCount();
          this.tempPoint4 = 3 == s ? this.getTempPoint4(val, index, value) : this.coordinates[0][3];
          this.connPoint = 3 == s || 4 == s ? format(val, index) : this.coordinates[0][4];
          str = transform(val, index, value) ? (data = this.getArrowPoints(val, this.connPoint, this.tempPoint4, false), this.getArrowPoints(this.connPoint, index, value, true)) : (data = this.getArrowPoints(index, this.connPoint, value, false), this.getArrowPoints(this.connPoint, val, this.tempPoint4, true));
          i = ((end = data.length) - 5) / 2;
          s = data.slice(0, i);
          index = data.slice(i, 5 + i);
          value = data.slice(5 + i, end);
          val = str.slice(0, i);
          data = str.slice(i, 5 + i);
          end = str.slice(5 + i, end);
          val = toString(val);
          s = toString(end.concat(s.slice(1)));
          value = toString(value);
          value = val.concat(data, s, index, value);
          this.generatePositions(value);
        } else {
          this.generatePositions(this.coordinates[0]);
        }
      }
    }
  }, {
    "key" : `getArrowPoints`,
    "value" : function(value, target, source, i) {
      var item = format(value, target);
      var result = cb(item, source);
      var index = callback(source, item, 0, 0.3 * result, true);
      var ret = callback(source, item, 0, 0.5 * result, true);
      index = [item, index = callback(item, index, width, result / 5, i), ret = callback(item, ret, width, result / 4, i), source];
      item = this.getArrowHeadPoints(index, this.headHeightFactor, this.headWidthFactor, this.neckHeightFactor, this.neckWidthFactor);
      result = item[0];
      i = item[4];
      ret = cb(value, target) / merge(index) / 2;
      source = this.getArrowBodyPoints(index, result, i, ret);
      index = source.length;
      ret = source.slice(0, index / 2);
      index = source.slice(index / 2, index);
      return ret.push(result), index.push(i), (ret = ret.reverse()).push(target), (index = index.reverse()).push(value), ret.reverse().concat(item, index);
    }
  }, {
    "key" : `getArrowHeadPoints`,
    "value" : function(key, name, value) {
      var result = merge(key) * this.headHeightFactor;
      var c = key[key.length - 1];
      var data = (cb(name, value), result * this.headWidthFactor);
      name = result * this.neckWidthFactor;
      value = result * this.neckHeightFactor;
      result = callback(key[key.length - 2], c, 0, result, true);
      key = callback(key[key.length - 2], c, 0, value, true);
      value = callback(c, result, width, data, false);
      data = callback(c, result, width, data, true);
      return [callback(c, key, width, name, false), value, c, data, callback(c, key, width, name, true)];
    }
  }, {
    "key" : "getArrowBodyPoints",
    "value" : function(obj, val, type, size) {
      var props = keys(obj);
      var height = merge(obj) * size;
      var magnitude = (height - cb(val, type)) / 2;
      var html = 0;
      var result = [];
      var beforeGroupFooterItems = [];
      var i = 1;
      for (; i < obj.length - 1; i++) {
        var d = print(obj[i - 1], obj[i], obj[i + 1]) / 2;
        var value = (height / 2 - (html = html + cb(obj[i - 1], obj[i])) / props * magnitude) / Math.sin(d);
        var ret = callback(obj[i - 1], obj[i], Math.PI - d, value, true);
        value = callback(obj[i - 1], obj[i], d, value, false);
        result.push(ret);
        beforeGroupFooterItems.push(value);
      }
      return result.concat(beforeGroupFooterItems);
    }
  }, {
    "key" : "getTempPoint4",
    "value" : function(name, value, a) {
      var i;
      var result;
      var c = format(name, value);
      value = cb(c, a);
      a = print(name, c, a);
      var p = a < width ? (i = value * Math.sin(a), p = value * Math.cos(a), result = callback(name, c, width, i, false), callback(c, result, width, p, true)) : width <= a && a < Math.PI ? (i = value * Math.sin(Math.PI - a), p = value * Math.cos(Math.PI - a), result = callback(name, c, width, i, false), callback(c, result, width, p, false)) : a >= Math.PI && a < 1.5 * Math.PI ? (i = value * Math.sin(a - Math.PI), p = value * Math.cos(a - Math.PI), result = callback(name, c, width, i, true), callback(c, 
      result, width, p, true)) : (i = value * Math.sin(2 * Math.PI - a), p = value * Math.cos(2 * Math.PI - a), result = callback(name, c, width, i, true), callback(c, result, width, p, false));
      return p;
    }
  }]), ColorControls);
  var RemoteDestroyEvent = (_inherits(ElementEditor, Controller), expect(ElementEditor, [{
    "key" : `initConsts`,
    "value" : function() {
      this.t = 0.4;
      this.fixPointCount = 3;
    }
  }, {
    "key" : `generate`,
    "value" : function() {
      var array;
      var data = this.getPoints();
      if (!(data.length < 2)) {
        if (2 == this.getPointCount()) {
          size = format(data[0], data[1]);
          array = cb(data[0], size) / 0.9;
          value = callback(data[0], size, width, array, true);
          data = [data[0], value, data[1]];
        }
        var size = format(data[0], data[2]);
        data.push(size, data[0], data[1]);
        var buffer = [];
        var i = 0;
        for (; i < data.length - 2; i++) {
          var g = data[i];
          var a = data[i + 1];
          var f = data[i + 2];
          f = debug(this.t, g, a, f);
          buffer = buffer.concat(f);
        }
        size = buffer.length;
        buffer = [buffer[size - 1]].concat(buffer.slice(0, size - 1));
        var temporaryStyles = [];
        i = 0;
        for (; i < data.length - 2; i++) {
          g = data[i];
          a = data[i + 1];
          temporaryStyles.push(g);
          var canvasWidth = 0;
          for (; canvasWidth <= 100; canvasWidth++) {
            var value = filter(canvasWidth / 100, g, buffer[2 * i], buffer[2 * i + 1], a);
            temporaryStyles.push(value);
          }
          temporaryStyles.push(a);
        }
        this.generatePositions(temporaryStyles);
      }
    }
  }]), ElementEditor);
  var ModelAnimation = (_inherits(LineChart, Thing), expect(LineChart, [{
    "key" : "initConsts",
    "value" : function() {
      this.headHeightFactor = 0.18;
      this.headWidthFactor = 0.3;
      this.neckHeightFactor = 0.85;
      this.neckWidthFactor = 0.15;
      this.tailWidthFactor = 0.1;
    }
  }, {
    "key" : `generate`,
    "value" : function() {
      var $chrome;
      var ret;
      var end;
      var count;
      var array;
      var a;
      var index = this.getPointCount();
      if (!(index < 2)) {
        a = this.getPoints();
        $chrome = this.getTailPoints(a);
        end = (ret = this.getArrowHeadPoints(a, $chrome[0], $chrome[1]))[0];
        count = ret[4];
        index = (array = this.getArrowBodyPoints(a, end, count, this.tailWidthFactor)).length;
        (a = [$chrome[0]].concat(array.slice(0, index / 2))).push(end);
        (index = [$chrome[1]].concat(array.slice(index / 2, index))).push(count);
        a = clamp(a);
        index = clamp(index);
        this.generatePositions(a.concat(ret, index.reverse()));
      }
    }
  }, {
    "key" : `getTailPoints`,
    "value" : function(target) {
      var organizations = merge(target) * this.tailWidthFactor;
      return [callback(target[1], target[0], width, organizations, false), callback(target[1], target[0], width, organizations, true)];
    }
  }]), LineChart);
  var Handler = (_inherits(ScatterChart, Thing), expect(ScatterChart, [{
    "key" : `initConsts`,
    "value" : function() {
      this.headHeightFactor = 0.18;
      this.headWidthFactor = 0.3;
      this.neckHeightFactor = 0.85;
      this.neckWidthFactor = 0.15;
      this.tailWidthFactor = 0.1;
      this.swallowTailFactor = 1;
      this.swallowTailPnt = null;
    }
  }, {
    "key" : `generate`,
    "value" : function() {
      var $chrome;
      var ret;
      var end;
      var count;
      var array;
      var a;
      var index = this.getPointCount();
      if (!(index < 2)) {
        a = this.getPoints();
        $chrome = this.getTailPoints(a);
        end = (ret = this.getArrowHeadPoints(a, $chrome[0], $chrome[2]))[0];
        count = ret[4];
        index = (array = this.getArrowBodyPoints(a, end, count, this.tailWidthFactor)).length;
        (a = [$chrome[0]].concat(array.slice(0, index / 2))).push(end);
        (index = [$chrome[2]].concat(array.slice(index / 2, index))).push(count);
        a = clamp(a);
        index = clamp(index);
        this.generatePositions(a.concat(ret, index.reverse(), [$chrome[1], a[0]]));
      }
    }
  }, {
    "key" : `getTailPoints`,
    "value" : function(target) {
      var height = merge(target) * this.tailWidthFactor;
      var ret = callback(target[1], target[0], width, height, false);
      var bubble = callback(target[1], target[0], width, height, true);
      height = height * this.swallowTailFactor;
      return [ret, callback(target[1], target[0], 0, height, true), bubble];
    }
  }]), ScatterChart);
  var handler = function(name, data, model) {
    switch(data) {
      case IPTYPE.POLYGON:
        return new Controller(name, model);
      case IPTYPE.DOUBLE_ARROW:
        return new RemoteUpdateEvent(name, model);
      case IPTYPE.ATTACK_ARROW:
        return new Thing(name, model);
      case IPTYPE.ELLIPSE:
        return new Resource(name, model);
      case IPTYPE.CIRCLE:
        return new ProxyProperty(name, model);
      case IPTYPE.FINE_ARROW:
        return new Promise(name, model);
      case IPTYPE.TAILED_ATTACK_ARROW:
        return new RemoteCreateEvent(name, model);
      case IPTYPE.ASSAULT_DIRECTION:
        return new HtmlAttribute(name, model);
      case IPTYPE.GATHERING_PLACE:
        return new RemoteDestroyEvent(name, model);
      case IPTYPE.CLOSED_CURVE:
        return new Mix(name, model);
      case IPTYPE.SECTOR:
        return new ObserverProperty(name, model);
      case IPTYPE.RECTANGLE:
        return new ViewModel(name, model);
      case IPTYPE.SQUAD_COMBAT:
        return new ModelAnimation(name, model);
      case IPTYPE.TAILED_SQUAD_COMBAT:
        return new Handler(name, model);
    }
  };
  mode = (expect(onready, [{
    "key" : `activate`,
    "value" : function(name) {
      this.plotType = name;
      this.clear();
      this.points = [];
      this.plotDrawTip = new Map(this.viewer);
      this.MousePoint = new Date(this.viewer);
      this.registerEvents();
      this.viewer.enableCursorStyle = false;
      this.viewer._element.style.cursor = "default";
      this.initMouseTip();
      this.PlotDrawStartEvent.raiseEvent();
    }
  }, {
    "key" : `initMouseTip`,
    "value" : function() {
      var _0x2d1cb8 = this.getPlotNam();
      var title = "\u6309\u4e0b\u9f20\u6807\u53f3\u952e\u53d6\u6d88\u7ed8\u5236";
      var _0x489e13 = "\u6309\u4e0b\u9f20\u6807\u5de6\u952e\u786e\u5b9a\u7b2c\u4e00\u4e2a\u70b9\u7684\u4f4d\u7f6e";
      switch(this.plotType) {
        case IPTYPE.MARKER:
          this.plotDrawTip.setContent(["\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a" + _0x2d1cb8 + "\uff0c\u9700\u89811\u4e2a\u70b9", "\u6309\u4e0b\u9f20\u6807\u5de6\u952e\u786e\u5b9a\u4f4d\u7f6e", title]);
          break;
        case IPTYPE.POLYLINE:
        case IPTYPE.SQUAD_COMBAT:
        case IPTYPE.TAILED_SQUAD_COMBAT:
          this.plotDrawTip.setContent(["\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a" + _0x2d1cb8 + "\uff0c\u6700\u5c11\u9700\u89812\u4e2a\u70b9", _0x489e13, title]);
          break;
        case IPTYPE.ELLIPSE:
        case IPTYPE.CIRCLE:
        case IPTYPE.RECTANGLE:
        case IPTYPE.FINE_ARROW:
        case IPTYPE.ASSAULT_DIRECTION:
          this.plotDrawTip.setContent(["\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a" + _0x2d1cb8 + "\uff0c\u9700\u89812\u4e2a\u70b9", _0x489e13, title]);
          break;
        case IPTYPE.POLYGON:
        case IPTYPE.ATTACK_ARROW:
        case IPTYPE.TAILED_ATTACK_ARROW:
        case IPTYPE.CLOSED_CURVE:
          this.plotDrawTip.setContent(["\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a" + _0x2d1cb8 + "\uff0c\u6700\u5c11\u9700\u89813\u4e2a\u70b9", _0x489e13, title]);
          break;
        case IPTYPE.GATHERING_PLACE:
        case IPTYPE.SECTOR:
          this.plotDrawTip.setContent(["\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a" + _0x2d1cb8 + "\uff0c\u9700\u89813\u4e2a\u70b9", _0x489e13, title]);
          break;
        case IPTYPE.DOUBLE_ARROW:
          this.plotDrawTip.setContent(["\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a" + _0x2d1cb8 + "\uff0c\u9700\u89814\u4e2a\u70b9", _0x489e13, title]);
      }
    }
  }, {
    "key" : `getPlotNam`,
    "value" : function() {
      switch(this.plotType) {
        case IPTYPE.MARKER:
          return "\u70b9";
        case IPTYPE.POLYLINE:
          return "\u7ebf";
        case IPTYPE.POLYGON:
          return "\u9762";
        case IPTYPE.ELLIPSE:
          return "\u692d\u5706";
        case IPTYPE.CIRCLE:
          return "\u6b63\u5706";
        case IPTYPE.RECTANGLE:
          return "\u77e9\u5f62";
        case IPTYPE.CLOSED_CURVE:
          return "\u66f2\u7ebf\u9762";
        case IPTYPE.SECTOR:
          return "\u6247\u5f62";
        case IPTYPE.FINE_ARROW:
          return "\u76f4\u7bad\u5934";
        case IPTYPE.ASSAULT_DIRECTION:
          return "\u7a81\u51fb\u65b9\u5411";
        case IPTYPE.ATTACK_ARROW:
          return "\u70b9\u8fdb\u653b\u65b9\u5411";
        case IPTYPE.TAILED_ATTACK_ARROW:
          return "\u8fdb\u653b\u65b9\u5411\u5c3e";
        case IPTYPE.GATHERING_PLACE:
          return "\u96c6\u7ed3\u5730";
        case IPTYPE.SQUAD_COMBAT:
          return "\u5206\u961f\u4f5c\u6218";
        case IPTYPE.TAILED_SQUAD_COMBAT:
          return "\u5206\u961f\u4f5c\u6218\u5c3e";
        case IPTYPE.DOUBLE_ARROW:
          return "\u94b3\u51fb";
      }
    }
  }, {
    "key" : "deactivate",
    "value" : function() {
      this.unRegisterEvents();
      this.plotType = void 0;
      this.viewer._element.style.cursor = "pointer";
      this.viewer.enableCursorStyle = true;
      if (this.plotDrawTip) {
        this.plotDrawTip.remove();
        this.MousePoint.remove();
        this.plotDrawTip = void 0;
        this.MousePoint = void 0;
      }
    }
  }, {
    "key" : "clear",
    "value" : function() {
      if (this.plot) {
        this.plot.remove();
        this.plot = void 0;
      }
    }
  }, {
    "key" : `generatePlot`,
    "value" : function(target, value) {
      target = {
        "type" : "Feature",
        "properties" : {
          "plotCode" : createIntervalElements(),
          "style" : {
            "height" : value
          }
        },
        "geometry" : {
          "type" : "Polygon",
          "coordinates" : [target]
        }
      };
      this.plot = handler(this.viewer, this.plotType, target);
      this.plot.openEditMode(true);
    }
  }, {
    "key" : "initEvents",
    "value" : function() {
      this.handler = new Cesium["ScreenSpaceEventHandler"](this.viewer.scene.canvas);
      this.PlotDrawStartEvent = new Cesium.Event;
      this.PlotDrawEndEvent = new Cesium.Event;
    }
  }, {
    "key" : `registerEvents`,
    "value" : function() {
      this.leftClickEvent();
      this.rightClickEvent();
      this.mouseMoveEvent();
    }
  }, {
    "key" : `leftClickEvent`,
    "value" : function() {
      var options = this;
      this.handler.setInputAction(function(buf) {
        var parseInt = hahaha;
        options[parseInt(2276)]._element[parseInt(1998)][parseInt(737)] = parseInt(1654);
        var p = options[parseInt(2276)][parseInt(2758)][parseInt(1238)](buf[parseInt(586)]);
        if (p = p || options[parseInt(2276)].scene.camera.pickEllipsoid(buf[parseInt(586)], options[parseInt(2276)].scene.globe[parseInt(1923)])) {
          buf = stringify(p);
          p = Cesium.Cartographic.fromCartesian(p);
          if (0 == options[parseInt(1137)][parseInt(2189)]) {
            options[parseInt(1137)][parseInt(2008)](buf);
            options[parseInt(2700)](options[parseInt(1137)], p.height);
          } else {
            if (cb(buf, options[parseInt(1137)][options[parseInt(1137)][parseInt(2189)] - 1]) < 0.000003) {
              return;
            }
            options[parseInt(1137)][parseInt(2008)](buf);
            options.plot[parseInt(877)](options[parseInt(1137)]);
          }
          options[parseInt(1762)]();
          if (options[parseInt(1298)][parseInt(491)] == options.points.length) {
            options[parseInt(2788)]();
            options[parseInt(1983)]();
          }
        }
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
    }
  }, {
    "key" : `setMouseTipContent`,
    "value" : function() {
      var _0x3d5831 = this.getPlotNam();
      switch(this.plotType) {
        case IPTYPE.POLYLINE:
        case IPTYPE.SQUAD_COMBAT:
        case IPTYPE.TAILED_SQUAD_COMBAT:
          this.plotDrawTip.setContent(["\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a" + _0x3d5831 + "\uff0c\u6700\u5c11\u9700\u89812\u4e2a\u70b9", "\u5df2\u6709" + this.points.length + "\u4e2a\u70b9\uff0c\u6309\u4e0b\u9f20\u6807\u5de6\u952e\u786e\u5b9a\u7b2c" + (this.points.length + 1) + "\u4e2a\u70b9", , this.points.length < 2 ? "\u6309\u4e0b\u9f20\u6807\u53f3\u952e\u53d6\u6d88\u7ed8\u5236" : "\u6309\u4e0b\u9f20\u6807\u53f3\u952e\u7ed3\u675f\u7ed8\u5236"]);
          break;
        case IPTYPE.ELLIPSE:
        case IPTYPE.CIRCLE:
        case IPTYPE.RECTANGLE:
        case IPTYPE.FINE_ARROW:
        case IPTYPE.ASSAULT_DIRECTION:
          this.plotDrawTip.setContent(["\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a" + _0x3d5831 + "\uff0c\u9700\u89812\u4e2a\u70b9", "\u5df2\u6709" + this.points.length + "\u4e2a\u70b9\uff0c\u6309\u4e0b\u9f20\u6807\u5de6\u952e\u786e\u5b9a\u7b2c" + (this.points.length + 1) + "\u4e2a\u70b9", , "\u6309\u4e0b\u9f20\u6807\u53f3\u952e\u53d6\u6d88\u7ed8\u5236"]);
          break;
        case IPTYPE.POLYGON:
        case IPTYPE.ATTACK_ARROW:
        case IPTYPE.TAILED_ATTACK_ARROW:
        case IPTYPE.CLOSED_CURVE:
          this.plotDrawTip.setContent(["\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a" + _0x3d5831 + "\uff0c\u6700\u5c11\u9700\u89813\u4e2a\u70b9", "\u5df2\u6709" + this.points.length + "\u4e2a\u70b9\uff0c\u6309\u4e0b\u9f20\u6807\u5de6\u952e\u786e\u5b9a\u7b2c" + (this.points.length + 1) + "\u4e2a\u70b9", , this.points.length < 3 ? "\u6309\u4e0b\u9f20\u6807\u53f3\u952e\u53d6\u6d88\u7ed8\u5236" : "\u6309\u4e0b\u9f20\u6807\u53f3\u952e\u7ed3\u675f\u7ed8\u5236"]);
          break;
        case IPTYPE.GATHERING_PLACE:
        case IPTYPE.SECTOR:
          this.plotDrawTip.setContent(["\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a" + _0x3d5831 + "\uff0c\u9700\u89813\u4e2a\u70b9", "\u5df2\u6709" + this.points.length + "\u4e2a\u70b9\uff0c\u6309\u4e0b\u9f20\u6807\u5de6\u952e\u786e\u5b9a\u7b2c" + (this.points.length + 1) + "\u4e2a\u70b9", , "\u6309\u4e0b\u9f20\u6807\u53f3\u952e\u53d6\u6d88\u7ed8\u5236"]);
          break;
        case IPTYPE.DOUBLE_ARROW:
          this.plotDrawTip.setContent(["\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a" + _0x3d5831 + "\uff0c\u9700\u89814\u4e2a\u70b9", "\u5df2\u6709" + this.points.length + "\u4e2a\u70b9\uff0c\u6309\u4e0b\u9f20\u6807\u5de6\u952e\u786e\u5b9a\u7b2c" + (this.points.length + 1) + "\u4e2a\u70b9", , "\u6309\u4e0b\u9f20\u6807\u53f3\u952e\u53d6\u6d88\u7ed8\u5236"]);
      }
    }
  }, {
    "key" : `mouseMoveEvent`,
    "value" : function() {
      var obj = this;
      this.handler.setInputAction(function(result) {
        var parseInt = hahaha;
        var value = (value = obj[parseInt(2276)].scene[parseInt(1238)](result[parseInt(2840)])) || obj[parseInt(2276)][parseInt(2758)][parseInt(1306)][parseInt(1080)](result.endPosition, obj[parseInt(2276)][parseInt(2758)][parseInt(2359)][parseInt(1923)]);
        if (value) {
          obj.plotDrawTip.updatePosition(value);
          obj[parseInt(1455)][parseInt(3164)](value);
          if (obj[parseInt(1298)]) {
            value = stringify(value);
            if (!(cb(value, obj[parseInt(1137)][obj.points.length - 1]) < 0.000003)) {
              value = obj.points[parseInt(439)]([value]);
              obj[parseInt(1298)].setPoints(value);
            }
          }
        }
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
    }
  }, {
    "key" : `rightClickEvent`,
    "value" : function() {
      var obj = this;
      this.handler.setInputAction(function(canCreateDiscussions) {
        var parseInt = hahaha;
        if (0 != obj[parseInt(1137)][parseInt(2189)]) {
          if (obj[parseInt(1298)].fixPointCount) {
            if (obj[parseInt(1137)][parseInt(2189)] == obj.plot[parseInt(491)]) {
              obj[parseInt(1298)][parseInt(877)](obj[parseInt(1137)]);
              obj[parseInt(2788)]();
              obj[parseInt(1983)]();
            } else {
              obj[parseInt(1983)]();
              obj.clear();
            }
          } else {
            if (obj[parseInt(1137)][parseInt(2189)] >= obj[parseInt(1298)].minPointCount) {
              obj[parseInt(1298)][parseInt(877)](obj[parseInt(1137)]);
              obj[parseInt(2788)]();
              obj[parseInt(1983)]();
            } else {
              obj[parseInt(1983)]();
              obj[parseInt(2822)]();
            }
          }
        } else {
          obj[parseInt(1983)]();
        }
      }, Cesium.ScreenSpaceEventType.RIGHT_CLICK);
    }
  }, {
    "key" : `unRegisterEvents`,
    "value" : function() {
      this.handler.removeInputAction(Cesium.ScreenSpaceEventType.RIGHT_CLICK);
      this.handler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_CLICK);
      this.handler.removeInputAction(Cesium.ScreenSpaceEventType.MOUSE_MOVE);
      this.handler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);
    }
  }, {
    "key" : `drawEnd`,
    "value" : function() {
      this.plot.openEditMode(false);
      this.PlotDrawEndEvent.raiseEvent(this.plot, this.plotType);
    }
  }]), onready);
  expect(SyncedObject, [{
    "key" : `initEventHandler`,
    "value" : function() {
      this.eventHandler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas);
      this.PlotEditEndEvent = new Cesium.Event;
    }
  }, {
    "key" : `activate`,
    "value" : function() {
      this.deactivate();
      this.initLeftClickEventHandler();
    }
  }, {
    "key" : `deactivate`,
    "value" : function() {
      this.eventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_CLICK);
      this.clear();
    }
  }, {
    "key" : `clear`,
    "value" : function() {
      this.clearEditVertex();
    }
  }, {
    "key" : `initLeftClickEventHandler`,
    "value" : function() {
      var obj = this;
      this.eventHandler.setInputAction(function(currentItems) {
        var parseInt = hahaha;
        var val = (val = obj[parseInt(2276)][parseInt(2758)][parseInt(1238)](currentItems[parseInt(586)])) || obj[parseInt(2276)][parseInt(2758)][parseInt(1306)][parseInt(1080)](currentItems[parseInt(586)], obj[parseInt(2276)][parseInt(2758)].globe.ellipsoid);
        if (val) {
          val = stringify(val);
          if (val = obj[parseInt(2498)](val)) {
            if (!(obj.militaryPlot && obj[parseInt(532)].plotCode == val.properties[parseInt(2717)])) {
              obj[parseInt(462)]();
              obj[parseInt(3125)](val);
            }
          } else {
            obj[parseInt(462)]();
          }
        }
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
    }
  }, {
    "key" : `getByPlotIntersect`,
    "value" : function(key) {
      var plots = this.militaryPlotLayer.plots;
      var i = 0;
      for (; i < plots.length; i++) {
        var p = plots[i];
        var inner = assert(p.positions);
        inner.push(inner[0]);
        var objToEvaluate = turf.polygon([inner]);
        inner = turf.point(key);
        if (turf.booleanPointInPolygon(inner, objToEvaluate)) {
          return p;
        }
      }
    }
  }, {
    "key" : `handleEditMilitaryPlot`,
    "value" : function() {
      this.clear();
      var result = this.militaryPlot;
      if (result) {
        this.militaryPlot = void 0;
        result.openEditMode(false);
        if (this.isEdited) {
          this.PlotEditEndEvent.raiseEvent(result);
          this.isEdited = false;
          this.isEditing = false;
        }
      }
    }
  }, {
    "key" : `handlePickMilitaryPlot`,
    "value" : function(type) {
      this.militaryPlot = this.militaryPlotLayer.getByPlotCode(type.properties.plotCode);
      if (this.militaryPlot) {
        this.isEditing = false;
        this.isEdited = false;
        this.militaryPlot.openEditMode(true);
        this.editPositions = this.plotPointsToPositions();
        this.EditMoveCenterPositoin = this.getMilitaryPlotCenterPosition();
        this.clear();
        this.createEditVertex();
        this.registerEvents();
      }
    }
  }, {
    "key" : `registerEvents`,
    "value" : function() {
      this.initLeftDownEventHandler();
      this.initMouseMoveEventHandler();
      this.initLeftUpEventHandler();
    }
  }, {
    "key" : `unRegisterEvents`,
    "value" : function() {
      this.eventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOWN);
      this.eventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_UP);
      this.eventHandler.removeInputAction(Cesium.ScreenSpaceEventType.MOUSE_MOVE);
    }
  }, {
    "key" : `initLeftDownEventHandler`,
    "value" : function() {
      var map = this;
      this.eventHandler.setInputAction(function(state) {
        var parseInt = hahaha;
        state = map[parseInt(2276)].scene.pick(state.position);
        if (state && state.id && state.id[parseInt(1720)]) {
          if (!(parseInt(1139) != state.id[parseInt(1720)] && parseInt(471) != state.id[parseInt(1720)])) {
            map[parseInt(3088)] = true;
            map[parseInt(2276)][parseInt(2758)][parseInt(2190)][parseInt(1218)] = false;
            map[parseInt(2276)].enableCursorStyle = false;
            map[parseInt(2276)][parseInt(2530)][parseInt(1998)][parseInt(737)] = "";
            document[parseInt(1494)][parseInt(1998)][parseInt(737)] = parseInt(367);
            map[parseInt(1670)] = state.id;
            map[parseInt(1670)][parseInt(2752)] = false;
          }
        }
      }, Cesium.ScreenSpaceEventType.LEFT_DOWN);
    }
  }, {
    "key" : `initLeftUpEventHandler`,
    "value" : function() {
      var options = this;
      this.eventHandler.setInputAction(function(canCreateDiscussions) {
        var extname = hahaha;
        if (options.isEditing) {
          options.viewer[extname(1633)] = true;
          document[extname(1494)][extname(1998)][extname(737)] = extname(1654);
          options[extname(2276)][extname(2758)][extname(2190)][extname(1218)] = true;
          options.editVertext[extname(2752)] = true;
          options.isEditing = false;
        }
      }, Cesium.ScreenSpaceEventType.LEFT_UP);
    }
  }, {
    "key" : "initMouseMoveEventHandler",
    "value" : function() {
      var data = this;
      this.eventHandler.setInputAction(function(key) {
        var getRefreshTokenKey = hahaha;
        var id = (id = data[getRefreshTokenKey(2276)].scene.pickPosition(key[getRefreshTokenKey(2840)])) || data[getRefreshTokenKey(2276)][getRefreshTokenKey(2758)][getRefreshTokenKey(1306)][getRefreshTokenKey(1080)](key[getRefreshTokenKey(2840)], data[getRefreshTokenKey(2276)].scene[getRefreshTokenKey(2359)].ellipsoid);
        if (id && data[getRefreshTokenKey(3088)]) {
          if (getRefreshTokenKey(471) == data[getRefreshTokenKey(1670)][getRefreshTokenKey(1720)]) {
            key = data[getRefreshTokenKey(1054)];
            if (!key) {
              return;
            }
            data[getRefreshTokenKey(2985)](key, id);
          } else {
            data.editPositions[data[getRefreshTokenKey(1670)].vertexIndex] = id;
            if (data[getRefreshTokenKey(532)][getRefreshTokenKey(2931)].plotType == IPTYPE.MARKER) {
              data[getRefreshTokenKey(532)][getRefreshTokenKey(2552)](data[getRefreshTokenKey(2229)](data[getRefreshTokenKey(1484)][0]));
            }
            data[getRefreshTokenKey(532)].setPoints(assert(data[getRefreshTokenKey(1484)]));
          }
          data[getRefreshTokenKey(581)] = true;
          data.EditMoveCenterPositoin = data[getRefreshTokenKey(1552)]();
        }
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
    }
  }, {
    "key" : `getMilitaryPlotCenterPosition`,
    "value" : function() {
      switch(this.militaryPlot.properties.plotType) {
        case IPTYPE.CIRCLE:
        case IPTYPE.MARKER:
          return this.editPositions[0];
      }
      var tmp = turf.lineString(this.militaryPlot.getPoints());
      tmp = turf.bbox(tmp);
      tmp = turf.bboxPolygon(tmp);
      tmp = turf.center(tmp).geometry.coordinates;
      return Cesium.Cartesian3.fromDegrees(tmp[0], tmp[1], this.militaryPlot.getHeight());
    }
  }, {
    "key" : `moveEntityByOffset`,
    "value" : function(target, object) {
      target = require(target);
      object = require(object);
      var mergeAxisLength = object.x - target.x;
      var SHIP_SPEED = object.y - target.y;
      var json = void 0;
      var i = 0;
      for (; i < this.editPositions.length; i++) {
        (json = require(this.editPositions[i])).x += mergeAxisLength;
        json.y += SHIP_SPEED;
        this.editPositions[i] = Cesium.Cartesian3.fromDegrees(json.x, json.y, json.z);
      }
      this.militaryPlot.setPoints(assert(this.editPositions));
    }
  }, {
    "key" : `getPositionHeight`,
    "value" : function(target) {
      return Cesium.Cartographic.fromCartesian(target).height;
    }
  }, {
    "key" : `plotPointsToPositions`,
    "value" : function() {
      var crossfilterable_layers = this.militaryPlot.getPoints();
      var itemNodeList = this.militaryPlot.getHeight();
      var newNodeLists = [];
      var layer_i = 0;
      for (; layer_i < crossfilterable_layers.length; layer_i++) {
        var layer = crossfilterable_layers[layer_i];
        newNodeLists.push(layer[0]);
        newNodeLists.push(layer[1]);
        newNodeLists.push(itemNodeList);
      }
      return Cesium.Cartesian3.fromDegreesArrayHeights(newNodeLists);
    }
  }, {
    "key" : "createEditVertex",
    "value" : function() {
      var same = this;
      this.vertexEntities = [];
      var pipelets = this.plotPointsToPositions();
      if (this.militaryPlot.properties.plotName == IPTYPE.CIRCLE) {
        return this.createCircleEditVertex(), void this.createEditMoveCenterEntity();
      }
      pipelets.forEach(function(canCreateDiscussions, key) {
        var rel2Mstr = hahaha;
        var artistTrack = same[rel2Mstr(2276)][rel2Mstr(1319)][rel2Mstr(3010)]({
          "position" : new (Cesium[rel2Mstr(1679)])(function(canCreateDiscussions) {
            var now = rel2Mstr;
            return same[now(1484)][key];
          }, false),
          "type" : "MilitaryPlotEditVertex",
          "vertexIndex" : key,
          "point" : {
            "color" : Cesium[rel2Mstr(2292)][rel2Mstr(3198)][rel2Mstr(2265)](0.4),
            "pixelSize" : 10,
            "outlineColor" : Cesium.Color[rel2Mstr(2537)][rel2Mstr(2265)](0.4),
            "outlineWidth" : 3,
            "disableDepthTestDistance" : 2E3
          }
        });
        same[rel2Mstr(1220)][rel2Mstr(2008)](artistTrack);
      });
      if (1 != this.editPositions.length) {
        this.createEditMoveCenterEntity();
      }
    }
  }, {
    "key" : `createCircleEditVertex`,
    "value" : function() {
      var primaryReplicas = this;
      var falseySection = this.viewer.entities.add({
        "position" : new Cesium.CallbackProperty(function(canCreateDiscussions) {
          var stringify = hahaha;
          return primaryReplicas[stringify(1484)][1];
        }, false),
        "type" : "MilitaryPlotEditVertex",
        "vertexIndex" : 1,
        "point" : {
          "color" : Cesium.Color.DARKBLUE.withAlpha(0.4),
          "pixelSize" : 10,
          "outlineColor" : Cesium.Color.YELLOW.withAlpha(0.4),
          "outlineWidth" : 3,
          "disableDepthTestDistance" : 2E3
        }
      });
      this.vertexEntities.push(falseySection);
    }
  }, {
    "key" : `createEditMoveCenterEntity`,
    "value" : function() {
      var primaryReplicas = this;
      this.EditMoveCenterEntity = this.viewer.entities.add({
        "position" : new Cesium.CallbackProperty(function(canCreateDiscussions) {
          var stringify = hahaha;
          return primaryReplicas[stringify(1054)];
        }, false),
        "type" : "MilitaryPlotEditMoveVertex",
        "point" : {
          "color" : Cesium.Color.RED.withAlpha(0.4),
          "pixelSize" : 10,
          "outlineColor" : Cesium.Color.WHITE.withAlpha(0.3),
          "outlineWidth" : 3,
          "disableDepthTestDistance" : 2E3
        }
      });
    }
  }, {
    "key" : "clearEditVertex",
    "value" : function() {
      var lithe = this;
      if (this.vertexEntities) {
        this.vertexEntities.forEach(function(mmCoreSplitViewBlock) {
          var resolve = hahaha;
          lithe.viewer[resolve(1319)][resolve(508)](mmCoreSplitViewBlock);
        });
      }
      this.vertexEntities = [];
      this.viewer.entities.remove(this.EditMoveCenterEntity);
    }
  }]);
  exports = SyncedObject;
  expect(match, [{
    "key" : `setPlotSelectable`,
    "value" : function(name) {
      this.plotSelecteable = name;
    }
  }, {
    "key" : `initPlots`,
    "value" : function(name) {
    }
  }, {
    "key" : "addPlot",
    "value" : function(name) {
    }
  }, {
    "key" : `removeByPlotCode`,
    "value" : function(name) {
      var i = 0;
      for (; i < this.plots.length; i++) {
        if (this.plots[i].properties.plotCode == name) {
          return this.plots[i].remove(), void this.plots.splice(i, 1);
        }
      }
    }
  }, {
    "key" : `getByPlotCode`,
    "value" : function(name) {
      var i = 0;
      for (; i < this.plots.length; i++) {
        if (this.plots[i].properties.plotCode == name) {
          return this.plots[i];
        }
      }
    }
  }, {
    "key" : `removeAll`,
    "value" : function() {
      this.clear();
    }
  }, {
    "key" : "clear",
    "value" : function() {
      this.plots.forEach(function(inventoryService) {
        inventoryService.remove();
      });
      this.plots = [];
    }
  }]);
  meta = match;
  _inherits(ThreadForm, meta);
  expect(ThreadForm, [{
    "key" : `addPlot`,
    "value" : function(value) {
      return value = handler(this.viewer, value.properties.plotType, value), this.plots.push(value), value;
    }
  }, {
    "key" : `flyToByPlotCode`,
    "value" : function(target) {
      var i;
      var same = this;
      target = this.getByPlotCode(target);
      if (target) {
        this.setSelectedPlot(target);
        i = this.viewer.entities.add({
          "polygon" : {
            "hierarchy" : target.positions,
            "perPositionHeight" : true,
            "material" : Cesium.Color.YELLOW.withAlpha(0.001),
            "outline" : false
          }
        });
        this.viewer.flyTo(i).then(function() {
          var rel2Mstr = hahaha;
          same[rel2Mstr(2276)][rel2Mstr(1319)][rel2Mstr(508)](i);
        });
      }
    }
  }, {
    "key" : `setSelectedPlot`,
    "value" : function(type) {
      if (this.plotSelecteable) {
        if (this.selectedPlot) {
          this.selectedPlot.setSelected(false);
        }
        this.selectedPlot = type;
        this.selectedPlot.setSelected(true);
        this.selectedPlotChanged.raiseEvent(type);
      }
    }
  }, {
    "key" : `clearSelectedPlot`,
    "value" : function() {
      if (this.selectedPlot) {
        this.selectedPlot.setSelected(false);
        this.selectedPlot.openEditMode(false);
        this.selectedPlot = void 0;
      }
    }
  }, {
    "key" : "initEvent",
    "value" : function() {
      var o = this;
      (new Cesium["ScreenSpaceEventHandler"](this.viewer.scene.canvas)).setInputAction(function(currentItems) {
        var parseInt = hahaha;
        var value;
        if (!!o[parseInt(455)]) {
          if (value = (value = o[parseInt(2276)][parseInt(2758)].pickPosition(currentItems[parseInt(586)])) || o[parseInt(2276)][parseInt(2758)][parseInt(1306)][parseInt(1080)](currentItems[parseInt(586)], o.viewer.scene.globe[parseInt(1923)])) {
            value = stringify(value);
            if (value = o[parseInt(2498)](value)) {
              if (!(o[parseInt(1277)] && o.selectedPlot[parseInt(2931)][parseInt(2717)] == value[parseInt(2931)][parseInt(2717)])) {
                if (o[parseInt(1277)]) {
                  o[parseInt(1277)][parseInt(1666)](false);
                  o[parseInt(1277)] = void 0;
                  o[parseInt(1346)][parseInt(2477)](void 0);
                }
                o[parseInt(1277)] = value;
                o[parseInt(1277)].setSelected(true);
                o.selectedPlotChanged[parseInt(2477)](value);
              }
            } else {
              if (o[parseInt(1277)]) {
                o.selectedPlot[parseInt(1666)](false);
                o[parseInt(1277)] = void 0;
                o[parseInt(1346)][parseInt(2477)](void 0);
              }
            }
          }
        }
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
    }
  }, {
    "key" : `getByPlotIntersect`,
    "value" : function(key) {
      var comparisons = this.plots;
      var i = 0;
      for (; i < comparisons.length; i++) {
        var t = comparisons[i];
        var inner = assert(t.positions);
        inner.push(inner[0]);
        var objToEvaluate = turf.polygon([inner]);
        inner = turf.point(key);
        if (turf.booleanPointInPolygon(inner, objToEvaluate)) {
          return t;
        }
      }
    }
  }]);
  output = ThreadForm;
  expect(i, [{
    "key" : `registerMouseEvents`,
    "value" : function() {
      this.eventHandler = new Cesium["ScreenSpaceEventHandler"](this.viewer.scene.canvas);
      this.initLeftDownEventHandler();
      this.initMouseMoveEventHandler();
      this.initLeftUpEventHandler();
    }
  }, {
    "key" : "unRegisterMouseEvents",
    "value" : function() {
      this.eventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOWN);
      this.eventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_UP);
      this.eventHandler.removeInputAction(Cesium.ScreenSpaceEventType.MOUSE_MOVE);
    }
  }, {
    "key" : `destroy`,
    "value" : function() {
      this.unRegisterMouseEvents();
      this.viewer = void 0;
      this.htmlPlotLayer = void 0;
      this.eventHandler = void 0;
    }
  }, {
    "key" : `initLeftDownEventHandler`,
    "value" : function() {
      var data = this;
      this.eventHandler.setInputAction(function(p) {
        var parseInt = hahaha;
        if (!!data.htmlPlotLayer.selectedPlot) {
          if ((p = data[parseInt(2276)][parseInt(2758)][parseInt(1708)](p[parseInt(586)])) && p.id && parseInt(2849) === p.id[parseInt(1720)] && data[parseInt(616)][parseInt(1277)][parseInt(2931)][parseInt(2717)] == p.id[parseInt(2717)]) {
            data[parseInt(2276)][parseInt(1633)] = false;
            document[parseInt(1494)][parseInt(1998)][parseInt(737)] = parseInt(367);
            data[parseInt(591)] = true;
            data[parseInt(825)] = new Date(data.viewer);
            data[parseInt(2276)][parseInt(2758)].screenSpaceCameraController[parseInt(1218)] = false;
          }
        }
      }, Cesium.ScreenSpaceEventType.LEFT_DOWN);
    }
  }, {
    "key" : "initLeftUpEventHandler",
    "value" : function() {
      var same = this;
      this.eventHandler.setInputAction(function(canCreateDiscussions) {
        var rel2Mstr = hahaha;
        if (same[rel2Mstr(591)]) {
          same[rel2Mstr(2276)].enableCursorStyle = true;
          document[rel2Mstr(1494)][rel2Mstr(1998)][rel2Mstr(737)] = rel2Mstr(1654);
          same[rel2Mstr(591)] = false;
          same[rel2Mstr(2276)][rel2Mstr(2758)][rel2Mstr(2190)][rel2Mstr(1218)] = true;
          same[rel2Mstr(825)].remove();
          same[rel2Mstr(825)] = void 0;
        }
      }, Cesium.ScreenSpaceEventType.LEFT_UP);
    }
  }, {
    "key" : "initMouseMoveEventHandler",
    "value" : function() {
      var o = this;
      this.eventHandler.setInputAction(function(data) {
        var camelize = hahaha;
        if (!!o[camelize(591)]) {
          if (data = o.viewer[camelize(2758)][camelize(1238)](data[camelize(2840)])) {
            o[camelize(825)][camelize(3164)](data);
            o[camelize(616)][camelize(1277)].updatePosition(data);
          }
        }
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
    }
  }]);
  frame = i;
  var _0x5694b1 = {
    "SIMPLELABEL" : `simplelabel`,
    "GRADIENTSLABEL" : `gradientslabel`,
    "LOCATIONLABEL" : "locationlabel"
  };
  appendCSS(`.gradients-label-container {\n    background-image: linear-gradient(to right, #e64dc1, #00ffc3);\n    position: absolute;\n    left: 0px;\n    bottom: 0px;\n    cursor: default;\n    padding: 5px;\n    border: 1px solid #9c9944e8;\n}\n\n.gradients-label-container:hover {\n    border: 1px solid rgb(9, 255, 0);\n}\n\n.gradients-label-container::before {\n    position: absolute;\n    content: "";\n    left: 50%;\n    bottom: -30px;\n    height: 30px;\n    border-left: 1px dashed #c5e22770;\n}\n\n\n/* \u7b80\u5355 */\n\n.simple-label-container {\n    background: #e3eee59e;\n    position: absolute;\n    left: 0px;\n    bottom: 0px;\n    cursor: default;\n    padding: 5px;\n    border: 1px solid #9c9944e8;\n}\n\n.label-container-is-selected {\n    border: 2px solid yellow;\n}\n\n.label-container-is-selected::before {\n    border-left: 2px dashed yellow !important;\n}\n\n.simple-label-container:hover {\n    border: 1px solid rgb(9, 255, 0);\n}\n\n.simple-label-container::before {\n    position: absolute;\n    content: "";\n    left: 50%;\n    bottom: -30px;\n    height: 30px;\n    border-left: 1px dashed #c5e22770;\n}`, 
  {});
  expect(proceed, [{
    "key" : `setSelected`,
    "value" : function(name) {
      if (name) {
        this.container.classList.add("label-container-is-selected");
      } else {
        this.container.classList.remove("label-container-is-selected");
      }
      this.setPointVisible(name);
    }
  }, {
    "key" : `addBillboard`,
    "value" : function() {
      this.billboardEntity = this.viewer.entities.add({
        "position" : this.position,
        "type" : "HtmlPlot",
        "plotCode" : this.properties.plotCode,
        "point" : {
          "color" : Cesium.Color.DARKBLUE.withAlpha(0.4),
          "pixelSize" : 6,
          "outlineColor" : Cesium.Color.YELLOW.withAlpha(0.4),
          "outlineWidth" : 2,
          "scaleByDistance" : new Cesium["NearFarScalar"](300, 1, 1200, 0.4),
          "disableDepthTestDistance" : 500
        }
      });
    }
  }, {
    "key" : `setPointVisible`,
    "value" : function(name) {
      if (name) {
        this.billboardEntity.point.pixelSize = 10;
        this.billboardEntity.point.outlineWidth = 3;
        this.billboardEntity.point.outlineColor = Cesium.Color.YELLOW;
      } else {
        this.billboardEntity.point.pixelSize = 6;
        this.billboardEntity.point.outlineWidth = 2;
        this.billboardEntity.point.outlineColor = Cesium.Color.YELLOW.withAlpha(0.4);
      }
    }
  }, {
    "key" : `updatePosition`,
    "value" : function(value) {
      this.billboardEntity.position = value;
      var coordinates = Cesium.Cartographic.fromCartesian(value);
      this.position = value;
      this.coordinates = [Cesium.Math.toDegrees(coordinates.longitude), Cesium.Math.toDegrees(coordinates.latitude), coordinates.height];
    }
  }, {
    "key" : `updateLabel`,
    "value" : function(name) {
      this.labelHtml.innerHTML = name;
      this.properties.attr.label = name;
    }
  }, {
    "key" : `toGeoJson`,
    "value" : function() {
      return {
        "type" : "Feature",
        "properties" : this.properties,
        "geometry" : {
          "type" : "Point",
          "coordinates" : this.coordinates
        }
      };
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.viewer.entities.remove(this.billboardEntity);
      this.viewer.cesiumWidget.container.removeChild(this.container);
      this.viewer.scene.postRender.removeEventListener(this.postRender, this);
    }
  }]);
  state = proceed;
  var ClientRequest = (_inherits(_class, state), expect(_class, [{
    "key" : `createDom`,
    "value" : function() {
      this.container = document.createElement("div");
      this.container.classList.add("simple-label-container");
      var label = document.createElement("div");
      label.innerHTML = this.label;
      this.labelHtml = label;
      this.container.appendChild(label);
      this.viewer.cesiumWidget.container.appendChild(this.container);
    }
  }, {
    "key" : `addPostRender`,
    "value" : function() {
      this.viewer.scene.postRender.addEventListener(this.postRender, this);
    }
  }, {
    "key" : `postRender`,
    "value" : function() {
      var item;
      var cw;
      if (this.container && this.container.style) {
        cw = this.viewer.scene.canvas.height;
        item = new Cesium["Cartesian2"];
        Cesium.SceneTransforms.wgs84ToWindowCoordinates(this.viewer.scene, this.position, item);
        this.container.style.bottom = cw - item.y + 40 + "px";
        cw = this.container.offsetWidth;
        this.container.style.left = item.x - cw / 2 + "px";
        if (2E3 < this.viewer.camera.positionCartographic.height) {
          this.container.style.display = "none";
        } else {
          this.container.style.display = "block";
        }
      }
    }
  }]), _class);
  var Request = (_inherits(Tooltip, state), expect(Tooltip, [{
    "key" : `createDom`,
    "value" : function() {
      this.container = document.createElement("div");
      this.container.classList.add("gradients-label-container");
      var label = document.createElement("div");
      label.innerHTML = this.label;
      this.labelHtml = label;
      this.container.appendChild(label);
      this.viewer.cesiumWidget.container.appendChild(this.container);
    }
  }, {
    "key" : "addPostRender",
    "value" : function() {
      this.viewer.scene.postRender.addEventListener(this.postRender, this);
    }
  }, {
    "key" : `postRender`,
    "value" : function() {
      var item;
      var cw;
      if (this.container && this.container.style) {
        cw = this.viewer.scene.canvas.height;
        item = new Cesium["Cartesian2"];
        Cesium.SceneTransforms.wgs84ToWindowCoordinates(this.viewer.scene, this.position, item);
        this.container.style.bottom = cw - item.y + 40 + "px";
        cw = this.container.offsetWidth;
        this.container.style.left = item.x - cw / 2 + "px";
        if (2E3 < this.viewer.camera.positionCartographic.height) {
          this.container.style.display = "none";
        } else {
          this.container.style.display = "block";
        }
      }
    }
  }]), Tooltip);
  var request = function(options, useCache, cb) {
    switch(useCache) {
      case _0x5694b1.SIMPLELABEL:
        return new ClientRequest(options, cb);
      case _0x5694b1.GRADIENTSLABEL:
        return new Request(options, cb);
    }
  };
  location = (_inherits(StyleButton, meta), expect(StyleButton, [{
    "key" : `initEvent`,
    "value" : function() {
      var obj = this;
      (new Cesium["ScreenSpaceEventHandler"](this.viewer.scene.canvas)).setInputAction(function(data) {
        var parseInt = hahaha;
        if (obj.plotSelecteable) {
          if ((data = obj[parseInt(2276)][parseInt(2758)].pick(data[parseInt(586)])) && data.id) {
            if (!(data.id && data.id[parseInt(1720)] && parseInt(2849) == data.id.type)) {
              if (obj[parseInt(1277)]) {
                obj[parseInt(1277)][parseInt(1666)](false);
                obj.selectedPlot = void 0;
                obj.selectedPlotChanged.raiseEvent(void 0);
              }
            }
            if (!(obj[parseInt(1277)] && obj[parseInt(1277)][parseInt(2931)].plotCode == data.id.plotCode)) {
              if (data = obj[parseInt(2426)](data.id[parseInt(2717)])) {
                obj[parseInt(2890)]();
                obj[parseInt(1277)] = data;
                obj[parseInt(1277)][parseInt(1666)](true);
                obj[parseInt(1346)][parseInt(2477)](data);
              } else {
                if (obj[parseInt(1277)]) {
                  obj[parseInt(1277)][parseInt(1666)](false);
                  obj[parseInt(1277)] = void 0;
                }
                obj[parseInt(1346)].raiseEvent(void 0);
              }
            }
          } else {
            if (obj[parseInt(1277)]) {
              obj.selectedPlot[parseInt(1666)](false);
              obj.selectedPlot = void 0;
              obj[parseInt(1346)][parseInt(2477)](void 0);
            }
          }
        }
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
    }
  }, {
    "key" : "addPlot",
    "value" : function(target) {
      return target = request(this.viewer, target.properties.plotType, target), this.plots.push(target), target.layer = this, target;
    }
  }, {
    "key" : `setSelectedPlot`,
    "value" : function(type) {
      if (this.plotSelecteable) {
        if (this.selectedPlot) {
          this.selectedPlot.setSelected(false);
        }
        this.selectedPlot = type;
        this.selectedPlot.setSelected(true);
        this.selectedPlotChanged.raiseEvent(type);
      }
    }
  }, {
    "key" : `clearSelectedPlot`,
    "value" : function() {
      if (this.selectedPlot) {
        this.selectedPlot.setSelected(false);
        this.selectedPlot = void 0;
      }
    }
  }, {
    "key" : `flyToByPlotCode`,
    "value" : function(name) {
      name = this.getByPlotCode(name);
      if (name) {
        this.setSelectedPlot(name);
        this.viewer.flyTo(name.billboardEntity);
      }
    }
  }]), StyleButton);
  var Draw = {
    "POLYHEDRON" : `polyhedron`,
    "HEMISPHERE" : `hemisphere`,
    "CYLINDER" : `cylinder`
  };
  doc = (expect(end, [{
    "key" : `generatePositions`,
    "value" : function() {
      var result = this;
      this.positions = [];
      var coordinates = void 0;
      switch(this.geometry.type) {
        case "Point":
          coordinates = [this.coordinates];
          break;
        case "LineString":
          coordinates = this.coordinates;
          break;
        case "Polygon":
          coordinates = this.coordinates[0];
      }
      coordinates.forEach(function(canCreateDiscussions) {
        var put_rows = hahaha;
        result.positions[put_rows(2008)](Cesium[put_rows(3131)][put_rows(2770)](canCreateDiscussions[0], canCreateDiscussions[1], canCreateDiscussions[2]));
      });
    }
  }, {
    "key" : `setPositions`,
    "value" : function(name) {
      switch(this.positions = name || [], this.coordinates = [], this.geometry.type) {
        case "Point":
          this.setPointCoordinates();
          break;
        case "LineString":
          this.setLineStringCoordinates();
          break;
        case "Polygon":
          this.setPolygonCoordinates();
      }
      if (this.updatePositionAction) {
        this.updatePositionAction();
      }
    }
  }, {
    "key" : `setPointCoordinates`,
    "value" : function() {
      var cart = Cesium.Cartographic.fromCartesian(this.positions[0]);
      this.coordinates = [Cesium.Math.toDegrees(cart.longitude), Cesium.Math.toDegrees(cart.latitude), cart.height];
    }
  }, {
    "key" : "setLineStringCoordinates",
    "value" : function() {
      var colData = this;
      this.positions.forEach(function(result) {
        var parseInt = hahaha;
        result = Cesium.Cartographic[parseInt(2206)](result);
        result = [Cesium[parseInt(2090)].toDegrees(result[parseInt(2596)]), Cesium.Math[parseInt(1611)](result[parseInt(480)]), result[parseInt(1132)]];
        colData[parseInt(2656)][parseInt(2008)](result);
      });
    }
  }, {
    "key" : `setPolygonCoordinates`,
    "value" : function() {
      var primaryReplicas = this;
      this.coordinates.push([]);
      this.positions.forEach(function(datum) {
        var stringify = hahaha;
        datum = Cesium.Cartographic[stringify(2206)](datum);
        datum = [Cesium[stringify(2090)][stringify(1611)](datum.longitude), Cesium.Math[stringify(1611)](datum.latitude), datum.height];
        primaryReplicas[stringify(2656)][0][stringify(2008)](datum);
      });
    }
  }, {
    "key" : `getPositions`,
    "value" : function() {
      return this.positions.slice(0);
    }
  }, {
    "key" : `getPositionCount`,
    "value" : function() {
      return this.positions.length;
    }
  }, {
    "key" : `setSelected`,
    "value" : function(name) {
    }
  }, {
    "key" : `openEditMode`,
    "value" : function(name) {
    }
  }, {
    "key" : `remove`,
    "value" : function() {
    }
  }]), end);
  var CSSEditContainer = (_inherits(Polygon, doc), expect(Polygon, [{
    "key" : `createEntity`,
    "value" : function() {
      this.entity = this.viewer.entities.add({
        "plotType" : "HedronPlot",
        "plotCode" : this.properties.plotCode,
        "polygon" : {
          "hierarchy" : this.positions,
          "material" : Cesium.Color.fromCssColorString(this.style.color),
          "perPositionHeight" : true,
          "extrudedHeight" : get(this.positions[0]) + this.style.extrudedHeight
        }
      });
    }
  }, {
    "key" : `createLabelEntity`,
    "value" : function() {
      this.textEntity = this.viewer.entities.add({
        "position" : this.getLabelEntityPosition(),
        "show" : false,
        "plotType" : "HedronPlot",
        "plotCode" : this.properties.plotCode,
        "label" : {
          "text" : this.properties.attr.name,
          "fillColor" : Cesium.Color.WHITE,
          "scale" : 0.5,
          "font" : "normal 40px MicroSoft YaHei",
          "distanceDisplayCondition" : new Cesium["DistanceDisplayCondition"](0, 5E5),
          "scaleByDistance" : new Cesium.NearFarScalar(5E4, 1, 5E5, 0.4),
          "verticalOrigin" : Cesium.VerticalOrigin.BOTTOM,
          "style" : Cesium.LabelStyle.FILL_AND_OUTLINE,
          "pixelOffset" : new Cesium["Cartesian2"](0, -10),
          "outlineWidth" : 20,
          "outlineColor" : Cesium.Color.BLACK
        }
      });
    }
  }, {
    "key" : "getLabelEntityPosition",
    "value" : function() {
      var tmp = all(this.getPositions());
      if (tmp.push(tmp[0]), tmp.length < 4) {
        return this.positions[0];
      }
      var val = turf.polygon([tmp]);
      tmp = turf.bbox(val);
      val = turf.bboxPolygon(tmp);
      tmp = turf.center(val).geometry.coordinates;
      val = get(this.positions[0]) + this.style.extrudedHeight;
      return Cesium.Cartesian3.fromDegrees(tmp[0], tmp[1], val);
    }
  }, {
    "key" : `openEditMode`,
    "value" : function(name) {
      var obj = this;
      if (name) {
        this.entity.polygon.hierarchy = new Cesium["CallbackProperty"](function(canCreateDiscussions) {
          var put_rows = hahaha;
          return new (Cesium[put_rows(1433)])(obj[put_rows(1707)]);
        }, false);
        this.entity.polygon.extrudedHeight = new Cesium["CallbackProperty"](function(canCreateDiscussions) {
          var parseInt = hahaha;
          return get(obj.positions[0]) + obj[parseInt(1998)][parseInt(3009)];
        });
        this.entity.polyline = {
          "positions" : new Cesium.CallbackProperty(function(canCreateDiscussions) {
            var parseInt = hahaha;
            return obj[parseInt(1707)][parseInt(439)](obj[parseInt(1707)][0]);
          }, false),
          "width" : 1,
          "material" : new Cesium["PolylineDashMaterialProperty"]({
            "color" : Cesium.Color.YELLOW
          }),
          "depthFailMaterial" : new Cesium["PolylineDashMaterialProperty"]({
            "color" : Cesium.Color.YELLOW
          })
        };
      } else {
        this.entity.polygon.hierarchy = this.positions;
        this.entity.polygon.extrudedHeight = get(this.positions[0]) + this.style.extrudedHeight;
        this.entity.polyline = {
          "positions" : new Cesium.CallbackProperty(function(canCreateDiscussions) {
            var put_rows = hahaha;
            return obj.positions[put_rows(439)](obj.positions[0]);
          }, false),
          "width" : 0
        };
      }
    }
  }, {
    "key" : `updatePositionAction`,
    "value" : function() {
      geocode(this.positions);
      this.textEntity.position = this.getLabelEntityPosition();
      this.setPolygonCenter();
    }
  }, {
    "key" : `updateStyle`,
    "value" : function(name) {
      this.entity.polygon.extrudedHeight = this.style.extrudedHeight;
      this.entity.polygon.material = Cesium.Color.fromCssColorString(this.style.color);
      this.textEntity.label.text = this.properties.attr.name;
    }
  }, {
    "key" : "setSelected",
    "value" : function(name) {
      this.entity.polygon.outline = !!name;
      this.entity.polygon.outlineColor = Cesium.Color.YELLOW;
    }
  }, {
    "key" : `toGeoJson`,
    "value" : function() {
      return {
        "type" : "Feature",
        "properties" : this.properties,
        "geometry" : {
          "type" : "Polygon",
          "coordinates" : this.coordinates
        }
      };
    }
  }, {
    "key" : `checkTargetIsIntersect`,
    "value" : function(name) {
      return cache(this.targetPosition = name, this.getPositions(), this.style.extrudedHeight);
    }
  }, {
    "key" : `createLineEntity`,
    "value" : function() {
      var primaryReplicas = this;
      this.setPolygonCenter();
      this.lineEntity = this.viewer.entities.add({
        "polyline" : {
          "positions" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
            var stringify = hahaha;
            return [primaryReplicas[stringify(2431)], primaryReplicas[stringify(1097)]];
          }, false),
          "show" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
            var put_rows = hahaha;
            return Cesium[put_rows(3131)][put_rows(1473)](primaryReplicas.targetPosition, primaryReplicas.hedronCenter) < 4E3;
          }, false),
          "material" : new Cesium["PolylineDashMaterialProperty"]({
            "color" : Cesium.Color.YELLOW
          }),
          "depthFailMaterial" : new Cesium["PolylineDashMaterialProperty"]({
            "color" : Cesium.Color.YELLOW
          })
        }
      });
    }
  }, {
    "key" : "setPolygonCenter",
    "value" : function() {
      var val;
      var tmp = all(this.getPositions());
      tmp.push(tmp[0]);
      if (tmp.length < 4) {
        this.hedronCenter = this.positions[0];
      } else {
        val = turf.polygon([tmp]);
        tmp = turf.bbox(val);
        val = turf.bboxPolygon(tmp);
        tmp = turf.center(val).geometry.coordinates;
        val = get(this.positions[0]);
        this.hedronCenter = Cesium.Cartesian3.fromDegrees(tmp[0], tmp[1], val);
      }
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.viewer.entities.remove(this.entity);
      this.viewer.entities.remove(this.textEntity);
      this.viewer.entities.remove(this.lineEntity);
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.viewer.entities.remove(this.entity);
    }
  }]), Polygon);
  var XMLEditContainer = (_inherits(Area, doc), expect(Area, [{
    "key" : `createEntity`,
    "value" : function() {
      this.entity = this.viewer.entities.add({
        "plotType" : "HedronPlot",
        "plotCode" : this.properties.plotCode,
        "position" : this.positions[0],
        "ellipsoid" : {
          "radii" : new Cesium["Cartesian3"](this.style.radius, this.style.radius, this.style.radius),
          "maximumCone" : Cesium.Math.toRadians(90),
          "material" : Cesium.Color.fromCssColorString(this.style.color),
          "subdivisions" : 128,
          "stackPartitions" : 24,
          "slicePartitions" : 24,
          "outline" : true,
          "outlineColor" : Cesium.Color.YELLOW.withAlpha(0.4)
        }
      });
    }
  }, {
    "key" : `createLabelEntity`,
    "value" : function() {
      this.textEntity = this.viewer.entities.add({
        "position" : this.getLabelEntityPosition(),
        "show" : false,
        "plotType" : "HedronPlot",
        "plotCode" : this.properties.plotCode,
        "label" : {
          "text" : this.properties.attr.name,
          "fillColor" : Cesium.Color.WHITE,
          "scale" : 0.5,
          "font" : "normal 40px MicroSoft YaHei",
          "distanceDisplayCondition" : new Cesium.DistanceDisplayCondition(0, 5E5),
          "scaleByDistance" : new Cesium["NearFarScalar"](5E4, 1, 5E5, 0.4),
          "verticalOrigin" : Cesium.VerticalOrigin.BOTTOM,
          "style" : Cesium.LabelStyle.FILL_AND_OUTLINE,
          "pixelOffset" : new Cesium["Cartesian2"](0, -10),
          "outlineWidth" : 20,
          "outlineColor" : Cesium.Color.BLACK
        }
      });
    }
  }, {
    "key" : `getLabelEntityPosition`,
    "value" : function() {
      var tmp = parseFloat(this.positions[0]);
      var height = get(this.positions[0]) + this.style.radius;
      return Cesium.Cartesian3.fromDegrees(tmp[0], tmp[1], height);
    }
  }, {
    "key" : `updatePositionAction`,
    "value" : function() {
      this.textEntity.position = this.getLabelEntityPosition();
    }
  }, {
    "key" : `setVisible`,
    "value" : function(name) {
      this.entity.show = name;
    }
  }, {
    "key" : `updateStyle`,
    "value" : function(name) {
      this.entity.ellipsoid.radii = new Cesium.Cartesian3(this.style.radius, this.style.radius, this.style.radius);
      this.entity.ellipsoid.material = Cesium.Color.fromCssColorString(this.style.color);
      this.textEntity.label.text = this.properties.attr.name;
      this.textEntity.position = this.getLabelEntityPosition();
    }
  }, {
    "key" : `openEditMode`,
    "value" : function(name) {
      var primaryReplicas = this;
      this.entity.position = name ? new Cesium["CallbackProperty"](function(canCreateDiscussions) {
        var stringify = hahaha;
        return primaryReplicas[stringify(1707)][0];
      }) : this.positions[0];
    }
  }, {
    "key" : `setSelected`,
    "value" : function(name) {
      if (name) {
        this.entity.ellipsoid.outlineColor = Cesium.Color.YELLOW;
        this.entity.ellipsoid.stackPartitions = 64;
        this.entity.ellipsoid.slicePartitions = 64;
      } else {
        this.setVisible(true);
        this.openEditMode(false);
        this.entity.ellipsoid.outlineColor = Cesium.Color.YELLOW.withAlpha(0.4);
        this.entity.ellipsoid.stackPartitions = 24;
        this.entity.ellipsoid.slicePartitions = 24;
      }
    }
  }, {
    "key" : "toGeoJson",
    "value" : function() {
      return {
        "type" : "Feature",
        "properties" : this.properties,
        "geometry" : {
          "type" : "Point",
          "coordinates" : this.coordinates
        }
      };
    }
  }, {
    "key" : `checkTargetIsIntersect`,
    "value" : function(target) {
      return this.targetPosition = target, Cesium.Cartesian3.distance(this.positions[0], target) < this.style.radius;
    }
  }, {
    "key" : "createLineEntity",
    "value" : function() {
      var primaryReplicas = this;
      this.lineEntity = this.viewer.entities.add({
        "polyline" : {
          "positions" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
            var stringify = hahaha;
            return [primaryReplicas[stringify(2431)], primaryReplicas.positions[0]];
          }, false),
          "show" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
            var stringify = hahaha;
            return Cesium[stringify(3131)][stringify(1473)](primaryReplicas[stringify(2431)], primaryReplicas[stringify(1707)][0]) < 4E3;
          }, false),
          "material" : new Cesium.PolylineDashMaterialProperty({
            "color" : Cesium.Color.YELLOW
          }),
          "depthFailMaterial" : new Cesium["PolylineDashMaterialProperty"]({
            "color" : Cesium.Color.YELLOW
          })
        }
      });
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.viewer.entities.remove(this.entity);
      this.viewer.entities.remove(this.textEntity);
      this.viewer.entities.remove(this.lineEntity);
    }
  }]), Area);
  var URI = (_inherits(Circle, doc), expect(Circle, [{
    "key" : `createEntity`,
    "value" : function() {
      this.entity = this.viewer.entities.add({
        "plotType" : "HedronPlot",
        "plotCode" : this.properties.plotCode,
        "polygon" : {
          "hierarchy" : this.getHierarchy(),
          "material" : Cesium.Color.fromCssColorString(this.style.color),
          "perPositionHeight" : true,
          "extrudedHeight" : get(this.positions[0]) + this.style.extrudedHeight
        }
      });
    }
  }, {
    "key" : `createLabelEntity`,
    "value" : function() {
      this.textEntity = this.viewer.entities.add({
        "position" : this.getLabelEntityPosition(),
        "show" : false,
        "plotType" : "HedronPlot",
        "plotCode" : this.properties.plotCode,
        "label" : {
          "text" : this.properties.attr.name,
          "fillColor" : Cesium.Color.WHITE,
          "scale" : 0.5,
          "font" : "normal 40px MicroSoft YaHei",
          "distanceDisplayCondition" : new Cesium.DistanceDisplayCondition(0, 5E5),
          "scaleByDistance" : new Cesium["NearFarScalar"](5E4, 1, 5E5, 0.4),
          "verticalOrigin" : Cesium.VerticalOrigin.BOTTOM,
          "style" : Cesium.LabelStyle.FILL_AND_OUTLINE,
          "pixelOffset" : new Cesium.Cartesian2(0, -10),
          "outlineWidth" : 20,
          "outlineColor" : Cesium.Color.BLACK
        }
      });
    }
  }, {
    "key" : `getLabelEntityPosition`,
    "value" : function() {
      var tmp = parseFloat(this.positions[0]);
      var height = get(this.positions[0]) + this.style.extrudedHeight;
      return Cesium.Cartesian3.fromDegrees(tmp[0], tmp[1], height);
    }
  }, {
    "key" : `updatePositionAction`,
    "value" : function() {
      this.textEntity.position = this.getLabelEntityPosition();
    }
  }, {
    "key" : `setVisible`,
    "value" : function(name) {
      this.entity.show = name;
    }
  }, {
    "key" : `updateStyle`,
    "value" : function(name) {
      this.entity.polygon.extrudedHeight = get(this.positions[0]) + this.style.extrudedHeight;
      this.entity.polygon.hierarchy = this.getHierarchy();
      this.entity.polygon.material = Cesium.Color.fromCssColorString(this.style.color);
      this.textEntity.label.text = this.properties.attr.name;
      this.textEntity.position = this.getLabelEntityPosition();
    }
  }, {
    "key" : `getHierarchy`,
    "value" : function() {
      var sharpness = val([this.coordinates[0], this.coordinates[1]], this.style.radius);
      return this.circleDsToPositions(sharpness);
    }
  }, {
    "key" : `circleDsToPositions`,
    "value" : function(name) {
      var retinaResult = this;
      var primaryReplicas = [];
      return name.map(function(canCreateDiscussions) {
        var stringify = hahaha;
        primaryReplicas[stringify(2008)](Cesium[stringify(3131)][stringify(2770)](canCreateDiscussions[0], canCreateDiscussions[1], retinaResult.coordinates[2]));
      }), primaryReplicas;
    }
  }, {
    "key" : "openEditMode",
    "value" : function(name) {
      var c = this;
      if (name) {
        this.entity.polygon.hierarchy = new Cesium["CallbackProperty"](function(canCreateDiscussions) {
          return c.getHierarchy();
        });
        this.entity.polygon.extrudedHeight = new Cesium["CallbackProperty"](function(canCreateDiscussions) {
          var put_rows = hahaha;
          return get(c[put_rows(1707)][0]) + c.style.extrudedHeight;
        });
      } else {
        this.entity.polygon.hierarchy = this.getHierarchy();
        this.entity.polygon.extrudedHeight = get(this.positions[0]) + this.style.extrudedHeight;
      }
    }
  }, {
    "key" : "setSelected",
    "value" : function(name) {
      if (name) {
        this.entity.polygon.outline = true;
      } else {
        this.setVisible(true);
        this.openEditMode(false);
        this.entity.polygon.outline = false;
      }
      this.entity.polygon.outlineColor = Cesium.Color.YELLOW;
    }
  }, {
    "key" : `toGeoJson`,
    "value" : function() {
      return {
        "type" : "Feature",
        "properties" : this.properties,
        "geometry" : {
          "type" : "Point",
          "coordinates" : this.coordinates
        }
      };
    }
  }, {
    "key" : `checkTargetIsIntersect`,
    "value" : function(name) {
      return cache(this.targetPosition = name, this.getHierarchy(), this.style.extrudedHeight);
    }
  }, {
    "key" : `createLineEntity`,
    "value" : function() {
      var primaryReplicas = this;
      this.lineEntity = this.viewer.entities.add({
        "polyline" : {
          "positions" : new Cesium.CallbackProperty(function(canCreateDiscussions) {
            var stringify = hahaha;
            return [primaryReplicas[stringify(2431)], primaryReplicas[stringify(1707)][0]];
          }, false),
          "show" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
            var stringify = hahaha;
            return Cesium[stringify(3131)].distance(primaryReplicas[stringify(2431)], primaryReplicas[stringify(1707)][0]) < 4E3;
          }, false),
          "material" : new Cesium["PolylineDashMaterialProperty"]({
            "color" : Cesium.Color.YELLOW
          }),
          "depthFailMaterial" : new Cesium.PolylineDashMaterialProperty({
            "color" : Cesium.Color.YELLOW
          })
        }
      });
    }
  }, {
    "key" : "remove",
    "value" : function() {
      this.viewer.entities.remove(this.entity);
      this.viewer.entities.remove(this.textEntity);
      this.viewer.entities.remove(this.lineEntity);
    }
  }]), Circle);
  var parse = function(source, tileClass, options) {
    switch(tileClass) {
      case Draw.POLYHEDRON:
        return new CSSEditContainer(source, options);
      case Draw.HEMISPHERE:
        return new XMLEditContainer(source, options);
      case Draw.CYLINDER:
        return new URI(source, options);
    }
  };
  init = (expect(Header, [{
    "key" : "activate",
    "value" : function(name) {
      this.deactivate();
      this.clear();
      this.plotType = name;
      this.positions = [];
      this.plotDrawTip = new Map(this.viewer);
      this.MousePoint = new Date(this.viewer);
      this.registerEvents();
      this.viewer.enableCursorStyle = false;
      this.viewer._element.style.cursor = "default";
      this.initTip();
    }
  }, {
    "key" : `initTip`,
    "value" : function() {
      switch(this.plotType) {
        case Draw.POLYHEDRON:
          this.plotDrawTip.setContent(["\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a\u591a\u8fb9\u4f53\uff0c\u81f3\u5c11\u9700\u89813\u4e2a\u70b9", "\u6309\u4e0b\u9f20\u6807\u5de6\u952e\u786e\u5b9a\u7b2c1\u4e2a\u70b9", "\u6309\u4e0b\u9f20\u6807\u53f3\u952e\u53d6\u6d88\u7ed8\u5236"]);
          break;
        case Draw.HEMISPHERE:
          this.plotDrawTip.setContent(["\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a\u534a\u7403\u4f53\uff0c\u9700\u89811\u4e2a\u70b9", "\u6309\u4e0b\u9f20\u6807\u5de6\u952e\u786e\u5b9a\u4f4d\u7f6e", "\u6309\u4e0b\u9f20\u6807\u53f3\u952e\u53d6\u6d88\u7ed8\u5236"]);
          break;
        case Draw.CYLINDER:
          this.plotDrawTip.setContent(["\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a\u5706\u67f1\u4f53\uff0c\u9700\u89811\u4e2a\u70b9", "\u6309\u4e0b\u9f20\u6807\u5de6\u952e\u786e\u5b9a\u4f4d\u7f6e", "\u6309\u4e0b\u9f20\u6807\u53f3\u952e\u53d6\u6d88\u7ed8\u5236"]);
      }
    }
  }, {
    "key" : "deactivate",
    "value" : function() {
      this.unRegisterEvents();
      this.plotType = void 0;
      this.viewer._element.style.cursor = "pointer";
      this.viewer.enableCursorStyle = true;
      if (this.plotDrawTip) {
        this.plotDrawTip.remove();
        this.MousePoint.remove();
        this.plotDrawTip = void 0;
        this.MousePoint = void 0;
      }
    }
  }, {
    "key" : "clear",
    "value" : function() {
      if (this.plot) {
        this.plot.remove();
        this.plot = void 0;
      }
    }
  }, {
    "key" : `generatePlot`,
    "value" : function(type) {
      var ATTR_INPUT_TYPE = createIntervalElements();
      type = this.generateGeoFeature(ATTR_INPUT_TYPE, type);
      this.plot = parse(this.viewer, this.plotType, type);
      this.plot.openEditMode(true);
    }
  }, {
    "key" : `generateGeoFeature`,
    "value" : function(type, obj) {
      var geomType = void 0;
      var data = void 0;
      switch(this.plotType) {
        case Draw.HEMISPHERE:
        case Draw.CYLINDER:
          geomType = "Point";
          data = this.getPointCoordinates(obj);
          break;
        case Draw.POLYLINE:
        case Draw.CIRCLE:
          geomType = "LineString";
          data = this.getLineStringCoordinates(obj);
          break;
        case Draw.POLYHEDRON:
          geomType = "Polygon";
          data = this.getPolygonCoordinates(obj);
      }
      return {
        "type" : "Feature",
        "properties" : {
          "plotCode" : type,
          "style" : void 0
        },
        "geometry" : {
          "type" : geomType,
          "coordinates" : data
        }
      };
    }
  }, {
    "key" : "getPointCoordinates",
    "value" : function(value) {
      return value = Cesium.Cartographic.fromCartesian(value[0]), [Cesium.Math.toDegrees(value.longitude), Cesium.Math.toDegrees(value.latitude), value.height];
    }
  }, {
    "key" : `getLineStringCoordinates`,
    "value" : function(name) {
      var newaxe = [];
      return name.forEach(function(position) {
        position = Cesium.Cartographic.fromCartesian(position);
        position = [Cesium.Math.toDegrees(position.longitude), Cesium.Math.toDegrees(position.latitude), position.height];
        newaxe.push(position);
      }), newaxe;
    }
  }, {
    "key" : "getPolygonCoordinates",
    "value" : function(name) {
      var el = [[]];
      return name.forEach(function(position) {
        var property = hahaha;
        position = Cesium[property(1543)].fromCartesian(position);
        position = [Cesium.Math.toDegrees(position.longitude), Cesium[property(2090)][property(1611)](position.latitude), position[property(1132)]];
        el[0][property(2008)](position);
      }), el;
    }
  }, {
    "key" : "initEvents",
    "value" : function() {
      this.handler = new Cesium["ScreenSpaceEventHandler"](this.viewer.scene.canvas);
      this.PlotDrawStartEvent = new Cesium.Event;
      this.PlotDrawEndEvent = new Cesium.Event;
    }
  }, {
    "key" : `registerEvents`,
    "value" : function() {
      this.leftClickEvent();
      this.rightClickEvent();
      this.mouseMoveEvent();
    }
  }, {
    "key" : "leftClickEvent",
    "value" : function() {
      var options = this;
      this.handler.setInputAction(function(colData) {
        var parseInt = hahaha;
        options[parseInt(2276)]._element[parseInt(1998)][parseInt(737)] = parseInt(1654);
        colData = options[parseInt(2276)][parseInt(2758)].pickPosition(colData[parseInt(586)]);
        if (colData) {
          options[parseInt(1707)].push(colData);
          if (1 == options[parseInt(1707)][parseInt(2189)]) {
            options[parseInt(2700)](options[parseInt(1707)]);
          } else {
            options.plot[parseInt(2631)](options[parseInt(1707)]);
          }
          options[parseInt(406)]();
          if (options[parseInt(1298)].fixPositionCount == options[parseInt(1707)][parseInt(2189)]) {
            options[parseInt(2788)]();
            options[parseInt(1983)]();
          }
        }
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
    }
  }, {
    "key" : `setTipContent`,
    "value" : function() {
      if (this.plotType === Draw.POLYHEDRON) {
        this.plotDrawTip.setContent(["\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a\u591a\u8fb9\u4f53\uff0c\u6700\u5c11\u9700\u89813\u4e2a\u70b9\u3002", "\u5df2\u6709" + this.positions.length + "\u4e2a\u70b9\uff0c\u6309\u4e0b\u9f20\u6807\u5de6\u952e\u786e\u5b9a\u7b2c" + (this.positions.length + 1) + "\u4e2a\u70b9", this.positions.length < 3 ? "\u6309\u4e0b\u9f20\u6807\u53f3\u952e\u53d6\u6d88\u7ed8\u5236" : "\u6309\u4e0b\u9f20\u6807\u53f3\u952e\u7ed3\u675f\u7ed8\u5236"]);
      }
    }
  }, {
    "key" : `mouseMoveEvent`,
    "value" : function() {
      var same = this;
      this.handler.setInputAction(function(el) {
        var rel2Mstr = hahaha;
        same[rel2Mstr(2276)][rel2Mstr(2530)][rel2Mstr(1998)][rel2Mstr(737)] = rel2Mstr(1654);
        el = same[rel2Mstr(2276)][rel2Mstr(2758)][rel2Mstr(1238)](el[rel2Mstr(2840)]);
        if (el) {
          same[rel2Mstr(2270)].updatePosition(el);
          same[rel2Mstr(1455)][rel2Mstr(3164)](el);
          if (same[rel2Mstr(1298)]) {
            el = same[rel2Mstr(1707)][rel2Mstr(439)]([el]);
            same[rel2Mstr(1298)][rel2Mstr(2631)](el);
          }
        }
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
    }
  }, {
    "key" : `rightClickEvent`,
    "value" : function() {
      var obj = this;
      this.handler.setInputAction(function(canCreateDiscussions) {
        var parseInt = hahaha;
        if (0 != obj[parseInt(1707)][parseInt(2189)]) {
          if (obj[parseInt(1298)][parseInt(2862)]) {
            if (obj.positions[parseInt(2189)] == obj.plot[parseInt(2862)]) {
              obj[parseInt(1298)].setPositions(obj[parseInt(1707)]);
              obj[parseInt(2788)]();
              obj[parseInt(1983)]();
            } else {
              obj[parseInt(1983)]();
              obj.clear();
            }
          } else {
            if (obj[parseInt(1707)][parseInt(2189)] >= obj[parseInt(1298)].minPositionCount) {
              obj.plot.setPositions(obj[parseInt(1707)]);
              obj[parseInt(2788)]();
              obj[parseInt(1983)]();
            } else {
              obj[parseInt(1983)]();
              obj[parseInt(2822)]();
            }
          }
        } else {
          obj[parseInt(1983)]();
        }
      }, Cesium.ScreenSpaceEventType.RIGHT_CLICK);
    }
  }, {
    "key" : `unRegisterEvents`,
    "value" : function() {
      this.handler.removeInputAction(Cesium.ScreenSpaceEventType.RIGHT_CLICK);
      this.handler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_CLICK);
      this.handler.removeInputAction(Cesium.ScreenSpaceEventType.MOUSE_MOVE);
      this.handler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);
    }
  }, {
    "key" : "drawEnd",
    "value" : function() {
      this.plot.openEditMode(false);
      this.PlotDrawEndEvent.raiseEvent(this.plot, this.plotType);
    }
  }]), Header);
  var Error = (expect(annotationViewerShown, [{
    "key" : `registerMouseEvents`,
    "value" : function() {
      this.eventHandler = new Cesium["ScreenSpaceEventHandler"](this.viewer.scene.canvas);
      this.initLeftDownEventHandler();
      this.initMouseMoveEventHandler();
      this.initLeftUpEventHandler();
    }
  }, {
    "key" : `unRegisterMouseEvents`,
    "value" : function() {
      this.eventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOWN);
      this.eventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_UP);
      this.eventHandler.removeInputAction(Cesium.ScreenSpaceEventType.MOUSE_MOVE);
    }
  }, {
    "key" : `destroy`,
    "value" : function() {
      this.unRegisterMouseEvents();
      this.viewer = void 0;
      this.plotLayer = void 0;
      this.eventHandler = void 0;
    }
  }, {
    "key" : `initLeftDownEventHandler`,
    "value" : function() {
      var obj = this;
      this.eventHandler.setInputAction(function(document) {
        var prefixed = hahaha;
        if (!!obj.plotLayer.selectedPlot) {
          if ((document = obj[prefixed(2276)][prefixed(2758)][prefixed(1708)](document[prefixed(586)])) && document.id && "HedronPlot" === document.id[prefixed(549)] && obj[prefixed(2784)][prefixed(1277)][prefixed(2931)].plotCode == document.id[prefixed(2717)]) {
            if (!([prefixed(1062), prefixed(657)][prefixed(2358)](obj[prefixed(2784)][prefixed(1277)].properties[prefixed(549)]) < 0)) {
              obj[prefixed(2276)][prefixed(1633)] = false;
              document[prefixed(1494)].style[prefixed(737)] = prefixed(367);
              obj[prefixed(591)] = true;
              obj[prefixed(825)] = new Date(obj[prefixed(2276)]);
              obj[prefixed(2784)].selectedPlot[prefixed(1598)](true);
              obj[prefixed(2784)].selectedPlot[prefixed(2556)](false);
              obj[prefixed(2276)][prefixed(2758)][prefixed(2190)][prefixed(1218)] = false;
            }
          }
        }
      }, Cesium.ScreenSpaceEventType.LEFT_DOWN);
    }
  }, {
    "key" : `initLeftUpEventHandler`,
    "value" : function() {
      var self = this;
      this.eventHandler.setInputAction(function(canCreateDiscussions) {
        var put_rows = hahaha;
        if (self.plotLayer[put_rows(1277)] && -1 < [put_rows(1062), put_rows(657)][put_rows(2358)](self.plotLayer[put_rows(1277)][put_rows(2931)][put_rows(549)])) {
          self[put_rows(2784)][put_rows(1277)][put_rows(2556)](true);
          self.plotLayer[put_rows(1277)][put_rows(1598)](false);
        }
        if (self[put_rows(591)]) {
          self.viewer[put_rows(1633)] = true;
          document[put_rows(1494)][put_rows(1998)][put_rows(737)] = put_rows(1654);
          self[put_rows(591)] = false;
          self.viewer.scene.screenSpaceCameraController[put_rows(1218)] = true;
          self.mousePoint[put_rows(508)]();
          self[put_rows(825)] = void 0;
        }
      }, Cesium.ScreenSpaceEventType.LEFT_UP);
    }
  }, {
    "key" : `initMouseMoveEventHandler`,
    "value" : function() {
      var particles = this;
      this.eventHandler.setInputAction(function(primaryReplicas) {
        var stringify = hahaha;
        var panelPosition;
        if (!!particles[stringify(591)]) {
          if (panelPosition = (panelPosition = particles[stringify(2276)].scene[stringify(1238)](primaryReplicas[stringify(2840)])) || particles[stringify(2276)][stringify(2758)][stringify(1306)].pickEllipsoid(primaryReplicas[stringify(586)], particles[stringify(2276)][stringify(2758)][stringify(2359)][stringify(1923)])) {
            particles[stringify(825)].updatePosition(panelPosition);
            particles[stringify(2784)][stringify(1277)][stringify(2631)]([panelPosition]);
          }
        }
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
    }
  }]), annotationViewerShown);
  var SyncRunner = (expect(Wizard, [{
    "key" : "initEventHandler",
    "value" : function() {
      this.eventHandler = new Cesium["ScreenSpaceEventHandler"](this.viewer.scene.canvas);
    }
  }, {
    "key" : `activate`,
    "value" : function() {
      this.deactivate();
      this.initLeftClickEventHandler();
    }
  }, {
    "key" : `deactivate`,
    "value" : function() {
      this.eventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_CLICK);
      this.unRegisterEvents();
      this.clear();
    }
  }, {
    "key" : `clear`,
    "value" : function() {
      this.clearEditVertex();
    }
  }, {
    "key" : `initLeftClickEventHandler`,
    "value" : function() {
      var viewer = this;
      this.eventHandler.setInputAction(function(options) {
        options = viewer.viewer.scene.pick(options.position);
        if (options && options.id && "HedronPlot" == options.id.plotType) {
          if (viewer.plotLayer.selectedPlot) {
            if (polyhedron.indexOf(viewer.plotLayer.selectedPlot.properties.plotType) < 0) {
              viewer.handleEditPlot();
            } else {
              if (!(viewer.editPlot && viewer.editPlot.plotCode == options.id.plotCode)) {
                viewer.handleEditPlot();
                viewer.handlePickPlot(options.id);
              }
            }
          }
        } else {
          viewer.handleEditPlot();
        }
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
    }
  }, {
    "key" : "handleEditPlot",
    "value" : function() {
      this.clear();
      if (this.editPlot) {
        this.editPlot.openEditMode(false);
        this.editPlot = void 0;
        if (this.isEdited) {
          this.isEdited = false;
          this.isEditing = false;
        }
      }
    }
  }, {
    "key" : `handlePickPlot`,
    "value" : function(name) {
      this.editPlot = this.plotLayer.getByPlotCode(name.plotCode);
      if (this.editPlot) {
        this.isEditing = false;
        this.isEdited = false;
        this.editPlot.openEditMode(true);
        this.editPositions = this.editPlot.getPositions();
        this.clear();
        this.createEditVertex();
        this.registerEvents();
      }
    }
  }, {
    "key" : "registerEvents",
    "value" : function() {
      this.initLeftDownEventHandler();
      this.initMouseMoveEventHandler();
      this.initLeftUpEventHandler();
    }
  }, {
    "key" : "unRegisterEvents",
    "value" : function() {
      this.eventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOWN);
      this.eventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_UP);
      this.eventHandler.removeInputAction(Cesium.ScreenSpaceEventType.MOUSE_MOVE);
    }
  }, {
    "key" : `initLeftDownEventHandler`,
    "value" : function() {
      var obj = this;
      this.eventHandler.setInputAction(function(options) {
        var parseInt = hahaha;
        options = obj.viewer[parseInt(2758)].pick(options[parseInt(586)]);
        if (options && options.id && options.id[parseInt(1720)] && parseInt(2806) == options.id[parseInt(1720)]) {
          obj[parseInt(3088)] = true;
          obj[parseInt(2276)][parseInt(2758)][parseInt(2190)][parseInt(1218)] = false;
          obj[parseInt(2276)][parseInt(1633)] = false;
          obj.viewer[parseInt(2530)][parseInt(1998)][parseInt(737)] = "";
          document[parseInt(1494)][parseInt(1998)][parseInt(737)] = parseInt(367);
          obj[parseInt(1670)] = options.id;
          obj[parseInt(1670)][parseInt(2752)] = false;
        }
      }, Cesium.ScreenSpaceEventType.LEFT_DOWN);
    }
  }, {
    "key" : `initLeftUpEventHandler`,
    "value" : function() {
      var options = this;
      this.eventHandler.setInputAction(function(canCreateDiscussions) {
        var extname = hahaha;
        if (options[extname(3088)]) {
          options.viewer[extname(1633)] = true;
          document[extname(1494)][extname(1998)].cursor = "default";
          options[extname(2276)].scene[extname(2190)][extname(1218)] = true;
          options[extname(1670)][extname(2752)] = true;
          options.isEditing = false;
        }
      }, Cesium.ScreenSpaceEventType.LEFT_UP);
    }
  }, {
    "key" : "initMouseMoveEventHandler",
    "value" : function() {
      var primaryReplicas = this;
      this.eventHandler.setInputAction(function(boardManager) {
        var stringify = hahaha;
        boardManager = primaryReplicas[stringify(2276)][stringify(2758)].pickPosition(boardManager[stringify(2840)]);
        if (boardManager && primaryReplicas[stringify(3088)]) {
          primaryReplicas.editPositions[primaryReplicas[stringify(1670)].vertexIndex] = boardManager;
          primaryReplicas[stringify(2551)][stringify(2631)](primaryReplicas[stringify(1484)]);
          primaryReplicas[stringify(581)] = true;
        }
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
    }
  }, {
    "key" : `createEditVertex`,
    "value" : function() {
      var args = this;
      this.vertexEntities = [];
      this.editPlot.getPositions().forEach(function(canCreateDiscussions, strIndex) {
        var parseInt = hahaha;
        var artistTrack = args.viewer[parseInt(1319)][parseInt(3010)]({
          "position" : new Cesium.CallbackProperty(function(canCreateDiscussions) {
            var toInt = parseInt;
            return args[toInt(1484)][strIndex];
          }, false),
          "type" : "PlotEditVertex",
          "vertexIndex" : strIndex,
          "point" : {
            "color" : Cesium[parseInt(2292)][parseInt(3198)][parseInt(2265)](0.4),
            "pixelSize" : 10,
            "outlineColor" : Cesium[parseInt(2292)][parseInt(2537)][parseInt(2265)](0.4),
            "outlineWidth" : 3,
            "disableDepthTestDistance" : 2E4
          }
        });
        args[parseInt(1220)][parseInt(2008)](artistTrack);
      });
    }
  }, {
    "key" : `clearEditVertex`,
    "value" : function() {
      var same = this;
      if (this.vertexEntities) {
        this.vertexEntities.forEach(function(mmCoreSplitViewBlock) {
          var rel2Mstr = hahaha;
          same[rel2Mstr(2276)][rel2Mstr(1319)][rel2Mstr(508)](mmCoreSplitViewBlock);
        });
      }
      this.vertexEntities = [];
    }
  }]), Wizard);
  data = function validateSync(name, target) {
    call(this, validateSync);
    this.pointEdit = new Error(name, target);
    this.polygonEdit = new SyncRunner(name, target);
    this.polygonEdit.activate();
  };
  _inherits(KeyBoardHelper, meta);
  expect(KeyBoardHelper, [{
    "key" : `addPlot`,
    "value" : function(obj) {
      return obj = parse(this.viewer, obj.properties.plotType, obj), this.plots.push(obj), obj;
    }
  }, {
    "key" : `initEvent`,
    "value" : function() {
      var o = this;
      (new Cesium["ScreenSpaceEventHandler"](this.viewer.scene.canvas)).setInputAction(function(e) {
        var parseInt = hahaha;
        if (o[parseInt(455)]) {
          if ((e = o.viewer[parseInt(2758)][parseInt(1708)](e[parseInt(586)])) && e.id) {
            if (!(e.id && e.id[parseInt(1720)] && "HedronPlot" == e.id[parseInt(1720)])) {
              if (o[parseInt(1277)]) {
                o[parseInt(1277)][parseInt(1666)](false);
                o[parseInt(1277)] = void 0;
                o[parseInt(1346)][parseInt(2477)](void 0);
              }
            }
            if (!(o.selectedPlot && o[parseInt(1277)][parseInt(2931)][parseInt(2717)] == e.id.plotCode)) {
              if (e = o.getByPlotCode(e.id[parseInt(2717)])) {
                o[parseInt(1277)] = e;
                o[parseInt(1277)][parseInt(1666)](true);
                o[parseInt(1346)][parseInt(2477)](e);
              } else {
                if (o[parseInt(1277)]) {
                  o[parseInt(1277)].setSelected(false);
                  o.selectedPlot = void 0;
                }
                o.selectedPlotChanged[parseInt(2477)](void 0);
              }
            }
          } else {
            if (o[parseInt(1277)]) {
              o[parseInt(1277)].setSelected(false);
              o[parseInt(1277)] = void 0;
              o.selectedPlotChanged.raiseEvent(void 0);
            }
          }
        }
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
    }
  }, {
    "key" : `updateTargetPosition`,
    "value" : function(name) {
      var colData = this;
      this.plots.forEach(function(obj) {
        var parseInt = hahaha;
        if (obj[parseInt(691)](name)) {
          if (!colData[parseInt(1021)][obj[parseInt(2931)][parseInt(2717)]]) {
            colData[parseInt(1021)][obj[parseInt(2931)][parseInt(2717)]] = true;
            console[parseInt(1012)]("\u76ee\u6807\u8fdb\u5165\uff1a" + obj.properties[parseInt(2717)]);
            obj[parseInt(1666)](true);
            colData[parseInt(444)][parseInt(2477)](obj);
          }
        } else {
          if (colData[parseInt(1021)][obj[parseInt(2931)][parseInt(2717)]]) {
            colData[parseInt(1021)][obj[parseInt(2931)][parseInt(2717)]] = false;
            console[parseInt(1012)]("\u76ee\u6807\u79bb\u5f00\uff1a" + obj[parseInt(2931)][parseInt(2717)]);
            obj[parseInt(1666)](false);
            colData[parseInt(1281)].raiseEvent(obj);
          }
        }
      });
    }
  }]);
  forced = KeyBoardHelper;
  var GraphNodeType = {
    "POLYGON" : `polygon`,
    "WALL" : `wall`
  };
  tel = (expect(parseGeocodingResults, [{
    "key" : `generatePositions`,
    "value" : function() {
      var same = this;
      this.positions = [];
      var coordinates = void 0;
      switch(this.geometry.type) {
        case "LineString":
          coordinates = this.coordinates;
          break;
        case "Polygon":
          coordinates = this.coordinates[0];
      }
      coordinates.forEach(function(canCreateDiscussions) {
        var rel2Mstr = hahaha;
        same[rel2Mstr(1707)][rel2Mstr(2008)](Cesium[rel2Mstr(3131)][rel2Mstr(2770)](canCreateDiscussions[0], canCreateDiscussions[1], canCreateDiscussions[2]));
      });
    }
  }, {
    "key" : "setPositions",
    "value" : function(name) {
      switch(this.positions = name || [], this.coordinates = [], this.geometry.type) {
        case "LineString":
          this.setLineStringCoordinates();
          break;
        case "Polygon":
          this.setPolygonCoordinates();
      }
      if (this.updatePositionAction) {
        this.updatePositionAction();
      }
    }
  }, {
    "key" : `setLineStringCoordinates`,
    "value" : function() {
      var same = this;
      this.positions.forEach(function(pantry) {
        var rel2Mstr = hahaha;
        pantry = Cesium.Cartographic[rel2Mstr(2206)](pantry);
        pantry = [Cesium[rel2Mstr(2090)][rel2Mstr(1611)](pantry[rel2Mstr(2596)]), Cesium[rel2Mstr(2090)][rel2Mstr(1611)](pantry.latitude), pantry[rel2Mstr(1132)]];
        same[rel2Mstr(2656)][rel2Mstr(2008)](pantry);
      });
    }
  }, {
    "key" : `setPolygonCoordinates`,
    "value" : function() {
      var retinaResult = this;
      this.coordinates.push([]);
      this.positions.forEach(function(result) {
        var put_rows = hahaha;
        result = Cesium[put_rows(1543)][put_rows(2206)](result);
        result = [Cesium[put_rows(2090)].toDegrees(result[put_rows(2596)]), Cesium[put_rows(2090)][put_rows(1611)](result[put_rows(480)]), result[put_rows(1132)]];
        retinaResult.coordinates[0][put_rows(2008)](result);
      });
    }
  }, {
    "key" : `getPositions`,
    "value" : function() {
      var primaryReplicas = [];
      var coordinates = void 0;
      switch(this.geometry.type) {
        case "LineString":
          coordinates = this.coordinates;
          break;
        case "Polygon":
          coordinates = this.coordinates[0];
      }
      return coordinates.forEach(function(canCreateDiscussions) {
        var stringify = hahaha;
        primaryReplicas[stringify(2008)](Cesium[stringify(3131)][stringify(2770)](canCreateDiscussions[0], canCreateDiscussions[1], canCreateDiscussions[2]));
      }), primaryReplicas;
    }
  }, {
    "key" : `getPositionCount`,
    "value" : function() {
      return this.positions.length;
    }
  }, {
    "key" : `setSelected`,
    "value" : function(name) {
    }
  }, {
    "key" : `openEditMode`,
    "value" : function(name) {
    }
  }, {
    "key" : "remove",
    "value" : function() {
    }
  }]), parseGeocodingResults);
  var WrappedRange = (_inherits(FastFunction, tel), expect(FastFunction, [{
    "key" : `createEntity`,
    "value" : function() {
      this.polygonEntity = this.viewer.entities.add({
        "plotType" : this.properties.plotBase,
        "plotCode" : this.properties.plotCode,
        "polygon" : {
          "hierarchy" : this.getPositions(),
          "material" : new Cesium["ImageMaterialProperty"]({
            "image" : renderImage(this.style),
            "transparent" : true,
            "color" : Cesium.Color.WHITE
          }),
          "stRotation" : Cesium.Math.toRadians(this.style.stRotation),
          "classificationType" : Cesium.ClassificationType.BOTH
        }
      });
    }
  }, {
    "key" : `getStyle`,
    "value" : function() {
      return this.style;
    }
  }, {
    "key" : "updateStyle",
    "value" : function() {
      var entity = this;
      this.polygonEntity.polygon.material.image = renderImage(this.style);
      this.polygonEntity.polygon.stRotation = new Cesium["CallbackProperty"](function(canCreateDiscussions) {
        var put_rows = hahaha;
        return Cesium.Math[put_rows(1544)](entity.style.stRotation);
      }, false);
    }
  }, {
    "key" : `openEditMode`,
    "value" : function(name) {
      var primaryReplicas = this;
      this.polygonEntity.polygon.hierarchy = name ? new Cesium["CallbackProperty"](function(canCreateDiscussions) {
        var stringify = hahaha;
        return new Cesium.PolygonHierarchy(primaryReplicas[stringify(1951)]());
      }, false) : this.getPositions();
    }
  }, {
    "key" : "setSelected",
    "value" : function(name) {
      var primaryReplicas = this;
      this.polygonEntity.polyline = name ? {
        "positions" : new Cesium.CallbackProperty(function(canCreateDiscussions) {
          var stringify = hahaha;
          return primaryReplicas[stringify(1951)]();
        }, false),
        "width" : 1,
        "material" : Cesium.Color.AQUA,
        "depthFailMaterial" : Cesium.Color.AQUA
      } : {
        "positions" : [],
        "width" : 0,
        "material" : Cesium.Color.AQUA,
        "depthFailMaterial" : Cesium.Color.AQUA
      };
    }
  }, {
    "key" : `getDefaultStyle`,
    "value" : function() {
      return {
        "text" : "\u591a\u8fb9\u5f62\u6587\u5b57\u8d34\u56fe",
        "fontSize" : 84,
        "color" : "#FFFF00",
        "stRotation" : 0
      };
    }
  }, {
    "key" : "toGeoJson",
    "value" : function() {
      return {
        "type" : "Feature",
        "properties" : this.properties,
        "geometry" : {
          "type" : "Polygon",
          "coordinates" : this.coordinates
        }
      };
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.viewer.entities.remove(this.polygonEntity);
    }
  }]), FastFunction);
  var Vector = (_inherits(Path, tel), expect(Path, [{
    "key" : `createEntity`,
    "value" : function() {
      this.initHeights();
      this.initWall();
    }
  }, {
    "key" : "getStyle",
    "value" : function() {
      return this.style;
    }
  }, {
    "key" : `updateStyle`,
    "value" : function() {
      this.initHeights();
      this.wallEntity.wall.material.image = renderImage(this.style);
    }
  }, {
    "key" : `updatePositionAction`,
    "value" : function() {
      this.initHeights();
    }
  }, {
    "key" : `initHeights`,
    "value" : function() {
      this.style.baseHeight = geocode(this.positions, this.style.baseHeight);
      if (this.style.baseHeight < 0) {
        this.style.baseHeight = 0;
      }
      var crossfilterable_layers = (new Array(this.positions.length)).fill(this.style.baseHeight);
      var newNodeLists = [];
      var layer_i = 0;
      for (; layer_i < crossfilterable_layers.length; layer_i++) {
        newNodeLists.push(crossfilterable_layers[layer_i] + this.style.wallHeight);
      }
      this.minimumHeights = crossfilterable_layers;
      this.maximumHeights = newNodeLists;
    }
  }, {
    "key" : `initWall`,
    "value" : function() {
      var rpm_traffic = this;
      this.wallEntity = this.viewer.entities.add({
        "plotType" : this.properties.plotBase,
        "plotCode" : this.properties.plotCode,
        "wall" : {
          "positions" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
            var now = hahaha;
            return rpm_traffic[now(1707)];
          }, false),
          "minimumHeights" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
            var now = hahaha;
            return rpm_traffic[now(3120)];
          }, false),
          "maximumHeights" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
            var now = hahaha;
            return rpm_traffic[now(441)];
          }, false),
          "material" : new Cesium["ImageMaterialProperty"]({
            "image" : renderImage(this.style),
            "transparent" : true,
            "color" : Cesium.Color.WHITE
          }),
          "outline" : false,
          "outlineWidth" : 10,
          "outlineColor" : Cesium.Color.AQUA
        }
      });
    }
  }, {
    "key" : `setSelected`,
    "value" : function(value) {
      this.wallEntity.wall.outline = value;
    }
  }, {
    "key" : `getDefaultStyle`,
    "value" : function() {
      return {
        "wallHeight" : 10,
        "color" : "#FFFF00",
        "fontSize" : 84,
        "text" : "\u7acb\u4f53\u5899\u6587\u5b57\u8d34\u56fe"
      };
    }
  }, {
    "key" : `toGeoJson`,
    "value" : function() {
      return {
        "type" : "Feature",
        "properties" : this.properties,
        "geometry" : {
          "type" : "LineString",
          "coordinates" : this.coordinates
        }
      };
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.viewer.entities.remove(this.wallEntity);
    }
  }]), Path);
  var normalize = function(range, text, position) {
    switch(text) {
      case GraphNodeType.POLYGON:
        return new WrappedRange(range, position);
      case GraphNodeType.WALL:
        return new Vector(range, position);
    }
  };
  ID = (expect(Draggable, [{
    "key" : `activate`,
    "value" : function(name) {
      this.deactivate();
      this.clear();
      this.plotType = name;
      this.positions = [];
      this.plotDrawTip = new Map(this.viewer);
      this.MousePoint = new Date(this.viewer);
      this.registerEvents();
      this.viewer.enableCursorStyle = false;
      this.viewer._element.style.cursor = "default";
      this.initTip();
    }
  }, {
    "key" : `initTip`,
    "value" : function() {
      switch(this.plotType) {
        case GraphNodeType.WALL:
          this.plotDrawTip.setContent(["\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a\u7acb\u4f53\u5899\u6587\u5b57\u8d34\u56fe\uff0c\u9700\u89812\u4e2a\u70b9", "\u6309\u4e0b\u9f20\u6807\u5de6\u952e\u786e\u5b9a\u7b2c1\u4e2a\u70b9", "\u6309\u4e0b\u9f20\u6807\u53f3\u952e\u53d6\u6d88\u7ed8\u5236"]);
          break;
        case GraphNodeType.POLYGON:
          this.plotDrawTip.setContent(["\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a\u8d34\u5730\u591a\u8fb9\u5f62\u6587\u5b57\u8d34\u56fe\uff0c\u81f3\u5c11\u9700\u89813\u4e2a\u70b9", "\u6309\u4e0b\u9f20\u6807\u5de6\u952e\u786e\u5b9a\u7b2c1\u4e2a\u70b9", "\u6309\u4e0b\u9f20\u6807\u53f3\u952e\u53d6\u6d88\u7ed8\u5236"]);
      }
    }
  }, {
    "key" : `deactivate`,
    "value" : function() {
      this.unRegisterEvents();
      this.plotType = void 0;
      this.viewer._element.style.cursor = "pointer";
      this.viewer.enableCursorStyle = true;
      if (this.plotDrawTip) {
        this.plotDrawTip.remove();
        this.MousePoint.remove();
        this.plotDrawTip = void 0;
        this.MousePoint = void 0;
      }
    }
  }, {
    "key" : "clear",
    "value" : function() {
      if (this.plot) {
        this.plot.remove();
        this.plot = void 0;
      }
    }
  }, {
    "key" : "generatePlot",
    "value" : function(target) {
      var targetRecip = createIntervalElements();
      target = this.generateGeoFeature(targetRecip, target);
      this.plot = normalize(this.viewer, this.plotType, target);
      this.plot.openEditMode(true);
    }
  }, {
    "key" : `generateGeoFeature`,
    "value" : function(type, obj) {
      var geomType = void 0;
      var data = void 0;
      switch(this.plotType) {
        case GraphNodeType.WALL:
          geomType = "LineString";
          data = this.getLineStringCoordinates(obj);
          break;
        case GraphNodeType.POLYGON:
          geomType = "Polygon";
          data = this.getPolygonCoordinates(obj);
      }
      return {
        "type" : "Feature",
        "properties" : {
          "plotCode" : type,
          "style" : void 0
        },
        "geometry" : {
          "type" : geomType,
          "coordinates" : data
        }
      };
    }
  }, {
    "key" : `getLineStringCoordinates`,
    "value" : function(name) {
      var primaryReplicas = [];
      return name.forEach(function(data) {
        var stringify = hahaha;
        data = Cesium[stringify(1543)][stringify(2206)](data);
        data = [Cesium[stringify(2090)][stringify(1611)](data[stringify(2596)]), Cesium[stringify(2090)][stringify(1611)](data[stringify(480)]), data.height];
        primaryReplicas[stringify(2008)](data);
      }), primaryReplicas;
    }
  }, {
    "key" : `getPolygonCoordinates`,
    "value" : function(name) {
      var allAttachPoints = [[]];
      return name.forEach(function(position) {
        position = Cesium.Cartographic.fromCartesian(position);
        position = [Cesium.Math.toDegrees(position.longitude), Cesium.Math.toDegrees(position.latitude), position.height];
        allAttachPoints[0].push(position);
      }), allAttachPoints;
    }
  }, {
    "key" : `initEvents`,
    "value" : function() {
      this.handler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas);
      this.PlotDrawStartEvent = new Cesium.Event;
      this.PlotDrawEndEvent = new Cesium.Event;
    }
  }, {
    "key" : `registerEvents`,
    "value" : function() {
      this.leftClickEvent();
      this.rightClickEvent();
      this.mouseMoveEvent();
    }
  }, {
    "key" : `leftClickEvent`,
    "value" : function() {
      var data = this;
      this.handler.setInputAction(function(specialChars) {
        var String = hahaha;
        data[String(2276)][String(2530)][String(1998)][String(737)] = String(1654);
        specialChars = data[String(2276)].scene[String(1238)](specialChars[String(586)]);
        if (specialChars) {
          data.positions[String(2008)](specialChars);
          if (1 == data[String(1707)].length) {
            data.generatePlot(data[String(1707)]);
          } else {
            data[String(1298)][String(2631)](data[String(1707)]);
          }
          data.setTipContent();
          if (data[String(1298)][String(2862)] == data[String(1707)].length) {
            data.drawEnd();
            data[String(1983)]();
          }
        }
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
    }
  }, {
    "key" : "setTipContent",
    "value" : function() {
      switch(this.plotType) {
        case GraphNodeType.WALL:
          this.plotDrawTip.setContent(["\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a\u7acb\u4f53\u5899\u6587\u5b57\u8d34\u56fe\uff0c\u9700\u89812\u4e2a\u70b9\u3002", "\u5df2\u6709" + this.positions.length + "\u4e2a\u70b9\uff0c\u6309\u4e0b\u9f20\u6807\u5de6\u952e\u786e\u5b9a\u7b2c" + (this.positions.length + 1) + "\u4e2a\u70b9", this.positions.length < 2 ? "\u6309\u4e0b\u9f20\u6807\u53f3\u952e\u53d6\u6d88\u7ed8\u5236" : "\u6309\u4e0b\u9f20\u6807\u53f3\u952e\u7ed3\u675f\u7ed8\u5236"]);
          break;
        case GraphNodeType.POLYGON:
          this.plotDrawTip.setContent(["\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a\u8d34\u5730\u591a\u8fb9\u5f62\u6587\u5b57\u8d34\u56fe\uff0c\u6700\u5c11\u9700\u89813\u4e2a\u70b9\u3002", "\u5df2\u6709" + this.positions.length + "\u4e2a\u70b9\uff0c\u6309\u4e0b\u9f20\u6807\u5de6\u952e\u786e\u5b9a\u7b2c" + (this.positions.length + 1) + "\u4e2a\u70b9", this.positions.length < 3 ? "\u6309\u4e0b\u9f20\u6807\u53f3\u952e\u53d6\u6d88\u7ed8\u5236" : "\u6309\u4e0b\u9f20\u6807\u53f3\u952e\u7ed3\u675f\u7ed8\u5236"]);
      }
    }
  }, {
    "key" : `mouseMoveEvent`,
    "value" : function() {
      var obj = this;
      this.handler.setInputAction(function(bShowArray) {
        var parseInt = hahaha;
        obj[parseInt(2276)]._element[parseInt(1998)][parseInt(737)] = "default";
        bShowArray = obj[parseInt(2276)].scene[parseInt(1238)](bShowArray[parseInt(2840)]);
        if (bShowArray) {
          obj.plotDrawTip[parseInt(3164)](bShowArray);
          obj[parseInt(1455)][parseInt(3164)](bShowArray);
          if (obj[parseInt(1298)]) {
            bShowArray = obj[parseInt(1707)][parseInt(439)]([bShowArray]);
            obj.plot[parseInt(2631)](bShowArray);
          }
        }
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
    }
  }, {
    "key" : "rightClickEvent",
    "value" : function() {
      var obj = this;
      this.handler.setInputAction(function(canCreateDiscussions) {
        var parseInt = hahaha;
        if (0 != obj[parseInt(1707)][parseInt(2189)]) {
          if (obj.plot[parseInt(2862)]) {
            if (obj[parseInt(1707)].length == obj[parseInt(1298)].fixPositionCount) {
              obj[parseInt(1298)][parseInt(2631)](obj.positions);
              obj[parseInt(2788)]();
              obj[parseInt(1983)]();
            } else {
              obj[parseInt(1983)]();
              obj[parseInt(2822)]();
            }
          } else {
            if (obj[parseInt(1707)][parseInt(2189)] >= obj[parseInt(1298)][parseInt(3107)]) {
              obj.plot[parseInt(2631)](obj[parseInt(1707)]);
              obj[parseInt(2788)]();
              obj[parseInt(1983)]();
            } else {
              obj[parseInt(1983)]();
              obj[parseInt(2822)]();
            }
          }
        } else {
          obj[parseInt(1983)]();
        }
      }, Cesium.ScreenSpaceEventType.RIGHT_CLICK);
    }
  }, {
    "key" : `unRegisterEvents`,
    "value" : function() {
      this.handler.removeInputAction(Cesium.ScreenSpaceEventType.RIGHT_CLICK);
      this.handler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_CLICK);
      this.handler.removeInputAction(Cesium.ScreenSpaceEventType.MOUSE_MOVE);
      this.handler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);
    }
  }, {
    "key" : `drawEnd`,
    "value" : function() {
      this.plot.openEditMode(false);
      this.PlotDrawEndEvent.raiseEvent(this.plot, this.plotType);
    }
  }]), Draggable);
  expect(desc, [{
    "key" : `initEventHandler`,
    "value" : function() {
      this.eventHandler = new Cesium["ScreenSpaceEventHandler"](this.viewer.scene.canvas);
    }
  }, {
    "key" : `activate`,
    "value" : function() {
      this.deactivate();
      this.initLeftClickEventHandler();
    }
  }, {
    "key" : "deactivate",
    "value" : function() {
      this.eventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_CLICK);
      this.unRegisterEvents();
      this.clear();
    }
  }, {
    "key" : "clear",
    "value" : function() {
      if (this.editTextMapPlot) {
        this.editTextMapPlot.openEditMode(true);
      }
      this.clearEditVertex();
      this.clearMidVertex();
    }
  }, {
    "key" : `initLeftClickEventHandler`,
    "value" : function() {
      var pools = this;
      this.eventHandler.setInputAction(function(pool) {
        var put_rows = hahaha;
        pool = pools[put_rows(2276)][put_rows(2758)][put_rows(1708)](pool[put_rows(586)]);
        if (pool) {
          if (pool.id && put_rows(1887) == pool.id.plotType) {
            if (!(pools[put_rows(3056)] && pools[put_rows(3056)].plotCode == pool.id[put_rows(2717)])) {
              pools[put_rows(2330)]();
              pools[put_rows(2488)](pool.id);
            }
          } else {
            pools[put_rows(2822)]();
          }
        } else {
          pools[put_rows(2330)]();
        }
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
    }
  }, {
    "key" : `handleEditTextMapPlot`,
    "value" : function() {
      this.clear();
      this.editTextMapPlot = void 0;
      if (this.isEdited) {
        this.isEdited = false;
        this.isEditing = false;
      }
    }
  }, {
    "key" : `handlePickTextMapPlot`,
    "value" : function(name) {
      this.editTextMapPlot = this.textMapPlotLayer.getByPlotCode(name.plotCode);
      if (this.editTextMapPlot) {
        this.isEditing = false;
        this.isEdited = false;
        this.editTextMapPlot.openEditMode(true);
        this.editPositions = this.editTextMapPlot.getPositions();
        this.EditMoveCenterPositoin = this.getTextMapPlotCenterPosition();
        this.clear();
        this.createEditVertex();
        this.createMidVertex();
        this.registerEvents();
      }
    }
  }, {
    "key" : `registerEvents`,
    "value" : function() {
      this.initLeftDownEventHandler();
      this.initMouseMoveEventHandler();
      this.initLeftUpEventHandler();
    }
  }, {
    "key" : `unRegisterEvents`,
    "value" : function() {
      this.eventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOWN);
      this.eventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_UP);
      this.eventHandler.removeInputAction(Cesium.ScreenSpaceEventType.MOUSE_MOVE);
    }
  }, {
    "key" : `initLeftDownEventHandler`,
    "value" : function() {
      var obj = this;
      this.eventHandler.setInputAction(function(options) {
        var parseInt = hahaha;
        options = obj[parseInt(2276)][parseInt(2758)][parseInt(1708)](options[parseInt(586)]);
        if (options && options.id && options.id[parseInt(1720)]) {
          if (parseInt(1085) == options.id.type || parseInt(1866) == options.id[parseInt(1720)]) {
            obj[parseInt(3088)] = true;
            obj[parseInt(2276)][parseInt(2758)].screenSpaceCameraController[parseInt(1218)] = false;
            obj.viewer[parseInt(1633)] = false;
            obj[parseInt(2276)][parseInt(2530)].style[parseInt(737)] = "";
            document.body.style[parseInt(737)] = "move";
            obj[parseInt(1670)] = options.id;
            obj.editVertext.show = false;
            obj.clearMidVertex();
          } else {
            if (parseInt(1851) == options.id[parseInt(1720)]) {
              obj.editPositions.splice(options.id[parseInt(1593)], 0, options.id.position[parseInt(2041)]);
              obj[parseInt(3056)][parseInt(2631)](obj[parseInt(1484)]);
              obj[parseInt(2822)]();
              obj.createEditVertex();
              obj.createMidVertex();
              obj[parseInt(581)] = true;
            }
          }
        }
      }, Cesium.ScreenSpaceEventType.LEFT_DOWN);
    }
  }, {
    "key" : "initLeftUpEventHandler",
    "value" : function() {
      var element = this;
      this.eventHandler.setInputAction(function(canCreateDiscussions) {
        var prefixed = hahaha;
        if (element[prefixed(3088)]) {
          element.viewer[prefixed(1633)] = true;
          document[prefixed(1494)].style[prefixed(737)] = prefixed(1654);
          element[prefixed(2276)][prefixed(2758)][prefixed(2190)].enableRotate = true;
          element[prefixed(1670)][prefixed(2752)] = true;
          element.isEditing = false;
          element[prefixed(1521)]();
          element.createMidVertex();
          if (prefixed(2442) == element[prefixed(3056)][prefixed(3090)]) {
            element[prefixed(3056)][prefixed(1013)]();
          }
        }
      }, Cesium.ScreenSpaceEventType.LEFT_UP);
    }
  }, {
    "key" : "initMouseMoveEventHandler",
    "value" : function() {
      var map = this;
      this.eventHandler.setInputAction(function(data) {
        var parseInt = hahaha;
        var val = map[parseInt(2276)][parseInt(2758)][parseInt(1238)](data[parseInt(2840)]);
        if (val && map[parseInt(3088)]) {
          if (parseInt(1866) == map[parseInt(1670)][parseInt(1720)]) {
            data = map.EditMoveCenterPositoin;
            if (!data) {
              return;
            }
            map[parseInt(2985)](data, val);
          } else {
            map[parseInt(1484)][map[parseInt(1670)].vertexIndex] = val;
            map[parseInt(3056)][parseInt(2631)](map[parseInt(1484)]);
          }
          map[parseInt(581)] = true;
          map[parseInt(1054)] = map.getTextMapPlotCenterPosition();
        }
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
    }
  }, {
    "key" : `getTextMapPlotCenterPosition`,
    "value" : function() {
      var line = [];
      var z = 0;
      this.editPositions.forEach(function(x) {
        var put_rows = hahaha;
        x = require(x);
        line[put_rows(2008)]([x.x, x.y]);
        if (z < x.z) {
          z = x.z;
        }
      });
      var tmp = turf.lineString(line);
      tmp = turf.bbox(tmp);
      tmp = turf.bboxPolygon(tmp);
      tmp = turf.center(tmp).geometry.coordinates;
      return Cesium.Cartesian3.fromDegrees(tmp[0], tmp[1], z);
    }
  }, {
    "key" : `moveEntityByOffset`,
    "value" : function(target, source) {
      target = require(target);
      source = require(source);
      var mergeAxisLength = source.x - target.x;
      var SHIP_SPEED = source.y - target.y;
      var z = source.z - target.z;
      var movmethod = this.editTextMapPlot.properties.plotType;
      var json = void 0;
      var i = 0;
      for (; i < this.editPositions.length; i++) {
        (json = require(this.editPositions[i])).x += mergeAxisLength;
        json.y += SHIP_SPEED;
        if (!(movmethod != GraphNodeType.CIRCLE && movmethod != GraphNodeType.RECTANGLE)) {
          json.z += z;
        }
        this.editPositions[i] = Cesium.Cartesian3.fromDegrees(json.x, json.y, json.z);
      }
      this.editTextMapPlot.setPositions(this.editPositions);
    }
  }, {
    "key" : `createEditVertex`,
    "value" : function() {
      var o = this;
      this.vertexEntities = [];
      this.editTextMapPlot.getPositions().forEach(function(canCreateDiscussions, idx) {
        var camelize = hahaha;
        var artistTrack = o.viewer[camelize(1319)][camelize(3010)]({
          "position" : new (Cesium[camelize(1679)])(function(canCreateDiscussions) {
            return o.editPositions[idx];
          }, false),
          "type" : camelize(1085),
          "vertexIndex" : idx,
          "point" : {
            "color" : Cesium[camelize(2292)].DARKBLUE.withAlpha(0.4),
            "pixelSize" : 10,
            "outlineColor" : Cesium.Color.YELLOW[camelize(2265)](0.4),
            "outlineWidth" : 3,
            "disableDepthTestDistance" : 2E3
          }
        });
        o[camelize(1220)][camelize(2008)](artistTrack);
      });
      if (1 != this.editPositions.length) {
        this.createEditMoveCenterEntity();
      }
    }
  }, {
    "key" : `createEditMoveCenterEntity`,
    "value" : function() {
      var primaryReplicas = this;
      this.EditMoveCenterEntity = this.viewer.entities.add({
        "position" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
          var stringify = hahaha;
          return primaryReplicas[stringify(1054)];
        }, false),
        "type" : "TextMapPlotEditMove",
        "point" : {
          "color" : Cesium.Color.RED.withAlpha(0.4),
          "pixelSize" : 10,
          "outlineColor" : Cesium.Color.WHITE.withAlpha(0.3),
          "outlineWidth" : 3,
          "disableDepthTestDistance" : 2E3
        }
      });
    }
  }, {
    "key" : `clearEditVertex`,
    "value" : function() {
      var same = this;
      if (this.vertexEntities) {
        this.vertexEntities.forEach(function(mmCoreSplitViewBlock) {
          var rel2Mstr = hahaha;
          same[rel2Mstr(2276)][rel2Mstr(1319)][rel2Mstr(508)](mmCoreSplitViewBlock);
        });
      }
      this.vertexEntities = [];
      this.viewer.entities.remove(this.EditMoveCenterEntity);
    }
  }, {
    "key" : "createMidVertex",
    "value" : function() {
      if (this.editTextMapPlot.properties.plotType != GraphNodeType.WALL) {
        this.midVertexEntities = [];
        var layer_i = 0;
        for (; layer_i < this.editPositions.length; layer_i++) {
          var gridPosition = geodeticToGeocentric(this.editPositions[layer_i], this.editPositions[layer_i + 1]);
          gridPosition = this.viewer.entities.add({
            "position" : gridPosition,
            "type" : "TextMapPlotEditMidVertex",
            "vertexIndex" : layer_i + 1,
            "point" : {
              "color" : Cesium.Color.LIMEGREEN.withAlpha(0.4),
              "pixelSize" : 10,
              "outlineColor" : Cesium.Color.YELLOW.withAlpha(0.4),
              "outlineWidth" : 3,
              "disableDepthTestDistance" : 2E3
            }
          });
          this.midVertexEntities.push(gridPosition);
        }
      }
    }
  }, {
    "key" : `clearMidVertex`,
    "value" : function() {
      var same = this;
      if (this.midVertexEntities) {
        this.midVertexEntities.forEach(function(mmCoreSplitViewBlock) {
          var rel2Mstr = hahaha;
          same[rel2Mstr(2276)][rel2Mstr(1319)][rel2Mstr(508)](mmCoreSplitViewBlock);
        });
      }
      this.midVertexEntities = [];
    }
  }]);
  descriptor = desc;
  _inherits(SlackData, meta);
  expect(SlackData, [{
    "key" : `addPlot`,
    "value" : function(value) {
      return value = normalize(this.viewer, value.properties.plotType, value), this.plots.push(value), value;
    }
  }, {
    "key" : `flyToByPlotCode`,
    "value" : function(name) {
      var e = this.getByPlotCode(name);
      if (e) {
        switch(e.properties.plotType) {
          case GraphNodeType.WALL:
            this.viewer.flyTo(e.wallEntity);
            break;
          case GraphNodeType.POLYGON:
            this.viewer.flyTo(e.polygonEntity);
        }
        this.setSelectedPlotByCode(name);
      }
    }
  }, {
    "key" : `initEvent`,
    "value" : function() {
      var obj = this;
      (new Cesium["ScreenSpaceEventHandler"](this.viewer.scene.canvas)).setInputAction(function(e) {
        var parseInt = hahaha;
        if (obj[parseInt(455)]) {
          if ((e = obj[parseInt(2276)][parseInt(2758)][parseInt(1708)](e[parseInt(586)])) && e.id) {
            if (!(e.id && e.id[parseInt(1720)] && parseInt(1887) == e.id[parseInt(1720)])) {
              if (obj[parseInt(1277)]) {
                obj[parseInt(1277)][parseInt(1666)](false);
                obj[parseInt(1277)] = void 0;
                obj[parseInt(1346)][parseInt(2477)](void 0);
              }
            }
            if (!(obj[parseInt(1277)] && obj.selectedPlot[parseInt(2931)][parseInt(2717)] == e.id.plotCode)) {
              if (e = obj[parseInt(2426)](e.id.plotCode)) {
                obj.clearSelectedPlot();
                obj[parseInt(1277)] = e;
                obj.selectedPlot[parseInt(1666)](true);
                obj[parseInt(1346)][parseInt(2477)](e);
              } else {
                if (obj.selectedPlot) {
                  obj[parseInt(1277)][parseInt(1666)](false);
                  obj[parseInt(1277)] = void 0;
                }
                obj[parseInt(1346)][parseInt(2477)](void 0);
              }
            }
          } else {
            if (obj[parseInt(1277)]) {
              obj.selectedPlot.setSelected(false);
              obj.selectedPlot = void 0;
              obj[parseInt(1346)][parseInt(2477)](void 0);
            }
          }
        }
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
    }
  }, {
    "key" : `setSelectedPlotByCode`,
    "value" : function(type) {
      this.clearSelectedPlot();
      type = this.getByPlotCode(type);
      if (type) {
        this.selectedPlot = type;
        this.selectedPlot.setSelected(true);
        this.selectedPlotChanged.raiseEvent(type);
      }
    }
  }, {
    "key" : `clearSelectedPlot`,
    "value" : function() {
      if (this.selectedPlot) {
        this.selectedPlot.setSelected(false);
        this.selectedPlot = void 0;
      }
    }
  }]);
  view = SlackData;
  var cur = {
    "MARKER" : `marker`,
    "TEXT" : `text`,
    "POLYLINE" : "polyline",
    "POLYGON" : `polygon`,
    "CIRCLE" : `circle`,
    "RECTANGLE" : `rectangle`,
    "DYNAMICFENCE" : `dynamicfence`,
    "NORMALFENCE" : "normalfence",
    "CORRIDOR" : `corridor`,
    "POLYLINEVOLUME" : `polylinevolume`
  };
  state = (expect(dragOver, [{
    "key" : `generatePositions`,
    "value" : function() {
      var same = this;
      this.positions = [];
      var coordinates = void 0;
      switch(this.geometry.type) {
        case "Point":
          coordinates = [this.coordinates];
          break;
        case "LineString":
          coordinates = this.coordinates;
          break;
        case "Polygon":
          coordinates = this.coordinates[0];
      }
      coordinates.forEach(function(canCreateDiscussions) {
        var rel2Mstr = hahaha;
        same[rel2Mstr(1707)][rel2Mstr(2008)](Cesium[rel2Mstr(3131)][rel2Mstr(2770)](canCreateDiscussions[0], canCreateDiscussions[1], canCreateDiscussions[2]));
      });
    }
  }, {
    "key" : "setPositions",
    "value" : function(name) {
      switch(this.positions = name || [], this.coordinates = [], this.geometry.type) {
        case "Point":
          this.setPointCoordinates();
          break;
        case "LineString":
          this.setLineStringCoordinates();
          break;
        case "Polygon":
          this.setPolygonCoordinates();
      }
      if (this.updatePositionAction) {
        this.updatePositionAction();
      }
    }
  }, {
    "key" : `setPointCoordinates`,
    "value" : function() {
      var cart = Cesium.Cartographic.fromCartesian(this.positions[0]);
      this.coordinates = [Cesium.Math.toDegrees(cart.longitude), Cesium.Math.toDegrees(cart.latitude), cart.height];
    }
  }, {
    "key" : `setLineStringCoordinates`,
    "value" : function() {
      var lasso = this;
      this.positions.forEach(function(position) {
        position = Cesium.Cartographic.fromCartesian(position);
        position = [Cesium.Math.toDegrees(position.longitude), Cesium.Math.toDegrees(position.latitude), position.height];
        lasso.coordinates.push(position);
      });
    }
  }, {
    "key" : `setPolygonCoordinates`,
    "value" : function() {
      var retinaResult = this;
      this.coordinates.push([]);
      this.positions.forEach(function(pantry) {
        var put_rows = hahaha;
        pantry = Cesium[put_rows(1543)][put_rows(2206)](pantry);
        pantry = [Cesium[put_rows(2090)][put_rows(1611)](pantry.longitude), Cesium[put_rows(2090)][put_rows(1611)](pantry.latitude), pantry[put_rows(1132)]];
        retinaResult.coordinates[0].push(pantry);
      });
    }
  }, {
    "key" : `getPositions`,
    "value" : function() {
      return this.positions.slice(0);
    }
  }, {
    "key" : `getPositionCount`,
    "value" : function() {
      return this.positions.length;
    }
  }, {
    "key" : `setSelected`,
    "value" : function(name) {
    }
  }, {
    "key" : `openEditMode`,
    "value" : function(name) {
    }
  }, {
    "key" : `remove`,
    "value" : function() {
    }
  }]), dragOver);
  var MockAdUnit = (_inherits(ReactTooltip, state), expect(ReactTooltip, [{
    "key" : `createEntity`,
    "value" : function() {
      this.markerEntity = this.viewer.entities.add({
        "position" : this.positions[0],
        "plotType" : "GeoPlot",
        "plotCode" : this.properties.plotCode,
        "billboard" : {
          "image" : this.style.img,
          "scaleByDistance" : new Cesium["NearFarScalar"](1300, 0.4, 12E3, 0.1),
          "distanceDisplayCondition" : new Cesium["DistanceDisplayCondition"](0, 1E4),
          "verticalOrigin" : Cesium.VerticalOrigin.BOTTOM,
          "disableDepthTestDistance" : 500
        },
        "point" : {
          "color" : Cesium.Color.DARKBLUE.withAlpha(0.4),
          "pixelSize" : 0,
          "outlineColor" : Cesium.Color.YELLOW.withAlpha(0.4),
          "outlineWidth" : 0,
          "scaleByDistance" : new Cesium["NearFarScalar"](1E3, 1, 4200, 0.4),
          "disableDepthTestDistance" : 500
        }
      });
    }
  }, {
    "key" : "setSelected",
    "value" : function(name) {
    }
  }, {
    "key" : `getDefaultStyle`,
    "value" : function() {
      return {
        "img" : "../../static/images/poi/sp.png"
      };
    }
  }, {
    "key" : "openEditMode",
    "value" : function(name) {
      var primaryReplicas = this;
      this.markerEntity.position = name ? new Cesium.CallbackProperty(function(canCreateDiscussions) {
        var stringify = hahaha;
        return primaryReplicas[stringify(1707)][0];
      }, false) : this.positions[0];
    }
  }, {
    "key" : `toGeoJson`,
    "value" : function() {
      return {
        "type" : "Feature",
        "properties" : this.properties,
        "geometry" : {
          "type" : "Point",
          "coordinates" : this.coordinates
        }
      };
    }
  }, {
    "key" : "remove",
    "value" : function() {
      this.viewer.entities.remove(this.markerEntity);
    }
  }]), ReactTooltip);
  var Texture = (_inherits(Cell, state), expect(Cell, [{
    "key" : `createEntity`,
    "value" : function() {
      this.textEntity = this.viewer.entities.add({
        "position" : this.positions[0],
        "plotType" : "GeoPlot",
        "plotCode" : this.properties.plotCode,
        "label" : {
          "text" : this.properties.attr.text,
          "fillColor" : Cesium.Color.fromCssColorString(this.style.fillColor),
          "scale" : 0.5,
          "font" : "normal 40px MicroSoft YaHei",
          "distanceDisplayCondition" : new Cesium["DistanceDisplayCondition"](0, 5E3),
          "scaleByDistance" : new Cesium.NearFarScalar(500, 1, 1500, 0.4),
          "verticalOrigin" : Cesium.VerticalOrigin.BOTTOM,
          "style" : Cesium.LabelStyle.FILL_AND_OUTLINE,
          "pixelOffset" : new Cesium["Cartesian2"](0, -10),
          "outlineWidth" : 9,
          "disableDepthTestDistance" : 500,
          "outlineColor" : Cesium.Color.fromCssColorString(this.style.outlineColor)
        },
        "point" : {
          "color" : Cesium.Color.DARKBLUE.withAlpha(0.4),
          "pixelSize" : 0,
          "outlineColor" : Cesium.Color.YELLOW.withAlpha(0.4),
          "outlineWidth" : 0,
          "scaleByDistance" : new Cesium["NearFarScalar"](1E3, 1, 4200, 0.4),
          "disableDepthTestDistance" : 500
        }
      });
    }
  }, {
    "key" : "setSelected",
    "value" : function(name) {
    }
  }, {
    "key" : "updateText",
    "value" : function() {
      this.textEntity.label.text = this.properties.attr.text;
    }
  }, {
    "key" : `getDefaultStyle`,
    "value" : function() {
      return {
        "fillColor" : "#FFFF00",
        "outlineColor" : "#FF0000"
      };
    }
  }, {
    "key" : `openEditMode`,
    "value" : function(name) {
      var primaryReplicas = this;
      this.textEntity.position = name ? new Cesium["CallbackProperty"](function(canCreateDiscussions) {
        var stringify = hahaha;
        return primaryReplicas[stringify(1707)][0];
      }, false) : this.positions[0];
    }
  }, {
    "key" : `toGeoJson`,
    "value" : function() {
      return {
        "type" : "Feature",
        "properties" : this.properties,
        "geometry" : {
          "type" : "Point",
          "coordinates" : this.coordinates
        }
      };
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.viewer.entities.remove(this.textEntity);
    }
  }]), Cell);
  var ClassLink = (_inherits(e, state), expect(e, [{
    "key" : `createEntity`,
    "value" : function() {
      this.polylineEntity = this.viewer.entities.add({
        "plotType" : "GeoPlot",
        "plotCode" : this.properties.plotCode,
        "polyline" : {
          "positions" : this.positions,
          "width" : 2,
          "material" : new Cesium["PolylineDashMaterialProperty"]({
            "color" : Cesium.Color.RED
          }),
          "depthFailMaterial" : new Cesium["PolylineDashMaterialProperty"]({
            "color" : Cesium.Color.RED
          })
        }
      });
    }
  }, {
    "key" : "openEditMode",
    "value" : function(name) {
      var primaryReplicas = this;
      this.polylineEntity.polyline.positions = name ? new Cesium["CallbackProperty"](function(canCreateDiscussions) {
        var stringify = hahaha;
        return primaryReplicas[stringify(1707)];
      }, false) : this.positions;
    }
  }, {
    "key" : `setSelected`,
    "value" : function(name) {
      if (name) {
        this.polylineEntity.polyline.material = new Cesium["PolylineDashMaterialProperty"]({
          "color" : Cesium.Color.YELLOW
        });
        this.polylineEntity.polyline.depthFailMaterial = new Cesium.PolylineDashMaterialProperty({
          "color" : Cesium.Color.YELLOW
        });
      } else {
        this.polylineEntity.polyline.material = Cesium.Color.RED.withAlpha(0.5);
        this.polylineEntity.polyline.depthFailMaterial = Cesium.Color.RED.withAlpha(0.5);
      }
    }
  }, {
    "key" : `toGeoJson`,
    "value" : function() {
      return {
        "type" : "Feature",
        "properties" : this.properties,
        "geometry" : {
          "type" : "LineString",
          "coordinates" : this.coordinates
        }
      };
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.viewer.entities.remove(this.polylineEntity);
    }
  }]), e);
  var SpriteMultiple = (_inherits(Text, state), expect(Text, [{
    "key" : `createEntity`,
    "value" : function() {
      this.polygonEntity = this.viewer.entities.add({
        "plotType" : "GeoPlot",
        "plotCode" : this.properties.plotCode,
        "polygon" : {
          "hierarchy" : this.positions,
          "material" : Cesium.Color.RED.withAlpha(0.5),
          "perPositionHeight" : true
        }
      });
    }
  }, {
    "key" : `openEditMode`,
    "value" : function(name) {
      var rpm_traffic = this;
      if (name) {
        this.polygonEntity.polygon = {
          "hierarchy" : new Cesium.CallbackProperty(function(canCreateDiscussions) {
            var now = hahaha;
            return new (Cesium[now(1433)])(rpm_traffic[now(1707)]);
          }, false),
          "material" : Cesium.Color.RED.withAlpha(0.5),
          "perPositionHeight" : true
        };
        this.polygonEntity.polyline = {
          "positions" : new Cesium.CallbackProperty(function(canCreateDiscussions) {
            var now = hahaha;
            return rpm_traffic[now(1707)][now(439)](rpm_traffic[now(1707)][0]);
          }, false),
          "width" : 1,
          "material" : new Cesium["PolylineDashMaterialProperty"]({
            "color" : Cesium.Color.YELLOW
          }),
          "depthFailMaterial" : new Cesium["PolylineDashMaterialProperty"]({
            "color" : Cesium.Color.YELLOW
          })
        };
      } else {
        this.polygonEntity.polygon.hierarchy = this.positions;
        this.polygonEntity.polyline = {
          "positions" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
            var now = hahaha;
            return rpm_traffic[now(1707)][now(439)](rpm_traffic[now(1707)][0]);
          }, false),
          "width" : 0
        };
      }
    }
  }, {
    "key" : "setSelected",
    "value" : function(name) {
      var map = this;
      this.polygonEntity.polyline = name ? {
        "positions" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
          var parseInt = hahaha;
          return map[parseInt(1707)][parseInt(439)](map[parseInt(1707)][0]);
        }, false),
        "width" : 1,
        "material" : new Cesium["PolylineDashMaterialProperty"]({
          "color" : Cesium.Color.YELLOW
        }),
        "depthFailMaterial" : new Cesium.PolylineDashMaterialProperty({
          "color" : Cesium.Color.YELLOW
        })
      } : {
        "positions" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
          var put_rows = hahaha;
          return map[put_rows(1707)].concat(map[put_rows(1707)][0]);
        }, false),
        "width" : 0
      };
    }
  }, {
    "key" : `toGeoJson`,
    "value" : function() {
      return {
        "type" : "Feature",
        "properties" : this.properties,
        "geometry" : {
          "type" : "Polygon",
          "coordinates" : this.coordinates
        }
      };
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.viewer.entities.remove(this.polygonEntity);
    }
  }]), Text);
  var ScopeChain = (_inherits(BarChart, state), expect(BarChart, [{
    "key" : "updatePositionAction",
    "value" : function() {
      geocode(this.positions);
    }
  }, {
    "key" : "createEntity",
    "value" : function() {
      this.circleEntity = this.viewer.entities.add({
        "plotType" : "GeoPlot",
        "plotCode" : this.properties.plotCode,
        "position" : this.positions[0],
        "ellipse" : {
          "height" : this.getHeight(),
          "semiMinorAxis" : this.getAxis(),
          "semiMajorAxis" : this.getAxis(),
          "material" : Cesium.Color.RED.withAlpha(0.6)
        }
      });
    }
  }, {
    "key" : `getHeight`,
    "value" : function() {
      return get(this.positions[0]);
    }
  }, {
    "key" : "getAxis",
    "value" : function() {
      var a = this.positions[0];
      var pos = this.positions[0];
      return 1 < this.positions.length && (pos = this.positions[1]), getDistance(a, pos);
    }
  }, {
    "key" : `openEditMode`,
    "value" : function(name) {
      var rpm_traffic = this;
      if (name) {
        this.circleEntity.position = new Cesium["CallbackProperty"](function(canCreateDiscussions) {
          var now = hahaha;
          return rpm_traffic[now(1707)][0];
        }, false);
        this.circleEntity.ellipse.semiMinorAxis = new Cesium["CallbackProperty"](function(canCreateDiscussions) {
          var now = hahaha;
          return rpm_traffic[now(570)]();
        }, false);
        this.circleEntity.ellipse.semiMajorAxis = new Cesium.CallbackProperty(function(canCreateDiscussions) {
          var now = hahaha;
          return rpm_traffic[now(570)]();
        }, false);
        this.circleEntity.ellipse.height = new Cesium["CallbackProperty"](function(canCreateDiscussions) {
          var now = hahaha;
          return rpm_traffic[now(933)]();
        }, false);
      } else {
        this.circleEntity.position = this.positions[0];
        this.circleEntity.ellipse.height = this.getHeight();
        this.circleEntity.ellipse.semiMajorAxis = this.getAxis();
      }
    }
  }, {
    "key" : `toGeoJson`,
    "value" : function() {
      return {
        "type" : "Feature",
        "properties" : this.properties,
        "geometry" : {
          "type" : "LineString",
          "coordinates" : this.coordinates
        }
      };
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.viewer.entities.remove(this.circleEntity);
    }
  }]), BarChart);
  var Context = (_inherits(Agent, state), expect(Agent, [{
    "key" : `updatePositionAction`,
    "value" : function() {
      geocode(this.positions);
    }
  }, {
    "key" : `createEntity`,
    "value" : function() {
      this.polygonEntity = this.viewer.entities.add({
        "plotType" : "GeoPlot",
        "plotCode" : this.properties.plotCode,
        "polygon" : {
          "hierarchy" : this.getRectanglePositions(),
          "material" : Cesium.Color.RED.withAlpha(0.6),
          "perPositionHeight" : true
        }
      });
    }
  }, {
    "key" : `getRectanglePositions`,
    "value" : function() {
      var p = this.positions[0];
      var c = this.positions[0];
      return 1 < this.positions.length && (c = this.positions[1]), p = Cesium.Cartographic.fromCartesian(p), c = Cesium.Cartographic.fromCartesian(c), p.height < 0 && (p.height = 0), c.height < 0 && (c.height = 0), c = this.getRectanglePointsByTwoPoint(p, c), p = [c[0][0], c[0][1], p.height, c[1][0], c[1][1], p.height, c[2][0], c[2][1], p.height, c[3][0], c[3][1], p.height, c[0][0], c[0][1], p.height], new Cesium["PolygonHierarchy"](Cesium.Cartesian3.fromDegreesArrayHeights(p));
    }
  }, {
    "key" : "getRectanglePointsByTwoPoint",
    "value" : function(value, obj) {
      var _0xd2c516 = [Cesium.Math.toDegrees(value.longitude), Cesium.Math.toDegrees(value.latitude)];
      var _0x27016c = [Cesium.Math.toDegrees(obj.longitude), Cesium.Math.toDegrees(obj.latitude)];
      return [_0xd2c516, [Cesium.Math.toDegrees(value.longitude), Cesium.Math.toDegrees(obj.latitude)], _0x27016c, [Cesium.Math.toDegrees(obj.longitude), Cesium.Math.toDegrees(value.latitude)]];
    }
  }, {
    "key" : `openEditMode`,
    "value" : function(name) {
      var _0xf7b1f9 = this;
      this.polygonEntity.polygon.hierarchy = name ? new Cesium["CallbackProperty"](function(canCreateDiscussions) {
        return _0xf7b1f9.getRectanglePositions();
      }, false) : this.getRectanglePositions();
    }
  }, {
    "key" : `toGeoJson`,
    "value" : function() {
      return {
        "type" : "Feature",
        "properties" : this.properties,
        "geometry" : {
          "type" : "LineString",
          "coordinates" : this.coordinates
        }
      };
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.viewer.entities.remove(this.polygonEntity);
    }
  }]), Agent);
  var typeToString = function(type, v, o) {
    switch(v) {
      case cur.POLYGON:
        return new SpriteMultiple(type, o);
      case cur.MARKER:
        return new MockAdUnit(type, o);
      case cur.TEXT:
        return new Texture(type, o);
      case cur.POLYLINE:
        return new ClassLink(type, o);
      case cur.CIRCLE:
        return new ScopeChain(type, o);
      case cur.RECTANGLE:
        return new Context(type, o);
    }
  };
  doc = (expect(onload, [{
    "key" : `activate`,
    "value" : function(name) {
      this.deactivate();
      this.clear();
      this.plotType = name;
      this.positions = [];
      this.plotDrawTip = new Map(this.viewer);
      this.MousePoint = new Date(this.viewer);
      this.registerEvents();
      this.viewer.enableCursorStyle = false;
      this.viewer._element.style.cursor = "default";
      this.initTip();
    }
  }, {
    "key" : `initTip`,
    "value" : function() {
      switch(this.plotType) {
        case cur.MARKER:
          this.plotDrawTip.setContent(["\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a\u70b9\uff0c\u9700\u89811\u4e2a\u70b9", "\u6309\u4e0b\u9f20\u6807\u5de6\u952e\u786e\u5b9a\u4f4d\u7f6e", "\u6309\u4e0b\u9f20\u6807\u53f3\u952e\u53d6\u6d88\u7ed8\u5236"]);
          break;
        case cur.TEXT:
          this.plotDrawTip.setContent(["\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a\u6587\u672c\uff0c\u9700\u89811\u4e2a\u70b9", "\u6309\u4e0b\u9f20\u6807\u5de6\u952e\u786e\u5b9a\u4f4d\u7f6e", "\u6309\u4e0b\u9f20\u6807\u53f3\u952e\u53d6\u6d88\u7ed8\u5236"]);
          break;
        case cur.POLYLINE:
          this.plotDrawTip.setContent(["\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a\u7ebf\uff0c\u6700\u5c11\u9700\u89812\u4e2a\u70b9", "\u6309\u4e0b\u9f20\u6807\u5de6\u952e\u786e\u5b9a\u7b2c1\u4e2a\u70b9", "\u6309\u4e0b\u9f20\u6807\u53f3\u952e\u53d6\u6d88\u7ed8\u5236"]);
          break;
        case cur.POLYGON:
          this.plotDrawTip.setContent(["\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a\u9762\uff0c\u6700\u5c11\u9700\u89813\u4e2a\u70b9", "\u6309\u4e0b\u9f20\u6807\u5de6\u952e\u786e\u5b9a\u7b2c1\u4e2a\u70b9", "\u6309\u4e0b\u9f20\u6807\u53f3\u952e\u53d6\u6d88\u7ed8\u5236"]);
          break;
        case cur.CIRCLE:
          this.plotDrawTip.setContent(["\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a\u5706\uff0c\u9700\u89812\u4e2a\u70b9", "\u6309\u4e0b\u9f20\u6807\u5de6\u952e\u786e\u5b9a\u7b2c1\u4e2a\u70b9", "\u6309\u4e0b\u9f20\u6807\u53f3\u952e\u53d6\u6d88\u7ed8\u5236"]);
          break;
        case cur.RECTANGLE:
          this.plotDrawTip.setContent(["\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a\u77e9\u5f62\uff0c\u9700\u89812\u4e2a\u70b9", "\u6309\u4e0b\u9f20\u6807\u5de6\u952e\u786e\u5b9a\u7b2c1\u4e2a\u70b9", "\u6309\u4e0b\u9f20\u6807\u53f3\u952e\u53d6\u6d88\u7ed8\u5236"]);
          break;
        case cur.DYNAMICFENCE:
          this.plotDrawTip.setContent(["\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a\u52a8\u6001\u56f4\u680f\uff0c\u6700\u5c11\u9700\u89812\u4e2a\u70b9", "\u6309\u4e0b\u9f20\u6807\u5de6\u952e\u786e\u5b9a\u7b2c1\u4e2a\u70b9", "\u6309\u4e0b\u9f20\u6807\u53f3\u952e\u53d6\u6d88\u7ed8\u5236"]);
          break;
        case cur.NORMALFENCE:
          this.plotDrawTip.setContent(["\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a\u9759\u6001\u56f4\u680f\uff0c\u6700\u5c11\u9700\u89812\u4e2a\u70b9", "\u6309\u4e0b\u9f20\u6807\u5de6\u952e\u786e\u5b9a\u7b2c1\u4e2a\u70b9", "\u6309\u4e0b\u9f20\u6807\u53f3\u952e\u53d6\u6d88\u7ed8\u5236"]);
          break;
        case cur.POLYLINEVOLUME:
          this.plotDrawTip.setContent(["\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a\u666e\u901a\u5899\u4f53\uff0c\u6700\u5c11\u9700\u89812\u4e2a\u70b9", "\u6309\u4e0b\u9f20\u6807\u5de6\u952e\u786e\u5b9a\u7b2c1\u4e2a\u70b9", "\u6309\u4e0b\u9f20\u6807\u53f3\u952e\u53d6\u6d88\u7ed8\u5236"]);
      }
    }
  }, {
    "key" : "deactivate",
    "value" : function() {
      this.unRegisterEvents();
      this.plotType = void 0;
      this.viewer._element.style.cursor = "pointer";
      this.viewer.enableCursorStyle = true;
      if (this.plotDrawTip) {
        this.plotDrawTip.remove();
        this.MousePoint.remove();
        this.plotDrawTip = void 0;
        this.MousePoint = void 0;
      }
    }
  }, {
    "key" : `clear`,
    "value" : function() {
      if (this.plot) {
        this.plot.remove();
        this.plot = void 0;
      }
    }
  }, {
    "key" : "generatePlot",
    "value" : function(name) {
      var nsReg = createIntervalElements();
      name = this.generateGeoFeature(nsReg, name);
      this.plot = typeToString(this.viewer, this.plotType, name);
      this.plot.openEditMode(true);
    }
  }, {
    "key" : `generateGeoFeature`,
    "value" : function(type, obj) {
      var geomType = void 0;
      var data = void 0;
      switch(this.plotType) {
        case cur.MARKER:
        case cur.TEXT:
          geomType = "Point";
          data = this.getPointCoordinates(obj);
          break;
        case cur.POLYLINE:
        case cur.CIRCLE:
        case cur.RECTANGLE:
        case cur.DYNAMICFENCE:
        case cur.NORMALFENCE:
        case cur.POLYLINEVOLUME:
          geomType = "LineString";
          data = this.getLineStringCoordinates(obj);
          break;
        case cur.POLYGON:
          geomType = "Polygon";
          data = this.getPolygonCoordinates(obj);
      }
      return {
        "type" : "Feature",
        "properties" : {
          "plotCode" : type,
          "style" : void 0
        },
        "geometry" : {
          "type" : geomType,
          "coordinates" : data
        }
      };
    }
  }, {
    "key" : `getPointCoordinates`,
    "value" : function(value) {
      return value = Cesium.Cartographic.fromCartesian(value[0]), [Cesium.Math.toDegrees(value.longitude), Cesium.Math.toDegrees(value.latitude), value.height];
    }
  }, {
    "key" : "getLineStringCoordinates",
    "value" : function(name) {
      var retval = [];
      return name.forEach(function(result) {
        var parseInt = hahaha;
        result = Cesium[parseInt(1543)][parseInt(2206)](result);
        result = [Cesium[parseInt(2090)].toDegrees(result[parseInt(2596)]), Cesium[parseInt(2090)][parseInt(1611)](result[parseInt(480)]), result[parseInt(1132)]];
        retval[parseInt(2008)](result);
      }), retval;
    }
  }, {
    "key" : `getPolygonCoordinates`,
    "value" : function(name) {
      var el = [[]];
      return name.forEach(function(result) {
        var property = hahaha;
        result = Cesium[property(1543)][property(2206)](result);
        result = [Cesium[property(2090)][property(1611)](result[property(2596)]), Cesium.Math[property(1611)](result[property(480)]), result[property(1132)]];
        el[0][property(2008)](result);
      }), el;
    }
  }, {
    "key" : `initEvents`,
    "value" : function() {
      this.handler = new Cesium["ScreenSpaceEventHandler"](this.viewer.scene.canvas);
      this.PlotDrawStartEvent = new Cesium.Event;
      this.PlotDrawEndEvent = new Cesium.Event;
    }
  }, {
    "key" : `registerEvents`,
    "value" : function() {
      this.leftClickEvent();
      this.rightClickEvent();
      this.mouseMoveEvent();
    }
  }, {
    "key" : `leftClickEvent`,
    "value" : function() {
      var o = this;
      this.handler.setInputAction(function(bShowArray) {
        var parseInt = hahaha;
        o[parseInt(2276)][parseInt(2530)][parseInt(1998)][parseInt(737)] = parseInt(1654);
        bShowArray = o.viewer[parseInt(2758)][parseInt(1238)](bShowArray[parseInt(586)]);
        if (bShowArray) {
          o[parseInt(1707)][parseInt(2008)](bShowArray);
          if (1 == o[parseInt(1707)].length) {
            o.generatePlot(o[parseInt(1707)]);
          } else {
            o[parseInt(1298)][parseInt(2631)](o.positions);
          }
          o[parseInt(406)]();
          if (o[parseInt(1298)].fixPositionCount == o[parseInt(1707)].length) {
            o[parseInt(2788)]();
            o[parseInt(1983)]();
          }
        }
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
    }
  }, {
    "key" : "setTipContent",
    "value" : function() {
      switch(this.plotType) {
        case cur.POLYLINE:
          this.plotDrawTip.setContent(["\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a\u7ebf\uff0c\u6700\u5c11\u9700\u89812\u4e2a\u70b9\u3002", "\u5df2\u6709" + this.positions.length + "\u4e2a\u70b9\uff0c\u6309\u4e0b\u9f20\u6807\u5de6\u952e\u786e\u5b9a\u7b2c" + (this.positions.length + 1) + "\u4e2a\u70b9", this.positions.length < 2 ? "\u6309\u4e0b\u9f20\u6807\u53f3\u952e\u53d6\u6d88\u7ed8\u5236" : "\u6309\u4e0b\u9f20\u6807\u53f3\u952e\u7ed3\u675f\u7ed8\u5236"]);
          break;
        case cur.POLYGON:
          this.plotDrawTip.setContent(["\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a\u9762\uff0c\u6700\u5c11\u9700\u89813\u4e2a\u70b9\u3002", "\u5df2\u6709" + this.positions.length + "\u4e2a\u70b9\uff0c\u6309\u4e0b\u9f20\u6807\u5de6\u952e\u786e\u5b9a\u7b2c" + (this.positions.length + 1) + "\u4e2a\u70b9", this.positions.length < 3 ? "\u6309\u4e0b\u9f20\u6807\u53f3\u952e\u53d6\u6d88\u7ed8\u5236" : "\u6309\u4e0b\u9f20\u6807\u53f3\u952e\u7ed3\u675f\u7ed8\u5236"]);
          break;
        case cur.CIRCLE:
          this.plotDrawTip.setContent(["\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a\u5706\uff0c\u9700\u89812\u4e2a\u70b9\u3002", "\u5df2\u6709" + this.positions.length + "\u4e2a\u70b9\uff0c\u6309\u4e0b\u9f20\u6807\u5de6\u952e\u786e\u5b9a\u7b2c" + (this.positions.length + 1) + "\u4e2a\u70b9", "\u6309\u4e0b\u9f20\u6807\u53f3\u952e\u53d6\u6d88\u7ed8\u5236"]);
          break;
        case cur.RECTANGLE:
          this.plotDrawTip.setContent(["\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a\u77e9\u5f62\uff0c\u9700\u89812\u4e2a\u70b9\u3002", "\u5df2\u6709" + this.positions.length + "\u4e2a\u70b9\uff0c\u6309\u4e0b\u9f20\u6807\u5de6\u952e\u786e\u5b9a\u7b2c" + (this.positions.length + 1) + "\u4e2a\u70b9", "\u6309\u4e0b\u9f20\u6807\u53f3\u952e\u53d6\u6d88\u7ed8\u5236"]);
          break;
        case cur.DYNAMICFENCE:
          this.plotDrawTip.setContent(["\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a\u52a8\u6001\u56f4\u680f\uff0c\u6700\u5c11\u9700\u89812\u4e2a\u70b9\u3002", "\u5df2\u6709" + this.positions.length + "\u4e2a\u70b9\uff0c\u6309\u4e0b\u9f20\u6807\u5de6\u952e\u786e\u5b9a\u7b2c" + (this.positions.length + 1) + "\u4e2a\u70b9", this.positions.length < 2 ? "\u6309\u4e0b\u9f20\u6807\u53f3\u952e\u53d6\u6d88\u7ed8\u5236" : "\u6309\u4e0b\u9f20\u6807\u53f3\u952e\u7ed3\u675f\u7ed8\u5236"]);
          break;
        case cur.FENCENORMAL:
          this.plotDrawTip.setContent(["\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a\u666e\u901a\u56f4\u680f\uff0c\u6700\u5c11\u9700\u89812\u4e2a\u70b9\u3002", "\u5df2\u6709" + this.positions.length + "\u4e2a\u70b9\uff0c\u6309\u4e0b\u9f20\u6807\u5de6\u952e\u786e\u5b9a\u7b2c" + (this.positions.length + 1) + "\u4e2a\u70b9", this.positions.length < 2 ? "\u6309\u4e0b\u9f20\u6807\u53f3\u952e\u53d6\u6d88\u7ed8\u5236" : "\u6309\u4e0b\u9f20\u6807\u53f3\u952e\u7ed3\u675f\u7ed8\u5236"]);
          break;
        case cur.POLYLINEVOLUME:
          this.plotDrawTip.setContent(["\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a\u666e\u901a\u5899\u4f53\uff0c\u6700\u5c11\u9700\u89812\u4e2a\u70b9\u3002", "\u5df2\u6709" + this.positions.length + "\u4e2a\u70b9\uff0c\u6309\u4e0b\u9f20\u6807\u5de6\u952e\u786e\u5b9a\u7b2c" + (this.positions.length + 1) + "\u4e2a\u70b9", this.positions.length < 2 ? "\u6309\u4e0b\u9f20\u6807\u53f3\u952e\u53d6\u6d88\u7ed8\u5236" : "\u6309\u4e0b\u9f20\u6807\u53f3\u952e\u7ed3\u675f\u7ed8\u5236"]);
      }
    }
  }, {
    "key" : `mouseMoveEvent`,
    "value" : function() {
      var data = this;
      this.handler.setInputAction(function(event) {
        var String = hahaha;
        data.viewer[String(2530)][String(1998)][String(737)] = String(1654);
        event = data.viewer.scene[String(1238)](event[String(2840)]);
        if (event) {
          data[String(2270)].updatePosition(event);
          data[String(1455)].updatePosition(event);
          if (data[String(1298)]) {
            event = data[String(1707)].concat([event]);
            data.plot.setPositions(event);
          }
        }
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
    }
  }, {
    "key" : `rightClickEvent`,
    "value" : function() {
      var obj = this;
      this.handler.setInputAction(function(canCreateDiscussions) {
        var parseInt = hahaha;
        if (0 != obj[parseInt(1707)][parseInt(2189)]) {
          if (obj[parseInt(1298)][parseInt(2862)]) {
            if (obj.positions[parseInt(2189)] == obj[parseInt(1298)][parseInt(2862)]) {
              obj.plot[parseInt(2631)](obj[parseInt(1707)]);
              obj[parseInt(2788)]();
              obj[parseInt(1983)]();
            } else {
              obj[parseInt(1983)]();
              obj[parseInt(2822)]();
            }
          } else {
            if (obj[parseInt(1707)][parseInt(2189)] >= obj.plot[parseInt(3107)]) {
              obj.plot[parseInt(2631)](obj[parseInt(1707)]);
              obj[parseInt(2788)]();
              obj.deactivate();
            } else {
              obj[parseInt(1983)]();
              obj[parseInt(2822)]();
            }
          }
        } else {
          obj[parseInt(1983)]();
        }
      }, Cesium.ScreenSpaceEventType.RIGHT_CLICK);
    }
  }, {
    "key" : `unRegisterEvents`,
    "value" : function() {
      this.handler.removeInputAction(Cesium.ScreenSpaceEventType.RIGHT_CLICK);
      this.handler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_CLICK);
      this.handler.removeInputAction(Cesium.ScreenSpaceEventType.MOUSE_MOVE);
      this.handler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);
    }
  }, {
    "key" : `drawEnd`,
    "value" : function() {
      this.plot.openEditMode(false);
      this.PlotDrawEndEvent.raiseEvent(this.plot, this.plotType);
    }
  }]), onload);
  expect(number, [{
    "key" : `initEventHandler`,
    "value" : function() {
      this.eventHandler = new Cesium["ScreenSpaceEventHandler"](this.viewer.scene.canvas);
    }
  }, {
    "key" : `activate`,
    "value" : function() {
      this.deactivate();
      this.initLeftClickEventHandler();
    }
  }, {
    "key" : `deactivate`,
    "value" : function() {
      this.eventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_CLICK);
      this.unRegisterEvents();
      this.clear();
    }
  }, {
    "key" : `clear`,
    "value" : function() {
      if (this.editGeoPlot) {
        this.editGeoPlot.openEditMode(true);
      }
      this.clearEditVertex();
      this.clearMidVertex();
    }
  }, {
    "key" : "initLeftClickEventHandler",
    "value" : function() {
      var receiver = this;
      this.eventHandler.setInputAction(function(child) {
        var toPythonCase = hahaha;
        child = receiver[toPythonCase(2276)][toPythonCase(2758)][toPythonCase(1708)](child[toPythonCase(586)]);
        if (child) {
          if (child.id && "GeoPlot" == child.id[toPythonCase(549)]) {
            if (!(receiver[toPythonCase(2448)] && receiver[toPythonCase(2448)][toPythonCase(2717)] == child.id[toPythonCase(2717)])) {
              receiver[toPythonCase(1415)]();
              receiver[toPythonCase(1033)](child.id);
            }
          } else {
            receiver.clear();
          }
        } else {
          receiver[toPythonCase(1415)]();
        }
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
    }
  }, {
    "key" : `handleEditGeoPlot`,
    "value" : function() {
      this.clear();
      this.editGeoPlot;
      this.editGeoPlot = void 0;
      if (this.isEdited) {
        this.isEdited = false;
        this.isEditing = false;
      }
    }
  }, {
    "key" : "handlePickGeoPlot",
    "value" : function(name) {
      this.editGeoPlot = this.geoPlotLayer.getByPlotCode(name.plotCode);
      if (this.editGeoPlot) {
        this.isEditing = false;
        this.isEdited = false;
        this.editGeoPlot.openEditMode(true);
        this.editPositions = this.editGeoPlot.getPositions();
        this.EditMoveCenterPositoin = this.getGeoPlotCenterPosition();
        this.clear();
        this.createEditVertex();
        this.createMidVertex();
        this.registerEvents();
      }
    }
  }, {
    "key" : `registerEvents`,
    "value" : function() {
      this.initLeftDownEventHandler();
      this.initMouseMoveEventHandler();
      this.initLeftUpEventHandler();
    }
  }, {
    "key" : "unRegisterEvents",
    "value" : function() {
      this.eventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOWN);
      this.eventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_UP);
      this.eventHandler.removeInputAction(Cesium.ScreenSpaceEventType.MOUSE_MOVE);
    }
  }, {
    "key" : "initLeftDownEventHandler",
    "value" : function() {
      var data = this;
      this.eventHandler.setInputAction(function(obj) {
        var String = hahaha;
        obj = data[String(2276)].scene[String(1708)](obj[String(586)]);
        if (obj && obj.id && obj.id[String(1720)]) {
          if (String(2879) == obj.id[String(1720)] || String(1357) == obj.id[String(1720)]) {
            data[String(3088)] = true;
            data[String(2276)].scene[String(2190)][String(1218)] = false;
            data.viewer.enableCursorStyle = false;
            data.viewer[String(2530)][String(1998)].cursor = "";
            document[String(1494)][String(1998)].cursor = String(367);
            data[String(1670)] = obj.id;
            data.editVertext[String(2752)] = false;
            data[String(1521)]();
          } else {
            if (String(2361) == obj.id[String(1720)]) {
              data.editPositions[String(2998)](obj.id[String(1593)], 0, obj.id[String(586)][String(2041)]);
              data[String(2448)].setPositions(data.editPositions);
              data.clear();
              data[String(1779)]();
              data[String(2142)]();
              data[String(581)] = true;
            }
          }
        }
      }, Cesium.ScreenSpaceEventType.LEFT_DOWN);
    }
  }, {
    "key" : `initLeftUpEventHandler`,
    "value" : function() {
      var obj = this;
      this.eventHandler.setInputAction(function(canCreateDiscussions) {
        var parseInt = hahaha;
        if (obj[parseInt(3088)]) {
          obj[parseInt(2276)][parseInt(1633)] = true;
          document.body[parseInt(1998)].cursor = parseInt(1654);
          obj[parseInt(2276)][parseInt(2758)][parseInt(2190)].enableRotate = true;
          obj[parseInt(1670)].show = true;
          obj.isEditing = false;
          obj[parseInt(1521)]();
          obj[parseInt(2142)]();
          if (parseInt(2442) == obj[parseInt(2448)][parseInt(3090)]) {
            obj[parseInt(2448)][parseInt(1013)]();
          }
        }
      }, Cesium.ScreenSpaceEventType.LEFT_UP);
    }
  }, {
    "key" : `initMouseMoveEventHandler`,
    "value" : function() {
      var obj = this;
      this.eventHandler.setInputAction(function(args) {
        var parseInt = hahaha;
        var value = obj[parseInt(2276)][parseInt(2758)][parseInt(1238)](args[parseInt(2840)]);
        if (value && obj.isEditing) {
          if (parseInt(1357) == obj[parseInt(1670)][parseInt(1720)]) {
            args = obj.EditMoveCenterPositoin;
            if (!args) {
              return;
            }
            obj[parseInt(2985)](args, value);
          } else {
            obj[parseInt(1484)][obj.editVertext[parseInt(1593)]] = value;
            obj[parseInt(2448)].setPositions(obj[parseInt(1484)]);
          }
          obj[parseInt(581)] = true;
          obj[parseInt(1054)] = obj[parseInt(852)]();
        }
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
    }
  }, {
    "key" : "getGeoPlotCenterPosition",
    "value" : function() {
      var line = [];
      var z = 0;
      switch(this.editGeoPlot.properties.plotType) {
        case cur.CIRCLE:
        case cur.MARKER:
        case cur.TEXT:
          return this.editPositions[0];
      }
      this.editPositions.forEach(function(x) {
        var put_rows = hahaha;
        x = require(x);
        line[put_rows(2008)]([x.x, x.y]);
        if (z < x.z) {
          z = x.z;
        }
      });
      var tmp = turf.lineString(line);
      tmp = turf.bbox(tmp);
      tmp = turf.bboxPolygon(tmp);
      tmp = turf.center(tmp).geometry.coordinates;
      return Cesium.Cartesian3.fromDegrees(tmp[0], tmp[1], z);
    }
  }, {
    "key" : `moveEntityByOffset`,
    "value" : function(target, source) {
      target = require(target);
      source = require(source);
      var mergeAxisLength = source.x - target.x;
      var SHIP_SPEED = source.y - target.y;
      var z = source.z - target.z;
      var dirIntent = this.editGeoPlot.properties.plotType;
      var json = void 0;
      var i = 0;
      for (; i < this.editPositions.length; i++) {
        (json = require(this.editPositions[i])).x += mergeAxisLength;
        json.y += SHIP_SPEED;
        if (!(dirIntent != cur.CIRCLE && dirIntent != cur.RECTANGLE)) {
          json.z += z;
        }
        this.editPositions[i] = Cesium.Cartesian3.fromDegrees(json.x, json.y, json.z);
      }
      this.editGeoPlot.setPositions(this.editPositions);
    }
  }, {
    "key" : "createEditVertex",
    "value" : function() {
      var parent = this;
      this.vertexEntities = [];
      var pipelets = this.editGeoPlot.getPositions();
      if (this.editGeoPlot.properties.plotType == cur.CIRCLE) {
        return this.createCircleEditVertex(), void this.createEditMoveCenterEntity();
      }
      pipelets.forEach(function(canCreateDiscussions, idx) {
        var put_rows = hahaha;
        var falseySection = parent.viewer[put_rows(1319)][put_rows(3010)]({
          "position" : new (Cesium[put_rows(1679)])(function(canCreateDiscussions) {
            var getRelidFromPath = put_rows;
            return parent[getRelidFromPath(1484)][idx];
          }, false),
          "type" : "GeoPlotEditVertex",
          "vertexIndex" : idx,
          "point" : {
            "color" : Cesium.Color[put_rows(3198)][put_rows(2265)](0.4),
            "pixelSize" : 10,
            "outlineColor" : Cesium[put_rows(2292)][put_rows(2537)][put_rows(2265)](0.4),
            "outlineWidth" : 3,
            "disableDepthTestDistance" : 2E3
          }
        });
        parent[put_rows(1220)].push(falseySection);
      });
      if (1 != this.editPositions.length) {
        this.createEditMoveCenterEntity();
      }
    }
  }, {
    "key" : "createCircleEditVertex",
    "value" : function() {
      var primaryReplicas = this;
      var falseySection = this.viewer.entities.add({
        "position" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
          var stringify = hahaha;
          return primaryReplicas[stringify(1484)][1];
        }, false),
        "type" : "GeoPlotEditVertex",
        "vertexIndex" : 1,
        "point" : {
          "color" : Cesium.Color.DARKBLUE.withAlpha(0.4),
          "pixelSize" : 10,
          "outlineColor" : Cesium.Color.YELLOW.withAlpha(0.4),
          "outlineWidth" : 3,
          "disableDepthTestDistance" : 2E3
        }
      });
      this.vertexEntities.push(falseySection);
    }
  }, {
    "key" : `createEditMoveCenterEntity`,
    "value" : function() {
      var primaryReplicas = this;
      this.EditMoveCenterEntity = this.viewer.entities.add({
        "position" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
          var stringify = hahaha;
          return primaryReplicas[stringify(1054)];
        }, false),
        "type" : "GeoPlotEditMove",
        "point" : {
          "color" : Cesium.Color.RED.withAlpha(0.4),
          "pixelSize" : 10,
          "outlineColor" : Cesium.Color.WHITE.withAlpha(0.3),
          "outlineWidth" : 3,
          "disableDepthTestDistance" : 2E3
        }
      });
    }
  }, {
    "key" : `clearEditVertex`,
    "value" : function() {
      var same = this;
      if (this.vertexEntities) {
        this.vertexEntities.forEach(function(mmCoreSplitViewBlock) {
          var rel2Mstr = hahaha;
          same[rel2Mstr(2276)][rel2Mstr(1319)][rel2Mstr(508)](mmCoreSplitViewBlock);
        });
      }
      this.vertexEntities = [];
      this.viewer.entities.remove(this.EditMoveCenterEntity);
    }
  }, {
    "key" : `createMidVertex`,
    "value" : function() {
      var dirIntent = this.editGeoPlot.properties.plotType;
      if (dirIntent != cur.RECTANGLE && dirIntent != cur.CIRCLE) {
        this.midVertexEntities = [];
        var layer_i = 0;
        for (; layer_i < this.editPositions.length; layer_i++) {
          var gridPosition = geodeticToGeocentric(this.editPositions[layer_i], this.editPositions[layer_i + 1]);
          gridPosition = this.viewer.entities.add({
            "position" : gridPosition,
            "type" : "GeoPlotEditMidVertex",
            "vertexIndex" : layer_i + 1,
            "point" : {
              "color" : Cesium.Color.LIMEGREEN.withAlpha(0.4),
              "pixelSize" : 10,
              "outlineColor" : Cesium.Color.YELLOW.withAlpha(0.4),
              "outlineWidth" : 3,
              "disableDepthTestDistance" : 2E3
            }
          });
          this.midVertexEntities.push(gridPosition);
        }
      }
    }
  }, {
    "key" : "clearMidVertex",
    "value" : function() {
      var primaryReplicas = this;
      if (this.midVertexEntities) {
        this.midVertexEntities.forEach(function(mmCoreSplitViewBlock) {
          var stringify = hahaha;
          primaryReplicas[stringify(2276)].entities[stringify(508)](mmCoreSplitViewBlock);
        });
      }
      this.midVertexEntities = [];
    }
  }]);
  tel = number;
  _inherits(Singleline, meta);
  expect(Singleline, [{
    "key" : `addPlot`,
    "value" : function(obj) {
      return obj = typeToString(this.viewer, obj.properties.plotType, obj), this.plots.push(obj), obj;
    }
  }, {
    "key" : `flyToByPlotCode`,
    "value" : function(name) {
      var e = this.getByPlotCode(name);
      if (e) {
        switch(e.properties.plotType) {
          case cur.MARKER:
            this.viewer.flyTo(e.markerEntity);
            break;
          case cur.NORMALFENCE:
          case cur.DYNAMICFENCE:
            this.viewer.flyTo(e.fenceEntity);
        }
        this.setSelectedPlotByCode(name);
      }
    }
  }, {
    "key" : `initEvent`,
    "value" : function() {
      var obj = this;
      (new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas)).setInputAction(function(data) {
        var parseInt = hahaha;
        if (obj.plotSelecteable) {
          if ((data = obj[parseInt(2276)].scene.pick(data[parseInt(586)])) && data.id) {
            if (!(data.id && data.id.type && "GeoPlot" == data.id[parseInt(1720)])) {
              if (obj[parseInt(1277)]) {
                obj[parseInt(1277)].setSelected(false);
                obj.selectedPlot = void 0;
                obj[parseInt(1346)][parseInt(2477)](void 0);
              }
            }
            if (!(obj[parseInt(1277)] && obj.selectedPlot[parseInt(2931)][parseInt(2717)] == data.id[parseInt(2717)])) {
              if (data = obj[parseInt(2426)](data.id[parseInt(2717)])) {
                obj[parseInt(2890)]();
                obj[parseInt(1277)] = data;
                obj.selectedPlot.setSelected(true);
                obj.selectedPlotChanged[parseInt(2477)](data);
              } else {
                if (obj[parseInt(1277)]) {
                  obj.selectedPlot[parseInt(1666)](false);
                  obj[parseInt(1277)] = void 0;
                }
                obj[parseInt(1346)][parseInt(2477)](void 0);
              }
            }
          } else {
            if (obj[parseInt(1277)]) {
              obj[parseInt(1277)][parseInt(1666)](false);
              obj.selectedPlot = void 0;
              obj[parseInt(1346)][parseInt(2477)](void 0);
            }
          }
        }
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
    }
  }, {
    "key" : `setSelectedPlotByCode`,
    "value" : function(type) {
      this.clearSelectedPlot();
      type = this.getByPlotCode(type);
      if (type) {
        this.selectedPlot = type;
        this.selectedPlot.setSelected(true);
        this.selectedPlotChanged.raiseEvent(type);
      }
    }
  }, {
    "key" : `clearSelectedPlot`,
    "value" : function() {
      if (this.selectedPlot) {
        this.selectedPlot.setSelected(false);
        this.selectedPlot = void 0;
      }
    }
  }]);
  state = Singleline;
  xt3d.LabelPlotting = {
    "EntityDraw" : k,
    "EntityEdit" : entryToSend,
    "LedText" : pos,
    "ShulieText" : name,
    "HtmlPlot" : {
      "PlotEdit" : frame,
      "PlotLayer" : location
    },
    "HedronPlot" : {
      "PlotDraw" : init,
      "PlotEdit" : data,
      "PlotLayer" : forced
    },
    "MilitaryPlot" : {
      "PlotDraw" : mode,
      "PlotEdit" : exports,
      "PlotLayer" : output
    },
    "TextMapPlot" : {
      "PlotDraw" : ID,
      "PlotEdit" : descriptor,
      "PlotLayer" : view
    },
    "GeoPlot" : {
      "PlotDraw" : doc,
      "PlotEdit" : tel,
      "PlotLayer" : state
    },
    "getPlotCode" : createIntervalElements,
    "cartesian3ToCoordinates" : compute
  };
  expect(username, [{
    "key" : "activate",
    "value" : function(type) {
      this.deactivate();
      this.clear();
      this.drawType = type;
      this.positions = [];
      this.tempPositions = [];
      this.registerEvents();
      this.viewer.enableCursorStyle = false;
      this.viewer._element.style.cursor = "default";
    }
  }, {
    "key" : "deactivate",
    "value" : function() {
      this.unRegisterEvents();
      this.drawType = void 0;
      this.drawEntity = void 0;
      this.viewer._element.style.cursor = "pointer";
      this.viewer.enableCursorStyle = true;
    }
  }, {
    "key" : `clear`,
    "value" : function() {
      if (this.drawEntity) {
        this.viewer.entities.remove(this.drawEntity);
        this.drawEntity = void 0;
      }
    }
  }, {
    "key" : `initEvents`,
    "value" : function() {
      this.handler = new Cesium["ScreenSpaceEventHandler"](this.viewer.scene.canvas);
      this.DrawStartEvent = new Cesium.Event;
      this.DrawEndEvent = new Cesium.Event;
    }
  }, {
    "key" : `registerEvents`,
    "value" : function() {
      this.leftClickEvent();
      this.rightClickEvent();
      this.mouseMoveEvent();
    }
  }, {
    "key" : `leftClickEvent`,
    "value" : function() {
      var o = this;
      this.handler.setInputAction(function(store) {
        var camelize = hahaha;
        o[camelize(2276)][camelize(2530)][camelize(1998)][camelize(737)] = camelize(1654);
        var artistTrack = o[camelize(2276)][camelize(2758)][camelize(1238)](store.position);
        if (artistTrack = artistTrack || o[camelize(2276)][camelize(2758)][camelize(1306)][camelize(1080)](store[camelize(586)], o.viewer[camelize(2758)][camelize(2359)].ellipsoid)) {
          o[camelize(1707)][camelize(2008)](artistTrack);
          if (1 == o[camelize(1707)][camelize(2189)]) {
            o[camelize(2724)]();
          }
        }
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
    }
  }, {
    "key" : "handleFirstPosition",
    "value" : function() {
      switch(this.drawType) {
        case "Point":
          this.generatePoint();
          this.drawEnd();
          break;
        case "Polyline":
          this.generatePolyline();
          break;
        case "Polygon":
          this.generatePolygon();
      }
    }
  }, {
    "key" : `generatePoint`,
    "value" : function() {
      this.drawEntity = this.viewer.entities.add({
        "position" : this.positions[0],
        "point" : {
          "pixelSize" : 4,
          "color" : Cesium.Color.RED
        }
      });
    }
  }, {
    "key" : `generatePolyline`,
    "value" : function() {
      var primaryReplicas = this;
      this.drawEntity = this.viewer.entities.add({
        "polyline" : {
          "positions" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
            var stringify = hahaha;
            return primaryReplicas[stringify(3119)];
          }, false),
          "width" : 2,
          "material" : new Cesium.PolylineDashMaterialProperty({
            "color" : Cesium.Color.YELLOW
          }),
          "depthFailMaterial" : new Cesium["PolylineDashMaterialProperty"]({
            "color" : Cesium.Color.YELLOW
          })
        }
      });
    }
  }, {
    "key" : `generatePolygon`,
    "value" : function() {
      var same = this;
      this.drawEntity = this.viewer.entities.add({
        "polygon" : {
          "hierarchy" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
            var put_rows = hahaha;
            return new (Cesium[put_rows(1433)])(same[put_rows(3119)]);
          }, false),
          "material" : Cesium.Color.RED.withAlpha(0.4),
          "perPositionHeight" : true
        },
        "polyline" : {
          "positions" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
            var rel2Mstr = hahaha;
            return same[rel2Mstr(3119)][rel2Mstr(439)](same[rel2Mstr(3119)][0]);
          }, false),
          "width" : 1,
          "material" : new Cesium.PolylineDashMaterialProperty({
            "color" : Cesium.Color.YELLOW
          }),
          "depthFailMaterial" : new Cesium["PolylineDashMaterialProperty"]({
            "color" : Cesium.Color.YELLOW
          })
        }
      });
    }
  }, {
    "key" : "mouseMoveEvent",
    "value" : function() {
      var obj = this;
      this.handler.setInputAction(function(currentItems) {
        var parseInt = hahaha;
        obj[parseInt(2276)]._element[parseInt(1998)][parseInt(737)] = parseInt(1654);
        var member = obj[parseInt(2276)][parseInt(2758)].pickPosition(currentItems[parseInt(2840)]);
        if ((member = member || obj[parseInt(2276)][parseInt(2758)].camera.pickEllipsoid(currentItems[parseInt(1108)], obj[parseInt(2276)][parseInt(2758)][parseInt(2359)].ellipsoid)) && obj[parseInt(2280)]) {
          obj[parseInt(3119)] = obj.positions.concat([member]);
        }
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
    }
  }, {
    "key" : `rightClickEvent`,
    "value" : function() {
      var obj = this;
      this.handler.setInputAction(function(canCreateDiscussions) {
        var parseInt = hahaha;
        if (obj[parseInt(2280)]) {
          switch(obj[parseInt(2891)]) {
            case parseInt(1811):
              obj[parseInt(2280)].polyline.positions = obj[parseInt(1707)];
              obj[parseInt(3107)] = 2;
              break;
            case parseInt(1195):
              obj.drawEntity[parseInt(2544)].hierarchy = obj[parseInt(1707)];
              obj[parseInt(2280)][parseInt(1562)].positions = obj[parseInt(1707)][parseInt(439)](obj.positions[0]);
              obj[parseInt(3107)] = 3;
          }
          if (obj[parseInt(1707)][parseInt(2189)] < obj.minPositionCount) {
            return obj[parseInt(2822)](), void obj[parseInt(1983)]();
          }
          obj[parseInt(2788)]();
        } else {
          obj[parseInt(1983)]();
        }
      }, Cesium.ScreenSpaceEventType.RIGHT_CLICK);
    }
  }, {
    "key" : "unRegisterEvents",
    "value" : function() {
      this.handler.removeInputAction(Cesium.ScreenSpaceEventType.RIGHT_CLICK);
      this.handler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_CLICK);
      this.handler.removeInputAction(Cesium.ScreenSpaceEventType.MOUSE_MOVE);
      this.handler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);
    }
  }, {
    "key" : `drawEnd`,
    "value" : function() {
      var rpm_traffic = this;
      this.drawEntity.remove = function() {
        var now = hahaha;
        rpm_traffic[now(2276)].entities[now(508)](rpm_traffic[now(2280)]);
      };
      this.DrawEndEvent.raiseEvent(this.drawEntity, this.positions, this.drawType);
      this.deactivate();
    }
  }]);
  k = username;
  expect(dragLeave, [{
    "key" : "initEventHandler",
    "value" : function() {
      this.eventHandler = new Cesium["ScreenSpaceEventHandler"](this.viewer.scene.canvas);
      this.EditEndEvent = new Cesium.Event;
    }
  }, {
    "key" : `activate`,
    "value" : function() {
      this.deactivate();
      this.initLeftClickEventHandler();
    }
  }, {
    "key" : `deactivate`,
    "value" : function() {
      this.eventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_CLICK);
      this.unRegisterEvents();
      this.clearAllEditVertex();
    }
  }, {
    "key" : `clearAllEditVertex`,
    "value" : function() {
      this.clearEditVertex();
      this.clearMidVertex();
    }
  }, {
    "key" : `initLeftClickEventHandler`,
    "value" : function() {
      var values = this;
      this.eventHandler.setInputAction(function(options) {
        var parseInt = hahaha;
        options = values[parseInt(2276)][parseInt(2758)][parseInt(1708)](options.position);
        if (options && options.id) {
          if (options.id && options.id.Type) {
            if (!(values[parseInt(1652)] && values[parseInt(1652)].id == options.id.id)) {
              values.handleEditEntity();
              values[parseInt(834)](options.id);
            }
          }
        } else {
          values[parseInt(905)]();
        }
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
    }
  }, {
    "key" : `handleEditEntity`,
    "value" : function() {
      this.unRegisterEvents();
      this.clearAllEditVertex();
      var result = this.editEntity;
      if (result) {
        this.closeEntityEditMode();
        this.editEntity = void 0;
        if (this.isEdited) {
          this.EditEndEvent.raiseEvent(result);
          this.isEdited = false;
          this.isEditing = false;
        }
      }
    }
  }, {
    "key" : `handlePickEditEntity`,
    "value" : function(type) {
      if (-1 != ["EditableMarker", "EditablePolyline", "EditablePolygon"].indexOf(type.Type)) {
        this.editEntity = type;
        this.isEditing = false;
        this.isEdited = false;
        this.editPositions = this.getEditEntityPositions();
        this.EditMoveCenterPositoin = this.getCenterPosition();
        this.openEntityEditModel();
        this.clearAllEditVertex();
        this.unRegisterEvents();
        this.createEditVertex();
        this.createMidVertex();
        this.registerEvents();
      }
    }
  }, {
    "key" : `openEntityEditModel`,
    "value" : function() {
      var r = this;
      switch(this.editEntity.Type) {
        case "EditableMarker":
          this.editEntity.position = new Cesium["CallbackProperty"](function(canCreateDiscussions) {
            var put_rows = hahaha;
            return r[put_rows(1484)][0];
          }, false);
          break;
        case "EditablePolyline":
          this.editEntity.polyline.positions = new Cesium["CallbackProperty"](function(canCreateDiscussions) {
            var put_rows = hahaha;
            return r[put_rows(1484)];
          }, false);
          break;
        case "EditablePolygon":
          this.editEntity.polygon.hierarchy = new Cesium["CallbackProperty"](function(canCreateDiscussions) {
            var put_rows = hahaha;
            return new Cesium.PolygonHierarchy(r[put_rows(1484)]);
          }, false);
          if (this.editEntity.polyline) {
            this.editEntity.polyline.positions = new Cesium["CallbackProperty"](function(canCreateDiscussions) {
              var put_rows = hahaha;
              return r.editPositions.concat(r[put_rows(1484)][0]);
            }, false);
          }
      }
    }
  }, {
    "key" : `closeEntityEditMode`,
    "value" : function() {
      switch(this.editEntity.Type) {
        case "EditableMarker":
          this.editEntity.position = this.editPositions[0];
          break;
        case "EditablePolyline":
          this.editEntity.polyline.positions = this.editPositions;
          break;
        case "EditablePolygon":
          this.editEntity.polygon.hierarchy = this.editPositions;
          if (this.editEntity.polyline) {
            this.editEntity.polyline.positions = this.editPositions.concat(this.editPositions[0]);
          }
      }
    }
  }, {
    "key" : `getEditEntityPositions`,
    "value" : function() {
      switch(this.editEntity.Type) {
        case "EditableMarker":
          return [this.editEntity.position._value];
        case "EditablePolyline":
          return this.editEntity.polyline.positions._value;
        case "EditablePolygon":
          return this.editEntity.polygon.hierarchy._value.positions;
      }
    }
  }, {
    "key" : "registerEvents",
    "value" : function() {
      this.initLeftDownEventHandler();
      this.initMouseMoveEventHandler();
      this.initLeftUpEventHandler();
    }
  }, {
    "key" : "unRegisterEvents",
    "value" : function() {
      this.eventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOWN);
      this.eventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_UP);
      this.eventHandler.removeInputAction(Cesium.ScreenSpaceEventType.MOUSE_MOVE);
    }
  }, {
    "key" : `initLeftDownEventHandler`,
    "value" : function() {
      var obj = this;
      this.eventHandler.setInputAction(function(args) {
        var parseInt = hahaha;
        args = obj[parseInt(2276)][parseInt(2758)][parseInt(1708)](args[parseInt(586)]);
        if (args && args.id && args.id.type) {
          if (parseInt(2919) == args.id[parseInt(1720)] || parseInt(1786) == args.id[parseInt(1720)]) {
            obj[parseInt(3088)] = true;
            obj[parseInt(2276)][parseInt(2758)][parseInt(2190)].enableRotate = false;
            obj[parseInt(2276)][parseInt(1633)] = false;
            obj[parseInt(2276)]._element[parseInt(1998)][parseInt(737)] = "";
            document[parseInt(1494)][parseInt(1998)][parseInt(737)] = "move";
            obj.editVertext = args.id;
            obj.editVertext[parseInt(2752)] = false;
            obj[parseInt(1521)]();
          } else {
            if (parseInt(2487) == args.id[parseInt(1720)]) {
              obj[parseInt(1484)][parseInt(2998)](args.id[parseInt(1593)], 0, args.id[parseInt(586)][parseInt(2041)]);
              obj[parseInt(3070)]();
              obj[parseInt(1779)]();
              obj[parseInt(2142)]();
              obj[parseInt(581)] = true;
            }
          }
        }
      }, Cesium.ScreenSpaceEventType.LEFT_DOWN);
    }
  }, {
    "key" : "initLeftUpEventHandler",
    "value" : function() {
      var self = this;
      this.eventHandler.setInputAction(function(canCreateDiscussions) {
        var put_rows = hahaha;
        if (self.isEditing) {
          self[put_rows(2276)][put_rows(1633)] = true;
          document[put_rows(1494)][put_rows(1998)][put_rows(737)] = put_rows(1654);
          self.viewer.scene[put_rows(2190)].enableRotate = true;
          self[put_rows(1670)][put_rows(2752)] = true;
          self[put_rows(3088)] = false;
          self[put_rows(1521)]();
          self.createMidVertex();
        }
      }, Cesium.ScreenSpaceEventType.LEFT_UP);
    }
  }, {
    "key" : `initMouseMoveEventHandler`,
    "value" : function() {
      var map = this;
      this.eventHandler.setInputAction(function(item) {
        var parseInt = hahaha;
        var val = (val = map[parseInt(2276)][parseInt(2758)][parseInt(1238)](item[parseInt(2840)])) || map[parseInt(2276)][parseInt(2758)].camera.pickEllipsoid(item[parseInt(2840)], map[parseInt(2276)].scene[parseInt(2359)].ellipsoid);
        if (val && map[parseInt(3088)]) {
          if (parseInt(1786) == map[parseInt(1670)][parseInt(1720)]) {
            item = map[parseInt(1054)];
            if (!item) {
              return;
            }
            map[parseInt(2985)](item, val);
          } else {
            map.editPositions[map[parseInt(1670)][parseInt(1593)]] = val;
          }
          map[parseInt(581)] = true;
          map[parseInt(1054)] = map[parseInt(2800)]();
        }
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
    }
  }, {
    "key" : `getCenterPosition`,
    "value" : function() {
      var primaryReplicas = this;
      var line = [];
      var z = 0;
      if ("EditableMarker" == this.editEntity.Type) {
        return this.editPositions[0];
      }
      this.editPositions.forEach(function(data) {
        var stringify = hahaha;
        data = primaryReplicas[stringify(1028)](data);
        line[stringify(2008)]([data.x, data.y]);
        if (z < data.z) {
          z = data.z;
        }
      });
      var tmp = turf.lineString(line);
      tmp = turf.bbox(tmp);
      tmp = turf.bboxPolygon(tmp);
      tmp = turf.center(tmp).geometry.coordinates;
      return Cesium.Cartesian3.fromDegrees(tmp[0], tmp[1], z);
    }
  }, {
    "key" : "moveEntityByOffset",
    "value" : function(target, object) {
      target = this.cartesian3ToPoint3D(target);
      object = this.cartesian3ToPoint3D(object);
      var mergeAxisLength = object.x - target.x;
      var SHIP_SPEED = object.y - target.y;
      var json = void 0;
      var layer_i = 0;
      for (; layer_i < this.editPositions.length; layer_i++) {
        (json = this.cartesian3ToPoint3D(this.editPositions[layer_i])).x += mergeAxisLength;
        json.y += SHIP_SPEED;
        this.editPositions[layer_i] = Cesium.Cartesian3.fromDegrees(json.x, json.y, json.z);
      }
    }
  }, {
    "key" : "createEditVertex",
    "value" : function() {
      var same = this;
      this.vertexEntities = [];
      this.editPositions.forEach(function(canCreateDiscussions, key) {
        var rel2Mstr = hahaha;
        var artistTrack = same[rel2Mstr(2276)][rel2Mstr(1319)][rel2Mstr(3010)]({
          "position" : new (Cesium[rel2Mstr(1679)])(function(canCreateDiscussions) {
            var now = rel2Mstr;
            return same[now(1484)][key];
          }, false),
          "type" : "EditVertex",
          "vertexIndex" : key,
          "point" : {
            "color" : Cesium.Color[rel2Mstr(3198)][rel2Mstr(2265)](0.4),
            "pixelSize" : 10,
            "outlineColor" : Cesium[rel2Mstr(2292)][rel2Mstr(2537)][rel2Mstr(2265)](0.4),
            "outlineWidth" : 3,
            "disableDepthTestDistance" : 2E3
          }
        });
        same[rel2Mstr(1220)][rel2Mstr(2008)](artistTrack);
      });
      if (1 != this.editPositions.length) {
        this.createEditMoveCenterEntity();
      }
    }
  }, {
    "key" : "createEditMoveCenterEntity",
    "value" : function() {
      var primaryReplicas = this;
      this.EditMoveCenterEntity = this.viewer.entities.add({
        "position" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
          var stringify = hahaha;
          return primaryReplicas[stringify(1054)];
        }, false),
        "type" : "EditMove",
        "point" : {
          "color" : Cesium.Color.RED.withAlpha(0.4),
          "pixelSize" : 10,
          "outlineColor" : Cesium.Color.WHITE.withAlpha(0.3),
          "outlineWidth" : 3,
          "disableDepthTestDistance" : 2E3
        }
      });
    }
  }, {
    "key" : `clearEditVertex`,
    "value" : function() {
      var same = this;
      if (this.vertexEntities) {
        this.vertexEntities.forEach(function(tObject3d) {
          var rel2Mstr = hahaha;
          same[rel2Mstr(2276)][rel2Mstr(1319)].remove(tObject3d);
        });
      }
      this.vertexEntities = [];
      this.viewer.entities.remove(this.EditMoveCenterEntity);
    }
  }, {
    "key" : "createMidVertex",
    "value" : function() {
      this.midVertexEntities = [];
      var layer_i = 0;
      for (; layer_i < this.editPositions.length; layer_i++) {
        var layer = this.editPositions[layer_i];
        var where = this.editPositions[layer_i + 1];
        where = this.midPosition(layer, where);
        where = this.viewer.entities.add({
          "position" : where,
          "type" : "EditMidVertex",
          "vertexIndex" : layer_i + 1,
          "point" : {
            "color" : Cesium.Color.LIMEGREEN.withAlpha(0.4),
            "pixelSize" : 10,
            "outlineColor" : Cesium.Color.YELLOW.withAlpha(0.4),
            "outlineWidth" : 3,
            "disableDepthTestDistance" : 2E3
          }
        });
        this.midVertexEntities.push(where);
      }
    }
  }, {
    "key" : `clearMidVertex`,
    "value" : function() {
      var lithe = this;
      if (this.midVertexEntities) {
        this.midVertexEntities.forEach(function(mmCoreSplitViewBlock) {
          var resolve = hahaha;
          lithe.viewer[resolve(1319)][resolve(508)](mmCoreSplitViewBlock);
        });
      }
      this.midVertexEntities = [];
    }
  }, {
    "key" : "cartesian3ToPoint3D",
    "value" : function(target) {
      return target = Cesium.Cartographic.fromCartesian(target), {
        "x" : Cesium.Math.toDegrees(target.longitude),
        "y" : Cesium.Math.toDegrees(target.latitude),
        "z" : target.height
      };
    }
  }, {
    "key" : "midPosition",
    "value" : function(object, target) {
      if (!object || !target) {
        return null;
      }
      return object = this.cartesian3ToPoint3D(object), target = this.cartesian3ToPoint3D(target), target = {
        "x" : (object.x + target.x) / 2,
        "y" : (object.y + target.y) / 2,
        "z" : (object.z + target.z) / 2
      }, Cesium.Cartesian3.fromDegrees(target.x, target.y, target.z);
    }
  }]);
  entryToSend = dragLeave;
  appendCSS(`.LocationPlot-container {\n    min-height: 65px;\n    min-width: 186px;\n    background: #e3eee59e;\n    position: absolute;\n    left: 0px;\n    bottom: 0px;\n    cursor: default;\n    padding: 0px 2px 5px 5px;\n    border: 1px solid #9c9944e8;\n}\n\n.LocationPlot-container::before {\n    position: absolute;\n    content: "";\n    left: 50%;\n    bottom: -50px;\n    height: 48px;\n    border-left: 2px dashed #c5e22770;\n    pointer-events: none;\n}\n\n.LocationPlot-container .info-item-close {\n    position: relative;\n    height: 15px;\n}\n\n.LocationPlot-container .info-close {\n    display: block;\n    height: 15px;\n    width: 15px;\n    position: absolute;\n    right: 0px;\n    background: #dc9e9e4d;\n    line-height: 15px;\n    text-align: center;\n}\n\n.LocationPlot-container .info-close:hover {\n    background: #e01c1c88;\n}`, 
  {});
  expect(reset, [{
    "key" : `createDom`,
    "value" : function() {
      this.container = document.createElement("div");
      this.container.classList.add("LocationPlot-container");
      this.container.innerHTML = ' <div class="info-item info-item-close">\n         <span class="info-close" title="\u5173\u95ed" id=\'closeId\'>\u00d7</span>\n       </div>\n       <div class="info-item">\n         <span class="info-label">\u7ecf\u5ea6\uff1a</span>\n         <span class="info-label lonId"  >{{ point.x.toFixed(10)}}</span>\n       </div>\n       <div class="info-item">\n         <span class="info-label">\u7eac\u5ea6\uff1a</span>\n         <span class="info-label latId"  >{{point.y.toFixed(10)}}</span>\n       </div>\n       <div class="info-item">\n         <span class="info-label">\u9ad8\u5ea6\uff1a</span>\n         <span class="info-label altId" >{{point.z.toFixed(10)}}</span>\n       </div>';
    }
  }, {
    "key" : `updatePosition`,
    "value" : function(value) {
      this.position = value;
      value = Cesium.Cartographic.fromCartesian(this.position);
      value = {
        "x" : Cesium.Math.toDegrees(value.longitude),
        "y" : Cesium.Math.toDegrees(value.latitude),
        "z" : value.height
      };
      this.setValue(value);
    }
  }, {
    "key" : `setValue`,
    "value" : function(target) {
      this.container.getElementsByClassName("lonId")[0].innerHTML = target.x;
      this.container.getElementsByClassName("latId")[0].innerHTML = target.y;
      this.container.getElementsByClassName("altId")[0].innerHTML = target.z;
    }
  }, {
    "key" : `addBillboard`,
    "value" : function() {
      var primaryReplicas = this;
      this.locationBillboard = this.viewer.entities.add({
        "position" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
          var stringify = hahaha;
          return primaryReplicas[stringify(586)];
        }, false),
        "type" : "PositionPick",
        "index" : this.index,
        "billboard" : {
          "image" : this.options.imgUrl,
          "scaleByDistance" : new Cesium["NearFarScalar"](300, 1, 1200, 0.4),
          "distanceDisplayCondition" : new Cesium["DistanceDisplayCondition"](0, 1E4),
          "verticalOrigin" : Cesium.VerticalOrigin.BOTTOM
        }
      });
    }
  }, {
    "key" : "addPostRender",
    "value" : function() {
      this.viewer.scene.postRender.addEventListener(this.postRender, this);
    }
  }, {
    "key" : `postRender`,
    "value" : function() {
      var item;
      var cw;
      if (this.container && this.container.style) {
        cw = this.viewer.scene.canvas.height;
        item = new Cesium["Cartesian2"];
        Cesium.SceneTransforms.wgs84ToWindowCoordinates(this.viewer.scene, this.position, item);
        this.container.style.position = "absolute";
        this.container.style.bottom = cw - item.y + 70 + "px";
        cw = this.container.offsetWidth;
        this.container.style.left = item.x - cw / 2 + "px";
        if (4E3 < this.viewer.camera.positionCartographic.height) {
          this.container.style.display = "none";
        } else {
          this.container.style.display = "block";
        }
      }
    }
  }, {
    "key" : `initEvents`,
    "value" : function() {
      var frontpageItems = this;
      this.eventHandler = new Cesium["ScreenSpaceEventHandler"](this.viewer.scene.canvas);
      this.registerMouseEvents();
      this.container.getElementsByClassName("info-close")[0].onclick = function(branch) {
        var parseInt = hahaha;
        frontpageItems[parseInt(508)]();
      };
    }
  }, {
    "key" : `registerMouseEvents`,
    "value" : function() {
      this.initLeftDownEventHandler();
      this.initMouseMoveEventHandler();
      this.initLeftUpEventHandler();
    }
  }, {
    "key" : `unRegisterMouseEvents`,
    "value" : function() {
      this.eventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOWN);
      this.eventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_UP);
      this.eventHandler.removeInputAction(Cesium.ScreenSpaceEventType.MOUSE_MOVE);
      this.eventHandler.removeInputAction(Cesium.ScreenSpaceEventType.RIGHT_CLICK);
    }
  }, {
    "key" : "initLeftDownEventHandler",
    "value" : function() {
      var o = this;
      this.eventHandler.setInputAction(function(data) {
        data = o.viewer.scene.pick(data.position);
        if (data && data.id && data.id.type && "PositionPick" == data.id.type && data.id.index == o.index) {
          o.isEditing = true;
          o.viewer.scene.screenSpaceCameraController.enableRotate = false;
          o.viewer.enableCursorStyle = false;
          o.viewer._element.style.cursor = "";
          document.body.style.cursor = "move";
        }
      }, Cesium.ScreenSpaceEventType.LEFT_DOWN);
    }
  }, {
    "key" : `initLeftUpEventHandler`,
    "value" : function() {
      var same = this;
      this.eventHandler.setInputAction(function(canCreateDiscussions) {
        var rel2Mstr = hahaha;
        same[rel2Mstr(3088)] = false;
        same[rel2Mstr(2276)][rel2Mstr(1633)] = true;
        document[rel2Mstr(1494)][rel2Mstr(1998)][rel2Mstr(737)] = rel2Mstr(1654);
        same[rel2Mstr(2276)][rel2Mstr(2758)][rel2Mstr(2190)][rel2Mstr(1218)] = true;
      }, Cesium.ScreenSpaceEventType.LEFT_UP);
    }
  }, {
    "key" : "initMouseMoveEventHandler",
    "value" : function() {
      var same = this;
      this.eventHandler.setInputAction(function(el) {
        var rel2Mstr = hahaha;
        el = same[rel2Mstr(2276)][rel2Mstr(2758)][rel2Mstr(1238)](el[rel2Mstr(2840)]);
        if (el && same[rel2Mstr(3088)]) {
          same.updatePosition(el);
        }
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
    }
  }, {
    "key" : `setSelected`,
    "value" : function(name) {
      this.vmInstance.isSelected = name || false;
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.unRegisterMouseEvents();
      this.viewer.entities.remove(this.locationBillboard);
      this.viewer.cesiumWidget.container.removeChild(this.container);
      this.viewer.scene.postRender.removeEventListener(this.postRender, this);
    }
  }]);
  pos = reset;
  expect(expand, [{
    "key" : `initEvents`,
    "value" : function() {
      this.handler = new Cesium["ScreenSpaceEventHandler"](this.viewer.scene.canvas);
      this.MeasureStartEvent = new Cesium.Event;
      this.MeasureEndEvent = new Cesium.Event;
    }
  }, {
    "key" : `activate`,
    "value" : function() {
      this.deactivate();
      this.registerEvents();
      this.viewer.enableCursorStyle = false;
      this.viewer._element.style.cursor = "default";
      this.isMeasure = true;
      this.circleRadius = 0.1;
      this.measureHeight = 0;
      this.positions = [];
    }
  }, {
    "key" : "deactivate",
    "value" : function() {
      if (this.isMeasure) {
        this.unRegisterEvents();
        this.viewer._element.style.cursor = "pointer";
        this.viewer.enableCursorStyle = true;
        this.isMeasure = false;
      }
    }
  }, {
    "key" : `clear`,
    "value" : function() {
      var same = this;
      this.viewer.entities.remove(this.lineEntity);
      this.lineEntity = void 0;
      this.viewer.entities.remove(this.labelEntity);
      this.labelEntity = void 0;
      this.removeCircleEntity();
      this.vertexEntities.forEach(function(mmCoreSplitViewBlock) {
        var rel2Mstr = hahaha;
        same[rel2Mstr(2276)][rel2Mstr(1319)][rel2Mstr(508)](mmCoreSplitViewBlock);
      });
      this.vertexEntities = [];
    }
  }, {
    "key" : `createLineEntity`,
    "value" : function() {
      var primaryReplicas = this;
      this.lineEntity = this.viewer.entities.add({
        "polyline" : {
          "positions" : new Cesium.CallbackProperty(function(canCreateDiscussions) {
            var stringify = hahaha;
            return primaryReplicas[stringify(1707)];
          }, false),
          "width" : 2,
          "material" : Cesium.Color.YELLOW,
          "depthFailMaterial" : new Cesium["PolylineDashMaterialProperty"]({
            "color" : Cesium.Color.RED
          })
        }
      });
    }
  }, {
    "key" : "createLabel",
    "value" : function() {
      var same = this;
      this.labelEntity = this.viewer.entities.add({
        "position" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
          var rel2Mstr = hahaha;
          return same[rel2Mstr(1707)][same[rel2Mstr(1707)][rel2Mstr(2189)] - 1];
        }, false),
        "label" : {
          "text" : "",
          "scale" : 0.5,
          "font" : "normal 40px MicroSoft YaHei",
          "distanceDisplayCondition" : new Cesium["DistanceDisplayCondition"](0, 5E3),
          "scaleByDistance" : new Cesium["NearFarScalar"](500, 1, 1500, 0.4),
          "verticalOrigin" : Cesium.VerticalOrigin.BOTTOM,
          "style" : Cesium.LabelStyle.FILL_AND_OUTLINE,
          "pixelOffset" : new Cesium["Cartesian2"](0, -30),
          "outlineWidth" : 9,
          "outlineColor" : Cesium.Color.WHITE
        }
      });
    }
  }, {
    "key" : "createVertex",
    "value" : function(name) {
      var primaryReplicas = this;
      var falseySection = this.viewer.entities.add({
        "position" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
          var stringify = hahaha;
          return primaryReplicas[stringify(1707)][name];
        }, false),
        "type" : "MeasureHeightVertex",
        "point" : {
          "color" : Cesium.Color.FUCHSIA,
          "pixelSize" : 6
        }
      });
      this.vertexEntities.push(falseySection);
    }
  }, {
    "key" : "createCircleEntitiy",
    "value" : function() {
      var require = this;
      this.circleEntity = this.viewer.entities.add({
        "position" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
          var resolve = hahaha;
          return require[resolve(1707)][require.positions[resolve(2189)] - 1];
        }, false),
        "ellipse" : {
          "height" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
            var resolve = hahaha;
            return cartesian = require[resolve(1707)][require[resolve(1707)].length - 1], Cesium[resolve(1543)].fromCartesian(cartesian)[resolve(1132)];
            var cartesian;
          }, false),
          "semiMinorAxis" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
            var resolve = hahaha;
            return require[resolve(2861)];
          }, false),
          "semiMajorAxis" : new Cesium.CallbackProperty(function(canCreateDiscussions) {
            var resolve = hahaha;
            return require[resolve(2861)];
          }, false),
          "material" : Cesium.Color.YELLOW.withAlpha(0.5)
        }
      });
    }
  }, {
    "key" : `removeCircleEntity`,
    "value" : function() {
      this.viewer.entities.remove(this.circleEntity);
      this.circleEntity = void 0;
    }
  }, {
    "key" : `registerEvents`,
    "value" : function() {
      this.leftClickEvent();
      this.rightClickEvent();
      this.mouseMoveEvent();
    }
  }, {
    "key" : `leftClickEvent`,
    "value" : function() {
      var o = this;
      this.handler.setInputAction(function(modules) {
        var camelize = hahaha;
        o.viewer._element.style[camelize(737)] = camelize(1654);
        var options;
        var numberStr = o[camelize(2276)].scene.pickPosition(modules[camelize(586)]);
        if (!numberStr) {
          options = o[camelize(2276)][camelize(2758)][camelize(2359)][camelize(1923)];
          numberStr = o[camelize(2276)].scene.camera[camelize(1080)](modules[camelize(586)], options);
        }
        if (numberStr) {
          if (0 == o[camelize(1707)].length) {
            o[camelize(1707)].push(numberStr);
            o[camelize(2364)](0);
            o[camelize(2507)]();
            o[camelize(2473)]();
            o[camelize(2682)]();
          } else {
            o[camelize(1173)]();
          }
        }
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
    }
  }, {
    "key" : `mouseMoveEvent`,
    "value" : function() {
      var data = this;
      this.handler.setInputAction(function(currentItems) {
        var parseInt = hahaha;
        var parameter;
        if (data.isMeasure) {
          data[parseInt(2276)][parseInt(2530)][parseInt(1998)].cursor = "default";
          if (parameter = (parameter = data[parseInt(2276)][parseInt(2758)][parseInt(1238)](currentItems[parseInt(2840)])) || data[parseInt(2276)][parseInt(2758)][parseInt(1306)][parseInt(1080)](currentItems[parseInt(1108)], data[parseInt(2276)].scene[parseInt(2359)][parseInt(1923)])) {
            data[parseInt(1328)](parameter);
          }
        }
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
    }
  }, {
    "key" : "handleMoveEvent",
    "value" : function(target) {
      var tmp;
      var e_total;
      var row;
      if (!(this.positions.length < 1)) {
        tmp = positionNode(this.positions[0]);
        e_total = (row = positionNode(target))[2] - tmp[2];
        tmp[2] = row[2];
        row = Cesium.Cartesian3.fromDegrees(tmp[0], tmp[1], row[2]);
        if (this.positions.length < 2) {
          this.positions.push(row);
          this.createVertex(1);
        } else {
          this.positions[1] = row;
          this.measureHeight = e_total.toFixed(3);
          this.labelEntity.label.text = "\u9ad8\u5ea6\uff1a" + this.measureHeight + " \u7c73";
        }
        this.circleRadius = inverse(this.positions[0], target);
      }
    }
  }, {
    "key" : `rightClickEvent`,
    "value" : function() {
      var that = this;
      this.handler.setInputAction(function(canCreateDiscussions) {
        if (that.isMeasure) {
          that.deactivate();
          that.clear();
        }
      }, Cesium.ScreenSpaceEventType.RIGHT_CLICK);
    }
  }, {
    "key" : "measureEnd",
    "value" : function() {
      this.deactivate();
      this.MeasureEndEvent.raiseEvent(this.measureHeight);
    }
  }, {
    "key" : "unRegisterEvents",
    "value" : function() {
      this.handler.removeInputAction(Cesium.ScreenSpaceEventType.RIGHT_CLICK);
      this.handler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_CLICK);
      this.handler.removeInputAction(Cesium.ScreenSpaceEventType.MOUSE_MOVE);
    }
  }]);
  name = expand;
  expect(Renderer, [{
    "key" : "initEvents",
    "value" : function() {
      this.handler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas);
      this.MeasureStartEvent = new Cesium.Event;
      this.MeasureEndEvent = new Cesium.Event;
    }
  }, {
    "key" : "activate",
    "value" : function() {
      this.deactivate();
      this.registerEvents();
      this.viewer.enableCursorStyle = false;
      this.viewer._element.style.cursor = "default";
      this.isMeasure = true;
      this.measureDistance = 0;
    }
  }, {
    "key" : "deactivate",
    "value" : function() {
      if (this.isMeasure) {
        this.unRegisterEvents();
        this.viewer._element.style.cursor = "pointer";
        this.viewer.enableCursorStyle = true;
        this.isMeasure = false;
        this.tempPositions = [];
        this.positions = [];
      }
    }
  }, {
    "key" : "clear",
    "value" : function() {
      var same = this;
      this.viewer.entities.remove(this.lineEntity);
      this.lineEntity = void 0;
      this.vertexEntities.forEach(function(mmCoreSplitViewBlock) {
        var rel2Mstr = hahaha;
        same[rel2Mstr(2276)][rel2Mstr(1319)][rel2Mstr(508)](mmCoreSplitViewBlock);
      });
      this.vertexEntities = [];
    }
  }, {
    "key" : `createLineEntity`,
    "value" : function() {
      var primaryReplicas = this;
      this.lineEntity = this.viewer.entities.add({
        "polyline" : {
          "positions" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
            var stringify = hahaha;
            return primaryReplicas[stringify(3119)];
          }, false),
          "width" : 2,
          "material" : Cesium.Color.YELLOW,
          "depthFailMaterial" : Cesium.Color.YELLOW
        }
      });
    }
  }, {
    "key" : "createVertex",
    "value" : function() {
      var falseySection = this.viewer.entities.add({
        "position" : this.positions[this.positions.length - 1],
        "id" : "MeasureDistanceVertex" + this.positions[this.positions.length - 1],
        "type" : "MeasureDistanceVertex",
        "label" : {
          "text" : fix(this.positions) + "\u7c73",
          "scale" : 0.5,
          "font" : "normal 24px MicroSoft YaHei",
          "distanceDisplayCondition" : new Cesium["DistanceDisplayCondition"](0, 5E3),
          "scaleByDistance" : new Cesium["NearFarScalar"](1E4, 1, 3E4, 0.4),
          "verticalOrigin" : Cesium.VerticalOrigin.BOTTOM,
          "style" : Cesium.LabelStyle.FILL_AND_OUTLINE,
          "pixelOffset" : new Cesium["Cartesian2"](0, -30),
          "outlineWidth" : 9,
          "outlineColor" : Cesium.Color.WHITE
        },
        "point" : {
          "color" : Cesium.Color.FUCHSIA,
          "pixelSize" : 8,
          "disableDepthTestDistance" : 500
        }
      });
      this.vertexEntities.push(falseySection);
    }
  }, {
    "key" : `createStartEntity`,
    "value" : function() {
      var falseySection = this.viewer.entities.add({
        "position" : this.positions[0],
        "type" : "MeasureDistanceVertex",
        "billboard" : {
          "image" : this.options.startImgUrl,
          "scaleByDistance" : new Cesium["NearFarScalar"](3E3, 1, 12E3, 0.4),
          "distanceDisplayCondition" : new Cesium.DistanceDisplayCondition(0, 1E4),
          "verticalOrigin" : Cesium.VerticalOrigin.BOTTOM
        },
        "point" : {
          "color" : Cesium.Color.FUCHSIA,
          "pixelSize" : 6
        }
      });
      this.vertexEntities.push(falseySection);
    }
  }, {
    "key" : `createEndEntity`,
    "value" : function() {
      var shortenTask = this.viewer.entities.getById("MeasureDistanceVertex" + this.positions[this.positions.length - 1]);
      this.viewer.entities.remove(shortenTask);
      this.viewer.entities.remove(this.moveVertexEntity);
      shortenTask = this.viewer.entities.add({
        "position" : this.positions[this.positions.length - 1],
        "type" : "MeasureDistanceVertex",
        "label" : {
          "text" : "\u603b\u8ddd\u79bb\uff1a" + fix(this.positions) + "\u7c73",
          "scale" : 0.5,
          "font" : "normal 26px MicroSoft YaHei",
          "distanceDisplayCondition" : new Cesium["DistanceDisplayCondition"](0, 5E3),
          "scaleByDistance" : new Cesium.NearFarScalar(1E3, 1, 3E3, 0.4),
          "verticalOrigin" : Cesium.VerticalOrigin.BOTTOM,
          "style" : Cesium.LabelStyle.FILL_AND_OUTLINE,
          "pixelOffset" : new Cesium["Cartesian2"](0, -50),
          "outlineWidth" : 9,
          "outlineColor" : Cesium.Color.WHITE,
          "eyeOffset" : new Cesium.Cartesian3(0, 0, -10)
        },
        "billboard" : {
          "image" : this.options.endImgUrl,
          "scaleByDistance" : new Cesium.NearFarScalar(3E3, 1, 12E3, 0.4),
          "distanceDisplayCondition" : new Cesium.DistanceDisplayCondition(0, 1E4),
          "verticalOrigin" : Cesium.VerticalOrigin.BOTTOM
        },
        "point" : {
          "color" : Cesium.Color.FUCHSIA,
          "pixelSize" : 6
        }
      });
      this.vertexEntities.push(shortenTask);
    }
  }, {
    "key" : `registerEvents`,
    "value" : function() {
      this.leftClickEvent();
      this.rightClickEvent();
      this.mouseMoveEvent();
    }
  }, {
    "key" : "leftClickEvent",
    "value" : function() {
      var colData = this;
      this.handler.setInputAction(function(currentItems) {
        var parseInt = hahaha;
        colData[parseInt(2276)]._element[parseInt(1998)][parseInt(737)] = parseInt(1654);
        var ellipsoid;
        var boundingSphere = colData[parseInt(2276)][parseInt(2758)][parseInt(1238)](currentItems[parseInt(586)]);
        if (boundingSphere || (ellipsoid = colData[parseInt(2276)][parseInt(2758)].globe.ellipsoid, boundingSphere = colData[parseInt(2276)][parseInt(2758)].camera[parseInt(1080)](currentItems[parseInt(586)], ellipsoid)), boundingSphere) {
          if (colData[parseInt(1707)][parseInt(2008)](boundingSphere), 1 == colData[parseInt(1707)][parseInt(2189)]) {
            return colData[parseInt(2507)](), void colData[parseInt(1644)]();
          }
          colData[parseInt(2364)]();
        }
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
    }
  }, {
    "key" : `mouseMoveEvent`,
    "value" : function() {
      var o = this;
      this.handler.setInputAction(function(currentItems) {
        var parseInt = hahaha;
        var http;
        if (o[parseInt(979)]) {
          o[parseInt(2276)][parseInt(2530)][parseInt(1998)].cursor = parseInt(1654);
          if (http = (http = o[parseInt(2276)][parseInt(2758)][parseInt(1238)](currentItems[parseInt(2840)])) || o[parseInt(2276)][parseInt(2758)][parseInt(1306)][parseInt(1080)](currentItems[parseInt(1108)], o.viewer[parseInt(2758)].globe[parseInt(1923)])) {
            o[parseInt(1328)](http);
          }
        }
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
    }
  }, {
    "key" : `handleMoveEvent`,
    "value" : function(name) {
      if (!(this.positions.length < 1)) {
        this.tempPositions = this.positions.concat(name);
      }
    }
  }, {
    "key" : `rightClickEvent`,
    "value" : function() {
      var obj = this;
      this.handler.setInputAction(function(canCreateDiscussions) {
        var parseInt = hahaha;
        if (!obj[parseInt(979)] || obj[parseInt(1707)][parseInt(2189)] < 1) {
          obj.deactivate();
          obj[parseInt(2822)]();
        } else {
          obj.createEndEntity();
          obj[parseInt(468)][parseInt(1562)] = {
            "positions" : obj[parseInt(1707)],
            "width" : 2,
            "material" : Cesium[parseInt(2292)][parseInt(2537)],
            "depthFailMaterial" : Cesium[parseInt(2292)][parseInt(2537)]
          };
          obj.measureEnd();
        }
      }, Cesium.ScreenSpaceEventType.RIGHT_CLICK);
    }
  }, {
    "key" : `measureEnd`,
    "value" : function() {
      this.deactivate();
      this.MeasureEndEvent.raiseEvent(this.measureDistance);
    }
  }, {
    "key" : `unRegisterEvents`,
    "value" : function() {
      this.handler.removeInputAction(Cesium.ScreenSpaceEventType.RIGHT_CLICK);
      this.handler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_CLICK);
      this.handler.removeInputAction(Cesium.ScreenSpaceEventType.MOUSE_MOVE);
    }
  }]);
  frame = Renderer;
  expect(header, [{
    "key" : `initEvents`,
    "value" : function() {
      this.handler = new Cesium["ScreenSpaceEventHandler"](this.viewer.scene.canvas);
      this.MeasureStartEvent = new Cesium.Event;
      this.MeasureEndEvent = new Cesium.Event;
    }
  }, {
    "key" : `activate`,
    "value" : function() {
      this.deactivate();
      this.registerEvents();
      this.viewer.enableCursorStyle = false;
      this.viewer._element.style.cursor = "default";
      this.isMeasure = true;
      this.measureArea = 0;
    }
  }, {
    "key" : `deactivate`,
    "value" : function() {
      if (this.isMeasure) {
        this.unRegisterEvents();
        this.viewer._element.style.cursor = "pointer";
        this.viewer.enableCursorStyle = true;
        this.isMeasure = false;
        this.tempPositions = [];
        this.positions = [];
        this.height = void 0;
      }
    }
  }, {
    "key" : `clear`,
    "value" : function() {
      var lithe = this;
      this.viewer.entities.remove(this.polygonEntity);
      this.polygonEntity = void 0;
      this.vertexEntities.forEach(function(mmCoreSplitViewBlock) {
        var resolve = hahaha;
        lithe.viewer[resolve(1319)][resolve(508)](mmCoreSplitViewBlock);
      });
      this.vertexEntities = [];
      this.viewer.entities.remove(this.mesureResultEntity);
      this.mesureResultEntity = void 0;
      this.height = void 0;
    }
  }, {
    "key" : `createPolygonEntity`,
    "value" : function() {
      var r = this;
      this.polygonEntity = this.viewer.entities.add({
        "polygon" : {
          "hierarchy" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
            var put_rows = hahaha;
            return new Cesium.PolygonHierarchy(r[put_rows(3119)]);
          }, false),
          "material" : Cesium.Color.RED.withAlpha(0.4),
          "perPositionHeight" : true
        },
        "polyline" : {
          "positions" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
            var put_rows = hahaha;
            return r[put_rows(3119)].concat(r[put_rows(3119)][0]);
          }, false),
          "width" : 1,
          "material" : new Cesium["PolylineDashMaterialProperty"]({
            "color" : Cesium.Color.YELLOW
          }),
          "depthFailMaterial" : new Cesium["PolylineDashMaterialProperty"]({
            "color" : Cesium.Color.YELLOW
          })
        }
      });
    }
  }, {
    "key" : `createVertex`,
    "value" : function() {
      var falseySection = this.viewer.entities.add({
        "position" : this.positions[this.positions.length - 1],
        "type" : "MeasureAreaVertex",
        "point" : {
          "color" : Cesium.Color.FUCHSIA,
          "pixelSize" : 8,
          "disableDepthTestDistance" : 500
        }
      });
      this.vertexEntities.push(falseySection);
    }
  }, {
    "key" : `createResultLabel`,
    "value" : function() {
      var rpm_traffic = this;
      this.mesureResultEntity = this.viewer.entities.add({
        "position" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
          var now = hahaha;
          return rpm_traffic[now(2800)]();
        }, false),
        "type" : "MeasureAreaResult",
        "label" : {
          "text" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
            var now = hahaha;
            return "\u9762\u79ef" + loaded(rpm_traffic[now(3119)]) + now(2612);
          }, false),
          "scale" : 0.5,
          "font" : "normal 28px MicroSoft YaHei",
          "distanceDisplayCondition" : new Cesium["DistanceDisplayCondition"](0, 5E3),
          "scaleByDistance" : new Cesium["NearFarScalar"](1E3, 1, 3E3, 0.4),
          "verticalOrigin" : Cesium.VerticalOrigin.BOTTOM,
          "style" : Cesium.LabelStyle.FILL_AND_OUTLINE,
          "pixelOffset" : new Cesium.Cartesian2(0, -30),
          "outlineWidth" : 9,
          "outlineColor" : Cesium.Color.YELLOW
        }
      });
    }
  }, {
    "key" : "getCenterPosition",
    "value" : function() {
      var primaryReplicas = this;
      var line = [];
      if (this.tempPositions.length < 3) {
        return this.tempPositions[0];
      }
      this.tempPositions.forEach(function(obj) {
        var stringify = hahaha;
        obj = primaryReplicas[stringify(1028)](obj);
        line.push([obj.x, obj.y]);
      });
      var tmp = turf.lineString(line);
      tmp = turf.bbox(tmp);
      tmp = turf.bboxPolygon(tmp);
      tmp = turf.center(tmp).geometry.coordinates;
      return Cesium.Cartesian3.fromDegrees(tmp[0], tmp[1], this.height + 0.3);
    }
  }, {
    "key" : "registerEvents",
    "value" : function() {
      this.leftClickEvent();
      this.rightClickEvent();
      this.mouseMoveEvent();
    }
  }, {
    "key" : `leftClickEvent`,
    "value" : function() {
      var _this = this;
      this.handler.setInputAction(function(currentItems) {
        var parseInt = hahaha;
        _this[parseInt(2276)][parseInt(2530)][parseInt(1998)][parseInt(737)] = parseInt(1654);
        var elementClasses;
        var _descriptor3 = _this.viewer[parseInt(2758)][parseInt(1238)](currentItems[parseInt(586)]);
        if (!_descriptor3) {
          elementClasses = _this[parseInt(2276)][parseInt(2758)].globe[parseInt(1923)];
          _descriptor3 = _this.viewer[parseInt(2758)][parseInt(1306)][parseInt(1080)](currentItems[parseInt(586)], elementClasses);
        }
        if (_descriptor3) {
          _this[parseInt(1707)][parseInt(2008)](_descriptor3);
          _this[parseInt(1132)] = _this[parseInt(1313)](_this.positions, _this[parseInt(1132)]);
          if (1 == _this[parseInt(1707)][parseInt(2189)]) {
            _this[parseInt(1910)]();
          }
          _this[parseInt(2364)]();
        }
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
    }
  }, {
    "key" : `mouseMoveEvent`,
    "value" : function() {
      var skipList = this;
      this.handler.setInputAction(function(primaryReplicas) {
        var stringify = hahaha;
        var connectorName;
        if (skipList[stringify(979)]) {
          skipList[stringify(2276)][stringify(2530)][stringify(1998)][stringify(737)] = stringify(1654);
          if (connectorName = (connectorName = skipList[stringify(2276)][stringify(2758)][stringify(1238)](primaryReplicas[stringify(2840)])) || skipList[stringify(2276)][stringify(2758)][stringify(1306)][stringify(1080)](primaryReplicas[stringify(1108)], skipList[stringify(2276)][stringify(2758)].globe.ellipsoid)) {
            skipList.handleMoveEvent(connectorName);
          }
        }
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
    }
  }, {
    "key" : `handleMoveEvent`,
    "value" : function(name) {
      if (!(this.positions.length < 1)) {
        this.height = this.unifiedHeight(this.positions, this.height);
        this.tempPositions = this.positions.concat(name);
        if (3 <= this.tempPositions.length && !this.mesureResultEntity) {
          this.createResultLabel();
        }
      }
    }
  }, {
    "key" : `unifiedHeight`,
    "value" : function(name, value) {
      value = value || this.getPositionHeight(name[0]);
      var i = 0;
      for (; i < name.length; i++) {
        var url = name[i];
        var point = this.cartesian3ToPoint3D(url);
        name[i] = Cesium.Cartesian3.fromDegrees(point.x, point.y, value);
      }
      return value;
    }
  }, {
    "key" : `getPositionHeight`,
    "value" : function(target) {
      return Cesium.Cartographic.fromCartesian(target).height;
    }
  }, {
    "key" : `cartesian3ToPoint3D`,
    "value" : function(target) {
      return target = Cesium.Cartographic.fromCartesian(target), {
        "x" : Cesium.Math.toDegrees(target.longitude),
        "y" : Cesium.Math.toDegrees(target.latitude),
        "z" : target.height
      };
    }
  }, {
    "key" : `rightClickEvent`,
    "value" : function() {
      var obj = this;
      this.handler.setInputAction(function(canCreateDiscussions) {
        var parseInt = hahaha;
        if (!obj[parseInt(979)] || obj.positions.length < 3) {
          obj[parseInt(1983)]();
          obj[parseInt(2822)]();
        } else {
          obj.tempPositions = [][parseInt(439)](array(obj[parseInt(1707)]));
          obj[parseInt(2464)][parseInt(1562)] = {
            "positions" : obj[parseInt(1707)][parseInt(439)](obj[parseInt(1707)][0]),
            "width" : 2,
            "material" : Cesium[parseInt(2292)].YELLOW,
            "depthFailMaterial" : new Cesium.PolylineDashMaterialProperty({
              "color" : Cesium[parseInt(2292)][parseInt(2537)]
            })
          };
          obj.polygonEntity[parseInt(2544)][parseInt(753)] = new (Cesium[parseInt(1433)])(obj[parseInt(3119)]);
          obj.mesureResultEntity[parseInt(586)] = obj[parseInt(2800)]();
          obj[parseInt(1271)][parseInt(2820)][parseInt(2607)] = parseInt(2860) + loaded(obj.positions) + parseInt(2612);
          obj[parseInt(1173)]();
        }
      }, Cesium.ScreenSpaceEventType.RIGHT_CLICK);
    }
  }, {
    "key" : `measureEnd`,
    "value" : function() {
      this.deactivate();
      this.MeasureEndEvent.raiseEvent(this.measureArea);
    }
  }, {
    "key" : `unRegisterEvents`,
    "value" : function() {
      this.handler.removeInputAction(Cesium.ScreenSpaceEventType.RIGHT_CLICK);
      this.handler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_CLICK);
      this.handler.removeInputAction(Cesium.ScreenSpaceEventType.MOUSE_MOVE);
    }
  }]);
  location = header;
  xt3d.Map3dTools = {
    "EntityDraw" : k,
    "EntityEdit" : entryToSend,
    "PositionPick" : pos,
    "Measure" : {
      "Area" : location,
      "Distance" : frame,
      "Height" : name
    }
  };
  appendCSS(`.MultiFieldAdaptWindow-container {\n    position: absolute;\n    left: 0px;\n    bottom: 0px;\n    min-width: 350px;\n    min-height: 200px;\n    color: white;\n}\n\n.MultiFieldAdaptWindow-container::before {\n    position: absolute;\n    content: "";\n    top: 100%;\n    left: calc(50% - 20px);\n    border: 20px solid transparent;\n    border-top: 40px solid rgba(30, 32, 42, 0.5);\n}\n\n.MultiFieldAdaptWindow-header {\n    height: 30px;\n    line-height: 30px;\n    color: white;\n    min-width: 200px;\n    padding: 0px 10px;\n    background: #1a4879;\n    border-top-right-radius: 4px;\n    border-top-left-radius: 4px;\n    position: relative;\n    user-select: none;\n}\n\n.MultiFieldAdaptWindow-close {\n    position: absolute;\n    right: 1px;\n    font-size: 25px;\n    cursor: pointer;\n    width: 29px;\n    text-align: center;\n}\n\n.MultiFieldAdaptWindow-close:hover {\n    background: #dc2929b9;\n}\n\n.MultiFieldAdaptWindow-body {\n    padding: 5px;\n    background: linear-gradient( 0deg, rgba(30, 32, 42, 0.5), rgba(13, 16, 19, 0.7));\n    border: 1px solid rgb(29, 26, 26);\n    border-top: 0px;\n    border-bottom-right-radius: 4px;\n    border-bottom-left-radius: 4px;\n}\n\n.MultiFieldAdaptWindow-info-item {\n    margin: 14px 0px;\n    max-width: 350px;\n}\n\n.MultiFieldAdaptWindow-ifno-label {\n    display: inline-block;\n    min-width: 60px;\n    text-align: justify;\n    text-align-last: justify;\n    background: #fff6f625;\n}\n\n.MultiFieldAdaptWindow-ifno-text {\n    background: #fff6f60e;\n}`, 
  {});
  expect(select, [{
    "key" : `createDom`,
    "value" : function() {
      this.container = document.createElement("div");
      this.container.innerHTML = '  <div class="MultiFieldAdaptWindow-container" v-if="show">\n          <div class="MultiFieldAdaptWindow-header">\n            <span class="MultiFieldAdaptWindow-title">  ' + this.title + '</span>\n            <span class="MultiFieldAdaptWindow-close" title="\u5173\u95ed"  >\u00d7</span>\n          </div>\n          <div class="MultiFieldAdaptWindow-body">\n           \x3c!-- <div v-for="(field,index) in fields" :key="index" class="MultiFieldAdaptWindow-info-item">\n              <span class="MultiFieldAdaptWindow-ifno-label" :style="getFieldStyle()">{{field}}\uff1a</span>\n              <span class="MultiFieldAdaptWindow-ifno-text">{{formatValue(values[index])}}</span>\n            </div>--\x3e\n          </div>\n        </div>';
    }
  }, {
    "key" : "initDom",
    "value" : function() {
      var i = 0;
      for (; i < this.values.length; i++) {
        var bezierPreviewContainer = document.createElement("div");
        bezierPreviewContainer.classList.add("MultiFieldAdaptWindow-info-item");
        var item = document.createElement("span");
        item.classList.add("MultiFieldAdaptWindow-ifno-label");
        item.innerHTML = this.fields[i] + "\uff1a";
        bezierPreviewContainer.appendChild(item);
        (item = document.createElement("span")).classList.add("MultiFieldAdaptWindow-ifno-text");
        item.innerHTML = this.values[i];
        bezierPreviewContainer.appendChild(item);
        this.container.getElementsByClassName("MultiFieldAdaptWindow-body")[0].appendChild(bezierPreviewContainer);
      }
    }
  }, {
    "key" : `initEvent`,
    "value" : function() {
      var frontpageItems = this;
      this.container.getElementsByClassName("MultiFieldAdaptWindow-close")[0].onclick = function(branch) {
        var parseInt = hahaha;
        frontpageItems[parseInt(1471)]();
      };
    }
  }, {
    "key" : "addPostRender",
    "value" : function() {
      this.viewer.scene.postRender.addEventListener(this.postRender, this);
    }
  }, {
    "key" : "postRender",
    "value" : function() {
      var item;
      var width;
      if (this.container && this.container.style) {
        width = this.viewer.scene.canvas.height;
        item = new Cesium["Cartesian2"];
        Cesium.SceneTransforms.wgs84ToWindowCoordinates(this.viewer.scene, this.position, item);
        this.container.style.position = "absolute";
        this.container.style.bottom = width - item.y + 80 + "px";
        width = this.container.scrollWidth;
        this.container.style.left = item.x - width / 2 + "px";
      }
    }
  }, {
    "key" : `close`,
    "value" : function() {
      this.container.remove();
      this.viewer.scene.postRender.removeEventListener(this.postRender, this);
    }
  }]);
  init = select;
  appendCSS(`.device-status-container {\n    position: absolute;\n    left: 0px;\n    bottom: 0px;\n    min-width: 350px;\n    min-height: 200px;\n    color: white;\n    user-select: none;\n    pointer-events: none;\n}\n\n.device-status-container-green {\n    background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA3FpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTQyIDc5LjE2MDkyNCwgMjAxNy8wNy8xMy0wMTowNjozOSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1MDM4NzVjMS0xMmVmLTg2NDAtYTBhMS04MzBiY2MwMGRmYTAiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6ODkxQzg3MzdDQjFCMTFFQTg3QzhENTA3RDA0QTkyNkIiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6ODkxQzg3MzZDQjFCMTFFQTg3QzhENTA3RDA0QTkyNkIiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOmMwYjc4N2Q4LWY5MTYtNmQ0My05ZmI5LTlkNzYwN2M3NGMyNiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo1MDM4NzVjMS0xMmVmLTg2NDAtYTBhMS04MzBiY2MwMGRmYTAiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz44idiZAAAObElEQVR42uzdCXCU5R3H8T2yR67NQUIgxEAIh8AoeKCi0noAg1ZtsToqWGXGqdpWp45TPFtFOoM4KqO241iPEQvaFvHAVsYWRLwtptgKsSJRMAFCSEIuks2xu2+fJ9k4QLO7b/Luhvd9n+9n5m/Ivrsx87zz/PK++3/3eZ2apjkAqMlJAAAEAAACAAABAIAAAEAAACAAABAAAAgAAAQAAAIAgO0CYFrTPYwQYCOVecuP+t6V7EARtUaUTJX3o4+dG/1e43Ee5/Hj9viwHAFcIepXoi4Q1UHeAmodAbwiag6THzCVObE2JCsALhO1NHqocZjxBkxlY6wNaUn44fJw/1lRFzLOgLUYPQI4SdSfRV0tajvDCagVAGFRN4vazFACprUp2acAuaJKRO0Q9YWeFxxYsbXUU5z5itPtymB/AMkVaeveXnDz9KtjbJ6bzACQE/itaO3Q84LapR/l+Cbm/c0d8Jayq4Dk00KRpjib58Q6ChhsALhF/UlUlagHdE5+j3ds4K9y8ocOdYab133VooW4/BhIBm9ZwJNzUVl2gqfJLoAzGQGwQFSWqCsdca4u6lf/5L9dnuKsl9MK0k+OtPdEGldVNoUOdoTZbUByuLI9ht7HG+yL14m6WFS3vp/ufM4zOvM8rSeiNa7+opnJD5gsQHQ+72eiVkT/3aXnBQd/99ky75isBVpEczSt3dnSvae1h+EGjgtDXYBZou4TNVvv/+3gyn/91Dch9xZ5ktDyelVrcHtDF/sAOG7mGjkCKHP09fmr9Pyf6h6pWOAtz1nucDpcrW9/e7h964Eg4w8cV3OMHAFsFXVA1+R/6NPZvkm5TzldTk97RV1H26bqdsYeOO4MdQGq9Pz1P7Bi62Rfee6LzjSXr3NnU1fzq7vaGHfA3PScApwh6oZ4T6hd9vFI79jAGy6/O9C1p7X70Iv/bXFE6PUDdgiACY6+T/wNPPnlVX5lORvcWZ6inoMdoUMvVDZr3WFmP2Aem4wEQEx7b9/i7r3KL9c3IdzaHW58vrI5EuQyP8BkDHUBQqL8A20QE3+EvMpPi2ha46rK5nBTp6ELffxT8r2TP1lYPvnDa8oLbz0ln/0GJIWhFYE+EfVMvCfIK/169h8OGf0tS1aeV+zO9rpFsLgLb55eMP7lS0vTpxX42H+AIRuNBEC1o++TfymVv2hKjrc04D3qiGDqCH/Z2kvGijDIYx8CyacnAOSqP7ek8pfwlGSlFd0xc2Ss7eJ0oLDspR+U+CfledllwPAGgPwM//xU/hI588uynGkuZ7znpE8vzBj/2g/HFf5iBkcDwOCkpguQLG2bq9tF6bpwqPDnMwrHvXBRia8sx8N+BXSZa+oA6PqmpWffXe/XNTz1n4bg9oaEnx3IOL0oo3z9j8YV3HBSLvsWSMhQF0Cu9vv7VP52aQXp7hO3LpqQPXdsdv0T2xrqVlYcTPgit9M58vbTRo59dt4Y79gARwNAbKnpAoiJ2yC/Oj0uQ0cSoYZguPH5HY2+8lxf6TPzTtCCYW33NW9+27alJuFpQeas4kx5NJB/3dQc9jMwOIa6AOJ8PNIbAPHfv0v8S6SnOeseqWisuuS13cHP64Oj7j2zqOiOmYX1j29r3PvLd/ZpnfEvLRYB5Bx15xlF41ZfVJI1ewyrDgNJDICUdwEmvXdV+fi1l5Z2727pEX/5a/bf/1Gtf0KuT77r78r1uasufnV38/qq5oTvDZxalBGYX5bFbgWOYmhFoBZ5pJ3SFMrwuPzTRvi9pQFPd3Vrz+EtNR2HZxW3uwJeV/EDZ4/q/KKxs+aWzfub1+1qLXn8/OK0fP///d6hxmCobsWnB1s2fMO9CYGjGe4CpA3nbzvy9tMKAvPHBTwjMzy1D3x8QL43MHHzleO94qFd5639pnFVZeORz5dHB+IoYQ+THxiQoRWB5GIgD6fyt4t0hiIuf5pr/MuXjnVomubK9sr7DziCOxqCTWt3tjat+6q15KHvjSr+7TmjR1w3NW/3tRv2NovHci+fGGh7b297x6cHOtnHQEwxVwTScwQglwN7I6W/XnTxEFeWx9U/+Tsq6jr23/vBwf7te5e8e6D6xo01nhOyvSf+c9GEzHOKM+oerWjMPL0oPfuC0kz2MTB4eo4A5IIgC1J5FOBK77u5wZ5FG6q79rR0O11Op7yL0LHPO/zhvuCXp62pGr307MJRd59ZJEvrCms7v/+Xr9mVQGoCYJSoy1J6GhA9OOmuaesJN3dFEj29dulH9c2v7mqVt0SSpweRtu4IuxKIKel3B04JuQ5AqDGoa1GR4Of1XbLYt0BCc1MWAFpY63K6nT6nz+2Uh+ND+Rnyg0BtW2oOyxYg+wpIOkN3B47fBdC03mN4eTXgUBcDrLl1cy37CEgZk3cBABwXepcFX8JQAWoGgPxwzbUMFWBZhlYE0mKdPwCwBHOvCAQgpQytCLRP1DLGELAsQysCHRK1jjEE7EdPAIwRdR9DBagZAPIefVfE2qiFtN7LceWVgAwnYEopvS9A9LO8TgIAMCe6AIDC6AIACqMLAGBoASDfBHyQoQLUDAC5zv5ChgqwLHPfHRhAStEFABRmqAsg3wS8mzEELMtQF0DebeelmFtDkd6bcri8XAkIWI3hLsB36wC6mP+AHQOALgBgbXQBAIXRBQAUZqgLIG/Q+RvGELAsQ10A+S7/HxlDwH70BEC6qMcYKkDNAPCKWsxQAZZFFwBQWAq7AGEtKL+wJiBgWoa6AHKC3xZzq9Z7e2AHKwICpmWoC9AtahVjCNgPXQCAAIiLLgBgbYa6APLGHz7GELAsQ10AeSWgnzEELMtQF0C6iTEELGuj0QB4mjEE7EdvAPyBoQLUDYAbY23QIlrvmoBcCQiYVko/CxDu+0lcCwiYFCsCAQqjCwAojC4AgKEHAF0AQOEAuFpUgOECLMlwF0B+5p93+QFrogsAKMxwF0CuCBRkHAFLitkFSNP5A1bF3BJdE9DlS+MUAbAYvUcAckWg9AHfHNC0SO8/mP6AbQNgsaNvZSAA1sN9AQCF0QUAFEYXAFBYCrsAACxL7xHAg6LyGS5AzQBYKCqL4QIsiS4AoLAUdgEiWkfvD2JNQMCsDHcB7hZ1aMAtmiN6JSDzHzApw12AlxhDwH7oAgAEQEJ0AQDrogsAKIzPAgAKM9wFWCKqlXEELMlwF2AtYwjYj94jgPtEjWG4ADUD4ApHrDZgRGuXX5w+N+8nAOaUui6A9t3dgRllwKToAgAKM9wFWCZqH+MIWJLhLsA6xhCwH7oAAAGQUOwuAACzM9wFiDh4wxCwKsNdgDZR2YwjYEmGuwBvirqOcQQsaaPRANguqnjALeHomoBe7g4MWI3eAPixqMwY20K9/2X6A7YNgDNF+RguwJIMdwHkWgBPMI6AeTjTXM7M00f5e7/R5MdyYjLcBZCH+XsZcsA8kz9/4ZSAf0q+X+uJdIbqO5bFeTpdAMB2k39q3+Tv+rr5J0VLZm6M85IUdgEADN/kd7scg5z8cSWjCwBguCb/oik5yZr8gwmAmaL87ALAkpM/ZhdA78eB5VoAfCQYsOZf/qR0AWoH2qD1rwno5+7AgAkn/1mi1hg9AnhH1OWOvm7AQOHgcOf43P7J+V52GZA8mWeNTu9v9Q1x8r8uarHRAPhS1PnxnuCflOeTxS4DkmuIk//UIyb/W0YD4BJHjI8Da93h6lBT5052E5AaobqOXw/h3f5vRV0l6t24pxiaFvsKwmlN9/T/c2v06xnsDsDU5GF/kaj1A22szFt+1Pd63wQ8JOppxhYw/eSXE79L7wsMdwEAmGbyy3P+6+Od8w81APq7AADMaaIjwRt+A0laFwDAcTFd1NeiVg/lxXqPAOaJymWsAVORC/X8Q9SMof4AvQFwsqhTRN0V/V7eJ6DiiOJxHufx4X/8zeg5/wdDDQC9bUAZAONFbRNVLapQVOkRT63ncR7n8WF/XHbndg9mwh/bBtQbAABsYFABcEQInBs9/Ljt2B8AwLr0vgeQI2oCwwWoGQAACAAAdqL3QiDZZuATf4CiAdASLQAKngLILsBjDBegZgDQBQAUDgAABAAAO6ELABAACdEFABQ+BaALACgcAHQBAIUDAAABAMBO6AIABEBCdAEAhU8B6AIACgcAXQBA4QAAQAAAsBO6AAABkBBdAEDhUwC6AIDCAUAXAFA4AAAQAADshC4AQAAkRBcAUPgUgC4AoHAA0AUAFA4AAAQAADuhCwAQAAnRBQAUPgWgCwAoHAB0AQCFAwAAAQDATugCAARAQnQBAIVPAegCAAoHAF0AQOEAAEAAALATugAAAZAQXQBA4VMAugCAwgFAFwBQOAAAEAAA7IQuAEAAJEQXAFD4FIAuAKBwANAFABQOAAAEAAA7oQsAEAAJ0QUAFD4FoAsAKBwAdAEAhQMAAAEAwE7oAgAEQEJ0AQCFTwHoAgAKBwBdAEDhAABAAACwE7oAAAGQEF0AQOFTALoAgMIBQBcAUDgAABAAAOzEqWnad99Ma7on3ilAoaiqWE+ozFvOaAI2PQKQHYBaUeUMGaBOACwWtc3R9wbg9aLek3/sRV3J0AHWF+86gJWiLhB1U/TQX9aToi4U9aioz+KdEgCwbgAUiBonaraotmO2vS3qFFEawwfY8xSgQdTlA0z+fnLyzxC1niEE7BUA8q//czpe+6Wo+aK8DCNgnwAojJ77J9IpqltUOsMI2CcA9ooqEuVL8Fr5l//jOKcJACwYAHJCbxY1PcFr5V//eaIiDCNgnwCQLhO1VZQnxvZZolYzfIA9A0D+Vc929F30c4ejryXojJ4a3C/qFVFrGD7AngHQfyogjwSmivpE1J2iThKVGz0C+DvDB1hbohWBZKtv8TGPbWLYAHs46tOAAAgAAAQAAAIAAAEAgAAAQAAAIAAAEAAACAAABAAAAgCA6f1PgAEAhYJlHfRnlF0AAAAASUVORK5CYII=") no-repeat;\n}\n\n.device-status-container-yellow {\n    background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA3FpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTQyIDc5LjE2MDkyNCwgMjAxNy8wNy8xMy0wMTowNjozOSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1MDM4NzVjMS0xMmVmLTg2NDAtYTBhMS04MzBiY2MwMGRmYTAiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OEY3MENDOTFDQjFCMTFFQUI5QUNBMzQ1NUY2MDY0MTciIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OEY3MENDOTBDQjFCMTFFQUI5QUNBMzQ1NUY2MDY0MTciIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOmMwYjc4N2Q4LWY5MTYtNmQ0My05ZmI5LTlkNzYwN2M3NGMyNiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo1MDM4NzVjMS0xMmVmLTg2NDAtYTBhMS04MzBiY2MwMGRmYTAiLz4gPC9y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") no-repeat;\n}\n\n.device-title {\n    position: absolute;\n    left: 60px;\n    top: 32px;\n}\n\n.device-name {\n    position: absolute;\n    left: 30px;\n    top: 58px;\n}\n\n.device-num {\n    position: absolute;\n    left: 30px;\n    top: 80px;\n}\n\n.device-status {\n    position: absolute;\n    left: 30px;\n    top: 102px;\n}\n\n.device-status-t0 {\n    color: #FFE103;\n}\n\n.device-status-t1 {\n    color: #29EA77;\n}\n\n.device-status-t0:before {\n    display: inline-block;\n    width: 10px;\n    height: 10px;\n    border-radius: 50%;\n    content: "";\n    background: #FFE103;\n    margin-right: 10px;\n}\n\n.device-status-t1:before {\n    display: inline-block;\n    width: 10px;\n    height: 10px;\n    border-radius: 50%;\n    content: "";\n    background: #29EA77;\n    margin-right: 10px;\n}`, 
  {});
  expect(Layer, [{
    "key" : `createDom`,
    "value" : function() {
      this.container = document.createElement("div");
      this.container.classList.add("device-status-container");
      if (this.infos.status) {
        this.container.classList.add("device-status-container-green");
      } else {
        this.container.classList.add("device-status-container-yellow");
      }
      var el = document.createElement("div");
      el.classList.add("device-title");
      this.container.appendChild(el);
      el.innerHTML = this.infos.title;
      var scroller = document.createElement("div");
      scroller.classList.add("device-name");
      scroller.innerHTML = this.infos.name;
      this.container.appendChild(scroller);
      scroller.innerHTML = "\n        <span>\u8bbe\u5907\u540d\u79f0\uff1a</span>\n        <span>" + this.infos.name + "</span>";
      el = document.createElement("div");
      el.classList.add("device-num");
      el.innerHTML = this.infos.num;
      this.container.appendChild(el);
      el.innerHTML = "\n        <span>\u8bbe\u5907\u7f16\u53f7\uff1a</span>\n        <span>" + this.infos.num + "</span>";
      scroller = document.createElement("div");
      scroller.classList.add("device-status");
      this.container.appendChild(scroller);
      el = document.createElement("span");
      el.innerHTML = "\u8bbe\u5907\u72b6\u6001\uff1a";
      scroller.appendChild(el);
      el = document.createElement("span");
      el.innerHTML = this.infos.status ? "\u5728\u7ebf" : "\u79bb\u7ebf";
      scroller.appendChild(el);
      if (this.infos.status) {
        el.classList.add("device-status-t1");
      } else {
        el.classList.add("device-status-t0");
      }
    }
  }, {
    "key" : "addPostRender",
    "value" : function() {
      this.viewer.scene.postRender.addEventListener(this.postRender, this);
    }
  }, {
    "key" : `postRender`,
    "value" : function() {
      var scrollHeight;
      var target;
      if (this.container && this.container.style) {
        scrollHeight = this.viewer.scene.canvas.height;
        target = new Cesium["Cartesian2"];
        Cesium.SceneTransforms.wgs84ToWindowCoordinates(this.viewer.scene, this.position, target);
        this.container.style.position = "absolute";
        this.container.style.bottom = scrollHeight - target.y + 60 + "px";
        this.container.scrollWidth;
        this.container.style.left = target.x - 10 + "px";
      }
    }
  }, {
    "key" : `close`,
    "value" : function() {
      this.container.remove();
      this.viewer.scene.postRender.removeEventListener(this.postRender, this);
    }
  }]);
  data = Layer;
  appendCSS(`.leaflet-popup-container {\n    position: absolute;\n    text-align: center;\n}\n\n.leaflet-popup-close-button {\n    position: absolute;\n    top: 0;\n    right: 0;\n    padding: 4px 4px 0 0;\n    text-align: center;\n    width: 18px;\n    height: 14px;\n    font: 16px/14px Tahoma, Verdana, sans-serif;\n    color: #c3c3c3;\n    text-decoration: none;\n    font-weight: bold;\n    background: transparent;\n    cursor: pointer;\n}\n\n.leaflet-popup-content-wrapper {\n    text-align: center;\n    max-height: 200px;\n    overflow-y: auto;\n    background: rgba(63, 72, 84, 0.7);\n    box-shadow: 0 3px 14px rgb(0 0 0 / 40%);\n    padding: 1px;\n    text-align: left;\n    border-radius: 4px;\n    padding: 8px;\n    color: white;\n}\n\n.leaflet-popup-tip-container {\n    margin: 0 auto;\n    width: 40px;\n    height: 20px;\n    position: relative;\n    overflow: hidden;\n}\n\n.leaflet-popup-tip {\n    background: rgba(63, 72, 84, 0.7);\n    box-shadow: 0 3px 14px rgb(0 0 0 / 40%);\n    width: 17px;\n    height: 17px;\n    padding: 1px;\n    margin: -10px auto 0;\n    transform: rotate( 45deg);\n}`, 
  {});
  expect(done, [{
    "key" : `init`,
    "value" : function() {
      this.createDom();
      this.addEvent();
    }
  }, {
    "key" : `createDom`,
    "value" : function() {
      var frontpageItems = this;
      var container = document.createElement("div");
      container.classList.add("leaflet-popup-container");
      var item = document.createElement("span");
      item.innerHTML = "\u00d7";
      item.classList.add("leaflet-popup-close-button");
      container.appendChild(item);
      var suggestionsEl = document.createElement("div");
      suggestionsEl.classList.add("leaflet-popup-content-wrapper");
      container.appendChild(suggestionsEl);
      this.createContent(suggestionsEl);
      var bezierPreviewContainer = document.createElement("div");
      bezierPreviewContainer.classList.add("leaflet-popup-tip-container");
      container.appendChild(bezierPreviewContainer);
      var icon_div = document.createElement("div");
      icon_div.classList.add("leaflet-popup-tip");
      bezierPreviewContainer.appendChild(icon_div);
      this.$container = container;
      this.$body = suggestionsEl;
      this.viewer.cesiumWidget.container.append(container);
      item.onclick = function(branch) {
        var parseInt = hahaha;
        frontpageItems[parseInt(1471)]();
      };
    }
  }, {
    "key" : `createContent`,
    "value" : function(name) {
      var pix_color = "";
      var i = 0;
      for (; i < this.values.length; i++) {
        pix_color = pix_color + ('\n                <tr>\n                  <td><label style="color:#e0f102;">' + this.fields[i] + "</label>\uff1a" + this.values[i] + "</td>\n                </tr>");
      }
      var text = " <table>" + pix_color + "</table> ";
      name.innerHTML = text;
    }
  }, {
    "key" : `addEvent`,
    "value" : function() {
      this.viewer.scene.postRender.addEventListener(this.postRenderEvent, this);
    }
  }, {
    "key" : `postRenderEvent`,
    "value" : function() {
      var textWidth = this.viewer.scene.canvas.height;
      var handleCanvas = new Cesium["Cartesian2"];
      Cesium.SceneTransforms.wgs84ToWindowCoordinates(this.viewer.scene, this.position, handleCanvas);
      this.$container.style.bottom = textWidth - handleCanvas.y + 30 + "px";
      textWidth = this.$container.offsetWidth;
      this.$container.style.left = handleCanvas.x - textWidth / 2 + "px";
      if (4E3 < this.viewer.camera.positionCartographic.height) {
        this.$container.style.display = "none";
      } else {
        this.$container.style.display = "block";
      }
    }
  }, {
    "key" : `close`,
    "value" : function() {
      this.viewer.scene.postRender.removeEventListener(this.postRenderEvent, this);
      this.$container.remove();
    }
  }]);
  forced = done;
  appendCSS(`.popup3d1-container {\n    min-height: 200px;\n    min-width: 350px;\n    background: #3183bdb0;\n    position: absolute;\n    left: 0px;\n    bottom: 0px;\n    cursor: default;\n}\n\n.popup3d1-container::before {\n    position: absolute;\n    content: "";\n    top: 100%;\n    left: calc(50% - 20px);\n    border: 20px solid transparent;\n    border-top: 40px solid #3183bdb0;\n}\n\n.popup3d1-header {\n    color: white;\n    background: #2152bb;\n    height: 30px;\n    line-height: 30px;\n}\n\n.popup3d1-header-title {\n    display: inline-block;\n    height: 100%;\n    margin-left: 5px;\n}\n\n.popup3d1-close {\n    position: absolute;\n    right: 1px;\n    font-size: 25px;\n    cursor: pointer;\n    width: 29px;\n    text-align: center;\n}\n\n.popup3d1-close:hover {\n    background: #dc2929b9;\n}\n\n.popup3d1-body {\n    padding: 10px;\n    color: white;\n}`, 
  {});
  expect(test, [{
    "key" : "createDom",
    "value" : function() {
      this.container = document.createElement("div");
      this.container.innerHTML = '  <div class="popup3d1-container" v-if="show">\n          <div class="popup3d1-header">\n            <span class="popup3d1-header-title">  ' + this.title + '</span>\n            <span class="popup3d1-close" title="\u5173\u95ed"  >\u00d7</span>\n          </div>\n          <div class="popup3d1-body">\n          ' + this.html || `\u7a97\u53e3\u5185\u5bb9\n          </div>\n        </div>`;
    }
  }, {
    "key" : `initEvent`,
    "value" : function() {
      var frontpageItems = this;
      this.container.getElementsByClassName("popup3d1-close")[0].onclick = function(branch) {
        var parseInt = hahaha;
        frontpageItems[parseInt(1471)]();
      };
    }
  }, {
    "key" : "addPostRender",
    "value" : function() {
      this.viewer.scene.postRender.addEventListener(this.postRender, this);
    }
  }, {
    "key" : "postRender",
    "value" : function() {
      var scrollHeight;
      var target;
      if (this.container && this.container.style) {
        scrollHeight = this.viewer.scene.canvas.height;
        target = new Cesium["Cartesian2"];
        Cesium.SceneTransforms.wgs84ToWindowCoordinates(this.viewer.scene, this.position, target);
        this.container.style.position = "absolute";
        this.container.style.bottom = scrollHeight - target.y + 80 + "px";
        this.container.scrollWidth;
        this.container.style.left = target.x - 170 + "px";
      }
    }
  }, {
    "key" : `close`,
    "value" : function() {
      this.container.remove();
      this.viewer.scene.postRender.removeEventListener(this.postRender, this);
    }
  }]);
  mode = test;
  appendCSS(`.popup3d2-container {\n    width: 350px;\n    height: 200px;\n    background: #14193399;\n    position: absolute;\n    left: 0px;\n    bottom: 0px;\n    cursor: default;\n}\n\n.popup3d2-container::before {\n    content: "";\n    width: calc(100% + 22px);\n    height: 39px;\n    position: absolute;\n    bottom: -39px;\n    left: -22px;\n    background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAB4AAAAAlCAYAAACj1PQVAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyhpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTQ1IDc5LjE2MzQ5OSwgMjAxOC8wOC8xMy0xNjo0MDoyMiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTkgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MTJFMTU1RjExN0UzMTFFOTg3RTBFODdGNTY0NThGQkUiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MTJFMTU1RjIxN0UzMTFFOTg3RTBFODdGNTY0NThGQkUiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDoxMkUxNTVFRjE3RTMxMUU5ODdFMEU4N0Y1NjQ1OEZCRSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDoxMkUxNTVGMDE3RTMxMUU5ODdFMEU4N0Y1NjQ1OEZCRSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pj97JFoAAAV9SURBVHja7N1faJ1nHQfw33nzpuekaZfWNFmbLHXWdf7DWgvebF4M0SEZhTG8mKvFyzG9UJFKh9peVGnd0DkE/10Ic6s6BBEGbshggho3BVGnRnC2s1n/ras2J2uzc05PXp+3yZzSm7XJkvfi84HveZ9z3ve8F7/bL8/71oqiiMs8NhCLsCllfcpfAwAAAAAAAIDlsXM68jfgtl9K2Z3Sa8IAAAAAAAAAb7hjKW8uF9kS3/jdKR9PaZkxAAAAAAAAwPJa6h3A96X0pBxK+bLxAgAAAAAAACyfpSyAP5jy4ZQXUh747687p00ZAAAAAAAAYBlkS3if+xfW+1MuGC0AAAAAAADA8lqqAnh3yvaUZ1MeMlYAAAAAAACA5bcUBXBfyoGF9edSusYKAAAAAAAAsPyWogD+VMpYypMpTxgpAAAAAAAAwMpYbAG8IWVvylzKHuMEAAAAAAAAWDmLLYC/mDKQ8nDKH4wTAAAAAAAAYOUspgC+IeWelNmYL4IBAAAAAAAAWEGLKYAPpfSmfD1lyigBAAAAAAAAVtbVFsA3pdyR8lLMF8EAAAAAAAAArLCrKYBrKfcvHA+kNI0RAAAAAAAAYOVdTQFc7vwtdwA/l/ItIwQAAAAAAACohistgMt3/h5cWO9N6RghAAAAAAAAQDVcaQF8d8rWlImUnxgfAAAAAAAAQHVcSQF8Tcq+lCJlz8IRAAAAAAAAgIq4kgK4fOTzUMzv/J0wOgAAAAAAAIBqeb0F8FjKp2P+nb97jQ0AAAAAAACgel5vAXwgpS/l2ynPGRsAAAAAAABA9eSjd370sh+P7/q/r9tTdqc0Y74IBgAAAAAAAKCC8v9Zl7uB6yn9o4fHG+lYS2n/867Hv5bXivLcoZQzRgYAAAAAAABQTfnw5nvjxWMHe9N6cP+OyVtv2nj2ruFG6209WbGqM5c181rx9m5RO/ngn2/4zlf/tLV2fNfPCmMDAAAAAAAAqJ68LH+HGq2xRz7wu2+8a31zvCgiLs5FlC3vqp4YKS8638mzqZf7tqXlb1MuGBsAAAAAAABA9ZSPdh58tfyd7UScOh9xYjqLszNZlGVwN6U/71z7hR1/e/g9g9NbRg+P9xobAAAAAAAAQPVk+3ZMfujV8vf0TC3WXWzE9ZveHyNjt0UxOxCnp7NotiPWr2pfl67dk/6zxtgAAAAAAAAAqie7eePZXeVO33OtiOGsHqtvfjDi1scibnkkesafipHVI3HuQi3a3Yh3rpsZT/+5ZvTweM3oAAAAAAAAAKolH2q0byzf+dtuZ9G/8b0RW+587ezat0a84xPR+8z+aHU7MVDvbLhl05lrf3FyaGr08Hj5muA4/qMfmiIAAAAAAABABWS1KPJLTW75UR+8/Ir6uksvCi6K+a/Dfa26sQEAAAAAAABUT/ZyJz+Z19IiL6J7eiLi/NRrZ4tuxNEfRzvmorcnoj2XvfL41MZTMV8XAwAAAAAAAFAh2eS5tU9kWcRAo4ipC9MRP98ZMfnNiH/8IOLJO+LMC7+ORl83Gj0RR5r9z8x08nOhAAYAAAAAAAConPyzT2976H1D//7YYL21ZW5NN442n4/ep/ddeuxzK+air68bb2pEdCN75dEj192Xfp4xNgAAAAAAAIDqyWY6+akHnt16d7Oz6uRAPWJkoIi1azuxek0nhge6MdQXUatlrZ8+P/L5706+ZSLKXhgAAAAAAACAyik3+s5+/++bJ+751fbbfv/S+kc7c/l0WQSva0TUe2rtIzNrJr7yxxs/8pnfbPteurY5vPlej38GAAAAAAAAqKC8LHRfPHZw9penNvwl5ZP1nrmB268/MdafX+x96sTQ8aMz/f9K102ntJS/AAAAAAAAANX1HwEGAM75MhcANnAkAAAAAElFTkSuQmCC) 0px 0px no-repeat;\n    background-position: 0px 0px;\n}\n\n.popup3d2-header {\n    height: 30px;\n    color: white;\n    background: #1f3f8e;\n    line-height: 30px;\n}\n\n.popup3d2-title {\n    display: inline-block;\n    height: 100%;\n    margin-left: 5px;\n    padding-left: 5px;\n}\n\n.popup3d2-close {\n    position: absolute;\n    right: 1px;\n    font-size: 25px;\n    cursor: pointer;\n    width: 29px;\n    text-align: center;\n}\n\n.popup3d2-close:hover {\n    background: #dc2929b9;\n}\n\n.popup3d2-body {\n    padding: 10px;\n    color: white;\n}`, 
  {});
  expect(add, [{
    "key" : `createDom`,
    "value" : function() {
      this.container = document.createElement("div");
      this.container.innerHTML = '  <div class="popup3d2-container" v-if="show">\n          <div class="popup3d2-header">\n            <span class="popup3d2-title">  ' + this.title + `</span>\n            <span class="popup3d2-close" title="\u5173\u95ed"  >\u00d7</span>\n          </div>\n          <div class="popup3d1-body">\n          ` + this.html || "\u7a97\u53e3\u5185\u5bb9\n          </div>\n        </div>";
    }
  }, {
    "key" : "initEvent",
    "value" : function() {
      var rejectingServer = this;
      this.container.getElementsByClassName("popup3d2-close")[0].onclick = function(branch) {
        rejectingServer.close();
      };
    }
  }, {
    "key" : `addPostRender`,
    "value" : function() {
      this.viewer.scene.postRender.addEventListener(this.postRender, this);
    }
  }, {
    "key" : "postRender",
    "value" : function() {
      var scrollHeight;
      var target;
      if (this.container && this.container.style) {
        scrollHeight = this.viewer.scene.canvas.height;
        target = new Cesium["Cartesian2"];
        Cesium.SceneTransforms.wgs84ToWindowCoordinates(this.viewer.scene, this.position, target);
        this.container.style.position = "absolute";
        this.container.style.bottom = scrollHeight - target.y + 80 + "px";
        this.container.style.left = target.x + 30 + "px";
        if (4E3 < this.viewer.camera.positionCartographic.height) {
          this.container.style.display = "none";
        } else {
          this.container.style.display = "block";
        }
      }
    }
  }, {
    "key" : `close`,
    "value" : function() {
      this.container.remove();
      this.viewer.scene.postRender.removeEventListener(this.postRender, this);
    }
  }]);
  exports = add;
  xt3d.Map3dWindow = {
    "MultiFieldAdaptWindow" : init,
    "DeviceStatusWindow" : data,
    "LeafletPopup" : forced,
    "PopupWindow1" : mode,
    "PopupWindow2" : exports
  };
  var Tile = {
    "FIRE" : `fire`,
    "FOUNTAIN" : "fountain",
    "SMOKE" : `smoke`
  };
  output = (expect(geoJsonToFeatureInfo, [{
    "key" : `setSelected`,
    "value" : function(name) {
    }
  }, {
    "key" : `toGeoJson`,
    "value" : function() {
      return {
        "type" : "Feature",
        "properties" : this.properties,
        "geometry" : {
          "type" : "Point",
          "coordinates" : this.coordinates
        }
      };
    }
  }]), geoJsonToFeatureInfo);
  var Grouping = (_inherits(Container, output), expect(Container, [{
    "key" : `init`,
    "value" : function() {
      this.entity = this.viewer.entities.add({
        "position" : this.position
      });
      this.particleSystem = this.createParticleSystem();
      this.viewer.scene.primitives.add(this.particleSystem);
      this.addEvent();
    }
  }, {
    "key" : `addEvent`,
    "value" : function() {
      this.emitterModelMatrix = new Cesium.Matrix4;
      this.translation = new Cesium["Cartesian3"];
      this.rotation = new Cesium.Quaternion;
      this.hpr = new Cesium["HeadingPitchRoll"];
      this.trs = new Cesium["TranslationRotationScale"];
      this.viewer.scene.preUpdate.addEventListener(this.preUpdateEvent, this);
    }
  }, {
    "key" : `removeEvent`,
    "value" : function() {
      this.viewer.scene.preUpdate.removeEventListener(this.preUpdateEvent, this);
      this.emitterModelMatrix = void 0;
      this.translation = void 0;
      this.rotation = void 0;
      this.hpr = void 0;
      this.trs = void 0;
    }
  }, {
    "key" : "preUpdateEvent",
    "value" : function(target, name) {
      this.particleSystem.modelMatrix = this.entity.computeModelMatrix(name, new Cesium["Matrix4"]);
      this.hpr = Cesium.HeadingPitchRoll.fromDegrees(0, 0, 0, this.hpr);
      this.trs.translation = Cesium.Cartesian3.fromElements(0, 0, 0, this.translation);
      this.trs.rotation = Cesium.Quaternion.fromHeadingPitchRoll(this.hpr, this.rotation);
      this.particleSystem.emitterModelMatrix = Cesium.Matrix4.fromTranslationRotationScale(this.trs, this.emitterModelMatrix);
    }
  }, {
    "key" : "createParticleSystem",
    "value" : function() {
      return new Cesium["ParticleSystem"]({
        "image" : this.style.fireImage,
        "startColor" : new Cesium.Color(1, 1, 1, 1),
        "endColor" : new Cesium["Color"](0.5, 0, 0, 0),
        "startScale" : this.style.startScale,
        "endScale" : this.style.endScale,
        "minimumParticleLife" : this.style.minimumParticleLife,
        "maximumParticleLife" : this.style.maximumParticleLife,
        "minimumSpeed" : this.style.minimumSpeed,
        "maximumSpeed" : this.style.maximumSpeed,
        "imageSize" : new Cesium["Cartesian2"](this.style.particleSize, this.style.particleSize),
        "emissionRate" : this.style.emissionRate,
        "lifetime" : 16,
        "loop" : true,
        "emitter" : new Cesium["ConeEmitter"](Cesium.Math.toRadians(45)),
        "sizeInMeters" : true
      });
    }
  }, {
    "key" : "remove",
    "value" : function() {
      this.removeEvent();
      this.viewer.scene.primitives.remove(this.particleSystem);
      this.viewer.entities.remove(this.entity);
    }
  }, {
    "key" : `updateStyle`,
    "value" : function() {
      this.particleSystem.startScale = this.style.startScale;
      this.particleSystem.endScale = this.style.endScale;
      this.particleSystem.minimumParticleLife = this.style.minimumParticleLife;
      this.particleSystem.maximumParticleLife = this.style.maximumParticleLife;
      this.particleSystem.minimumSpeed = this.style.minimumSpeed;
      this.particleSystem.maximumSpeed = this.style.maximumSpeed;
      this.particleSystem.imageSize = new Cesium["Cartesian2"](this.style.particleSize, this.style.particleSize);
      this.particleSystem.emissionRate = this.style.emissionRate;
    }
  }, {
    "key" : `getDefaultStyle`,
    "value" : function() {
      return {
        "fireImage" : "../../../static/images/particlesystem/fire.png",
        "startScale" : 3,
        "endScale" : 1.5,
        "minimumParticleLife" : 1.5,
        "maximumParticleLife" : 1.8,
        "minimumSpeed" : 7,
        "maximumSpeed" : 9,
        "particleSize" : 2,
        "emissionRate" : 200
      };
    }
  }]), Container);
  var GroupDurationSubscriber = (_inherits(Slider, output), expect(Slider, [{
    "key" : `init`,
    "value" : function() {
      this.entity = this.viewer.entities.add({
        "position" : this.position
      });
      this.particleSystem = this.createParticleSystem();
      this.viewer.scene.primitives.add(this.particleSystem);
      this.addEvent();
    }
  }, {
    "key" : "addEvent",
    "value" : function() {
      this.emitterModelMatrix = new Cesium["Matrix4"];
      this.translation = new Cesium.Cartesian3;
      this.rotation = new Cesium.Quaternion;
      this.hpr = new Cesium.HeadingPitchRoll;
      this.trs = new Cesium["TranslationRotationScale"];
      this.viewer.scene.preUpdate.addEventListener(this.preUpdateEvent, this);
    }
  }, {
    "key" : `removeEvent`,
    "value" : function() {
      this.viewer.scene.preUpdate.removeEventListener(this.preUpdateEvent, this);
      this.emitterModelMatrix = void 0;
      this.translation = void 0;
      this.rotation = void 0;
      this.hpr = void 0;
      this.trs = void 0;
    }
  }, {
    "key" : "preUpdateEvent",
    "value" : function(target, name) {
      this.particleSystem.modelMatrix = this.entity.computeModelMatrix(name, new Cesium["Matrix4"]);
      this.hpr = Cesium.HeadingPitchRoll.fromDegrees(0, 0, 0, this.hpr);
      this.trs.translation = Cesium.Cartesian3.fromElements(0, 0, 0, this.translation);
      this.trs.rotation = Cesium.Quaternion.fromHeadingPitchRoll(this.hpr, this.rotation);
      this.particleSystem.emitterModelMatrix = Cesium.Matrix4.fromTranslationRotationScale(this.trs, this.emitterModelMatrix);
    }
  }, {
    "key" : `createParticleSystem`,
    "value" : function() {
      var console = this;
      return this.gravityScratch = new Cesium["Cartesian3"], new Cesium["ParticleSystem"]({
        "image" : this.style.fountainImage,
        "startColor" : new Cesium["Color"](1, 1, 1, 0.6),
        "endColor" : new Cesium["Color"](0.8, 0.86, 1, 0.4),
        "startScale" : this.style.startScale,
        "endScale" : this.style.endScale,
        "minimumParticleLife" : this.style.minimumParticleLife,
        "maximumParticleLife" : this.style.maximumParticleLife,
        "minimumSpeed" : this.style.minimumSpeed,
        "maximumSpeed" : this.style.maximumSpeed,
        "imageSize" : new Cesium["Cartesian2"](this.style.particleSize, this.style.particleSize),
        "emissionRate" : this.style.emissionRate,
        "lifetime" : 16,
        "emitter" : new Cesium["CircleEmitter"](0.2),
        "updateCallback" : function(obj, body) {
          var complete = hahaha;
          return console[complete(1326)](obj, body);
        },
        "sizeInMeters" : true,
        "performance" : false
      });
    }
  }, {
    "key" : "applyGravity",
    "value" : function(target, object) {
      Cesium.Cartesian3.normalize(target.position, this.gravityScratch);
      Cesium.Cartesian3.multiplyByScalar(this.gravityScratch, this.style.gravity * object, this.gravityScratch);
      target.velocity = Cesium.Cartesian3.add(target.velocity, this.gravityScratch, target.velocity);
    }
  }, {
    "key" : `updateStyle`,
    "value" : function() {
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.removeEvent();
      this.viewer.scene.primitives.remove(this.particleSystem);
      this.viewer.entities.remove(this.entity);
    }
  }, {
    "key" : "getDefaultStyle",
    "value" : function() {
      return {
        "fountainImage" : "../../../static/images/particlesystem/fountain.png",
        "emissionRate" : 40,
        "gravity" : -3.5,
        "minimumParticleLife" : 6,
        "maximumParticleLife" : 7,
        "minimumSpeed" : 9,
        "maximumSpeed" : 9.5,
        "startScale" : 1,
        "endScale" : 7,
        "particleSize" : 1
      };
    }
  }]), Slider);
  var GroupedObservable = (_inherits(Overlay, output), expect(Overlay, [{
    "key" : `init`,
    "value" : function() {
      this.entity = this.viewer.entities.add({
        "position" : this.position
      });
      this.particleSystem = this.createParticleSystem();
      this.viewer.scene.primitives.add(this.particleSystem);
      this.addEvent();
    }
  }, {
    "key" : `addEvent`,
    "value" : function() {
      this.emitterModelMatrix = new Cesium.Matrix4;
      this.translation = new Cesium["Cartesian3"];
      this.rotation = new Cesium["Quaternion"];
      this.hpr = new Cesium["HeadingPitchRoll"];
      this.trs = new Cesium["TranslationRotationScale"];
      this.viewer.scene.preUpdate.addEventListener(this.preUpdateEvent, this);
    }
  }, {
    "key" : `removeEvent`,
    "value" : function() {
      this.viewer.scene.preUpdate.removeEventListener(this.preUpdateEvent, this);
      this.emitterModelMatrix = void 0;
      this.translation = void 0;
      this.rotation = void 0;
      this.hpr = void 0;
      this.trs = void 0;
    }
  }, {
    "key" : `preUpdateEvent`,
    "value" : function(target, name) {
      this.particleSystem.modelMatrix = this.entity.computeModelMatrix(name, new Cesium["Matrix4"]);
      this.hpr = Cesium.HeadingPitchRoll.fromDegrees(this.style.heading, this.style.pitch, 0, this.hpr);
      this.trs.translation = Cesium.Cartesian3.fromElements(0, 0, 0, this.translation);
      this.trs.rotation = Cesium.Quaternion.fromHeadingPitchRoll(this.hpr, this.rotation);
      this.particleSystem.emitterModelMatrix = Cesium.Matrix4.fromTranslationRotationScale(this.trs, this.emitterModelMatrix);
    }
  }, {
    "key" : `updateOrientation`,
    "value" : function(name) {
      if ("\u65e0\u98ce" == name) {
        return this.heading = 180, void(this.pitch = 0);
      }
      this.style.heading = this.getHeadingByOString(name) + 90;
      this.style.pitch = 60;
    }
  }, {
    "key" : `getHeadingByOString`,
    "value" : function(name) {
      switch(name) {
        case "\u5317\u98ce":
          return 180;
        case "\u4e1c\u5317\u98ce":
          return 225;
        case "\u4e1c\u98ce":
          return 270;
        case "\u4e1c\u5357\u98ce":
          return 315;
        case "\u5357\u98ce":
          return 360;
        case "\u897f\u5357\u98ce":
          return 45;
        case "\u897f\u98ce":
          return 90;
        case "\u897f\u5317\u98ce":
          return 135;
      }
    }
  }, {
    "key" : `createParticleSystem`,
    "value" : function() {
      var console = this;
      return this.gravityScratch = new Cesium.Cartesian3, new Cesium["ParticleSystem"]({
        "image" : this.style.smokeImage,
        "startColor" : new Cesium["Color"](0, 0, 0, 0.6),
        "endColor" : new Cesium["Color"](0, 0, 0, 0.8),
        "startScale" : this.style.startScale,
        "endScale" : this.style.endScale,
        "minimumParticleLife" : this.style.minimumParticleLife,
        "maximumParticleLife" : this.style.maximumParticleLife,
        "minimumSpeed" : this.style.minimumSpeed,
        "maximumSpeed" : this.style.maximumSpeed,
        "imageSize" : new Cesium["Cartesian2"](this.style.particleSize, this.style.particleSize),
        "emissionRate" : this.style.emissionRate,
        "lifetime" : 16,
        "emitter" : new Cesium["CircleEmitter"](0.2),
        "updateCallback" : function(obj, body) {
          var complete = hahaha;
          return console[complete(1326)](obj, body);
        },
        "sizeInMeters" : true,
        "performance" : false
      });
    }
  }, {
    "key" : `applyGravity`,
    "value" : function(target, object) {
      Cesium.Cartesian3.normalize(target.position, this.gravityScratch);
      Cesium.Cartesian3.multiplyByScalar(this.gravityScratch, this.style.gravity * object, this.gravityScratch);
      target.velocity = Cesium.Cartesian3.add(target.velocity, this.gravityScratch, target.velocity);
    }
  }, {
    "key" : `updateStyle`,
    "value" : function() {
      this.particleSystem.startScale = this.style.startScale;
      this.particleSystem.endScale = this.style.endScale;
      this.particleSystem.minimumParticleLife = this.style.minimumParticleLife;
      this.particleSystem.maximumParticleLife = this.style.maximumParticleLife;
      this.particleSystem.minimumSpeed = this.style.minimumSpeed;
      this.particleSystem.maximumSpeed = this.style.maximumSpeed;
      this.particleSystem.imageSize = new Cesium["Cartesian2"](this.style.particleSize, this.style.particleSize);
      this.particleSystem.emissionRate = this.style.emissionRate;
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.removeEvent();
      this.viewer.scene.primitives.remove(this.particleSystem);
      this.viewer.entities.remove(this.entity);
    }
  }, {
    "key" : `getDefaultStyle`,
    "value" : function() {
      return {
        "smokeImage" : "/static/images/particlesystem/0003.png",
        "emissionRate" : 40,
        "gravity" : -3.5,
        "minimumParticleLife" : 6,
        "maximumParticleLife" : 7,
        "minimumSpeed" : 9,
        "maximumSpeed" : 9.5,
        "startScale" : 1,
        "endScale" : 7,
        "particleSize" : 1,
        "heading" : 180,
        "pitch" : 0
      };
    }
  }]), Overlay);
  var resultSelector = function(key, y, group) {
    switch(y) {
      case Tile.FIRE:
        return new Grouping(key, group);
      case Tile.FOUNTAIN:
        return new GroupDurationSubscriber(key, group);
      case Tile.SMOKE:
        return new GroupedObservable(key, group);
    }
  };
  ID = (_inherits(FastCallback, meta), expect(FastCallback, [{
    "key" : `addPlot`,
    "value" : function(value) {
      value = resultSelector(this.viewer, value.properties.plotType, value);
      this.plots.push(value);
    }
  }, {
    "key" : `initEvent`,
    "value" : function() {
      var values = this;
      (new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas)).setInputAction(function(result) {
        var parseInt = hahaha;
        if (values[parseInt(455)]) {
          if ((result = values[parseInt(2276)][parseInt(2758)].pick(result[parseInt(586)])) && result.primitive && result[parseInt(1252)]) {
            values.selectedEntityChanged(result);
          } else {
            values[parseInt(2205)](void 0);
          }
        }
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
    }
  }, {
    "key" : "selectedEntityChanged",
    "value" : function(type) {
      if (!type) {
        return this.clearSelectedPlot(), void this.selectedPlotChanged.raiseEvent(void 0);
      }
      type = this.getPlotBy_textureAtlasGUID(type.collection._textureAtlasGUID);
      if (!type) {
        return this.clearSelectedPlot(), void this.selectedPlotChanged.raiseEvent(void 0);
      }
      if (this.selectedPlot) {
        if (this.selectedPlot.properties.plotCode == type.properties.plotCode) {
          return;
        }
        this.clearSelectedPlot();
      }
      this.selectedPlot = type;
      this.selectedPlot.setSelected(true);
      this.selectedPlotChanged.raiseEvent(type);
    }
  }, {
    "key" : `getPlotBy_textureAtlasGUID`,
    "value" : function(name) {
      var i = 0;
      for (; i < this.plots.length; i++) {
        var index = this.plots[i];
        if (index.particleSystem._billboardCollection._textureAtlasGUID == name) {
          return index;
        }
      }
    }
  }, {
    "key" : "flyToByPlotCode",
    "value" : function(name) {
      var t = this.getByPlotCode(name);
      if (t) {
        this.viewer.flyTo(t.gltfEntity);
        this.setSelectedPlotByCode(name);
      }
    }
  }, {
    "key" : `setSelectedPlotByCode`,
    "value" : function(name) {
      this.clearSelectedPlot();
      name = this.getByPlotCode(name);
      if (name) {
        this.selectedPlot = name;
        this.selectedPlot.setSelected(true);
      }
    }
  }, {
    "key" : `clearSelectedPlot`,
    "value" : function() {
      if (this.selectedPlot) {
        this.selectedPlot.setSelected(false);
        this.selectedPlot = void 0;
      }
    }
  }]), FastCallback);
  expect(remove, [{
    "key" : `init`,
    "value" : function() {
      this.entity = this.viewer.entities.add({
        "position" : this.position
      });
      this.particleSystem = this.createParticleSystem();
      this.viewer.scene.primitives.add(this.particleSystem);
      this.addEvent();
      this.addCircles();
      this.addLabels();
      this.addWindowEvent();
    }
  }, {
    "key" : `addWindowEvent`,
    "value" : function() {
      var o = this;
      var hiddenProperty = "hidden" in document ? "hidden" : "webkitHidden" in document ? "webkitHidden" : "mozHidden" in document ? "mozHidden" : null;
      var visibilityChangeEvent = hiddenProperty.replace(/hidden/i, "visibilitychange");
      document.addEventListener(visibilityChangeEvent, function() {
        var camelize = hahaha;
        if (o[camelize(2204)]) {
          if (document[hiddenProperty]) {
            o[camelize(2276)][camelize(2758)][camelize(2798)][camelize(508)](o.particleSystem);
          } else {
            o[camelize(2204)] = o[camelize(799)]();
            o.viewer[camelize(2758)][camelize(2798)].add(o[camelize(2204)]);
          }
        }
      });
    }
  }, {
    "key" : "addEvent",
    "value" : function() {
      this.emitterModelMatrix = new Cesium["Matrix4"];
      this.translation = new Cesium["Cartesian3"];
      this.rotation = new Cesium["Quaternion"];
      this.hpr = new Cesium["HeadingPitchRoll"];
      this.trs = new Cesium.TranslationRotationScale;
      this.viewer.scene.preUpdate.addEventListener(this.preUpdateEvent, this);
    }
  }, {
    "key" : `removeEvent`,
    "value" : function() {
      this.viewer.scene.preUpdate.removeEventListener(this.preUpdateEvent, this);
      this.emitterModelMatrix = void 0;
      this.translation = void 0;
      this.rotation = void 0;
      this.hpr = void 0;
      this.trs = void 0;
    }
  }, {
    "key" : `preUpdateEvent`,
    "value" : function(target, name) {
      this.particleSystem.modelMatrix = this.entity.computeModelMatrix(name, new Cesium.Matrix4);
      this.hpr = Cesium.HeadingPitchRoll.fromDegrees(0, 0, 0, this.hpr);
      this.trs.translation = Cesium.Cartesian3.fromElements(0, 0, 0, this.translation);
      this.trs.rotation = Cesium.Quaternion.fromHeadingPitchRoll(this.hpr, this.rotation);
      this.particleSystem.emitterModelMatrix = Cesium.Matrix4.fromTranslationRotationScale(this.trs, this.emitterModelMatrix);
    }
  }, {
    "key" : `createParticleSystem`,
    "value" : function() {
      return new Cesium["ParticleSystem"]({
        "image" : this.style.fireImage,
        "startColor" : new Cesium["Color"](1, 1, 1, 1),
        "endColor" : new Cesium["Color"](0.5, 0, 0, 0),
        "startScale" : this.style.startScale,
        "endScale" : this.style.endScale,
        "minimumParticleLife" : this.style.minimumParticleLife,
        "maximumParticleLife" : this.style.maximumParticleLife,
        "minimumSpeed" : this.style.minimumSpeed,
        "maximumSpeed" : this.style.maximumSpeed,
        "imageSize" : new Cesium["Cartesian2"](this.style.particleSize, this.style.particleSize),
        "emissionRate" : this.style.emissionRate,
        "lifetime" : 16,
        "loop" : true,
        "emitter" : new Cesium.ConeEmitter(Cesium.Math.toRadians(45)),
        "sizeInMeters" : true
      });
    }
  }, {
    "key" : `addCircles`,
    "value" : function() {
      var currentValue = this.addCircle(30, Cesium.Color.RED, -0.005, 12);
      this.circles.push(currentValue);
      currentValue = this.addCircle(60, Cesium.Color.YELLOW, -0.005, 8);
      this.circles.push(currentValue);
      currentValue = this.addCircle(90, Cesium.Color.CHARTREUSE, 0.005, 6);
      this.circles.push(currentValue);
    }
  }, {
    "key" : `addCircle`,
    "value" : function(type, obj, source, callsite) {
      var value = 0;
      return this.viewer.entities.add({
        "position" : this.position,
        "ellipse" : {
          "stRotation" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
            return value = value + source;
          }, false),
          "heightReference" : Cesium.HeightReference.CLAMP_TO_GROUND,
          "semiMinorAxis" : type,
          "semiMajorAxis" : type,
          "material" : this.createBottomRotateCircleTexture(callsite, obj.toCssColorString())
        }
      });
    }
  }, {
    "key" : `addLabels`,
    "value" : function() {
      var p = Cesium.Cartographic.fromCartesian(this.position);
      var localfunc = [Cesium.Math.toDegrees(p.longitude), Cesium.Math.toDegrees(p.latitude)];
      var tmp = gen(localfunc[0], localfunc[1], 90, 30);
      p = this.addLabel(Cesium.Cartesian3.fromDegrees(tmp[0], tmp[1], 0), "30\u7c73", Cesium.Color.RED);
      this.labels.push(p);
      tmp = gen(localfunc[0], localfunc[1], 90, 60);
      p = this.addLabel(Cesium.Cartesian3.fromDegrees(tmp[0], tmp[1], 0), "60\u7c73", Cesium.Color.YELLOW);
      this.labels.push(p);
      tmp = gen(localfunc[0], localfunc[1], 90, 90);
      p = this.addLabel(Cesium.Cartesian3.fromDegrees(tmp[0], tmp[1], 0), "90\u7c73", Cesium.Color.CHARTREUSE);
      this.labels.push(p);
    }
  }, {
    "key" : "addLabel",
    "value" : function(obj, name, uri) {
      return this.viewer.entities.add({
        "position" : obj,
        "label" : {
          "text" : name,
          "fillColor" : uri,
          "scale" : 0.4,
          "font" : "normal 60px MicroSoft YaHei",
          "verticalOrigin" : Cesium.VerticalOrigin.BOTTOM,
          "heightReference" : Cesium.HeightReference.CLAMP_TO_GROUND,
          "pixelOffset" : new Cesium.Cartesian2(0, -10),
          "distanceDisplayCondition" : new Cesium["DistanceDisplayCondition"](0, 5E5)
        }
      });
    }
  }, {
    "key" : "createBottomRotateCircleTexture",
    "value" : function(value, obj) {
      var hcanvas = document.createElement("canvas");
      hcanvas.width = 512;
      hcanvas.height = 512;
      var ctx = hcanvas.getContext("2d");
      return ctx.clearRect(0, 0, 512, 512), ctx.strokeStyle = obj, ctx.setLineDash([140, 30]), ctx.lineWidth = value, ctx.arc(256, 256, 241, 0, 2 * Math.PI, true), ctx.stroke(), hcanvas.toDataURL("image/png").replace("image/png", "image/octet-stream");
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      var same = this;
      this.removeEvent();
      this.viewer.scene.primitives.remove(this.particleSystem);
      this.viewer.entities.remove(this.entity);
      this.particleSystem = void 0;
      this.circles.forEach(function(mmCoreSplitViewBlock) {
        var rel2Mstr = hahaha;
        same[rel2Mstr(2276)][rel2Mstr(1319)][rel2Mstr(508)](mmCoreSplitViewBlock);
      });
      this.labels.forEach(function(mmCoreSplitViewBlock) {
        var put_rows = hahaha;
        same.viewer.entities[put_rows(508)](mmCoreSplitViewBlock);
      });
    }
  }, {
    "key" : `getDefaultStyle`,
    "value" : function() {
      return {
        "fireImage" : "/static/images/particlesystem/fire.png",
        "startScale" : 3,
        "endScale" : 1.5,
        "minimumParticleLife" : 1.5,
        "maximumParticleLife" : 1.8,
        "minimumSpeed" : 7,
        "maximumSpeed" : 9,
        "particleSize" : 2,
        "emissionRate" : 200
      };
    }
  }]);
  descriptor = remove;
  xt3d.ParticleSystem = {
    "PlotLayer" : ID,
    "getPlotCode" : createIntervalElements,
    "FirePoint" : descriptor
  };
  appendCSS(`.point-sample-label-container {\n    min-width: 96px;\n    min-height: 35px;\n    background: linear-gradient(0deg, #1e202a 0%, #0d1013 100%);\n    position: absolute;\n    left: 0px;\n    bottom: 0px;\n    cursor: default;\n    border-radius: 4px;\n    opacity: 0.96;\n    border: 1px solid #14171c;\n    box-shadow: 0px 2px 21px 0px rgba(33, 34, 39, 0.55);\n    border-radius: 4px;\n    box-sizing: border-box;\n}\n\n.point-sample-label-container::before {\n    content: "";\n    width: calc(100% + 22px);\n    height: 39px;\n    position: absolute;\n    bottom: -39px;\n    left: -22px;\n    background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAB4AAAAAlCAYAAACj1PQVAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyhpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTQ1IDc5LjE2MzQ5OSwgMjAxOC8wOC8xMy0xNjo0MDoyMiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTkgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MTJFMTU1RjExN0UzMTFFOTg3RTBFODdGNTY0NThGQkUiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MTJFMTU1RjIxN0UzMTFFOTg3RTBFODdGNTY0NThGQkUiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDoxMkUxNTVFRjE3RTMxMUU5ODdFMEU4N0Y1NjQ1OEZCRSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDoxMkUxNTVGMDE3RTMxMUU5ODdFMEU4N0Y1NjQ1OEZCRSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pj97JFoAAAV9SURBVHja7N1faJ1nHQfw33nzpuekaZfWNFmbLHXWdf7DWgvebF4M0SEZhTG8mKvFyzG9UJFKh9peVGnd0DkE/10Ic6s6BBEGbshggho3BVGnRnC2s1n/ras2J2uzc05PXp+3yZzSm7XJkvfi84HveZ9z3ve8F7/bL8/71oqiiMs8NhCLsCllfcpfAwAAAAAAAIDlsXM68jfgtl9K2Z3Sa8IAAAAAAAAAb7hjKW8uF9kS3/jdKR9PaZkxAAAAAAAAwPJa6h3A96X0pBxK+bLxAgAAAAAAACyfpSyAP5jy4ZQXUh747687p00ZAAAAAAAAYBlkS3if+xfW+1MuGC0AAAAAAADA8lqqAnh3yvaUZ1MeMlYAAAAAAACA5bcUBXBfyoGF9edSusYKAAAAAAAAsPyWogD+VMpYypMpTxgpAAAAAAAAwMpYbAG8IWVvylzKHuMEAAAAAAAAWDmLLYC/mDKQ8nDKH4wTAAAAAAAAYOUspgC+IeWelNmYL4IBAAAAAAAAWEGLKYAPpfSmfD1lyigBAAAAAAAAVtbVFsA3pdyR8lLMF8EAAAAAAAAArLCrKYBrKfcvHA+kNI0RAAAAAAAAYOVdTQFc7vwtdwA/l/ItIwQAAAAAAACohistgMt3/h5cWO9N6RghAAAAAAAAQDVcaQF8d8rWlImUnxgfAAAAAAAAQHVcSQF8Tcq+lCJlz8IRAAAAAAAAgIq4kgK4fOTzUMzv/J0wOgAAAAAAAIBqeb0F8FjKp2P+nb97jQ0AAAAAAACgel5vAXwgpS/l2ynPGRsAAAAAAABA9eSjd370sh+P7/q/r9tTdqc0Y74IBgAAAAAAAKCC8v9Zl7uB6yn9o4fHG+lYS2n/867Hv5bXivLcoZQzRgYAAAAAAABQTfnw5nvjxWMHe9N6cP+OyVtv2nj2ruFG6209WbGqM5c181rx9m5RO/ngn2/4zlf/tLV2fNfPCmMDAAAAAAAAqJ68LH+HGq2xRz7wu2+8a31zvCgiLs5FlC3vqp4YKS8638mzqZf7tqXlb1MuGBsAAAAAAABA9ZSPdh58tfyd7UScOh9xYjqLszNZlGVwN6U/71z7hR1/e/g9g9NbRg+P9xobAAAAAAAAQPVk+3ZMfujV8vf0TC3WXWzE9ZveHyNjt0UxOxCnp7NotiPWr2pfl67dk/6zxtgAAAAAAAAAqie7eePZXeVO33OtiOGsHqtvfjDi1scibnkkesafipHVI3HuQi3a3Yh3rpsZT/+5ZvTweM3oAAAAAAAAAKolH2q0byzf+dtuZ9G/8b0RW+587ezat0a84xPR+8z+aHU7MVDvbLhl05lrf3FyaGr08Hj5muA4/qMfmiIAAAAAAABABWS1KPJLTW75UR+8/Ir6uksvCi6K+a/Dfa26sQEAAAAAAABUT/ZyJz+Z19IiL6J7eiLi/NRrZ4tuxNEfRzvmorcnoj2XvfL41MZTMV8XAwAAAAAAAFAh2eS5tU9kWcRAo4ipC9MRP98ZMfnNiH/8IOLJO+LMC7+ORl83Gj0RR5r9z8x08nOhAAYAAAAAAAConPyzT2976H1D//7YYL21ZW5NN442n4/ep/ddeuxzK+air68bb2pEdCN75dEj192Xfp4xNgAAAAAAAIDqyWY6+akHnt16d7Oz6uRAPWJkoIi1azuxek0nhge6MdQXUatlrZ8+P/L5706+ZSLKXhgAAAAAAACAyik3+s5+/++bJ+751fbbfv/S+kc7c/l0WQSva0TUe2rtIzNrJr7yxxs/8pnfbPteurY5vPlej38GAAAAAAAAqKC8LHRfPHZw9penNvwl5ZP1nrmB268/MdafX+x96sTQ8aMz/f9K102ntJS/AAAAAAAAANX1HwEGAM75MhcANnAkAAAAAElFTkSuQmCC) 0px 0px no-repeat;\n    background-position: 0px 0px;\n}\n\n.point-sample-label-text {\n    width: 100%;\n    height: 100%;\n    text-align: center;\n    padding: 1px 20px;\n    font-size: 14px;\n    font-family: 'MicrosoftYaHei';\n    font-weight: 400;\n    color: #ffffff;\n    line-height: 33px;\n    border: 1px solid #ffffff4f;\n    -webkit-box-sizing: border-box;\n    box-sizing: border-box;\n}`, 
  {});
  expect(info, [{
    "key" : `addPostRender`,
    "value" : function() {
      this.viewer.scene.postRender.addEventListener(this.postRender, this);
    }
  }, {
    "key" : `postRender`,
    "value" : function() {
      var scrollHeight;
      var target;
      if (this.container && this.container.style && this.position) {
        scrollHeight = this.viewer.scene.canvas.height;
        target = new Cesium["Cartesian2"];
        Cesium.SceneTransforms.wgs84ToWindowCoordinates(this.viewer.scene, this.position, target);
        this.container.style.bottom = scrollHeight - target.y + 40 + "px";
        this.container.style.left = target.x + 20 + "px";
      }
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.viewer.scene.postRender.removeEventListener(this.postRender, this);
      this.viewer.cesiumWidget.container.removeChild(this.container);
    }
  }, {
    "key" : "createDom",
    "value" : function() {
      this.container = document.createElement("div");
      this.container.classList.add("point-sample-label-container");
      var label = document.createElement("div");
      label.classList.add("point-sample-label-text");
      label.innerHTML = this.label;
      this.container.appendChild(label);
      this.viewer.cesiumWidget.container.appendChild(this.container);
    }
  }]);
  view = info;
  expect(query, [{
    "key" : `createMarker`,
    "value" : function() {
      var values = this;
      var e = 1;
      var v = true;
      var value = this.pixelSize;
      var comment = true;
      var regexMask = 0.7;
      var mask = true;
      var indexOfFirstLeadingComment = this.pixelMax;
      this.markerEntity = this.viewer.entities.add({
        "position" : this.position
      });
      this.markerEntity.point = {
        "color" : new Cesium["CallbackProperty"](function() {
          var put_rows = hahaha;
          return v ? (e = e - 0.03) <= 0 && (v = false) : (e = 1, v = true), values.color[put_rows(2265)](e);
        }, false),
        "pixelSize" : new Cesium["CallbackProperty"](function(canCreateDiscussions, isSlidingUp) {
          return comment ? indexOfFirstLeadingComment <= (value = value + 2) && (comment = false) : (value = 10, comment = true), value;
        }, false),
        "outlineColor" : new Cesium.CallbackProperty(function() {
          var parseInt = hahaha;
          return mask ? (regexMask = regexMask - 0.035) <= 0 && (mask = false) : (regexMask = 0.7, mask = true), values[parseInt(2240)][parseInt(2265)](regexMask);
        }, false),
        "outlineWidth" : this.outWidth,
        "scaleByDistance" : new Cesium.NearFarScalar(1200, 1, 5200, 0.4)
      };
      if (this.iconUrl) {
        this.markerEntity.billboard = {
          "image" : this.iconUrl,
          "scaleByDistance" : new Cesium["NearFarScalar"](1200, 1, 5200, 0.4),
          "distanceDisplayCondition" : new Cesium["DistanceDisplayCondition"](0, 1E4)
        };
      }
    }
  }, {
    "key" : "remove",
    "value" : function() {
      this.viewer.entities.remove(this.markerEntity);
      this.markerEntity = void 0;
    }
  }]);
  doc = query;
  expect(search, [{
    "key" : `loadGif`,
    "value" : function(name) {
      var t = this;
      this.superGif = new SuperGif({
        "gif" : name
      });
      this.superGif.load(function() {
        var put_rows = hahaha;
        t[put_rows(1934)] = t.viewer[put_rows(1319)][put_rows(3010)]({
          "position" : t[put_rows(586)],
          "billboard" : {
            "image" : new (Cesium[put_rows(1679)])(function() {
              var zip_GETBITS = put_rows;
              return t.superGif[zip_GETBITS(1440)]()[zip_GETBITS(555)]("image/png");
            }, false),
            "verticalOrigin" : Cesium[put_rows(2999)].BOTTOM,
            "heightReference" : Cesium.HeightReference[put_rows(3196)],
            "scaleByDistance" : new (Cesium[put_rows(2725)])(500, 1, 2E3, 0.1)
          }
        });
      });
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.viewer.entities.remove(this.billboardEntity);
    }
  }]);
  tel = search;
  appendCSS(`.is-shulie {\n    width: 15px;\n    text-align: center;\n    background: transparent;\n    font-size: 9px;\n    font-weight: 600;\n    color: white;\n    font-family: "Microsoft YaHei", "Helvetica Neue For Number", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Hiragino Sans GB", "PingFang SC", "Helvetica Neue", Helvetica, Arial, sans-serif !important;\n    position: absolute;\n    display: block;\n    box-sizing: border-box;\n    pointer-events: none;\n}\n\n.is-shulie-item {\n    writing-mode: vertical-lr;\n    font-size: 16px;\n    letter-spacing: 4px;\n}\n\n.pre-topCard-list-item-line {\n    display: block;\n    height: 100px;\n    width: 1px;\n    margin-left: calc(50% + 2px);\n    margin-top: 3px;\n    background-color: #fff;\n}\n\n.pre-topCard-list-item-circle {\n    width: 10px;\n    height: 10px;\n    background-color: #fff;\n    border-radius: 50%;\n    margin-left: 5px;\n    margin-top: -10px;\n}`, 
  {});
  expect(address, [{
    "key" : `addPostRender`,
    "value" : function() {
      this.viewer.scene.postRender.addEventListener(this.postRender, this);
    }
  }, {
    "key" : `postRender`,
    "value" : function() {
      var item;
      var cw;
      if (this.container && this.container.style && this.position) {
        cw = this.viewer.scene.canvas.height;
        item = new Cesium.Cartesian2;
        Cesium.SceneTransforms.wgs84ToWindowCoordinates(this.viewer.scene, this.position, item);
        this.container.style.bottom = cw - item.y + 10 + "px";
        cw = this.container.offsetWidth;
        this.container.style.left = item.x - cw / 2 + "px";
        if (4E3 < this.viewer.camera.positionCartographic.height) {
          this.container.style.display = "none";
        } else {
          this.container.style.display = "block";
        }
      }
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.viewer.scene.postRender.removeEventListener(this.postRender, this);
      this.viewer.cesiumWidget.container.removeChild(this.container);
    }
  }, {
    "key" : `createDom`,
    "value" : function() {
      this.container = document.createElement("div");
      this.container.classList.add("is-shulie");
      var label = document.createElement("div");
      label.innerHTML = this.label;
      label.classList.add("is-shulie-item");
      this.container.appendChild(label);
      label = document.createElement("div");
      label.classList.add("pre-topCard-list-item-line");
      this.container.appendChild(label);
      label = document.createElement("div");
      label.classList.add("pre-topCard-list-item-circle");
      this.container.appendChild(label);
      this.viewer.cesiumWidget.container.appendChild(this.container);
    }
  }]);
  state = address;
  appendCSS(` .gradient-label {\n     text-align: center;\n     position: absolute;\n     padding: 5px 30px;\n     margin: 0;\n     color: #fff;\n     background: linear-gradient(rgb(7 10 203 / 75%), rgb(16 238 220));\n     -webkit-border-radius: 5px;\n     -moz-border-radius: 5px;\n     border-radius: 5px;\n     max-width: 180px;\n     max-height: 134px;\n     -webkit-user-select: none;\n     -moz-user-select: none;\n     -ms-user-select: none;\n     user-select: none;\n }\n \n .gradient-label:after {\n     content: "";\n     position: absolute;\n     bottom: -60px;\n     left: calc(50% - 3px);\n     display: block;\n     width: 3px;\n     height: 60px;\n     border-right: 3px solid #2bcdbb;\n }`, 
  {});
  expect(top, [{
    "key" : "addPostRender",
    "value" : function() {
      this.viewer.scene.postRender.addEventListener(this.postRender, this);
    }
  }, {
    "key" : `postRender`,
    "value" : function() {
      var item;
      var cw;
      if (this.container && this.container.style && this.position) {
        cw = this.viewer.scene.canvas.height;
        item = new Cesium["Cartesian2"];
        Cesium.SceneTransforms.wgs84ToWindowCoordinates(this.viewer.scene, this.position, item);
        this.container.style.bottom = cw - item.y + 60 + "px";
        cw = this.container.offsetWidth;
        this.container.style.left = item.x - cw / 2 + "px";
        if (4E3 < this.viewer.camera.positionCartographic.height) {
          this.container.style.display = "none";
        } else {
          this.container.style.display = "block";
        }
      }
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.viewer.scene.postRender.removeEventListener(this.postRender, this);
      this.viewer.cesiumWidget.container.removeChild(this.container);
    }
  }, {
    "key" : "createDom",
    "value" : function() {
      this.container = document.createElement("div");
      this.container.classList.add("gradient-label");
      var label = document.createElement("div");
      label.innerHTML = this.label;
      this.container.appendChild(label);
      this.viewer.cesiumWidget.container.appendChild(this.container);
    }
  }]);
  k = top;
  expect(capture, [{
    "key" : `add`,
    "value" : function() {
      var same = this;
      var len = this.height + this.style.bounceHeight;
      var i = 0;
      var pos = 0;
      this.bounceMarker = this.viewer.entities.add({
        "position" : new Cesium.CallbackProperty(function(canCreateDiscussions) {
          var rel2Mstr = hahaha;
          return pos = pos + same[rel2Mstr(1998)][rel2Mstr(584)], (i = i + pos) > same[rel2Mstr(1998)][rel2Mstr(1156)] && (i = same[rel2Mstr(1998)][rel2Mstr(1156)], pos = pos * -1, pos = pos * 0.55), Cesium[rel2Mstr(3131)][rel2Mstr(2770)](same[rel2Mstr(2140)], same[rel2Mstr(3054)], len - i);
        }),
        "billboard" : {
          "image" : this.style.image
        }
      });
      this.bounceMarker.bounce = function(a) {
        same.bounce();
      };
    }
  }, {
    "key" : `bounce`,
    "value" : function() {
      this.remove();
      this.add();
    }
  }, {
    "key" : "remove",
    "value" : function() {
      this.viewer.entities.remove(this.bounceMarker);
    }
  }]);
  entryToSend = capture;
  expect(append, [{
    "key" : `add`,
    "value" : function() {
      var same = this;
      var len = this.height + this.style.lineHeight;
      var end = len;
      var c = true;
      var i = len + this.style.bounceHeight;
      this.floatMarker = this.viewer.entities.add({
        "position" : new Cesium.CallbackProperty(function(canCreateDiscussions) {
          var rel2Mstr = hahaha;
          return c ? (end = end + same[rel2Mstr(1998)][rel2Mstr(584)], i < end && (c = false)) : (end = end - same[rel2Mstr(1998)][rel2Mstr(584)]) < len && (c = true), Cesium.Cartesian3[rel2Mstr(2770)](same[rel2Mstr(2140)], same[rel2Mstr(3054)], end);
        }),
        "billboard" : {
          "image" : this.style.image,
          "height" : 78,
          "width" : 42,
          "distanceDisplayCondition" : new Cesium["DistanceDisplayCondition"](0, 2E3)
        }
      });
      this.line = this.viewer.entities.add({
        "polyline" : {
          "positions" : Cesium.Cartesian3.fromDegreesArrayHeights([this.lng, this.lat, this.height, this.lng, this.lat, len]),
          "material" : new Cesium["PolylineDashMaterialProperty"]({
            "color" : Cesium.Color.AQUA
          }),
          "width" : 2,
          "distanceDisplayCondition" : new Cesium["DistanceDisplayCondition"](0, 2E3)
        }
      });
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.viewer.entities.remove(this.floatMarker);
      this.viewer.entities.remove(this.line);
    }
  }]);
  pos = append;
  expect(event, [{
    "key" : `init`,
    "value" : function() {
      var me = this;
      var img = new Image(512, 329);
      img.crossOrigin = "Anonymous";
      img.src = "data:image/png;base64,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";
      img.onload = function() {
        var propFunc = hahaha;
        var el = me.createCanvas({
          "image" : img,
          "text" : me[propFunc(2607)],
          "imgWidth" : 512,
          "imgHeight" : 329
        });
        var button = new Image(el.width, el[propFunc(1132)]);
        button[propFunc(2967)] = el[propFunc(555)](propFunc(2573));
        me[propFunc(2705)](button);
        me[propFunc(1E3)] = img;
        me.myCanvas = el;
      };
    }
  }, {
    "key" : "addBillboard",
    "value" : function(name) {
      this.plane = this.viewer.entities.add({
        "position" : this.position,
        "billboard" : {
          "image" : name,
          "verticalOrigin" : Cesium.VerticalOrigin.BOTTOM,
          "scaleByDistance" : new Cesium.NearFarScalar(800, 0.4, 1200, 0.2),
          "distanceDisplayCondition" : new Cesium["DistanceDisplayCondition"](0, 1E4)
        }
      });
    }
  }, {
    "key" : `createCanvas`,
    "value" : function(target) {
      var data = target.canvas;
      var src = target.image;
      var bg = target.text;
      return target.canvas || ((data = document.createElement("canvas")).width = target.imgWidth, data.height = target.imgHeight), target = data.getContext("2d"), target.clearRect(0, 0, data.width, data.height), target.drawImage(src, 0, 0), target.fillStyle = "rgb(255, 255, 255)", target.font = "80px sans-serif", target.textBaseline = "middle", target.fillText("\u6e29\u5ea6\uff1a", 50, data.height / 2), target.fillText(bg, 270, data.height / 2), target.fillText("\u2103", 380, data.height / 2), data;
    }
  }, {
    "key" : "updateText",
    "value" : function(target) {
      var canvas = this.createCanvas({
        "image" : this.origialImg,
        "text" : target,
        "canvas" : this.myCanvas
      });
      target = new Image(canvas.width, canvas.height);
      target.src = canvas.toDataURL("image/png");
      this.plane.billboard.image = target;
    }
  }]);
  location = event;
  appendCSS(`@keyframes dynamic-dynamic-divlabel-animate1 {\n    0%,\n    100% {\n        clip: rect(0px, var(--clip-width-1), 2px, 0px);\n    }\n    25% {\n        clip: rect(0px, 2px, var(--clip-height-1), 0px);\n    }\n    50% {\n        clip: rect( var(--clip-height-2), var(--clip-width-1), var(--clip-width-1), 0px);\n    }\n    75% {\n        clip: rect( 0px, var(--clip-width-1), var(--clip-height-1), var(--clip-width-2));\n    }\n}\n\n.dynamic-divlabel-container {\n    position: absolute;\n    left: 0px;\n    bottom: 0px;\n    pointer-events: none;\n    cursor: pointer;\n}\n\n.dynamic-divlabel-container1 {\n    --boder-height: 30px;\n    --clip-height-1: 40px;\n    --clip-height-2: 38px;\n    /* --border-color: rgb(24, 144, 255);\n    --box-shadow-color: rgba(24, 144, 255, 0.73); */\n    --text-color: #ccc;\n    --border-color: rgb(21, 209, 242);\n    --box-shadow-color: rgba(21, 209, 242, 0.56);\n    --text-font-size: 14px;\n    --clip-width-1: 165px;\n    --clip-width-2: 163px;\n    --boder-width: 150px;\n    --text-left-position: -75px;\n    --animation-name: dynamic-dynamic-divlabel-animate1;\n}\n\n.sz-component-animate-marker__boder {\n    width: var(--boder-width);\n    height: var(--boder-height);\n    margin: auto;\n    color: var(--border-color);\n    box-shadow: inset 0 0 0 1px var(--box-shadow-color);\n}\n\n.sz-component-animate-marker__text {\n    color: var(--text-color);\n    font-size: var(--text-font-size);\n    display: flex;\n    width: 100%;\n    height: 100%;\n    align-items: center;\n    justify-content: center;\n    font-weight: bolder;\n    user-select: none;\n    cursor: pointer;\n}\n\n.sz-component-animate-marker__boder,\n.sz-component-animate-marker__boder::before,\n.sz-component-animate-marker__boder::after {\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    left: 0;\n    right: 0;\n}\n\n.sz-component-animate-marker__boder::before,\n.sz-component-animate-marker__boder::after {\n    content: "";\n    margin: -5%;\n    box-shadow: inset 0 0 0 2px;\n    animation: var(--animation-name) 8s linear infinite;\n}\n\n.sz-component-animate-marker__boder::before {\n    animation-delay: -4s;\n}`, 
  {});
  expect(addItem, [{
    "key" : `createDom`,
    "value" : function() {
      this.$container = document.createElement("div");
      this.$container.classList.add("dynamic-divlabel-container");
      this.$container.classList.add("dynamic-divlabel-container1");
      this.$body = document.createElement("div");
      this.$body.classList.add("sz-component-animate-marker__boder");
      this.$label = document.createElement("span");
      this.$label.classList.add("sz-component-animate-marker__text");
      this.$label.innerHTML = this.label;
      this.$body.appendChild(this.$label);
      this.$container.appendChild(this.$body);
    }
  }, {
    "key" : `addPoint`,
    "value" : function() {
      this.viewer.entities.add({
        "position" : this.position,
        "point" : {
          "pixelSize" : 10,
          "color" : Cesium.Color.RED,
          "verticalOrigin" : Cesium.VerticalOrigin.BOTTOM
        }
      });
    }
  }, {
    "key" : `addPostRender`,
    "value" : function() {
      this.viewer.scene.postRender.addEventListener(this.postRender, this);
    }
  }, {
    "key" : "postRender",
    "value" : function() {
      var y;
      var cp;
      var width;
      if (this.$container && this.$container.style) {
        y = this.viewer.scene.canvas.height;
        cp = new Cesium.Cartesian2;
        Cesium.SceneTransforms.wgs84ToWindowCoordinates(this.viewer.scene, this.position, cp);
        width = this.$container.firstChild.offsetHeight;
        this.$container.style.bottom = y - cp.y + width + "px";
        width = this.$container.firstChild.offsetWidth;
        this.$container.style.left = cp.x - width / 2 + "px";
        if (14E3 < this.viewer.camera.positionCartographic.height) {
          this.$container.style.display = "none";
        } else {
          this.$container.style.display = "block";
        }
      }
    }
  }, {
    "key" : "remove",
    "value" : function() {
      this.$container.remove();
      this.viewer.scene.postRender.removeEventListener(this.postRender, this);
    }
  }]);
  frame = addItem;
  expect(_, [{
    "key" : "add",
    "value" : function(name, value, prop) {
      this.addBillboard(name, prop);
      this.addLabel(name, value);
    }
  }, {
    "key" : "addBillboard",
    "value" : function(value, target) {
      this.billboards.add({
        "position" : value,
        "image" : target,
        "scale" : 0.6,
        "verticalOrigin" : Cesium.VerticalOrigin.BOTTOM,
        "scaleByDistance" : new Cesium["NearFarScalar"](5E4, 1, 1E6, 0.4)
      });
    }
  }, {
    "key" : "addLabel",
    "value" : function(obj, value) {
      this.labels.add({
        "position" : obj,
        "text" : value,
        "fillColor" : Cesium.Color.WHITE,
        "scale" : 0.4,
        "font" : "normal 40px MicroSoft YaHei",
        "distanceDisplayCondition" : new Cesium.DistanceDisplayCondition(0, 5E5),
        "scaleByDistance" : new Cesium["NearFarScalar"](5E4, 1, 1E6, 0.4),
        "verticalOrigin" : Cesium.VerticalOrigin.BOTTOM,
        "style" : Cesium.LabelStyle.FILL_AND_OUTLINE,
        "pixelOffset" : new Cesium.Cartesian2(14, -4),
        "outlineWidth" : 20,
        "outlineColor" : Cesium.Color.BLACK
      });
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.viewer.scene.primitives.remove(this.billboards);
      this.viewer.scene.primitives.remove(this.labels);
    }
  }]);
  name = _;
  expect(self, [{
    "key" : `addDatasource`,
    "value" : function() {
      var me = this;
      (new Cesium["GeoJsonDataSource"]).load(this.data).then(function(obj) {
        var getDefaultLocale = hahaha;
        me.geoJsonDataSource = obj;
        me.viewer.dataSources[getDefaultLocale(3010)](obj);
        me[getDefaultLocale(1136)][getDefaultLocale(2477)](obj);
        obj.clustering[getDefaultLocale(2622)] = true;
        obj[getDefaultLocale(2685)].pixelRange = me[getDefaultLocale(1724)][getDefaultLocale(1297)];
        obj[getDefaultLocale(2685)][getDefaultLocale(1559)] = me[getDefaultLocale(1724)][getDefaultLocale(1559)];
        me[getDefaultLocale(2974)](obj);
        obj[getDefaultLocale(1319)].values[getDefaultLocale(1889)](function(values) {
          var parseInt = getDefaultLocale;
          values[parseInt(3136)][parseInt(1603)] = me.options[parseInt(593)];
          values.type = "cluster1";
        });
      });
    }
  }, {
    "key" : `setClusterEvent`,
    "value" : function(obj) {
      var map = this;
      this.removeListener = obj.clustering.clusterEvent.addEventListener(function(currentItems, obj) {
        var parseInt = hahaha;
        obj[parseInt(3136)][parseInt(2752)] = true;
        obj[parseInt(2820)][parseInt(2752)] = false;
        obj.billboard.id = obj[parseInt(2820)].id;
        obj[parseInt(3136)][parseInt(1578)] = Cesium[parseInt(2999)][parseInt(2812)];
        if (300 <= currentItems.length) {
          obj[parseInt(3136)].image = map[parseInt(1724)][parseInt(1685)] + parseInt(2345);
        } else {
          if (150 <= currentItems[parseInt(2189)]) {
            obj[parseInt(3136)].image = map[parseInt(1724)][parseInt(1685)] + parseInt(2213);
          } else {
            if (90 <= currentItems.length) {
              obj.billboard[parseInt(1603)] = map[parseInt(1724)][parseInt(1685)] + parseInt(2152);
            } else {
              if (30 <= currentItems[parseInt(2189)]) {
                obj[parseInt(3136)][parseInt(1603)] = map.options[parseInt(1685)] + "/30+.png";
              } else {
                if (10 < currentItems[parseInt(2189)]) {
                  obj[parseInt(3136)][parseInt(1603)] = map[parseInt(1724)][parseInt(1685)] + parseInt(2395);
                } else {
                  obj[parseInt(3136)].image = map.options[parseInt(1685)] + "/" + currentItems[parseInt(2189)] + ".png";
                }
              }
            }
          }
        }
      });
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.viewer.dataSources.add(this.geoJsonDataSource);
    }
  }]);
  init = self;
  expect(close, [{
    "key" : `addDatasource`,
    "value" : function() {
      var map = this;
      (new Cesium["GeoJsonDataSource"]).load(this.data).then(function(obj) {
        var parseInt = hahaha;
        map[parseInt(1925)] = obj;
        map[parseInt(2276)][parseInt(2657)][parseInt(3010)](obj);
        map[parseInt(1136)][parseInt(2477)](obj);
        obj[parseInt(2685)][parseInt(2622)] = true;
        obj[parseInt(2685)][parseInt(1297)] = map[parseInt(1724)].pixelRange;
        obj.clustering[parseInt(1559)] = map[parseInt(1724)][parseInt(1559)];
        map.setClusterEvent(obj);
        obj[parseInt(1319)].values.forEach(function(base_c) {
          var getConcrete = parseInt;
          base_c[getConcrete(3136)][getConcrete(1603)] = map.options[getConcrete(593)];
          base_c[getConcrete(1720)] = getConcrete(2153);
        });
      });
    }
  }, {
    "key" : `setClusterEvent`,
    "value" : function(obj) {
      var formats = this;
      this.removeListener = obj.clustering.clusterEvent.addEventListener(function(data, map) {
        var parseInt = hahaha;
        map[parseInt(3136)].show = true;
        map.label.show = false;
        map[parseInt(3136)].id = map[parseInt(2820)].id;
        map[parseInt(3136)][parseInt(1578)] = Cesium.VerticalOrigin[parseInt(2812)];
        map[parseInt(3136)][parseInt(1603)] = formats[parseInt(1631)](data[parseInt(2189)]);
      });
    }
  }, {
    "key" : "getCluserImage",
    "value" : function(value) {
      if (this.cluserImages[value]) {
        return this.cluserImages[value];
      }
      var clipCanvas = document.createElement("canvas");
      var size = 12 * (value + "").length + 50;
      clipCanvas.width = clipCanvas.height = size;
      var ctx = clipCanvas.getContext("2d");
      ctx.beginPath();
      ctx.globalAlpha = 0.5;
      ctx.fillStyle = this.getClusterColor(value);
      ctx.arc(size / 2, size / 2, size / 2 - 5, 0, 2 * Math.PI);
      ctx.fill();
      ctx.beginPath();
      ctx.globalAlpha = 0.8;
      ctx.fillStyle = this.getClusterColor(value);
      ctx.arc(size / 2, size / 2, size / 2 - 10, 0, 2 * Math.PI);
      ctx.fill();
      ctx.font = "20px \u5fae\u8f6f\u96c5\u9ed1";
      ctx.globalAlpha = 1;
      ctx.fillStyle = "rgb(255,255,255)";
      var xtext = size / 2 - 12 * value.toString().length / 2;
      return ctx.fillText(value, xtext, size / 2 + 10), clipCanvas;
    }
  }, {
    "key" : `getClusterColor`,
    "value" : function(key) {
      var target = 0;
      for (; target < this.clusterColors.length; target++) {
        var self = this.clusterColors[target];
        if (key >= self.value) {
          return self.color;
        }
      }
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.viewer.dataSources.add(this.geoJsonDataSource);
    }
  }]);
  data = close;
  expect(load, [{
    "key" : "addPostRender",
    "value" : function() {
      this.viewer.scene.postRender.addEventListener(this.postRender, this);
    }
  }, {
    "key" : "postRender",
    "value" : function() {
      var item;
      var cw;
      if (this.container && this.container.style && this.position) {
        cw = this.viewer.scene.canvas.height;
        item = new Cesium["Cartesian2"];
        Cesium.SceneTransforms.wgs84ToWindowCoordinates(this.viewer.scene, this.position, item);
        this.container.style.bottom = cw - item.y + 10 + "px";
        cw = this.container.offsetWidth;
        this.container.style.left = item.x - cw / 2 + "px";
        if (1E3 < this.viewer.camera.positionCartographic.height) {
          this.container.style.display = "none";
        } else {
          this.container.style.display = "block";
        }
      }
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.viewer.scene.postRender.removeEventListener(this.postRender, this);
      this.chart.dispose();
      this.viewer.cesiumWidget.container.removeChild(this.container);
    }
  }, {
    "key" : `createDom`,
    "value" : function() {
      this.container = document.createElement("div");
      this.container.style.cssText = "position:absolute;height:80px;width:80px;pointer-events:none";
      this.container.setAttribute("id", this.domId);
      this.viewer.cesiumWidget.container.appendChild(this.container);
    }
  }, {
    "key" : `initChart`,
    "value" : function() {
      this.chart = echarts.init(this.container);
      if (!this.option) {
        this.option = this.getOption();
      }
      this.chart.setOption(this.option);
    }
  }, {
    "key" : `getOption`,
    "value" : function() {
      return {
        "series" : [{
          "type" : "liquidFill",
          "data" : [0.51],
          "radius" : "90%",
          "outline" : {
            "show" : false
          },
          "label" : {
            "position" : ["50%", "65%"],
            "textStyle" : {
              "fontSize" : 15,
              "fontFamily" : "Lobster Two"
            }
          },
          "itemStyle" : {
            "color" : "#ff9501"
          }
        }]
      };
    }
  }]);
  forced = load;
  appendCSS(`.hot-spot {\n    user-select: none;\n    z-index: 999;\n    width: 70px;\n    height: 44px;\n    background-size: cover;\n    left: 0px;\n    bottom: 0px;\n    font-family: "PingFang-SC-Regular", "Helvetica Neue", "PingFang SC", Helvetica, "Hiragino Sans GB", "Microsoft YaHei", "\u5fae\u8f6f\u96c5\u9ed1", Arial, sans-serif;\n}\n\n.hot-spot,\n.hot-spot .hot-spot-board {\n    position: absolute;\n    background-repeat: no-repeat;\n}\n\n.hot-spot .hot-spot-board {\n    top: -240px;\n    transform: translateX(-30%);\n    width: 180px;\n    height: 52px;\n    padding: 15px 0;\n    background-position: 50%;\n    background-size: contain;\n    cursor: pointer;\n}\n\n.hot-spot .hot-spot-board-medium {\n    top: -200px;\n}\n\n.hot-spot .hot-spot-line {\n    position: absolute;\n    top: -158px;\n    left: 35px;\n    width: 2px;\n    height: 180px;\n    background: linear-gradient(180deg, #38c9ff, transparent);\n}\n\n.hot-spot .hot-spot-line:after {\n    height: 60%;\n    left: -5px;\n    animation: rise 3s linear infinite;\n    -webkit-animation: rise 3s linear infinite;\n    -moz-animation: rise 3s linear infinite;\n    -ms-animation: rise 3s linear infinite;\n    -o-animation: rise 3s linear infinite;\n}\n\n.hot-spot .hot-spot-line:after,\n.hot-spot .hot-spot-line:before {\n    content: "";\n    display: block;\n    width: 1px;\n    background: linear-gradient(180deg, #38c9ff, transparent);\n    position: absolute;\n    cursor: pointer;\n}\n\n.hot-spot .hot-spot-line:before {\n    height: 40%;\n    left: 6px;\n    animation: rise 3s linear 1s infinite;\n    -webkit-animation: rise 3s linear 1s infinite;\n    -moz-animation: rise 3s linear 1s infinite;\n    -ms-animation: rise 3s linear 1s infinite;\n    -o-animation: rise 3s linear 1s infinite;\n}\n\n.hot-spot .hot-spot-line-medium {\n    height: 140px;\n    top: -118px;\n}\n\n.hot-spot h5 {\n    font-size: 16px;\n    margin: 0;\n}\n\n.hot-spot h5,\n.hot-spot p {\n    width: 100%;\n    text-align: center;\n    line-height: 24px;\n    color: #beedff;\n}\n\n.hot-spot p {\n    font-size: 12px;\n}\n\n.hot-spot:hover {\n    background-position: 50%;\n    background-size: contain;\n    background-repeat: no-repeat;\n    cursor: pointer;\n}\n\n.hot-spot:hover h5,\n.hot-spot:hover p {\n    color: #fff;\n}\n\n.hot-spot:hover .hot-spot-line {\n    background: linear-gradient(180deg, #ff7a21, transparent);\n    background-size: contain;\n    background-repeat: no-repeat;\n}\n\n.hot-spot:hover .hot-spot-line:after,\n.hot-spot:hover .hot-spot-line:before {\n    background: linear-gradient(180deg, #ff7a21, transparent);\n}\n\n@-webkit-keyframes rise {\n    0% {\n        opacity: 0;\n        top: 75%;\n    }\n    50% {\n        opacity: 1;\n    }\n    to {\n        opacity: 0;\n        top: 0;\n    }\n}\n\n@keyframes rise {\n    0% {\n        opacity: 0;\n        top: 75%;\n    }\n    50% {\n        opacity: 1;\n    }\n    to {\n        opacity: 0;\n        top: 0;\n    }\n}\n\n.board {\n    position: fixed;\n    bottom: 0;\n    left: 0;\n    width: 100vw;\n    height: 40px;\n    line-height: 40px;\n    background-color: rgba(0, 0, 0, 0.5);\n    color: #fff;\n    text-align: center;\n    font-size: 12px;\n}`, 
  {});
  expect(show, [{
    "key" : `addPoint`,
    "value" : function() {
      this.viewer.entities.add({
        "position" : this.position,
        "point" : {
          "pixelSize" : 10,
          "color" : Cesium.Color.RED,
          "verticalOrigin" : Cesium.VerticalOrigin.BOTTOM
        }
      });
    }
  }, {
    "key" : `createDom`,
    "value" : function() {
      this.container = document.createElement("div");
      this.container.innerHTML = '<div class="hot-spot">\n            <div class="hot-spot-board hot-spot-board-medium">\n              <h5> ' + this.style.chineseTitle + "</h5>\n              <p> " + this.style.englishTitle + '</p>\n            </div>\n            <div class="hot-spot-line hot-spot-line-medium"></div>\n          </div>';
    }
  }, {
    "key" : "addPostRender",
    "value" : function() {
      this.viewer.scene.postRender.addEventListener(this.postRender, this);
    }
  }, {
    "key" : `postRender`,
    "value" : function() {
      var item;
      var cw;
      if (this.container && this.container.style) {
        cw = this.viewer.scene.canvas.height;
        item = new Cesium["Cartesian2"];
        Cesium.SceneTransforms.wgs84ToWindowCoordinates(this.viewer.scene, this.position, item);
        this.container.style.position = "absolute";
        this.container.style.bottom = cw - item.y + "px";
        cw = this.container.offsetWidth;
        this.container.style.left = item.x - cw / 2 + "px";
        if (5E3 < this.viewer.camera.positionCartographic.height) {
          this.container.style.display = "none";
        } else {
          this.container.style.display = "block";
        }
      }
    }
  }, {
    "key" : `windowClose`,
    "value" : function() {
      this.container.remove();
      this.viewer.scene.postRender.removeEventListener(this.postRender, this);
    }
  }]);
  mode = show;
  appendCSS(`.div-point-container {\n    position: absolute;\n    left: 0px;\n    bottom: 0px;\n    display: block;\n}\n\n.divpoint-wrap {\n    position: relative;\n    padding: 30px;\n    overflow: hidden;\n}\n\n.divpoint-theme .arrow,\n.divpoint-theme .title::before {\n    /* background-color: #28bbf0; */\n    background-color: #4984ed;\n}\n\n.divpoint .arrow {\n    position: absolute;\n    bottom: 0;\n    left: 0;\n    width: 45px;\n    height: 2px;\n    transform: rotate(-45deg) translate(5px, -15px);\n}\n\n.divpoint-theme .area {\n    background-image: linear-gradient( 135deg, transparent 30px, #28bbf06c 30px, #28bbf06c 50%, transparent 50%), linear-gradient( -45deg, transparent 30px, #28bbf06c 30px, #28bbf06c 50.1%, transparent 50%);\n}\n\n.divpoint .area {\n    position: relative;\n    min-width: 180px;\n    min-height: 150px;\n}\n\n.divpoint-theme .b-b,\n.divpoint-theme .b-b-r,\n.divpoint-theme .b-l,\n.divpoint-theme .b-r,\n.divpoint-theme .b-t,\n.divpoint-theme .b-t-l {\n    /* background:  #29baf1; */\n    background-color: #4984ed;\n    /* box-shadow: 0 0 10px 2px #29baf1; */\n    box-shadow: 0 0 10px 2px #4984ed;\n}\n\n.divpoint .b-t-l {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 1px;\n    height: 62px;\n    transform: rotate(45deg) translate(52px, -22px);\n    z-index: 10;\n}\n\n.divpoint .b-b-r {\n    position: absolute;\n    bottom: 0;\n    right: 0;\n    width: 1px;\n    height: 62px;\n    transform: rotate(45deg) translate(-52px, 22px);\n    z-index: 10;\n}\n\n.divpoint .b-t {\n    position: absolute;\n    top: 0;\n    left: 44px;\n    right: 0;\n    height: 1px;\n    z-index: 10;\n}\n\n.divpoint .b-r {\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 44px;\n    width: 1px;\n    z-index: 10;\n}\n\n.divpoint .b-b {\n    position: absolute;\n    left: 0;\n    right: 44px;\n    bottom: 0;\n    height: 1px;\n    z-index: 10;\n}\n\n.divpoint .b-l {\n    position: absolute;\n    top: 44px;\n    left: 0;\n    bottom: 0;\n    width: 1px;\n    z-index: 10;\n}\n\n.divpoint .label-wrap {\n    padding-left: 12px;\n    color: #fff;\n    font-size: 16px;\n    white-space: nowrap;\n    overflow: hidden;\n}\n\n.divpoint-theme .title {\n    /* background-image: linear-gradient(135deg, transparent 25px, #29baf1 25px); */\n    background-image: linear-gradient(135deg, transparent 25px, #4984ed 25px);\n}\n\n.divpoint .title {\n    margin-top: 20px;\n    padding: 0 12px 0 30px;\n    height: 36px;\n    line-height: 36px;\n    position: relative;\n}\n\n.divpoint .data-li {\n    padding: 4px 45px 4px 0;\n}\n\n.data-value,\n.divpoint .data-label {\n    display: inline-block;\n}\n\n.divpoint .data-value {\n    font-size: 14px;\n}\n\n.data-value,\n.divpoint .data-label {\n    display: inline-block;\n}\n\n.divpoint .label-num {\n    margin-right: 3px;\n    color: #f09e28;\n    font-weight: 600;\n}\n\n.divpoint .label-tag {\n    display: inline-block;\n    position: relative;\n    margin-right: 6px;\n    padding: 0 6px;\n    font-weight: 600;\n    cursor: pointer;\n    background-color: #909399;\n    border-radius: 4px;\n}`, 
  {});
  expect(insertAfter, [{
    "key" : "addPoint",
    "value" : function() {
      this.viewer.entities.add({
        "position" : this.position,
        "point" : {
          "pixelSize" : 10,
          "color" : Cesium.Color.RED,
          "verticalOrigin" : Cesium.VerticalOrigin.BOTTOM
        }
      });
    }
  }, {
    "key" : `createDom`,
    "value" : function() {
      this.$container = document.createElement("div");
      this.$container.innerHTML = ' <div class="div-point-container">\n                  <div class="divpoint divpoint-theme">\n                    <div class="divpoint-wrap">\n                      <div class="area">\n                        <div class="arrow-lt"></div>\n                        <div class="b-t"></div>\n                        <div class="b-r"></div>\n                        <div class="b-b"></div>\n                        <div class="b-l"></div>\n                        <div class="arrow-rb"></div>\n                        <div class="label-wrap">\n                          <div class="title">' + 
      this.wStation.name + '</div>\n                          <div class="label-content">\n                            <div class="data-li">\n                              <div class="data-label">\u5b9e\u65f6\u6d41\u91cf\uff1a</div>\n                              <div class="data-value">\n                                <span class="label-num">' + this.wStation.flow + '</span>\n                                <span class="label-unit">m\u00b3/s</span>\n                              </div>\n                            </div>\n\n                            <div class="data-li">\n                              <div class="data-label">\u6c34\u6c60\u6db2\u4f4d\uff1a</div>\n                              <div class="data-value">\n                                <span class="label-num">' + 
      this.wStation.stage + '</span>\n                                <span class="label-unit">m</span>\n                              </div>\n                            </div>\n                            <div class="data-li data-li-state">\n                              <div class="data-label">\u6c34\u6cf5\u72b6\u6001\uff1a</div>\n                             \x3c!-- <div class="data-value" v-for="(item, index) in wStation.status" :key="index">\n                                <el-tooltip\n                                  class="item"\n                                  effect="dark"\n                                  :content="item.stateName"\n                                  placement="bottom"\n                                >\n                                  <span class="label-tag" :style="{\'background\':getBg(item.state)}">{{item.num}}\u53f7</span>\n                                </el-tooltip>\n                              </div>--\x3e\n                            </div>\n                          </div>\n                        </div>\n                      </div>\n                      <div class="b-t-l"></div>\n                      <div class="b-b-r"></div>\n                    </div>\n                    <div class="arrow"></div>\n                  </div>\n                </div>';
    }
  }, {
    "key" : "addStates",
    "value" : function() {
      var page = this;
      var el = this.$container.getElementsByClassName("data-li-state")[0];
      this.wStation.status.forEach(function(jsFiles) {
        var rel2Mstr = hahaha;
        var same = document[rel2Mstr(1442)](rel2Mstr(2766));
        same[rel2Mstr(2209)][rel2Mstr(3010)]("label-tag");
        same[rel2Mstr(3008)] = jsFiles[rel2Mstr(2661)] + "\u53f7";
        same[rel2Mstr(1998)][rel2Mstr(2733)] = page.getBg(jsFiles[rel2Mstr(1844)]);
        el[rel2Mstr(1545)](same);
      });
    }
  }, {
    "key" : `getBg`,
    "value" : function(name) {
      switch(name) {
        case 0:
          return "red";
        case 1:
          return "green";
        case 2:
          return "#ffff00ab";
      }
    }
  }, {
    "key" : `addPostRender`,
    "value" : function() {
      this.viewer.scene.postRender.addEventListener(this.postRender, this);
    }
  }, {
    "key" : `postRender`,
    "value" : function() {
      var bodyHeight;
      var result;
      if (this.$container && this.$container.style) {
        bodyHeight = this.viewer.scene.canvas.height;
        result = new Cesium.Cartesian2;
        Cesium.SceneTransforms.wgs84ToWindowCoordinates(this.viewer.scene, this.position, result);
        this.$container.style.position = "absolute";
        this.$container.style.bottom = bodyHeight - result.y + "px";
        this.$container.offsetWidth;
        this.$container.style.left = result.x + "px";
        if (14E3 < this.viewer.camera.positionCartographic.height) {
          this.$container.style.display = "none";
        } else {
          this.$container.style.display = "block";
        }
      }
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.viewer.scene.postRender.removeEventListener(this.postRender, this);
      this.$container.remove();
    }
  }]);
  exports = insertAfter;
  expect(input, [{
    "key" : "addDatasource",
    "value" : function() {
      var o = this;
      (new Cesium["GeoJsonDataSource"]).load(this.data).then(function(obj) {
        var parseInt = hahaha;
        o[parseInt(1925)] = obj;
        o.viewer[parseInt(2657)][parseInt(3010)](obj);
        o.DataLoadedEvent[parseInt(2477)](obj);
        obj.clustering.enabled = true;
        obj[parseInt(2685)][parseInt(1297)] = o[parseInt(1724)][parseInt(1297)];
        obj[parseInt(2685)][parseInt(1559)] = o[parseInt(1724)][parseInt(1559)];
        o.setClusterEvent(obj);
        obj[parseInt(1319)][parseInt(944)].forEach(function(data) {
          var trim = parseInt;
          data[trim(3136)][trim(1603)] = o[trim(1724)][trim(593)];
          data.type = trim(2153);
        });
      });
    }
  }, {
    "key" : `setClusterEvent`,
    "value" : function(obj) {
      var wasmJS = this;
      this.removeListener = obj.clustering.clusterEvent.addEventListener(function(code, obj) {
        var parseInt = hahaha;
        obj[parseInt(3136)][parseInt(2752)] = true;
        obj.label[parseInt(2752)] = false;
        obj[parseInt(3136)].id = obj[parseInt(2820)].id;
        obj[parseInt(3136)].verticalOrigin = Cesium[parseInt(2999)][parseInt(2812)];
        obj[parseInt(3136)][parseInt(1603)] = wasmJS[parseInt(1631)](code.length);
      });
    }
  }, {
    "key" : `getCluserImage`,
    "value" : function(name) {
      if (this.cluserImages[name]) {
        return this.cluserImages[name];
      }
      var textedCanvas = document.createElement("canvas");
      var size = textedCanvas.height = textedCanvas.width = 12 * (name + "").length + 50;
      var ctx = textedCanvas.getContext("2d");
      ctx.save();
      var color = this.getClusterColor(name);
      ctx.fillStyle = color;
      ctx.arc(size / 2, size / 2, size / 4, 0, 2 * Math.PI);
      ctx.fill();
      ctx.closePath();
      ctx.lineWidth = 4;
      var _0xedf7c = 0;
      for (; _0xedf7c < 1; _0xedf7c++) {
        ctx.beginPath();
        ctx.arc(size / 2, size / 2, size / 4 + 4, 0, 2 * Math.PI, false);
        ctx.strokeStyle = Cesium.Color.fromCssColorString(color).withAlpha(0.4).toCssColorString();
        ctx.stroke();
        ctx.arc(size / 2, size / 2, size / 4 + 10, 0, 2 * Math.PI, false);
        ctx.strokeStyle = Cesium.Color.fromCssColorString(color).withAlpha(0.2).toCssColorString();
        ctx.stroke();
        ctx.closePath();
      }
      ctx.font = "20px \u5fae\u8f6f\u96c5\u9ed1";
      ctx.globalAlpha = 1;
      ctx.fillStyle = "rgb(255,255,255)";
      var introWordLeft = size / 2 - 12 * name.toString().length / 2;
      return ctx.fillText(name, introWordLeft, size / 2 + 8), ctx.restore(), this.cluserImages[name] = textedCanvas;
    }
  }, {
    "key" : "getClusterColor",
    "value" : function(key) {
      var target = 0;
      for (; target < this.clusterColors.length; target++) {
        var self = this.clusterColors[target];
        if (key >= self.value) {
          return self.color;
        }
      }
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.viewer.dataSources.add(this.geoJsonDataSource);
    }
  }]);
  output = input;
  expect(track, [{
    "key" : `addDatasource`,
    "value" : function() {
      var el = this;
      (new Cesium["GeoJsonDataSource"]).load(this.data).then(function(same) {
        var rel2Mstr = hahaha;
        el[rel2Mstr(1925)] = same;
        el[rel2Mstr(2276)][rel2Mstr(2657)][rel2Mstr(3010)](same);
        el[rel2Mstr(1136)][rel2Mstr(2477)](same);
        same[rel2Mstr(2685)][rel2Mstr(2622)] = true;
        same[rel2Mstr(2685)][rel2Mstr(1297)] = el[rel2Mstr(1724)][rel2Mstr(1297)];
        same[rel2Mstr(2685)][rel2Mstr(1559)] = el[rel2Mstr(1724)][rel2Mstr(1559)];
        el[rel2Mstr(2974)](same);
        same[rel2Mstr(1319)][rel2Mstr(944)][rel2Mstr(1889)](function(parameters) {
          var camelize = rel2Mstr;
          parameters.billboard[camelize(1603)] = el.options[camelize(593)];
          parameters.type = camelize(2153);
        });
      });
    }
  }, {
    "key" : "setClusterEvent",
    "value" : function(obj) {
      var phpr = this;
      this.removeListener = obj.clustering.clusterEvent.addEventListener(function(types, obj) {
        var random = hahaha;
        obj[random(3136)][random(2752)] = true;
        obj[random(2820)][random(2752)] = false;
        obj.billboard.id = obj.label.id;
        obj.billboard[random(1578)] = Cesium[random(2999)].BOTTOM;
        obj[random(3136)].image = phpr.getCluserImage(types[random(2189)]);
      });
    }
  }, {
    "key" : `getCluserImage`,
    "value" : function(name) {
      if (this.cluserImages[name]) {
        return this.cluserImages[name];
      }
      var textedCanvas = document.createElement("canvas");
      var size = textedCanvas.height = textedCanvas.width = 12 * (name + "").length + 50;
      var ctx = textedCanvas.getContext("2d");
      ctx.save();
      var color = this.getClusterColor(name);
      ctx.fillStyle = color;
      ctx.arc(size / 2, size / 2, size / 4, 0, 2 * Math.PI);
      ctx.fill();
      ctx.closePath();
      var a1 = 0;
      var ad = 90 * Math.PI / 180;
      var a3 = 30 * Math.PI / 180;
      ctx.lineWidth = 4;
      var _0x18aaf6 = 0;
      for (; _0x18aaf6 < 3; _0x18aaf6++) {
        ctx.beginPath();
        ctx.arc(size / 2, size / 2, size / 4 + 4, a1, a1 + ad, false);
        ctx.strokeStyle = Cesium.Color.fromCssColorString(color).withAlpha(0.4).toCssColorString();
        ctx.stroke();
        ctx.arc(size / 2, size / 2, size / 4 + 10, a1, a1 + ad, false);
        ctx.strokeStyle = Cesium.Color.fromCssColorString(color).withAlpha(0.2).toCssColorString();
        ctx.stroke();
        a1 = a1 + ad + a3;
        ctx.closePath();
      }
      ctx.font = "20px \u5fae\u8f6f\u96c5\u9ed1";
      ctx.globalAlpha = 1;
      ctx.fillStyle = "rgb(255,255,255)";
      var introWordLeft = size / 2 - 12 * name.toString().length / 2;
      return ctx.fillText(name, introWordLeft, size / 2 + 8), ctx.restore(), this.cluserImages[name] = textedCanvas;
    }
  }, {
    "key" : `getClusterColor`,
    "value" : function(key) {
      var target = 0;
      for (; target < this.clusterColors.length; target++) {
        var self = this.clusterColors[target];
        if (key >= self.value) {
          return self.color;
        }
      }
    }
  }, {
    "key" : "remove",
    "value" : function() {
      this.viewer.dataSources.add(this.geoJsonDataSource);
    }
  }]);
  ID = track;
  expect(bind, [{
    "key" : `addDatasource`,
    "value" : function() {
      var o = this;
      (new Cesium["GeoJsonDataSource"]).load(this.data).then(function(obj) {
        var parseInt = hahaha;
        o.geoJsonDataSource = obj;
        o.viewer[parseInt(2657)][parseInt(3010)](obj);
        o[parseInt(1136)][parseInt(2477)](obj);
        obj[parseInt(2685)][parseInt(2622)] = true;
        obj[parseInt(2685)].pixelRange = o[parseInt(1724)].pixelRange;
        obj[parseInt(2685)][parseInt(1559)] = o[parseInt(1724)].minimumClusterSize;
        o[parseInt(2974)](obj);
        obj.entities[parseInt(944)][parseInt(1889)](function(data) {
          var camelize = parseInt;
          data[camelize(3136)].image = o.options[camelize(593)];
          data[camelize(1720)] = camelize(2153);
        });
      });
    }
  }, {
    "key" : `setClusterEvent`,
    "value" : function(obj) {
      var formats = this;
      this.removeListener = obj.clustering.clusterEvent.addEventListener(function(data, obj) {
        var parseInt = hahaha;
        obj[parseInt(3136)][parseInt(2752)] = true;
        obj.label[parseInt(2752)] = false;
        obj.billboard.id = obj.label.id;
        obj.billboard[parseInt(1578)] = Cesium[parseInt(2999)][parseInt(2812)];
        obj[parseInt(3136)].image = formats[parseInt(1631)](data[parseInt(2189)]);
      });
    }
  }, {
    "key" : `getCluserImage`,
    "value" : function(name) {
      if (this.cluserImages[name]) {
        return this.cluserImages[name];
      }
      var textedCanvas = document.createElement("canvas");
      var size = textedCanvas.height = textedCanvas.width = 12 * (name + "").length + 50;
      var ctx = textedCanvas.getContext("2d");
      ctx.save();
      var color = this.getClusterColor(name);
      ctx.fillStyle = color;
      ctx.arc(size / 2, size / 2, size / 4, 0, 2 * Math.PI);
      ctx.fill();
      ctx.closePath();
      var a1 = 0;
      var ad = 80 * Math.PI / 180;
      var a3 = 40 * Math.PI / 180;
      ctx.lineWidth = size / 4;
      var _0x2c8676 = 0;
      for (; _0x2c8676 < 3; _0x2c8676++) {
        ctx.beginPath();
        ctx.arc(size / 2, size / 2, size / 4 + 4, a1, a1 + ad, false);
        ctx.strokeStyle = Cesium.Color.fromCssColorString(color).withAlpha(0.4).toCssColorString();
        ctx.stroke();
        a1 = a1 + ad + a3;
        ctx.closePath();
      }
      ctx.font = "20px \u5fae\u8f6f\u96c5\u9ed1";
      ctx.globalAlpha = 1;
      ctx.fillStyle = "rgb(255,255,255)";
      var introWordLeft = size / 2 - 12 * name.toString().length / 2;
      return ctx.fillText(name, introWordLeft, size / 2 + 8), ctx.restore(), this.cluserImages[name] = textedCanvas;
    }
  }, {
    "key" : "getClusterColor",
    "value" : function(key) {
      var target = 0;
      for (; target < this.clusterColors.length; target++) {
        var self = this.clusterColors[target];
        if (key >= self.value) {
          return self.color;
        }
      }
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.viewer.dataSources.add(this.geoJsonDataSource);
    }
  }]);
  descriptor = bind;
  xt3d.PointObject = {
    "SampleLabel" : view,
    "AlertMarker" : doc,
    "BillboardGif" : tel,
    "ErectLabel" : state,
    "GradientLabel" : k,
    "BounceMarker" : entryToSend,
    "FloatMarker" : pos,
    "BillboardPlane" : location,
    "DynamicDivLabel" : frame,
    "PrimitiveLabelCol" : name,
    "PointCluster1" : init,
    "PointCluster2" : data,
    "Liquidfill" : forced,
    "HotSpotBoard" : mode,
    "DivPoint" : exports,
    "PointCluster3" : output,
    "PointCluster4" : ID,
    "PointCluster5" : descriptor
  };
  expect(inner, [{
    "key" : `createPrimitive`,
    "value" : function() {
      var D_geometry = new Cesium["PolygonGeometry"]({
        "polygonHierarchy" : new Cesium.PolygonHierarchy(this.positions),
        "perPositionHeight" : true,
        "vertexFormat" : Cesium.EllipsoidSurfaceAppearance.VERTEX_FORMAT
      });
      return new Cesium.Primitive({
        "geometryInstances" : new Cesium["GeometryInstance"]({
          "geometry" : D_geometry
        }),
        "appearance" : this.getApper(),
        "show" : true
      });
    }
  }, {
    "key" : `getApper`,
    "value" : function() {
      var points_fb = new Cesium["EllipsoidSurfaceAppearance"]({
        "aboveGround" : true
      });
      return points_fb.material = new Cesium["Material"]({
        "fabric" : {
          "type" : "Water",
          "uniforms" : {
            "baseWaterColor" : this.options.baseWaterColor,
            "normalMap" : this.options.normalMap,
            "frequency" : this.options.frequency,
            "animationSpeed" : this.options.animationSpeed,
            "amplitude" : this.options.amplitude,
            "specularIntensity" : this.options.specularIntensity
          }
        }
      }), points_fb;
    }
  }]);
  location = inner;
  frame = function update(name) {
    return call(this, update), new Cesium.MaterialAppearance({
      "material" : new Cesium["Material"]({
        "fabric" : {
          "uniforms" : {
            "color" : name
          },
          "source" : "\n                    uniform vec4 color; \n                    czm_material czm_getMaterial(czm_materialInput materialInput)\n                    {\n                        czm_material material = czm_getDefaultMaterial(materialInput); \n                        vec2 st = materialInput.st;                        \n                        float alpha = distance(st,vec2(0.5, 0.5)); \n                        material.alpha = color.a  * alpha  * 1.5; \n                        material.diffuse = color.rgb * 1.3;                            \n                        return material;\n                    }\n                    "
        },
        "translucent" : true
      }),
      "faceForward" : false,
      "closed" : false
    });
  };
  var $assign = Object.assign;
  name = !$assign || processResource(function() {
    var A = {};
    var b = {};
    var S = Symbol();
    var K = "abcdefghijklmnopqrst";
    return A[S] = 7, K.split("").forEach(function(gid) {
      b[gid] = gid;
    }), 7 != $assign({}, A)[S] || Object.keys($assign({}, b)).join("") != K;
  }) ? function(value, obj) {
    var obj = toObject(value);
    var _len8 = arguments.length;
    var _key8 = 1;
    var callback = req.f;
    var isEnum = pIE.f;
    for (; _key8 < _len8;) {
      var property;
      var value = exists(arguments[_key8++]);
      var result = callback ? flatten(value).concat(callback(value)) : flatten(value);
      var s = result.length;
      var j = 0;
      for (; j < s;) {
        property = result[j++];
        if (!(es5 && !isEnum.call(value, property))) {
          obj[property] = value[property];
        }
      }
    }
    return obj;
  } : $assign;
  $export($export.S + $export.F, `Object`, {
    "assign" : name
  });
  var defaultActor = core.Object.assign;
  var _variationComponents = __webpack_require__(function(module) {
    module.exports = {
      "default" : defaultActor,
      "__esModule" : true
    };
  });
  _interopRequireWildcard(_variationComponents);
  var assign = _interopRequireWildcard(__webpack_require__(function(canCreateDiscussions, exports) {
    exports.__esModule = true;
    var obj;
    var scene = (obj = _variationComponents) && obj.__esModule ? obj : {
      "default" : obj
    };
    exports.default = scene.default || function(target) {
      var i = 1;
      for (; i < arguments.length; i++) {
        var prop;
        var source = arguments[i];
        for (prop in source) {
          if (Object.prototype.hasOwnProperty.call(source, prop)) {
            target[prop] = source[prop];
          }
        }
      }
      return target;
    };
  }));
  var g = jQuery("iterator");
  var fitToWindowStrategy = core.isIterable = function(value) {
    return value = Object(value), void 0 !== value[g] || "@@iterator" in value || Iterators.hasOwnProperty(recurse(value));
  };
  var _deepAssign = __webpack_require__(function(module) {
    module.exports = {
      "default" : fitToWindowStrategy,
      "__esModule" : true
    };
  });
  _interopRequireWildcard(_deepAssign);
  var measureStyle = core.getIterator = function(name) {
    var prop = getProperty(name);
    if ("function" != typeof prop) {
      throw TypeError(name + " is not iterable!");
    }
    return resolve(prop.call(name));
  };
  var _normalizeDataUri = __webpack_require__(function(module) {
    module.exports = {
      "default" : measureStyle,
      "__esModule" : true
    };
  });
  _interopRequireWildcard(_normalizeDataUri);
  var clone = _interopRequireWildcard(__webpack_require__(function(canCreateDiscussions, exports) {
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default" : obj
      };
    }
    exports.__esModule = true;
    var _deepAssign2 = _interopRequireDefault(_deepAssign);
    var _normalizeDataUri2 = _interopRequireDefault(_normalizeDataUri);
    exports.default = function(name, target) {
      if (Array.isArray(name)) {
        return name;
      }
      if ((0, _deepAssign2.default)(Object(name))) {
        return function(aMetaName, targetRadian) {
          var _arr = [];
          var _iteratorNormalCompletion3 = true;
          var _0x2497f5 = false;
          var interestingPoint = void 0;
          try {
            var _s;
            var _iterator3 = (0, _normalizeDataUri2.default)(aMetaName);
            for (; !(_iteratorNormalCompletion3 = (_s = _iterator3.next()).done) && (_arr.push(_s.value), !targetRadian || _arr.length !== targetRadian); _iteratorNormalCompletion3 = true) {
            }
          } catch (viewportCenter) {
            _0x2497f5 = true;
            interestingPoint = viewportCenter;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
              }
            } finally {
              if (_0x2497f5) {
                throw interestingPoint;
              }
            }
          }
          return _arr;
        }(name, target);
      }
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    };
  }));
  init = (expect(draw, [{
    "key" : `addData`,
    "value" : function(type) {
      var obj = this;
      if (Array.isArray(type)) {
        this.data = this.data.concat(type.map(function(event) {
          var put_rows = hahaha;
          return obj[put_rows(2246)](event.value), obj[put_rows(2821)](event);
        }));
      } else {
        this.updateMaxMin(type.value);
        this.data.push(this.convertData(type));
      }
      this.updateCesium(true);
    }
  }, {
    "key" : "updateHeatmap",
    "value" : function() {
      var rMax = this.viewer.camera.getMagnitude();
      var opt = this.autoRadiusConfig;
      var min = opt.min;
      var max = opt.max;
      var height = opt.minRadius;
      opt = opt.maxRadius;
      var rad = parseInt(height + (opt - height) * (rMax - min) / (max - min));
      this.heatmap.setData({
        "max" : this.max,
        "min" : this.min,
        "data" : this.data.map(function(markerCoord) {
          var put_rows = hahaha;
          return {
            "x" : markerCoord.x,
            "y" : markerCoord.y,
            "value" : markerCoord[put_rows(1573)],
            "radius" : rad
          };
        })
      });
    }
  }, {
    "key" : `updateCesium`,
    "value" : function(type) {
      if (this.layer) {
        this.viewer.scene.imageryLayers.remove(this.layer);
      }
      if (type) {
        this.updateHeatmap();
      }
      type = new Cesium["SingleTileImageryProvider"]({
        "url" : this.heatmap.getDataURL(),
        "rectangle" : (type = Cesium.Rectangle).fromDegrees.apply(type, array(this.bbox))
      });
      this.layer = this.viewer.scene.imageryLayers.addImageryProvider(type);
    }
  }, {
    "key" : `convertData`,
    "value" : function(target) {
      var target1 = target.x;
      var pos = target.y;
      target = target.value;
      pos = this.gps2point([target1, pos]);
      pos = clone(pos, 2);
      return {
        "x" : pos[0],
        "y" : pos[1],
        "value" : target
      };
    }
  }, {
    "key" : `updateMaxMin`,
    "value" : function(value) {
      if (void 0 === this.max) {
        this.max = value;
      } else {
        this.max = Math.max(value, this.max);
      }
      if (void 0 === this.min) {
        this.min = value;
      } else {
        this.min = Math.min(value, this.min);
      }
    }
  }, {
    "key" : `gps2point`,
    "value" : function() {
      var width = clone(0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : [], 2);
      var h2 = width[0];
      var maxWidth = width[1];
      var canvas = this.boxMeta;
      var y = canvas.top;
      var h1 = canvas.left;
      var height = canvas.height;
      width = canvas.width;
      canvas = this.canvasConfig;
      return [parseInt((h2 - h1) / width * canvas.width), parseInt((y - maxWidth) / height * canvas.height)];
    }
  }, {
    "key" : `destroy`,
    "value" : function() {
      this.viewer.camera.moveEnd.removeEventListener(this.cameraMoveEnd);
      if (this.layer) {
        this.viewer.scene.imageryLayers.remove(this.layer);
      }
      if (this.mountPoint) {
        this.mountPoint.remove();
      }
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.destroy();
    }
  }]), draw);
  expect(from, [{
    "key" : `createW_MaskRegion`,
    "value" : function() {
      this.wEntity = this.viewer.entities.add({
        "polygon" : {
          "hierarchy" : {
            "positions" : Cesium.Cartesian3.fromDegreesArray([-0.00001, 60, -0.00001, -60, -180, -60, -180, 60, -0.00001, 60])
          },
          "material" : this.options.fillColor
        }
      });
    }
  }, {
    "key" : `createE_MaskRegion`,
    "value" : function(name) {
      this.eEntity = this.viewer.entities.add({
        "polygon" : {
          "hierarchy" : {
            "positions" : Cesium.Cartesian3.fromDegreesArray([0.00001, 60, 0.00001, -60, 180, -60, 180, 60, 0.00001, 60]),
            "holes" : [{
              "positions" : name
            }]
          },
          "material" : this.options.fillColor
        },
        "polyline" : {
          "positions" : name,
          "width" : this.options.lineWidth,
          "material" : this.options.lineColor
        }
      });
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.viewer.entities.remove(this.eEntity);
      this.viewer.entities.remove(this.wEntity);
    }
  }]);
  data = from;
  xt3d.PolygonObject = {
    "WaterPrimitive" : location,
    "PrimitiveGradientAppearance" : frame,
    "CesiumHeatMap" : init,
    "MaskRegion" : data
  };
  forced = function render(name) {
    return call(this, render), new Cesium["PolylineMaterialAppearance"]({
      "material" : new Cesium["Material"]({
        "fabric" : {
          "type" : "ODLineMaterial",
          "uniforms" : {
            "color_0" : name,
            "totoalFrameCount_1" : 1E3
          },
          "source" : " \n                    uniform float totoalFrameCount_1;\n                    uniform vec4 color_0; \n                    czm_material czm_getMaterial(czm_materialInput materialInput)\n                    {\n                        czm_material material = czm_getDefaultMaterial(materialInput);\n                        vec2 st = materialInput.st;  \n                        float t = mod(czm_frameNumber, totoalFrameCount_1) / totoalFrameCount_1; \n                        t *= 1.03;\n                        float alpha = smoothstep(t- 0.03, t, st.s) * step(-t, -st.s); \n                        alpha += 0.1;\n                        alpha *= step(-0.4, -abs(0.5-st.t));                             \n                        material.diffuse = color_0.rgb;\n                        material.alpha = alpha;\n                        return material;\n                    } \n                "
        },
        "translucent" : true
      }),
      "faceForward" : false,
      "closed" : false
    });
  };
  Object.defineProperties(Connection.prototype, {
    "isConstant" : {
      "get" : function() {
        return false;
      }
    },
    "definitionChanged" : {
      "get" : function() {
        return this._definitionChanged;
      }
    },
    "color" : Cesium.createPropertyDescriptor(`color`)
  });
  Connection.prototype.getType = function(original_full_html) {
    return "PolylineArrowOpacity";
  };
  Connection.prototype.getValue = function(time, result) {
    return Cesium.defined(result) || (result = {}), result.color = Cesium.Property.getValueOrClonedDefault(this._color, time, Cesium.Color.WHITE, result.color), result.image = this.url, result.time = ((new Date).getTime() - this._time) % this.duration / this.duration, result.count = this.count || 4, result;
  };
  Connection.prototype.equals = function(other) {
    return this === other || other instanceof Connection && Cesium.Property.equals(this._color, other._color) && this.duration == other.duration && this.count == other.count;
  };
  Cesium.Material.PolylineArrowOpacityType = `PolylineArrowOpacity`;
  Cesium.Material.PolylineArrowOpacitySource = `czm_material czm_getMaterial(czm_materialInput materialInput)\n { czm_material material = czm_getDefaultMaterial(materialInput); vec2 st = materialInput.st;\n    vec4 colorImage = texture2D(image, vec2(fract( count * st.s - time),fract(st.t)));\n     material.alpha =  colorImage.a * color.a;\n     material.diffuse =  color.rgb * 3.0 ;\n     return material;}`;
  Cesium.Material._materialCache.addMaterial(Cesium.Material.PolylineArrowOpacityType, {
    "fabric" : {
      "type" : Cesium.Material.PolylineArrowOpacityType,
      "uniforms" : {
        "color" : new Cesium.Color(1, 0, 0, 0.5),
        "image" : "",
        "time" : 20,
        "count" : 4
      },
      "source" : Cesium.Material.PolylineArrowOpacitySource
    },
    "translucent" : function(material) {
      return true;
    }
  });
  Object.defineProperties(Player.prototype, {
    "isConstant" : {
      "get" : function() {
        return false;
      }
    },
    "definitionChanged" : {
      "get" : function() {
        return this._definitionChanged;
      }
    },
    "color" : Cesium.createPropertyDescriptor(`color`)
  });
  Player.prototype.getType = function(original_full_html) {
    return "PolylineEnergyTrans";
  };
  Player.prototype.getValue = function(time, result) {
    return Cesium.defined(result) || (result = {}), result.color = Cesium.Property.getValueOrClonedDefault(this._color, time, Cesium.Color.WHITE, result.color), result.image = this.url, result.time = ((new Date).getTime() - this._time) % this.duration / this.duration, result.count = this.count || 4, result;
  };
  Player.prototype.equals = function(other) {
    return this === other || other instanceof Player && Cesium.Property.equals(this._color, other._color) && this.duration == other.duration && this.count == other.count;
  };
  Cesium.Material.PolylineEnergyTransType = "PolylineEnergyTrans";
  Cesium.Material.PolylineEnergyTransSource = `czm_material czm_getMaterial(czm_materialInput materialInput)\n { czm_material material = czm_getDefaultMaterial(materialInput); vec2 st = materialInput.st;\n    vec4 colorImage = texture2D(image, vec2(fract( count * st.s - time),fract(st.t)));\n     material.alpha =  colorImage.a * color.a;\n     material.diffuse =  color.rgb *3.0 ;\n     return material;}`;
  Cesium.Material._materialCache.addMaterial(Cesium.Material.PolylineEnergyTransType, {
    "fabric" : {
      "type" : Cesium.Material.PolylineEnergyTransType,
      "uniforms" : {
        "color" : new Cesium[`Color`](1, 0, 0, 0.5),
        "image" : "",
        "time" : 20,
        "count" : 4
      },
      "source" : Cesium.Material.PolylineEnergyTransSource
    },
    "translucent" : function(material) {
      return true;
    }
  });
  Object.defineProperties(Light.prototype, {
    "isConstant" : {
      "get" : function() {
        return false;
      }
    },
    "definitionChanged" : {
      "get" : function() {
        return this._definitionChanged;
      }
    },
    "color" : Cesium.createPropertyDescriptor(`color`)
  });
  Light.prototype.getType = function(original_full_html) {
    return "PolylineLighting";
  };
  Light.prototype.getValue = function(time, result) {
    return Cesium.defined(result) || (result = {}), result.color = Cesium.Property.getValueOrClonedDefault(this._color, time, Cesium.Color.WHITE, result.color), result.image = Cesium.Material.PolylineLightingImage, result;
  };
  Light.prototype.equals = function(other) {
    return this === other || other instanceof Light && Cesium.Property.equals(this._color, other._color);
  };
  Cesium.Material.PolylineLightingType = "PolylineLighting";
  Cesium.Material.PolylineLightingImage = `data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAACYCAYAAACS0lH9AAAACXBIWXMAAAsTAAALEwEAmpwYAAAJ0GlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNi4wLWMwMDIgMTE2LjE2NDY1NSwgMjAyMS8wMS8yNi0xNTo0MToyMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOkRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDplODY0YmNmNy1lZGIyLWIyNDQtYWI0NC04OWZkNmMwOTQ4MDYiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NjIyOGMxMDUtODFmZS00MjAxLWIwOTEtZDkwMGI0NTI0NWMwIiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9IjcxNzA5OEJGODAwODNEREJGRDQyQzAzMzQ5NDlDRDFDIiBkYzpmb3JtYXQ9ImltYWdlL3BuZyIgcGhvdG9zaG9wOkNvbG9yTW9kZT0iMyIgcGhvdG9zaG9wOklDQ1Byb2ZpbGU9IiIgdGlmZjpJbWFnZVdpZHRoPSI1MTIiIHRpZmY6SW1hZ2VMZW5ndGg9IjE1MiIgdGlmZjpQaG90b21ldHJpY0ludGVycHJldGF0aW9uPSIyIiB0aWZmOlNhbXBsZXNQZXJQaXhlbD0iMyIgdGlmZjpYUmVzb2x1dGlvbj0iMS8xIiB0aWZmOllSZXNvbHV0aW9uPSIxLzEiIHRpZmY6UmVzb2x1dGlvblVuaXQ9IjEiIGV4aWY6RXhpZlZlcnNpb249IjAyMzEiIGV4aWY6Q29sb3JTcGFjZT0iNjU1MzUiIGV4aWY6UGl4ZWxYRGltZW5zaW9uPSI1MTIiIGV4aWY6UGl4ZWxZRGltZW5zaW9uPSIxNTIiIHhtcDpDcmVhdGVEYXRlPSIyMDIxLTAyLTIzVDEwOjAyOjQxKzA4OjAwIiB4bXA6TW9kaWZ5RGF0ZT0iMjAyMS0wMi0yM1QxMDowODo0NCswODowMCIgeG1wOk1ldGFkYXRhRGF0ZT0iMjAyMS0wMi0yM1QxMDowODo0NCswODowMCI+IDx4bXBNTTpIaXN0b3J5PiA8cmRmOlNlcT4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOmZmYTk5ZjhhLTdiZmQtNDcxNi04MTgwLWJmZTUyMmFmNGUzNSIgc3RFdnQ6d2hlbj0iMjAyMS0wMi0yM1QxMDowODo0NCswODowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDIxLjIgKE1hY2ludG9zaCkiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249ImNvbnZlcnRlZCIgc3RFdnQ6cGFyYW1ldGVycz0iZnJvbSBpbWFnZS9qcGVnIHRvIGltYWdlL3BuZyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0iZGVyaXZlZCIgc3RFdnQ6cGFyYW1ldGVycz0iY29udmVydGVkIGZyb20gaW1hZ2UvanBlZyB0byBpbWFnZS9wbmciLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjYyMjhjMTA1LTgxZmUtNDIwMS1iMDkxLWQ5MDBiNDUyNDVjMCIgc3RFdnQ6d2hlbj0iMjAyMS0wMi0yM1QxMDowODo0NCswODowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDIxLjIgKE1hY2ludG9zaCkiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPC9yZGY6U2VxPiA8L3htcE1NOkhpc3Rvcnk+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOmZmYTk5ZjhhLTdiZmQtNDcxNi04MTgwLWJmZTUyMmFmNGUzNSIgc3RSZWY6ZG9jdW1lbnRJRD0iNzE3MDk4QkY4MDA4M0REQkZENDJDMDMzNDk0OUNEMUMiIHN0UmVmOm9yaWdpbmFsRG9jdW1lbnRJRD0iNzE3MDk4QkY4MDA4M0REQkZENDJDMDMzNDk0OUNEMUMiLz4gPHBob3Rvc2hvcDpEb2N1bWVudEFuY2VzdG9ycz4gPHJkZjpCYWc+IDxyZGY6bGk+NzE3MDk4QkY4MDA4M0REQkZENDJDMDMzNDk0OUNEMUM8L3JkZjpsaT4gPC9yZGY6QmFnPiA8L3Bob3Rvc2hvcDpEb2N1bWVudEFuY2VzdG9ycz4gPHRpZmY6Qml0c1BlclNhbXBsZT4gPHJkZjpTZXE+IDxyZGY6bGk+ODwvcmRmOmxpPiA8cmRmOmxpPjg8L3JkZjpsaT4gPHJkZjpsaT44PC9yZGY6bGk+IDwvcmRmOlNlcT4gPC90aWZmOkJpdHNQZXJTYW1wbGU+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+h9EbuwAAA01JREFUeJzt3TuOFVkQBNDoJhmEkDBgZv8L5GMgIcRvHg5ryDTiHKn98Co67q16T4/HYwIAVHm+DgAA7FMAAKCQAgAAhSbJ03UIAGCXBQAACikAAFDIEQAAFLIAAEAhBQAACikAAFBoogQAQB0PfwAopAAAQCGvAQJAIQsAABSyAABAIQsAABSyAABAIQUAAAo5AgCAQr4ECACFPPwBoJACAACFHAEAQCEPfwAoZAEAgEIe/gBQyAIAAIU8/AGgkAUAAAr5LQAAKOS/fwAoZAEAgELuAABAIQsAABRSAACgkAIAAIXcAQCAQhYAAChkAQCAQgoAABRSAACgkIc/ABSaJC+uQwAAu7wFAACFFAAAKDR//wCAIhYAACjkEiAAFLIAAEChSfLyOgQAsMuXAAGgkLcAAKCQAgAAhbwFAACFFAAAKOQIAAAKTZJ/rkMAALsUAAAo5AgAAAr5EiAAFFIAAKCQOwAAUEgBAIBCk+TVdQgAYNckeXMdAgDYNUneXocAAHZNkvfXIQCAXZPkv+sQAMCuSfLvdQgAYNckeXcdAgDY5RIgABSaJK+vQwAAu/wWAAAUmiRP1yEAgF2T5HEdAgDYNUl+XocAAHZNkm/XIQCAXZPky3UIAGDXJPl8HQIA2DVJPl6HAAB2TZIP1yEAgF2T5NN1CABgl0uAAFBokny9DgEA7Jok369DAAC7JsmP6xAAwC4FAAAK+S0AACikAABAoUny6zoEALDLHQAAKKQAAEAhRwAAUGiS/L4OAQDsUgAAoJAjAAAopAAAQKFJ8v91CABgly8BAkChSfK4DgEA7PIWAAAUsgAAQCFvAQBAIQsAABRSAACgkEuAAFDo+ToAALDPlwABoJACAACFFAAAKOQtAAAoZAEAgEIWAAAopAAAQCEFAAAKuQMAAIUsAABQyKeAAaCQBQAACrkDAACFHAEAQCELAAAUsgAAQCELAAAUsgAAQCELAAAUsgAAQCEFAAAKOQIAgEIWAAAo5LcAAKCQAgAAhRwBAEAhCwAAFLIAAEAhCwAAFLIAAEAhBQAACvkSIAAUsgAAQCEFAAAKKQAAUMhrgABQyAIAAIUUAAAo5AgAAApZAACgkAIAAIUUAAAo5A4AABT6A6gaPQ6/wRIfAAAAAElFTkSuQmCC`;
  Cesium.Material.PolylineLightingSource = `czm_material czm_getMaterial(czm_materialInput materialInput)\n { czm_material material = czm_getDefaultMaterial(materialInput); vec2 st = materialInput.st;\n    vec4 colorImage = texture2D(image, vec2(fract(st.s), st.t));\n     material.alpha = colorImage.a * color.a;\n     material.diffuse = (colorImage.rgb + color.rgb)* 1.3 ;\n     return material;}`;
  Cesium.Material._materialCache.addMaterial(Cesium.Material.PolylineLightingType, {
    "fabric" : {
      "type" : Cesium.Material.PolylineLightingType,
      "uniforms" : {
        "color" : new Cesium[`Color`](1, 0, 0, 0.5),
        "image" : Cesium.Material.PolylineLightingImage
      },
      "source" : Cesium.Material.PolylineLightingSource
    },
    "translucent" : function(material) {
      return true;
    }
  });
  Object.defineProperties(PolylineOutlineMaterialProperty.prototype, {
    "isConstant" : {
      "get" : function() {
        return false;
      }
    },
    "definitionChanged" : {
      "get" : function() {
        return this._definitionChanged;
      }
    },
    "color" : Cesium.createPropertyDescriptor(`color`)
  });
  PolylineOutlineMaterialProperty.prototype.getType = function(original_full_html) {
    return "PolylineLinkPulse";
  };
  PolylineOutlineMaterialProperty.prototype.getValue = function(time, result) {
    return Cesium.defined(result) || (result = {}), result.color = Cesium.Property.getValueOrClonedDefault(this._color, time, Cesium.Color.WHITE, result.color), result.image = this.url, result.time = ((new Date).getTime() - this._time) % this.duration / this.duration, result;
  };
  PolylineOutlineMaterialProperty.prototype.equals = function(other) {
    return this === other || other instanceof PolylineOutlineMaterialProperty && Cesium.Property.equals(this._color, other._color);
  };
  Cesium.Material.PolylineLinkPulseType = `PolylineLinkPulse`;
  Cesium.Material.PolylineLinkPulseSource = `czm_material czm_getMaterial(czm_materialInput materialInput)\n { czm_material material = czm_getDefaultMaterial(materialInput); vec2 st = materialInput.st;\n    vec4 colorImage = texture2D(image, vec2(fract(st.s - time), st.t));\n     material.alpha = colorImage.a * color.a;\n     material.diffuse = (colorImage.rgb + color.rgb)* 2.5 ;\n     return material;}`;
  Cesium.Material._materialCache.addMaterial(Cesium.Material.PolylineLinkPulseType, {
    "fabric" : {
      "type" : Cesium.Material.PolylineLinkPulseType,
      "uniforms" : {
        "color" : new Cesium[`Color`](1, 0, 0, 0.5),
        "image" : "",
        "time" : 20
      },
      "source" : Cesium.Material.PolylineLinkPulseSource
    },
    "translucent" : function(material) {
      return true;
    }
  });
  Object.defineProperties(ImageMaterialProperty.prototype, {
    "isConstant" : {
      "get" : function() {
        return false;
      }
    },
    "definitionChanged" : {
      "get" : function() {
        return this._definitionChanged;
      }
    },
    "color" : Cesium.createPropertyDescriptor(`color`)
  });
  ImageMaterialProperty.prototype.getType = function(original_full_html) {
    return "PolylineMigrate";
  };
  ImageMaterialProperty.prototype.getValue = function(time, result) {
    return Cesium.defined(result) || (result = {}), result.color = Cesium.Property.getValueOrClonedDefault(this._color, time, Cesium.Color.WHITE, result.color), result.image = this.url, result.time = (performance.now() - this._time) % this.duration / this.duration, result;
  };
  ImageMaterialProperty.prototype.equals = function(other) {
    return this === other || other instanceof ImageMaterialProperty && Cesium.Property.equals(this._color, other._color) && this.duration == other.duration;
  };
  Cesium.Material.PolylineMigrateType = `PolylineMigrate`;
  Cesium.Material.PolylineMigrateSource = `czm_material czm_getMaterial(czm_materialInput materialInput)\n       {\n             czm_material material = czm_getDefaultMaterial(materialInput);\n             vec2 st = materialInput.st;\n             vec4 colorImage = texture2D(image, vec2(fract(st.s - time), st.t));\n             material.alpha = colorImage.a * color.a;\n             material.diffuse = color.rgb*1.5;\n             return material;\n     }`;
  Cesium.Material._materialCache.addMaterial(Cesium.Material.PolylineMigrateType, {
    "fabric" : {
      "type" : Cesium.Material.PolylineMigrateType,
      "uniforms" : {
        "color" : new Cesium[`Color`](1, 0, 0, 0.5),
        "image" : "",
        "transparent" : true,
        "time" : 20
      },
      "source" : Cesium.Material.PolylineMigrateSource
    },
    "translucent" : function(material) {
      return true;
    }
  });
  Object.defineProperties(PolylineSpriteMaterialProperty.prototype, {
    "isConstant" : {
      "get" : function() {
        return false;
      }
    },
    "definitionChanged" : {
      "get" : function() {
        return this._definitionChanged;
      }
    },
    "color" : Cesium.createPropertyDescriptor("color")
  });
  PolylineSpriteMaterialProperty.prototype.getType = function(original_full_html) {
    return "PolylineSprite";
  };
  PolylineSpriteMaterialProperty.prototype.getValue = function($el, e) {
    return Cesium.defined(e) || (e = {}), e.image = this.url, e.time = (performance.now() - this._time) % this.duration / this.duration, e;
  };
  PolylineSpriteMaterialProperty.prototype.equals = function(options) {
    return this === options || options instanceof PolylineSpriteMaterialProperty && this.duration == options.duration;
  };
  Cesium.Material.PolylineSpriteType = `PolylineSprite`;
  Cesium.Material.PolylineSpriteSource = `czm_material czm_getMaterial(czm_materialInput materialInput)\n      {\n            czm_material material = czm_getDefaultMaterial(materialInput);\n            vec2 st = materialInput.st;\n            vec4 colorImage = texture2D(image, vec2(fract(st.s - time), st.t));\n            material.alpha = colorImage.a;\n            material.diffuse = colorImage.rgb * 1.5 ;\n            return material;\n    }`;
  Cesium.Material._materialCache.addMaterial(Cesium.Material.PolylineSpriteType, {
    "fabric" : {
      "type" : Cesium.Material.PolylineSpriteType,
      "uniforms" : {
        "color" : new Cesium.Color(1, 0, 0, 0.5),
        "image" : "",
        "transparent" : true,
        "time" : 20
      },
      "source" : Cesium.Material.PolylineSpriteSource
    },
    "translucent" : function(material) {
      return true;
    }
  });
  Object.defineProperties(Entity.prototype, {
    "isConstant" : {
      "get" : function() {
        return false;
      }
    },
    "definitionChanged" : {
      "get" : function() {
        return this._definitionChanged;
      }
    },
    "color" : Cesium.createPropertyDescriptor(`color`)
  });
  Entity.prototype.getType = function(original_full_html) {
    return "PolylineTrail";
  };
  Entity.prototype.getValue = function(time, result) {
    return Cesium.defined(result) || (result = {}), result.color = Cesium.Property.getValueOrClonedDefault(this.color, time, Cesium.Color.WHITE, result.color), result.speed = this.speed, result.gradient = this.gradient, result.percent = this.percent, result;
  };
  Entity.prototype.equals = function(target) {
    return this === target || target instanceof Entity && this.speed == target.speed && Cesium.Property.equals(this.color, target.color);
  };
  Cesium.Material.PolylineTrailType = "PolylineTrail";
  Cesium.Material.PolylineTrailSource = `uniform vec4 color;\nuniform float speed;\nuniform float percent;\nuniform float gradient;\n\nczm_material czm_getMaterial(czm_materialInput materialInput){\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    vec2 st = materialInput.st;\n    float t =fract(czm_frameNumber * speed / 1000.0);\n    t *= (1.0 + percent);\n    float alpha = smoothstep(t- percent, t, st.s) * step(-t, -st.s);\n    alpha += gradient;\n    material.diffuse = color.rgb;\n    material.alpha = alpha;\n    return material;\n}`;
  Cesium.Material._materialCache.addMaterial(Cesium.Material.PolylineTrailType, {
    "fabric" : {
      "type" : Cesium.Material.PolylineTrailType,
      "uniforms" : {
        "color" : new Cesium[`Color`](1, 0, 0, 0.5),
        "transparent" : true,
        "speed" : 0,
        "gradient" : 0.01,
        "percent" : 0.1
      },
      "source" : Cesium.Material.PolylineTrailSource
    },
    "translucent" : function(material) {
      return true;
    }
  });
  Object.defineProperties(Property.prototype, {
    "isConstant" : {
      "get" : function() {
        return false;
      }
    },
    "definitionChanged" : {
      "get" : function() {
        return this._definitionChanged;
      }
    },
    "color" : Cesium.createPropertyDescriptor(`color`)
  });
  Property.prototype.getType = function(original_full_html) {
    return "PolylineTrialFlow";
  };
  Property.prototype.getValue = function(time, result) {
    return Cesium.defined(result) || (result = {}), result.color = Cesium.Property.getValueOrClonedDefault(this._color, time, Cesium.Color.WHITE, result.color), result.time = (performance.now() - this._time) % this.duration / this.duration, result;
  };
  Property.prototype.equals = function(options) {
    return this === options || options instanceof Property && this.duration == options.duration && Cesium.Property.equals(this._color, options._color);
  };
  Cesium.Material.PolylineTrialFlowType = `PolylineTrialFlow`;
  Cesium.Material.PolylineTrialFlowSource = `czm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    vec2 st = materialInput.st;\n    float t = time;\n    t *= 1.03;\n    float alpha = smoothstep(t- 0.1, t, st.s) * step(-t, -st.s);\n    alpha += 0.1;\n    material.diffuse= color.rgb;\n    material.alpha = alpha;\n    return material;\n}\n`;
  Cesium.Material._materialCache.addMaterial(Cesium.Material.PolylineTrialFlowType, {
    "fabric" : {
      "type" : Cesium.Material.PolylineTrialFlowType,
      "uniforms" : {
        "color" : new Cesium[`Color`](1, 0, 0, 0.5),
        "transparent" : true,
        "time" : 20
      },
      "source" : Cesium.Material.PolylineTrialFlowSource
    },
    "translucent" : function(material) {
      return true;
    }
  });
  Object.defineProperties(message.prototype, {
    "isConstant" : {
      "get" : function() {
        return false;
      }
    },
    "definitionChanged" : {
      "get" : function() {
        return this._definitionChanged;
      }
    },
    "color" : Cesium.createPropertyDescriptor(`color`)
  });
  message.prototype.getType = function(original_full_html) {
    return "PolylineVolumeTrial";
  };
  message.prototype.getValue = function(time, result) {
    return Cesium.defined(result) || (result = {}), result.color = Cesium.Property.getValueOrClonedDefault(this._color, time, Cesium.Color.WHITE, result.color), result.image = this.url, result.time = ((new Date).getTime() - this._time) % this.duration / this.duration, result.count = this.count || 4, result;
  };
  message.prototype.equals = function(other) {
    return this === other || other instanceof message && Cesium.Property.equals(this._color, other._color) && this.duration == other.duration && this.count == other.count;
  };
  Cesium.Material.PolylineVolumeTrialType = `PolylineVolumeTrial`;
  Cesium.Material.PolylineVolumeTrialSource = `czm_material czm_getMaterial(czm_materialInput materialInput)\n { czm_material material = czm_getDefaultMaterial(materialInput); vec2 st = materialInput.st;\n    vec4 colorImage = texture2D(image, vec2(fract( count * st.s - time),fract(st.t)));\n     material.alpha =  colorImage.a * color.a;\n     material.diffuse =  color.rgb *1.5 ;\n     return material;}`;
  Cesium.Material._materialCache.addMaterial(Cesium.Material.PolylineVolumeTrialType, {
    "fabric" : {
      "type" : Cesium.Material.PolylineVolumeTrialType,
      "uniforms" : {
        "color" : new Cesium[`Color`](1, 0, 0, 0.5),
        "image" : "",
        "time" : 20,
        "count" : 4
      },
      "source" : Cesium.Material.PolylineVolumeTrialSource
    },
    "translucent" : function(material) {
      return true;
    }
  });
  mode = function dragEnter(obj, target) {
    return call(this, dragEnter), new Cesium["PolylineGlowMaterialProperty"]({
      "glowPower" : obj,
      "color" : target
    });
  };
  Object.defineProperties(Application.prototype, {
    "isConstant" : {
      "get" : function() {
        return false;
      }
    },
    "definitionChanged" : {
      "get" : function() {
        return this._definitionChanged;
      }
    },
    "color" : Cesium.createPropertyDescriptor(`color`)
  });
  Application.prototype.getType = function(original_full_html) {
    return "PolylineSuper";
  };
  Application.prototype.getValue = function(time, result) {
    return Cesium.defined(result) || (result = {}), result.color = Cesium.Property.getValueOrClonedDefault(this._color, time, Cesium.Color.WHITE, result.color), result.image = this.url, result.time = ((new Date).getTime() - this._time) % this.duration / this.duration, result.count = this.count || 4, result;
  };
  Application.prototype.equals = function(other) {
    return this === other || other instanceof Application && Cesium.Property.equals(this._color, other._color) && this.duration == other.duration && this.count == other.count && this.url == other.url;
  };
  Cesium.Material.PolylineSuperType = `PolylineSuper`;
  Cesium.Material.PolylineSuperSource = `czm_material czm_getMaterial(czm_materialInput materialInput)\n { czm_material material = czm_getDefaultMaterial(materialInput); vec2 st = materialInput.st;\n    vec4 colorImage = texture2D(image, vec2(fract( count * st.s - time),fract(st.t)));\n     material.alpha =  colorImage.a * color.a;\n     material.diffuse =  color.rgb * 1.5 ;\n     return material;}`;
  Cesium.Material._materialCache.addMaterial(Cesium.Material.PolylineSuperType, {
    "fabric" : {
      "type" : Cesium.Material.PolylineSuperType,
      "uniforms" : {
        "color" : new Cesium[`Color`](1, 0, 0, 0.5),
        "image" : "",
        "time" : 20,
        "count" : 4
      },
      "source" : Cesium.Material.PolylineSuperSource
    },
    "translucent" : function(material) {
      return true;
    }
  });
  expect(exports, [{
    "key" : `addPath`,
    "value" : function() {
      this.path = this.viewer.entities.add({
        "position" : this.params.position,
        "orientation" : this.params.orientation,
        "model" : this.params.model,
        "label" : this.params.label,
        "path" : new Cesium["PathGraphics"](assign({
          "show" : true,
          "width" : 3,
          "leadTime" : 0,
          "trailTime" : 3600,
          "material" : Cesium.Color.RED
        }, this.params.style))
      });
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.viewer.entity.remove(this.path);
    }
  }]);
  exports = exports;
  expect(output, [{
    "key" : `addCylinder`,
    "value" : function() {
      var _0xe0b187 = this;
      this.cylinder = this.viewer.entities.add({
        "position" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
          return _0xe0b187.getPostion();
        }, false),
        "cylinder" : {
          "length" : this.style.length || 100,
          "topRadius" : 0,
          "bottomRadius" : 20,
          "material" : Cesium.Color.RED.withAlpha(0.6)
        }
      });
    }
  }, {
    "key" : `getPostion`,
    "value" : function() {
      var position = this.property.getValue(this.viewer.clock.currentTime);
      position = Cesium.Cartographic.fromCartesian(position);
      return Cesium.Cartesian3.fromRadians(position.longitude, position.latitude, position.height - (this.style.length || 50));
    }
  }, {
    "key" : "remove",
    "value" : function() {
      this.viewer.scene.postRender.removeEventListener(this.postRenderHandler, this);
      this.viewer.entity.remove(this.cylinder);
    }
  }]);
  output = output;
  xt3d.PolylineObject = {
    "PolylinODPrimitiveAppearance" : forced,
    "PolylineArrowMaterialProperty" : Connection,
    "PolylineEnergyTransMaterialProperty" : Player,
    "PolylineLightingMaterialProperty" : Light,
    "PolylineLinkPulseMaterialProperty" : PolylineOutlineMaterialProperty,
    "PolylineMigrateMaterialProperty" : ImageMaterialProperty,
    "PolylineSpriteMaterialProperty" : PolylineSpriteMaterialProperty,
    "PolylineTrailMaterialProperty" : Entity,
    "PolylineTrialFlowMaterialProperty" : Property,
    "PolylineVolumeTrialMaterialProperty" : message,
    "PolylineGlowMaterialProperty" : mode,
    "PolylineSuperMaterial" : Application,
    "FlyPath" : exports,
    "FlyCylinder" : output
  };
  appendCSS(`.cesium-image-layer-split {\n    position: absolute;\n    left: 50%;\n    top: 0px;\n    background-color: #d3d3d3;\n    width: 5px;\n    height: 100%;\n    z-index: 9999;\n}\n\n.cesium-image-layer-split:hover {\n    cursor: ew-resize;\n}`, {});
  expect(CesiumWidget, [{
    "key" : `initSlider`,
    "value" : function() {
      var e = document.createElement("div");
      e.classList.add("cesium-image-layer-split");
      this.viewer.cesiumWidget.container.appendChild(e);
      this.registEvent(e);
      this.viewer.scene.imagerySplitPosition = e.offsetLeft / e.parentElement.offsetWidth;
    }
  }, {
    "key" : `registEvent`,
    "value" : function(type) {
      var same = this;
      var handler = new Cesium["ScreenSpaceEventHandler"](type);
      var _0x547f08 = false;
      handler.setInputAction(function() {
        _0x547f08 = true;
      }, Cesium.ScreenSpaceEventType.LEFT_DOWN);
      handler.setInputAction(function(segPoints) {
        var rel2Mstr = hahaha;
        if (_0x547f08) {
          segPoints = (type[rel2Mstr(544)] + segPoints[rel2Mstr(2840)].x) / type.parentElement[rel2Mstr(2284)];
          type[rel2Mstr(1998)][rel2Mstr(1838)] = 100 * segPoints + "%";
          same[rel2Mstr(2276)][rel2Mstr(2758)][rel2Mstr(1317)] = segPoints;
        }
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
      handler.setInputAction(function() {
        _0x547f08 = false;
      }, Cesium.ScreenSpaceEventType.LEFT_UP);
      this.handler = handler;
      this.slider = type;
    }
  }, {
    "key" : `removeSplitLayer`,
    "value" : function() {
      this.viewer.imageryLayers.remove(this.splitLayer);
      this.splitLayer = void 0;
      this.slider.remove();
      this.handler.destroy();
    }
  }, {
    "key" : `destroy`,
    "value" : function() {
      this.removeSplitLayer();
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.destroy();
    }
  }]);
  ID = CesiumWidget;
  var bodyRegExp = /<html(.|\s)*>(.|\s)*<\/html>/im;
  var factory = function(knockout) {
    knockout.bindingHandlers.markdown = {
      "init" : function() {
        return {
          "controlsDescendantBindings" : true
        };
      },
      "update" : function(element, html) {
        for (; element.firstChild;) {
          knockout.removeNode(element.firstChild);
        }
        html = knockout.unwrap(html());
        html = bodyRegExp.test(html) ? html : sa.render(html);
        var spheres = knockout.utils.parseHtmlFragment(html, element);
        element.className = element.className + " markdown";
        var iter_sph = 0;
        for (; iter_sph < spheres.length; ++iter_sph) {
          var s = spheres[iter_sph];
          !function update(target) {
            if (target instanceof HTMLAnchorElement) {
              target.target = "_blank";
            }
            if (target.childNodes && 0 < target.childNodes.length) {
              var i = 0;
              for (; i < target.childNodes.length; ++i) {
                update(target.childNodes[i]);
              }
            }
          }(s);
          element.appendChild(s);
        }
      }
    };
  };
  var register = function(elqClass) {
    Cesium.knockout.bindingHandlers.swipeLeft = {
      "init" : function(element, valueAccessor, allBindingsAccessor, context, window) {
        var deferred = Cesium.knockout.unwrap(valueAccessor());
        (new foo(element)).on("swipeleft", function(canCreateDiscussions) {
          var slideBackward = hahaha;
          var value = window[slideBackward(2778)];
          deferred[slideBackward(1318)](value, arguments);
        });
      }
    };
    Cesium.knockout.bindingHandlers.swipeRight = {
      "init" : function(element, valueAccessor, allBindingsAccessor, viewmodel, model) {
        var modes = Cesium.knockout.unwrap(valueAccessor());
        (new foo(element)).on("swiperight", function(canCreateDiscussions) {
          var getMode = hahaha;
          var data = model.$data;
          modes[getMode(1318)](data, arguments);
        });
      }
    };
  };
  DistanceLegendViewModel.prototype.destroy = function() {
    this.EventHelper.removeAll();
  };
  DistanceLegendViewModel.prototype.show = function(o) {
    var load2 = this.enableDistanceLegend ? '<div class="distance-legend" data-bind="visible: distanceLabel && barWidth"><div class="distance-legend-label" data-bind="text: distanceLabel"></div><div class="distance-legend-scale-bar" data-bind="style: { width: barWidth + \'px\', left: (5 + (125 - barWidth) / 2) + \'px\' }"></div></div>' : `<div class="distance-legend"  style="display: none;" data-bind="visible: distanceLabel && barWidth"><div class="distance-legend-label"  data-bind="text: distanceLabel"></div><div class="distance-legend-scale-bar"  data-bind="style: { width: barWidth + 'px', left: (5 + (125 - barWidth) / 2) + 'px' }"></div></div>`;
    next(load2, o, this);
  };
  DistanceLegendViewModel.create = function(options) {
    var result = new DistanceLegendViewModel(options);
    return result.show(options.container), result;
  };
  var geodesic = new Cesium[`EllipsoidGeodesic`];
  var distances = [1, 2, 3, 5, 10, 20, 30, 50, 100, 200, 300, 500, 1E3, 2E3, 3E3, 5E3, 1E4, 2E4, 3E4, 5E4, 1E5, 2E5, 3E5, 5E5, 1E6, 2E6, 3E6, 5E6, 1E7, 2E7, 3E7, 5E7];
  Object.defineProperties(UserInterfaceControl.prototype, {
    "terria" : {
      "get" : function() {
        return this._terria;
      }
    },
    "hasText" : {
      "get" : function() {
        return Cesium.defined(this.text) && "string" == typeof this.text;
      }
    }
  });
  UserInterfaceControl.prototype.activate = function() {
    throw new Cesium["DeveloperError"]("activate must be implemented in the derived class.");
  };
  HttpStatusError.prototype = Object.create(UserInterfaceControl.prototype);
  (ResetViewNavigationControl.prototype = Object.create(HttpStatusError.prototype)).setNavigationLocked = function(canCreateDiscussions) {
    this.navigationLocked = canCreateDiscussions;
  };
  ResetViewNavigationControl.prototype.resetView = function() {
    if (!this.navigationLocked) {
      var scene = this.terria.scene;
      if (scene.screenSpaceCameraController.enableInputs) {
        this.isActive = true;
        var camera = scene.camera;
        if (Cesium.defined(this.terria.trackedEntity)) {
          var trackedEntity = this.terria.trackedEntity;
          this.terria.trackedEntity = void 0;
          this.terria.trackedEntity = trackedEntity;
        } else {
          if (this.terria.options.defaultResetView) {
            if (this.terria.options.defaultResetView && this.terria.options.defaultResetView instanceof Cesium.Cartographic) {
              camera.flyTo({
                "destination" : scene.globe.ellipsoid.cartographicToCartesian(this.terria.options.defaultResetView)
              });
            } else {
              if (this.terria.options.defaultResetView && this.terria.options.defaultResetView instanceof Cesium.Rectangle) {
                try {
                  Cesium.Rectangle.validate(this.terria.options.defaultResetView);
                  camera.flyTo({
                    "destination" : this.terria.options.defaultResetView,
                    "orientation" : {
                      "heading" : Cesium.Math.toRadians(5.729578)
                    }
                  });
                } catch (_0x4d79bb) {
                  console.log("Cesium-navigation/ResetViewNavigationControl:   options.defaultResetView Cesium Cesium.Rectangle is  invalid!");
                }
              }
            }
          } else {
            if ("function" == typeof camera.flyHome) {
              camera.flyHome(1);
            } else {
              camera.flyTo({
                "destination" : camera.DEFAULT_VIEW_RECTANGLE,
                "duration" : 1
              });
            }
          }
        }
        this.isActive = false;
      }
    }
  };
  ResetViewNavigationControl.prototype.activate = function() {
    this.resetView();
  };
  var Utils = {};
  var unprojectedScratch = new Cesium[`Cartographic`];
  var rayScratch = new Cesium[`Ray`];
  Utils.getCameraFocus = function(terria, remaining, result) {
    var scene = terria.scene;
    var camera = scene.camera;
    if (scene.mode !== Cesium.SceneMode.MORPHING && (Cesium.defined(result) || (result = new Cesium["Cartesian3"]), result = Cesium.defined(terria.trackedEntity) ? terria.trackedEntity.position.getValue(terria.clock.currentTime, result) : (rayScratch.origin = camera.positionWC, rayScratch.direction = camera.directionWC, scene.globe.pick(rayScratch, scene, result)), Cesium.defined(result))) {
      return scene.mode === Cesium.SceneMode.SCENE2D || scene.mode === Cesium.SceneMode.COLUMBUS_VIEW ? (result = camera.worldToCameraCoordinatesPoint(result, result), remaining && (result = scene.globe.ellipsoid.cartographicToCartesian(scene.mapProjection.unproject(result, unprojectedScratch), result))) : remaining || (result = camera.worldToCameraCoordinatesPoint(result, result)), result;
    }
  };
  ZoomNavigationControl.prototype.relativeAmount = 1;
  (ZoomNavigationControl.prototype = Object.create(HttpStatusError.prototype)).activate = function() {
    this.zoom(this.relativeAmount);
  };
  var cartesian3Scratch = new Cesium[`Cartesian3`];
  ZoomNavigationControl.prototype.zoom = function(relativeAmount) {
    if (this.isActive = true, Cesium.defined(this.terria)) {
      var scene = this.terria.scene;
      var sscc = scene.screenSpaceCameraController;
      if (!sscc.enableInputs || !sscc.enableZoom) {
        return;
      }
      var orientation;
      var camera = scene.camera;
      switch(scene.mode) {
        case Cesium.SceneMode.MORPHING:
          break;
        case Cesium.SceneMode.SCENE2D:
          camera.zoomIn(camera.positionCartographic.height * (1 - this.relativeAmount));
          break;
        default:
          position = Cesium.defined(this.terria.trackedEntity) ? new Cesium["Cartesian3"] : Utils.getCameraFocus(this.terria, false);
          orientation = Cesium.defined(position) ? {
            "direction" : camera.direction,
            "up" : camera.up
          } : (new Cesium.Ray(camera.worldToCameraCoordinatesPoint(scene.globe.ellipsoid.cartographicToCartesian(camera.positionCartographic)), camera.directionWC), position = Cesium.IntersectionTests.grazingAltitudeLocation(Cesium.Ray, scene.globe.ellipsoid), {
            "heading" : camera.heading,
            "pitch" : camera.pitch,
            "roll" : camera.roll
          });
          var direction = Cesium.Cartesian3.subtract(camera.position, position, cartesian3Scratch);
          direction = Cesium.Cartesian3.multiplyByScalar(direction, relativeAmount, direction);
          var position = Cesium.Cartesian3.add(position, direction, position);
          if (Cesium.defined(this.terria.trackedEntity) || scene.mode === Cesium.SceneMode.COLUMBUS_VIEW) {
            camera.position = position;
          } else {
            camera.flyTo({
              "destination" : position,
              "orientation" : orientation,
              "duration" : 0.5,
              "convert" : false
            });
          }
      }
    }
    this.isActive = false;
  };
  NavigationViewModel.prototype.destroy = function() {
    this.EventHelper.removeAll();
  };
  NavigationViewModel.prototype.show = function(o) {
    var load2;
    if (this.enableZoomControls && this.enableCompass) {
      load2 = '<div class="compass" title="" data-bind="visible: showCompass, event: { mousedown: handleMouseDown, dblclick: handleDoubleClick }"><div class="compass-outer-ring-background"></div>' + " <div class=\"compass-rotation-marker\" data-bind=\"visible: isOrbiting, style: { transform: 'rotate(-' + orbitCursorAngle + 'rad)', '-webkit-transform': 'rotate(-' + orbitCursorAngle + 'rad)', opacity: orbitCursorOpacity }, cesiumSvgPath: { path: svgCompassRotationMarker, width: 145, height: 145 }\"></div> <div class=\"compass-outer-ring\" title=\"\" data-bind=\"style: { transform: 'rotate(-' + heading + 'rad)', '-webkit-transform': 'rotate(-' + heading + 'rad)' }, cesiumSvgPath: { path: svgCompassOuterRing, width: 145, height: 145 }\"></div> <div class=\"compass-gyro-background\"></div> <div class=\"compass-gyro\" data-bind=\"cesiumSvgPath: { path: svgCompassGyro, width: 145, height: 145 }, css: { 'compass-gyro-active': isOrbiting }\"></div></div><div class=\"navigation-controls\">\x3c!-- ko foreach: controls --\x3e<div data-bind=\"click: activate, attr: { title: $data.name }, css: $root.isLastControl($data) ? 'navigation-control-last' : 'navigation-control' \">   \x3c!-- ko if: $data.hasText --\x3e   <div data-bind=\"text: $data.text, css: $data.isActive ?  'navigation-control-icon-active ' + $data.cssClass : $data.cssClass\"></div>   \x3c!-- /ko --\x3e  \x3c!-- ko ifnot: $data.hasText --\x3e  <div data-bind=\"cesiumSvgPath: { path: $data.svgIcon, width: $data.svgWidth, height: $data.svgHeight }, css: $data.isActive ?  'navigation-control-icon-active ' + $data.cssClass : $data.cssClass\"></div>  \x3c!-- /ko --\x3e </div> \x3c!-- /ko --\x3e</div>";
    } else {
      if (!this.enableZoomControls && this.enableCompass) {
        load2 = `<div class="compass" title="" data-bind="visible: showCompass, event: { mousedown: handleMouseDown, dblclick: handleDoubleClick }"><div class="compass-outer-ring-background"></div> <div class="compass-rotation-marker" data-bind="visible: isOrbiting, style: { transform: 'rotate(-' + orbitCursorAngle + 'rad)', '-webkit-transform': 'rotate(-' + orbitCursorAngle + 'rad)', opacity: orbitCursorOpacity }, cesiumSvgPath: { path: svgCompassRotationMarker, width: 145, height: 145 }"></div> <div class="compass-outer-ring" title="" data-bind="style: { transform: 'rotate(-' + heading + 'rad)', '-webkit-transform': 'rotate(-' + heading + 'rad)' }, cesiumSvgPath: { path: svgCompassOuterRing, width: 145, height: 145 }"></div> <div class="compass-gyro-background"></div> <div class="compass-gyro" data-bind="cesiumSvgPath: { path: svgCompassGyro, width: 145, height: 145 }, css: { 'compass-gyro-active': isOrbiting }"></div></div><div class="navigation-controls"  style="display: none;" >\x3c!-- ko foreach: controls --\x3e<div data-bind="click: activate, attr: { title: $data.name }, css: $root.isLastControl($data) ? 'navigation-control-last' : 'navigation-control' ">   \x3c!-- ko if: $data.hasText --\x3e   <div data-bind="text: $data.text, css: $data.isActive ?  'navigation-control-icon-active ' + $data.cssClass : $data.cssClass"></div>   \x3c!-- /ko --\x3e  \x3c!-- ko ifnot: $data.hasText --\x3e  <div data-bind="cesiumSvgPath: { path: $data.svgIcon, width: $data.svgWidth, height: $data.svgHeight }, css: $data.isActive ?  'navigation-control-icon-active ' + $data.cssClass : $data.cssClass"></div>  \x3c!-- /ko --\x3e </div> \x3c!-- /ko --\x3e</div>`;
      } else {
        if (this.enableZoomControls && !this.enableCompass) {
          load2 = '<div class="compass"  style="display: none;" title="" data-bind="visible: showCompass, event: { mousedown: handleMouseDown, dblclick: handleDoubleClick }"><div class="compass-outer-ring-background"></div>' + " <div class=\"compass-rotation-marker\" data-bind=\"visible: isOrbiting, style: { transform: 'rotate(-' + orbitCursorAngle + 'rad)', '-webkit-transform': 'rotate(-' + orbitCursorAngle + 'rad)', opacity: orbitCursorOpacity }, cesiumSvgPath: { path: svgCompassRotationMarker, width: 145, height: 145 }\"></div> <div class=\"compass-outer-ring\" title=\"\" data-bind=\"style: { transform: 'rotate(-' + heading + 'rad)', '-webkit-transform': 'rotate(-' + heading + 'rad)' }, cesiumSvgPath: { path: svgCompassOuterRing, width: 145, height: 145 }\"></div> <div class=\"compass-gyro-background\"></div> <div class=\"compass-gyro\" data-bind=\"cesiumSvgPath: { path: svgCompassGyro, width: 145, height: 145 }, css: { 'compass-gyro-active': isOrbiting }\"></div></div><div class=\"navigation-controls\"    >\x3c!-- ko foreach: controls --\x3e<div data-bind=\"click: activate, attr: { title: $data.name }, css: $root.isLastControl($data) ? 'navigation-control-last' : 'navigation-control' \">   \x3c!-- ko if: $data.hasText --\x3e   <div data-bind=\"text: $data.text, css: $data.isActive ?  'navigation-control-icon-active ' + $data.cssClass : $data.cssClass\"></div>   \x3c!-- /ko --\x3e  \x3c!-- ko ifnot: $data.hasText --\x3e  <div data-bind=\"cesiumSvgPath: { path: $data.svgIcon, width: $data.svgWidth, height: $data.svgHeight }, css: $data.isActive ?  'navigation-control-icon-active ' + $data.cssClass : $data.cssClass\"></div>  \x3c!-- /ko --\x3e </div> \x3c!-- /ko --\x3e</div>";
        } else {
          if (!(this.enableZoomControls || this.enableCompass)) {
            load2 = '<div class="compass"  style="display: none;" title="" data-bind="visible: showCompass, event: { mousedown: handleMouseDown, dblclick: handleDoubleClick }"><div class="compass-outer-ring-background"></div> <div class="compass-rotation-marker" data-bind="visible: isOrbiting, style: { transform: \'rotate(-\' + orbitCursorAngle + \'rad)\', \'-webkit-transform\': \'rotate(-\' + orbitCursorAngle + \'rad)\', opacity: orbitCursorOpacity }, cesiumSvgPath: { path: svgCompassRotationMarker, width: 145, height: 145 }"></div> <div class="compass-outer-ring" title="" data-bind="style: { transform: \'rotate(-\' + heading + \'rad)\', \'-webkit-transform\': \'rotate(-\' + heading + \'rad)\' }, cesiumSvgPath: { path: svgCompassOuterRing, width: 145, height: 145 }"></div> <div class="compass-gyro-background"></div> <div class="compass-gyro" data-bind="cesiumSvgPath: { path: svgCompassGyro, width: 145, height: 145 }, css: { \'compass-gyro-active\': isOrbiting }"></div></div><div class="navigation-controls"   style="display: none;" >\x3c!-- ko foreach: controls --\x3e<div data-bind="click: activate, attr: { title: $data.name }, css: $root.isLastControl($data) ? \'navigation-control-last\' : \'navigation-control\' ">   \x3c!-- ko if: $data.hasText --\x3e   <div data-bind="text: $data.text, css: $data.isActive ?  \'navigation-control-icon-active \' + $data.cssClass : $data.cssClass"></div>   \x3c!-- /ko --\x3e  \x3c!-- ko ifnot: $data.hasText --\x3e  <div data-bind="cesiumSvgPath: { path: $data.svgIcon, width: $data.svgWidth, height: $data.svgHeight }, css: $data.isActive ?  \'navigation-control-icon-active \' + $data.cssClass : $data.cssClass"></div>  \x3c!-- /ko --\x3e </div> \x3c!-- /ko --\x3e</div>';
          }
        }
      }
    }
    next(load2, o, this);
  };
  NavigationViewModel.prototype.add = function(name) {
    this.controls.push(name);
  };
  NavigationViewModel.prototype.remove = function(key) {
    this.controls.remove(key);
  };
  NavigationViewModel.prototype.isLastControl = function(control) {
    return control === this.controls[this.controls.length - 1];
  };
  var direction = new Cesium[`Cartesian2`];
  NavigationViewModel.prototype.handleMouseDown = function(scene, e) {
    if (this.terria.scene.mode === Cesium.SceneMode.MORPHING) {
      return true;
    }
    if (scene.navigationLocked) {
      return true;
    }
    var viewModel;
    var panel;
    var transform;
    var camera = e.currentTarget;
    var start = e.currentTarget.getBoundingClientRect();
    var position = start.width / 2;
    scene = new Cesium["Cartesian2"]((start.right - start.left) / 2, (start.bottom - start.top) / 2);
    start = new Cesium.Cartesian2(e.clientX - start.left, e.clientY - start.top);
    start = Cesium.Cartesian2.subtract(start, scene, direction);
    scene = Cesium.Cartesian2.magnitude(start) / position;
    if (scene < 50 / 145) {
      !function(viewModel, container, left) {
        function translate(deltaX, dist) {
          var LMinitSymbols = hahaha;
          var _0x114a09 = Math[LMinitSymbols(2375)](-deltaX.y, deltaX.x);
          viewModel[LMinitSymbols(2905)] = Cesium[LMinitSymbols(2090)][LMinitSymbols(1399)](_0x114a09 - Cesium[LMinitSymbols(2090)][LMinitSymbols(1163)]);
          deltaX = Cesium.Cartesian2[LMinitSymbols(2648)](deltaX);
          dist = dist / 2;
          dist = Math[LMinitSymbols(1125)](deltaX / dist, 1);
          dist = 0.5 * dist * dist + 0.5;
          viewModel[LMinitSymbols(1315)] = dist;
        }
        var scene = viewModel.terria.scene;
        var sscc = scene.screenSpaceCameraController;
        if (scene.mode !== Cesium.SceneMode.MORPHING && sscc.enableInputs && !viewModel.navigationLocked) {
          switch(scene.mode) {
            case Cesium.SceneMode.COLUMBUS_VIEW:
              if (sscc.enableLook) {
                break;
              }
              if (!sscc.enableTranslate || !sscc.enableTilt) {
                return;
              }
              break;
            case Cesium.SceneMode.SCENE3D:
              if (sscc.enableLook) {
                break;
              }
              if (!sscc.enableTilt || !sscc.enableRotate) {
                return;
              }
              break;
            case Cesium.SceneMode.SCENE2D:
              if (!sscc.enableTranslate) {
                return;
              }
          }
          document.removeEventListener("mousemove", viewModel.orbitMouseMoveFunction, false);
          document.removeEventListener("mouseup", viewModel.orbitMouseUpFunction, false);
          if (Cesium.defined(viewModel.orbitTickFunction)) {
            viewModel.terria.clock.onTick.removeEventListener(viewModel.orbitTickFunction);
          }
          viewModel.orbitMouseMoveFunction = void 0;
          viewModel.orbitMouseUpFunction = void 0;
          viewModel.orbitTickFunction = void 0;
          viewModel.isOrbiting = true;
          viewModel.orbitLastTimestamp = Cesium.getTimestamp();
          var position;
          var camera = scene.camera;
          if (Cesium.defined(viewModel.terria.trackedEntity)) {
            viewModel.orbitFrame = void 0;
            viewModel.orbitIsLook = false;
          } else {
            position = Utils.getCameraFocus(viewModel.terria, true, height);
            if (Cesium.defined(position)) {
              viewModel.orbitFrame = Cesium.Transforms.eastNorthUpToFixedFrame(position, scene.globe.ellipsoid, newTransformScratch);
              viewModel.orbitIsLook = false;
            } else {
              viewModel.orbitFrame = Cesium.Transforms.eastNorthUpToFixedFrame(camera.positionWC, scene.globe.ellipsoid, newTransformScratch);
              viewModel.orbitIsLook = true;
            }
          }
          viewModel.orbitTickFunction = function(e) {
            var defined = hahaha;
            var matches;
            var whenContext = Cesium[defined(1929)]();
            var power = (whenContext - viewModel[defined(1988)]) * (2.5 * (viewModel[defined(1315)] - 0.5) / 1E3);
            var value = viewModel.orbitCursorAngle + Cesium.Math[defined(1163)];
            var x = Math[defined(449)](value) * power;
            value = Math[defined(384)](value) * power;
            if (viewModel[defined(864)]) {
              return true;
            }
            if (Cesium.defined(viewModel[defined(2247)])) {
              matches = Cesium[defined(1030)][defined(788)](camera[defined(2133)], translate);
              camera[defined(457)](viewModel[defined(2247)]);
            }
            if (scene[defined(2598)] === Cesium.SceneMode[defined(363)]) {
              camera[defined(367)](new (Cesium[defined(3131)])(x, value, 0), Math.max(scene[defined(2818)].clientWidth, scene[defined(2818)][defined(663)]) / 100 * camera[defined(1323)][defined(1132)] * power);
            } else {
              if (viewModel[defined(2555)]) {
                camera[defined(684)](Cesium[defined(3131)][defined(2856)], -x);
                camera[defined(684)](camera[defined(379)], -value);
              } else {
                camera.rotateLeft(x);
                camera[defined(569)](value);
              }
            }
            if (Cesium.defined(viewModel[defined(2247)])) {
              camera[defined(457)](matches);
            }
            viewModel[defined(1988)] = whenContext;
          };
          viewModel.orbitMouseMoveFunction = function(e) {
            var updateAngleAndOpacity = hahaha;
            var coords = container.getBoundingClientRect();
            var k1 = new (Cesium[updateAngleAndOpacity(2689)])((coords[updateAngleAndOpacity(379)] - coords[updateAngleAndOpacity(1838)]) / 2, (coords[updateAngleAndOpacity(1404)] - coords[updateAngleAndOpacity(3190)]) / 2);
            e = new (Cesium[updateAngleAndOpacity(2689)])(e.clientX - coords.left, e[updateAngleAndOpacity(2199)] - coords[updateAngleAndOpacity(3190)]);
            translate(Cesium.Cartesian2[updateAngleAndOpacity(1416)](e, k1, direction), coords[updateAngleAndOpacity(807)]);
          };
          viewModel.orbitMouseUpFunction = function(e) {
            var defined = hahaha;
            viewModel[defined(1392)] = false;
            document[defined(1091)]("mousemove", viewModel[defined(1170)], false);
            document[defined(1091)](defined(2527), viewModel.orbitMouseUpFunction, false);
            if (Cesium[defined(1973)](viewModel[defined(2193)])) {
              viewModel.terria[defined(617)][defined(1825)][defined(1091)](viewModel[defined(2193)]);
            }
            viewModel[defined(1170)] = void 0;
            viewModel[defined(2855)] = void 0;
            viewModel[defined(2193)] = void 0;
          };
          document.addEventListener("mousemove", viewModel.orbitMouseMoveFunction, false);
          document.addEventListener("mouseup", viewModel.orbitMouseUpFunction, false);
          viewModel.terria.clock.onTick.addEventListener(viewModel.orbitTickFunction);
          translate(left, container.getBoundingClientRect().width);
        }
      }(this, camera, start);
    } else {
      if (!(scene < 1)) {
        return true;
      }
      panel = camera;
      position = start;
      scene = (viewModel = this).terria.scene;
      camera = scene.camera;
      start = scene.screenSpaceCameraController;
      if (scene.mode !== Cesium.SceneMode.MORPHING && scene.mode !== Cesium.SceneMode.SCENE2D && start.enableInputs) {
        if (!viewModel.navigationLocked) {
          if (start.enableLook || scene.mode !== Cesium.SceneMode.COLUMBUS_VIEW && (scene.mode !== Cesium.SceneMode.SCENE3D || start.enableRotate)) {
            document.removeEventListener("mousemove", viewModel.rotateMouseMoveFunction, false);
            document.removeEventListener("mouseup", viewModel.rotateMouseUpFunction, false);
            viewModel.rotateMouseMoveFunction = void 0;
            viewModel.rotateMouseUpFunction = void 0;
            viewModel.isRotating = true;
            viewModel.rotateInitialCursorAngle = Math.atan2(-position.y, position.x);
            if (Cesium.defined(viewModel.terria.trackedEntity)) {
              viewModel.rotateFrame = void 0;
              viewModel.rotateIsLook = false;
            } else {
              position = Utils.getCameraFocus(viewModel.terria, true, height);
              if (Cesium.defined(position) && (scene.mode !== Cesium.SceneMode.COLUMBUS_VIEW || start.enableLook || start.enableTranslate)) {
                viewModel.rotateFrame = Cesium.Transforms.eastNorthUpToFixedFrame(position, scene.globe.ellipsoid, newTransformScratch);
                viewModel.rotateIsLook = false;
              } else {
                viewModel.rotateFrame = Cesium.Transforms.eastNorthUpToFixedFrame(camera.positionWC, scene.globe.ellipsoid, newTransformScratch);
                viewModel.rotateIsLook = true;
              }
            }
            if (Cesium.defined(viewModel.rotateFrame)) {
              transform = Cesium.Matrix4.clone(camera.transform, translate);
              camera.lookAtTransform(viewModel.rotateFrame);
            }
            viewModel.rotateInitialCameraAngle = -camera.heading;
            if (Cesium.defined(viewModel.rotateFrame)) {
              camera.lookAtTransform(transform);
            }
            viewModel.rotateMouseMoveFunction = function(e) {
              var transform;
              var result = panel.getBoundingClientRect();
              var c = new Cesium["Cartesian2"]((result.right - result.left) / 2, (result.bottom - result.top) / 2);
              e = new Cesium["Cartesian2"](e.clientX - result.left, e.clientY - result.top);
              result = Cesium.Cartesian2.subtract(e, c, direction);
              e = Math.atan2(-result.y, result.x) - viewModel.rotateInitialCursorAngle;
              c = Cesium.Math.zeroToTwoPi(viewModel.rotateInitialCameraAngle - e);
              result = viewModel.terria.scene.camera;
              if (Cesium.defined(viewModel.rotateFrame)) {
                transform = Cesium.Matrix4.clone(result.transform, translate);
                result.lookAtTransform(viewModel.rotateFrame);
              }
              e = -result.heading;
              result.rotateRight(c - e);
              if (Cesium.defined(viewModel.rotateFrame)) {
                result.lookAtTransform(transform);
              }
            };
            viewModel.rotateMouseUpFunction = function(e) {
              viewModel.isRotating = false;
              document.removeEventListener("mousemove", viewModel.rotateMouseMoveFunction, false);
              document.removeEventListener("mouseup", viewModel.rotateMouseUpFunction, false);
              viewModel.rotateMouseMoveFunction = void 0;
              viewModel.rotateMouseUpFunction = void 0;
            };
            document.addEventListener("mousemove", viewModel.rotateMouseMoveFunction, false);
            document.addEventListener("mouseup", viewModel.rotateMouseUpFunction, false);
          }
        }
      }
    }
  };
  var translate = new Cesium[`Matrix4`];
  var newTransformScratch = new Cesium.Matrix4;
  var height = new Cesium.Cartesian3;
  NavigationViewModel.prototype.handleDoubleClick = function(viewModel, e) {
    var scene = viewModel.terria.scene;
    var camera = scene.camera;
    var controller = scene.screenSpaceCameraController;
    if (scene.mode === Cesium.SceneMode.MORPHING || !controller.enableInputs) {
      return true;
    }
    if (viewModel.navigationLocked) {
      return true;
    }
    if (scene.mode !== Cesium.SceneMode.COLUMBUS_VIEW || controller.enableTranslate) {
      if (scene.mode === Cesium.SceneMode.SCENE3D || scene.mode === Cesium.SceneMode.COLUMBUS_VIEW) {
        if (!controller.enableLook) {
          return;
        }
        if (scene.mode === Cesium.SceneMode.SCENE3D && !controller.enableRotate) {
          return;
        }
      }
      var position = Utils.getCameraFocus(viewModel.terria, true, height);
      if (Cesium.defined(position)) {
        controller = scene.globe.ellipsoid.cartographicToCartesian(camera.positionCartographic, new Cesium["Cartesian3"]);
        viewModel = scene.globe.ellipsoid.geodeticSurfaceNormal(position);
        scene = new Cesium["BoundingSphere"](position, 0);
        camera.flyToBoundingSphere(scene, {
          "offset" : new Cesium["HeadingPitchRange"](0, Cesium.Math.PI_OVER_TWO - Cesium.Cartesian3.angleBetween(viewModel, camera.directionWC), Cesium.Cartesian3.distance(controller, position)),
          "duration" : 1.5
        });
      } else {
        this.controls[1].resetView();
      }
    }
  };
  NavigationViewModel.create = function(options) {
    var result = new NavigationViewModel(options);
    return result.show(options.container), result;
  };
  setup.prototype.distanceLegendViewModel = void 0;
  setup.prototype.navigationViewModel = void 0;
  setup.prototype.navigationDiv = void 0;
  setup.prototype.distanceLegendDiv = void 0;
  setup.prototype.terria = void 0;
  setup.prototype.container = void 0;
  setup.prototype._onDestroyListeners = void 0;
  setup.prototype._navigationLocked = false;
  setup.prototype.setNavigationLocked = function(canCreateDiscussions) {
    this._navigationLocked = canCreateDiscussions;
    this.navigationViewModel.setNavigationLocked(this._navigationLocked);
  };
  setup.prototype.getNavigationLocked = function() {
    return this._navigationLocked;
  };
  setup.prototype.destroy = function() {
    if (Cesium.defined(this.navigationViewModel)) {
      this.navigationViewModel.destroy();
    }
    if (Cesium.defined(this.distanceLegendViewModel)) {
      this.distanceLegendViewModel.destroy();
    }
    if (Cesium.defined(this.navigationDiv)) {
      this.navigationDiv.parentNode.removeChild(this.navigationDiv);
    }
    delete this.navigationDiv;
    if (Cesium.defined(this.distanceLegendDiv)) {
      this.distanceLegendDiv.parentNode.removeChild(this.distanceLegendDiv);
    }
    delete this.distanceLegendDiv;
    if (Cesium.defined(this.container)) {
      this.container.parentNode.removeChild(this.container);
    }
    delete this.container;
    var i = 0;
    for (; i < this._onDestroyListeners.length; i++) {
      this._onDestroyListeners[i]();
    }
  };
  setup.prototype.remove = function() {
    this.destroy();
  };
  setup.prototype.addOnDestroyListener = function(callback) {
    if ("function" == typeof callback) {
      this._onDestroyListeners.push(callback);
    }
  };
  appendCSS(`/*html {\n    height: 100%;\n    -webkit-font-smoothing: antialiased;\n}\n\nbody {\n    height: 100%;\n    width: 100%;\n    margin: 0;\n    overflow: hidden;\n    padding: 0;\n    background: #000;\n    font-size: 15px;\n    font-family: @default-font;\n}*/\n\n.full-window {\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    margin: 0;\n    overflow: hidden;\n    padding: 0;\n    -webkit-transition: left 0.25s ease-out;\n    -moz-transition: left 0.25s ease-out;\n    -ms-transition: left 0.25s ease-out;\n    -o-transition: left 0.25s ease-out;\n    transition: left 0.25s ease-out;\n}\n\n.transparent-to-input {\n    pointer-events: none;\n}\n\n.opaque-to-input {\n    pointer-events: auto;\n}\n\n.clickable {\n    cursor: pointer;\n}\n\n\n/*a {\n    text-decoration: none;\n    color: @highlight-color;\n}*/\n\na:hover {\n    text-decoration: underline;\n}\n\n\n/*\n@modal-background-color: @panel-background-color;\n@modal-text-color: @panel-emphasized-text-color;\n@modal-header-background-color: rgba(0,0,0,0.2);\n@modal-header-text-color: @panel-emphasized-text-color;*/\n\n\n/*.modal-background {\n    .opaque-to-input;\n    position: fixed;\n    left: 0;\n    right: 0;\n    top: 0;\n    bottom: 0;\n    background-color: rgba(0,0,0,0.5);\n    z-index: 1000;  required for IE9 \n}*/\n\n\n/*\n.modal {\n    position: absolute;\n    margin: auto;\n    background-color: @modal-background-color;\n    top: 0;\n    left: 0;\n    bottom: 0;\n    right: 0;\n    max-height: 100%;\n    max-width: 100%;\n    font-family: @default-font;\n    color: @modal-text-color;\n}\n\n.modal-header {\n  background-color: @modal-header-background-color;\n  border-bottom: @panel-element-border;\n  font-size: 15px;\n  line-height: 40px;\n  margin: 0;\n}\n\n.modal-header h1 {\n  font-size: 15px;\n  color: @modal-header-text-color;\n  margin-left: 15px;\n}*/\n\n\n/* Commented out due to conflicts with client apps. \n.modal-content {\n  margin-left: 15px;\n  margin-right: 15px;\n  margin-bottom: 15px;\n  padding-top: 15px;\n  overflow: auto;\n}*/\n\n\n/*.modal-close-button {\n    position: absolute;\n    right: 15px;\n    cursor: pointer;\n    font-size: 18px;\n    color: @modal-header-text-color;\n}*/\n\n#ui {\n    z-index: 2100;\n}\n\n@media print {\n    .full-window {\n        position: initial;\n    }\n}\n\n\n/* input[type=text] {\n  height: 38px;\n  background-color: #eeeeee;\n  color: @input-text-color;\n  font-size: 14px;\n}\n\n::-webkit-input-placeholder {\n  color: fade(@input-text-color, 75%);\n  font-style: italic;\n}\n\n:-moz-placeholder { /* Firefox 18- \n  color: fade(@input-text-color, 75%);\n  font-style: italic;\n}\n\n::-moz-placeholder {  /* Firefox 19+  \n  color: fade(@input-text-color, 75%);\n  font-style: italic;\n}\n\n:-ms-input-placeholder {\n  color: fade(@input-text-color, 75%);\n  font-style: italic;\n}\n\ninput:focus {\n    outline-color: #FFFFFF;\n}\n*/\n\n\n/*select {\n  display: block;\n  background-color: @panel-form-input-background-color;\n  color: @panel-form-input-text-color;\n  height: 40px;\n  border: 0;\n  margin-top: 10px;\n  font-size: 14px;\n  padding-left: 5px;\n}*/\n\n.markdown img {\n    max-width: 100%;\n}\n\n.markdown svg {\n    max-height: 100%;\n}\n\n.markdown input,\n.markdown select,\n.markdown textarea,\n.markdown fieldset {\n    font-family: inherit;\n    font-size: 1rem;\n    box-sizing: border-box;\n    margin-top: 0;\n    margin-bottom: 0;\n}\n\n.markdown label {\n    vertical-align: middle;\n}\n\n.markdown h1,\n.markdown h2,\n.markdown h3,\n.markdown h4,\n.markdown h5,\n.markdown h6 {\n    font-family: inherit;\n    font-weight: bold;\n    line-height: 1.25;\n    margin-top: 1em;\n    margin-bottom: .5em;\n}\n\n.markdown h1 {\n    font-size: 2rem;\n}\n\n.markdown h2 {\n    font-size: 1.5rem;\n}\n\n.markdown h3 {\n    font-size: 1.25rem;\n}\n\n.markdown h4 {\n    font-size: 1rem;\n}\n\n.markdown h5 {\n    font-size: 0.875rem;\n}\n\n.markdown h6 {\n    font-size: 0.75rem;\n}\n\n.markdown p {\n    margin-top: 0;\n    margin-bottom: 1rem;\n}\n\n.markdown strong {\n    font-weight: bold;\n}\n\n.markdown em {\n    font-style: italic;\n}\n\n.markdown small {\n    font-size: 80%;\n}\n\n.markdown mark {\n    color: #000;\n    background: #ff0;\n}\n\n.markdown u {\n    text-decoration: underline;\n}\n\n.markdown s {\n    text-decoration: line-through;\n}\n\n.markdown dl,\n.markdown ol,\n.markdown ul {\n    margin-top: 0;\n    margin-bottom: 1rem;\n}\n\n.markdown ol {\n    list-style: decimal inside;\n}\n\n.markdown ul {\n    list-style: disc inside;\n}\n\n.markdown pre,\n.markdown code,\n.markdown samp {\n    font-family: monospace;\n    font-size: inherit;\n}\n\n.markdown pre {\n    margin-top: 0;\n    margin-bottom: 1rem;\n    overflow-x: scroll;\n}\n\n.markdown a {\n    color: #68ADFE;\n    text-decoration: none;\n}\n\n.markdown a:hover {\n    text-decoration: underline;\n}\n\n.markdown pre,\n.markdown code {\n    background-color: transparent;\n    border-radius: 3px;\n}\n\n.markdown hr {\n    border: 0;\n    border-bottom-style: solid;\n    border-bottom-width: 1px;\n    border-bottom-color: rgba(0, 0, 0, 0.125);\n}\n\n.markdown .left-align {\n    text-align: left;\n}\n\n.markdown .center {\n    text-align: center;\n}\n\n.markdown .right-align {\n    text-align: right;\n}\n\n.markdown .justify {\n    text-align: justify;\n}\n\n.markdown .truncate {\n    max-width: 100%;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.markdown ol.upper-roman {\n    list-style-type: upper-roman;\n}\n\n.markdown ol.lower-alpha {\n    list-style-type: lower-alpha;\n}\n\n.markdown ul.circle {\n    list-style-type: circle;\n}\n\n.markdown ul.square {\n    list-style-type: square;\n}\n\n.markdown .list-reset {\n    list-style: none;\n    padding-left: 0;\n}\n\n.floating {\n    pointer-events: auto;\n    position: absolute;\n    border-radius: 15px;\n}\n\n.floating-horizontal {\n    pointer-events: auto;\n    position: absolute;\n    border-radius: 15px;\n    padding-left: 5px;\n    padding-right: 5px;\n}\n\n.floating-vertical {\n    pointer-events: auto;\n    position: absolute;\n    border-radius: 15px;\n    padding-top: 5px;\n    padding-bottom: 5px;\n}\n\n@media print {\n    .floating {\n        display: none;\n    }\n}\n\n.distance-legend {\n    pointer-events: auto;\n    position: absolute;\n    border-radius: 15px;\n    padding-left: 5px;\n    padding-right: 5px;\n    bottom: 30px;\n    height: 30px;\n    width: 125px;\n    box-sizing: content-box;\n}\n\n.distance-legend-label {\n    display: inline-block;\n    font-family: 'Roboto', sans-serif;\n    font-size: 14px;\n    font-weight: lighter;\n    line-height: 30px;\n    color: #FFFFFF;\n    width: 125px;\n    text-align: center;\n}\n\n.distance-legend-scale-bar {\n    border-left: 1px solid #FFFFFF;\n    border-right: 1px solid #FFFFFF;\n    border-bottom: 1px solid #FFFFFF;\n    position: absolute;\n    height: 10px;\n    top: 15px;\n}\n\n@media print {\n    .distance-legend {\n        display: none;\n    }\n}\n\n@media screen and (max-width: 700px),\nscreen and (max-height: 420px) {\n    .distance-legend {\n        display: none;\n    }\n}\n\n.navigation-controls {\n    position: absolute;\n    right: 30px;\n    top: 210px;\n    width: 30px;\n    border: 1px solid rgba(255, 255, 255, 0.1);\n    font-weight: 300;\n    -webkit-touch-callout: none;\n    -webkit-user-select: none;\n    -khtml-user-select: none;\n    -moz-user-select: none;\n    -ms-user-select: none;\n    user-select: none;\n}\n\n.navigation-control {\n    cursor: pointer;\n    border-bottom: 1px solid #555555;\n}\n\n.naviagation-control:active {\n    color: #FFF;\n}\n\n.navigation-control-last {\n    cursor: pointer;\n    border-bottom: 1px solid #555555;\n    border-bottom: 0;\n}\n\n.navigation-control-icon-zoom-in {\n    position: relative;\n    text-align: center;\n    font-size: 20px;\n    color: #FFFFFF;\n    padding-bottom: 4px;\n}\n\n.navigation-control-icon-zoom-out {\n    position: relative;\n    text-align: center;\n    font-size: 20px;\n    color: #FFFFFF;\n}\n\n.navigation-control-icon-reset {\n    position: relative;\n    left: 10px;\n    width: 10px;\n    height: 10px;\n    fill: rgba(255, 255, 255, 0.8);\n    padding-top: 6px;\n    padding-bottom: 6px;\n    box-sizing: content-box;\n}\n\n.compass {\n    pointer-events: auto;\n    position: absolute;\n    right: 0px;\n    top: 100px;\n    width: 95px;\n    height: 95px;\n    overflow: hidden;\n}\n\n.compass-outer-ring {\n    position: absolute;\n    top: 0;\n    width: 95px;\n    height: 95px;\n    fill: rgba(255, 255, 255, 0.5);\n}\n\n.compass-outer-ring-background {\n    position: absolute;\n    top: 14px;\n    left: 14px;\n    width: 44px;\n    height: 44px;\n    border-radius: 44px;\n    border: 12px solid rgba(47, 53, 60, 0.8);\n    box-sizing: content-box;\n}\n\n.compass-gyro {\n    pointer-events: none;\n    position: absolute;\n    top: 0;\n    width: 95px;\n    height: 95px;\n    fill: #CCC;\n}\n\n.compass-gyro-active {\n    fill: #68ADFE;\n}\n\n.compass-gyro-background {\n    position: absolute;\n    top: 30px;\n    left: 30px;\n    width: 33px;\n    height: 33px;\n    border-radius: 33px;\n    background-color: rgba(47, 53, 60, 0.8);\n    border: 1px solid rgba(255, 255, 255, 0.2);\n    box-sizing: content-box;\n}\n\n.compass-gyro-background:hover+.compass-gyro {\n    fill: #68ADFE;\n}\n\n.compass-rotation-marker {\n    position: absolute;\n    top: 0;\n    width: 95px;\n    height: 95px;\n    fill: #68ADFE;\n}\n\n@media screen and (max-width: 700px),\nscreen and (max-height: 420px) {\n    .navigation-controls {\n        display: none;\n    }\n    .compass {\n        display: none;\n    }\n}\n\n@media print {\n    .navigation-controls {\n        display: none;\n    }\n    .compass {\n        display: none;\n    }\n}`, 
  {});
  indexOf.mixinWidget = function(cesiumWidget, options) {
    return each.apply(void 0, arguments);
  };
  var each = function(options, data) {
    var primaryReplicas;
    var b = new setup(options, data);
    options = Cesium.defined(options.cesiumWidget) ? options.cesiumWidget : options;
    return Object.defineProperties(options, {
      "cesiumNavigation" : {
        "configurable" : true,
        "get" : function() {
          return b;
        }
      }
    }), b.addOnDestroyListener((primaryReplicas = options, function() {
      var stringify = hahaha;
      delete primaryReplicas[stringify(3001)];
    })), b;
  };
  descriptor = function conf(name, value) {
    return call(this, conf), indexOf(name, value);
  };
  name = (expect(WordpressArticlesController, [{
    "key" : `initEvent`,
    "value" : function() {
      var self = this;
      this.viewer.scene.postRender.addEventListener(function(canCreateDiscussions) {
        var extent;
        var rectangle;
        if ("viewer" == self.activateContainer) {
          if (rectangle = self.viewer.camera.computeViewRectangle()) {
            extent = [Cesium.Math.toDegrees(rectangle.west), Cesium.Math.toDegrees(rectangle.south), Cesium.Math.toDegrees(rectangle.east), Cesium.Math.toDegrees(rectangle.north)];
            if (ol.extent.isEmpty(extent)) {
              console.log("extent is empty");
            } else {
              rectangle = self.getPolygonByBbox(extent);
              self.feature.setGeometry(new ol["geom"]["Polygon"](rectangle));
              self.map.getView().fit(extent, {
                "padding" : [50, 50, 50, 50]
              });
            }
          } else {
            console.log("rec is undefined");
          }
        }
      });
    }
  }, {
    "key" : `getPolygonByBbox`,
    "value" : function(name) {
      return [[[name[0], name[1]], [name[2], name[1]], [name[2], name[3]], [name[0], name[3]], [name[0], name[1]]]];
    }
  }, {
    "key" : `addMapData`,
    "value" : function() {
      this.feature = new ol["Feature"](new ol["geom"].Polygon([[[75, 20], [75, 40], [120, 40], [120, 20], [75, 20]]]));
      var item = new ol.source["Vector"]({
        "features" : [this.feature]
      });
      item = new ol.layer["Vector"]({
        "source" : item,
        "style" : new ol["style"].Style({
          "stroke" : new ol["style"].Stroke({
            "color" : "red",
            "width" : 1
          }),
          "fill" : new ol["style"].Fill({
            "color" : "rgba(255, 0, 0, 0.2)"
          })
        })
      });
      this.map.addLayer(item);
    }
  }, {
    "key" : `activate`,
    "value" : function() {
      var rpm_traffic = this;
      this.viewer.container.onmouseenter = function(handler) {
        var now = hahaha;
        rpm_traffic[now(1288)] = now(2276);
      };
      this.map.getViewport().onmouseenter = function(handler) {
        var now = hahaha;
        rpm_traffic[now(1288)] = "map";
      };
    }
  }, {
    "key" : `deactivate`,
    "value" : function() {
      this.viewer.container.onmouseenter = void 0;
      this.map.getViewport().onmouseenter = void 0;
      this.activateContainer = void 0;
    }
  }, {
    "key" : `destroy`,
    "value" : function() {
      this.deactivate();
    }
  }]), WordpressArticlesController);
  appendCSS(`.position-info-status-bar {\n    left: 0px;\n    right: 0px;\n    bottom: 0px;\n    display: block;\n    position: absolute;\n    padding: 3px 10px;\n    font-size: 13px;\n    color: #e9e9e9;\n    text-shadow: 2px 2px 2px #000;\n    background-color: rgba(0, 0, 0, .4);\n    pointer-events: none;\n    text-align: right;\n}\n\n.position-info-status-bar div {\n    float: left;\n    margin-right: 30px;\n}`, {});
  expect(r, [{
    "key" : `createDom`,
    "value" : function() {
      this.container = document.createElement("div");
      this.container.className = "position-info-status-bar";
      this.viewer.cesiumWidget.container.appendChild(this.container);
      this.divLng = document.createElement("div");
      this.container.appendChild(this.divLng);
      this.divLat = document.createElement("div");
      this.container.appendChild(this.divLat);
      this.divH = document.createElement("div");
      this.container.appendChild(this.divH);
      this.divHeading = document.createElement("div");
      this.container.appendChild(this.divHeading);
      this.divPitch = document.createElement("div");
      this.container.appendChild(this.divPitch);
      this.divcH = document.createElement("div");
      this.container.appendChild(this.divcH);
    }
  }, {
    "key" : `initEvent`,
    "value" : function() {
      var map = this;
      this.eventHandler = new Cesium["ScreenSpaceEventHandler"](this.viewer.scene.canvas);
      this.eventHandler.setInputAction(function(currentItems) {
        var parseInt = hahaha;
        var oldValue = map[parseInt(2276)][parseInt(2758)][parseInt(1238)](currentItems[parseInt(1108)]);
        if (oldValue = oldValue || map[parseInt(2276)][parseInt(2758)][parseInt(1306)].pickEllipsoid(currentItems[parseInt(1108)], map[parseInt(2276)].scene[parseInt(2359)][parseInt(1923)])) {
          map[parseInt(2404)](oldValue);
        }
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
      this.viewer.scene.camera.moveEnd.addEventListener(this.handleCameraMoveEvent, this);
    }
  }, {
    "key" : `handleMouseMoveEvent`,
    "value" : function(obj) {
      obj = this.catesian3ToDegrees(obj);
      this.divLng.innerHTML = "\u7ecf\u5ea6\uff1a" + obj.x.toFixed(6);
      this.divLat.innerHTML = "\u7eac\u5ea6\uff1a" + obj.y.toFixed(6);
      this.divH.innerHTML = "\u9ad8\u5ea6\uff1a" + obj.z.toFixed(6);
    }
  }, {
    "key" : `handleCameraMoveEvent`,
    "value" : function() {
      this.divHeading.innerHTML = "\u65b9\u5411\uff1a" + Cesium.Math.toDegrees(this.viewer.scene.camera.heading).toFixed(0) + "\u5ea6";
      this.divPitch.innerHTML = "\u4fef\u4ef0\u89d2\uff1a" + Cesium.Math.toDegrees(this.viewer.scene.camera.pitch).toFixed(0) + "\u5ea6";
      var worldPt = this.catesian3ToDegrees(this.viewer.scene.camera.position);
      this.divcH.innerHTML = "\u89c6\u9ad8\uff1a" + worldPt.z.toFixed(6) + "\u7c73";
    }
  }, {
    "key" : `catesian3ToDegrees`,
    "value" : function(target) {
      return target = Cesium.Cartographic.fromCartesian(target), {
        "x" : Cesium.Math.toDegrees(target.longitude),
        "y" : Cesium.Math.toDegrees(target.latitude),
        "z" : target.height
      };
    }
  }, {
    "key" : `show`,
    "value" : function() {
      this.container.style.display = "block";
    }
  }, {
    "key" : `hide`,
    "value" : function() {
      this.container.style.display = "none";
    }
  }, {
    "key" : "remove",
    "value" : function() {
      this.eventHandler.destroy();
      this.viewer.scene.camera.moveEnd.removeEventListener(this.handleCameraMoveEvent, this);
      this.container.remove();
    }
  }]);
  location = r;
  appendCSS(`.tooltip-container {\n    position: absolute;\n    left: 0px;\n    bottom: 0px;\n    min-width: 50px;\n    min-height: 20px;\n    color: white;\n    padding: 8px;\n    border-radius: 5px;\n    background-color: rgba(63, 72, 84, .9);\n}\n\n.tooltip-container::before {\n    position: absolute;\n    content: "";\n    top: 100%;\n    left: calc(50% - 5px);\n    border: 6px solid transparent;\n    border-top: 10px solid rgba(63, 72, 84, .9);\n}`, {});
  expect(x, [{
    "key" : "initEvent",
    "value" : function() {
      var o = this;
      this.handler = (new Cesium["ScreenSpaceEventHandler"](this.viewer.scene.canvas)).setInputAction(function(currentItems) {
        var parseInt = hahaha;
        var lower;
        var room = o.viewer[parseInt(2758)][parseInt(1708)](currentItems[parseInt(2840)]);
        if (room && room.id) {
          if (!!room.id[parseInt(846)]) {
            if (lower = (lower = o[parseInt(2276)][parseInt(2758)].pickPosition(currentItems[parseInt(2840)])) || o[parseInt(2276)][parseInt(2758)][parseInt(1306)][parseInt(1080)](currentItems[parseInt(2840)], o[parseInt(2276)][parseInt(2758)][parseInt(2359)][parseInt(1923)])) {
              o[parseInt(2752)](room.id[parseInt(846)], lower);
            }
          }
        } else {
          o.hide();
        }
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
    }
  }, {
    "key" : `initDom`,
    "value" : function() {
      this.$htmlContainer = document.createElement("div");
      this.$htmlContainer.classList.add("tooltip-container");
      this.viewer.cesiumWidget.container.appendChild(this.$htmlContainer);
    }
  }, {
    "key" : `show`,
    "value" : function(name, value) {
      if (!this.$htmlContainer) {
        this.initDom();
      }
      this.$htmlContainer.style.display = "block";
      this.$htmlContainer.innerHTML = name;
      this.setPosition(value);
    }
  }, {
    "key" : "setPosition",
    "value" : function(name) {
      var textWidth = this.viewer.scene.canvas.height;
      var handleCanvas = new Cesium["Cartesian2"];
      Cesium.SceneTransforms.wgs84ToWindowCoordinates(this.viewer.scene, name, handleCanvas);
      this.$htmlContainer.style.bottom = textWidth - handleCanvas.y + 20 + "px";
      textWidth = this.$htmlContainer.offsetWidth;
      this.$htmlContainer.style.left = handleCanvas.x - textWidth / 2 + "px";
    }
  }, {
    "key" : `hide`,
    "value" : function() {
      if (this.$htmlContainer) {
        this.$htmlContainer.style.display = "none";
      }
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.handler.destroy();
      this.$htmlContainer.remove();
    }
  }]);
  frame = x;
  expect(lock, [{
    "key" : `activate`,
    "value" : function() {
      this.cancelSync();
      this.isSync = true;
      this.startSync();
    }
  }, {
    "key" : `deactivate`,
    "value" : function() {
      this.isSync = false;
      this.cancelSync();
    }
  }, {
    "key" : `startSync`,
    "value" : function() {
      this.viewer1.scene.postRender.addEventListener(this.syncVEventHandle, this);
      var me = this;
      this.viewer1.container.onmouseenter = function(handler) {
        me.focusIndex = 0;
      };
      me.viewer2.container.onmouseenter = function(handler) {
        me.focusIndex = 1;
      };
    }
  }, {
    "key" : `cancelSync`,
    "value" : function() {
      this.viewer1.container.onmouseenter = void 0;
      this.viewer2.container.onmouseenter = void 0;
      this.viewer1.scene.postRender.removeEventListener(this.syncVEventHandle, this);
    }
  }, {
    "key" : `syncVEventHandle`,
    "value" : function() {
      if (this.isSync) {
        if (0 == this.focusIndex) {
          this.syncV2ToV1();
        } else {
          this.syncV1ToV2();
        }
      }
    }
  }, {
    "key" : "syncV2ToV1",
    "value" : function() {
      this.viewer2.camera.setView({
        "destination" : this.viewer1.camera.position,
        "orientation" : {
          "direction" : this.viewer1.camera._direction,
          "up" : this.viewer1.camera.up,
          "heading" : this.viewer1.camera.heading,
          "pitch" : this.viewer1.camera.pitch,
          "roll" : this.viewer1.camera.roll
        }
      });
    }
  }, {
    "key" : `syncV1ToV2`,
    "value" : function() {
      this.viewer1.camera.setView({
        "destination" : this.viewer2.camera.position,
        "orientation" : {
          "direction" : this.viewer2.camera._direction,
          "up" : this.viewer2.camera.up,
          "heading" : this.viewer2.camera.heading,
          "pitch" : this.viewer2.camera.pitch,
          "roll" : this.viewer2.camera.roll
        }
      });
    }
  }]);
  init = lock;
  appendCSS(`.loading-mask {\n    background: #0000;\n    position: absolute;\n    left: 0px;\n    top: 0px;\n    width: 100%;\n    height: 100%;\n    z-index: 999;\n    background: rgba(0, 0, 0, 0.8) url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAANoAAACDCAYAAADrnAXkAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyhpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTQyIDc5LjE2MDkyNCwgMjAxNy8wNy8xMy0wMTowNjozOSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6RDY2NUUxNEZCNEY5MTFFOEJFQkZDMzQwMzlFMkRBMjAiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6RDY2NUUxNEVCNEY5MTFFOEJFQkZDMzQwMzlFMkRBMjAiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUgKE1hY2ludG9zaCkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4NUFGNEIxMURFRjcxMUU3OTI5NUMwMURDNzVFOTQzQiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4NUFGNEIxMkRFRjcxMUU3OTI5NUMwMURDNzVFOTQzQiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PgSl3cMAABJnSURBVHja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') center no-repeat;\n}`, 
  {});
  expect(main, [{
    "key" : `remove`,
    "value" : function() {
      if (this.container) {
        this.viewer.cesiumWidget.container.removeChild(this.container);
        this.container = void 0;
      }
    }
  }]);
  data = main;
  xt3d.SceneControl = {
    "Navigation" : descriptor,
    "OverviewMap" : name,
    "PositionInfoStatusBar" : location,
    "SceneTooltip" : frame,
    "ViewerLink" : init,
    "ImageLayerSplit" : ID,
    "LoadingMask" : data
  };
  expect(_p, [{
    "key" : `exportImage`,
    "value" : function() {
      var image = this.viewer.scene.canvas.toDataURL("image/png").replace("image/png", "image/octet-stream");
      var elem = document.createElement("a");
      image = this.dataURLtoBlob(image);
      image = URL.createObjectURL(image);
      elem.download = "scene.png";
      elem.href = image;
      elem.click();
    }
  }, {
    "key" : `dataURLtoBlob`,
    "value" : function(name) {
      var arr = name.split(",");
      name = arr[0].match(/:(.*?);/)[1];
      var byteString = atob(arr[1]);
      var i = byteString.length;
      var view = new Uint8Array(i);
      for (; i--;) {
        view[i] = byteString.charCodeAt(i);
      }
      return new Blob([view], {
        "type" : name
      });
    }
  }, {
    "key" : "exportSmallImage",
    "value" : function() {
      var canvas = this.viewer.scene.canvas;
      var img = new Image;
      img.src = canvas.toDataURL("image/png");
      var premultiplyBlendMode = this;
      img.onload = function() {
        var Number = hahaha;
        var singleData = premultiplyBlendMode[Number(1750)](img).toDataURL(Number(777));
        var node = document[Number(1442)]("a");
        var mevt = new MouseEvent(Number(567));
        node[Number(1791)] = Number(2080);
        node[Number(472)] = singleData;
        node.dispatchEvent(mevt);
      };
    }
  }, {
    "key" : "imageToCanvas",
    "value" : function(target) {
      var halfCanvas = document.createElement("canvas");
      return halfCanvas.width = target.width / 3, halfCanvas.height = target.height / 3, halfCanvas.getContext("2d").drawImage(target, 0, 0, halfCanvas.width, halfCanvas.height), halfCanvas;
    }
  }]);
  forced = _p;
  appendCSS(`.scene3d-mousedownview {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 40px;\n    height: 40px;\n    margin-top: -23px;\n    margin-left: -23px;\n    pointer-events: none;\n    visibility: hidden;\n    opacity: 0;\n    -webkit-transition: visibility 0s .2s, opacity .2s ease-in;\n    -moz-transition: visibility 0s .2s, opacity .2s ease-in;\n    transition: visibility 0s .2s, opacity .2s ease-in;\n}\n\n.scene3d-mousedownview-img {\n    width: 36px;\n    height: 36px;\n    background-image: url(data:image/png;base64,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);\n    background-size: 100% 100%\n}\n\n.scene3d-mousedownview-show {\n    visibility: visible;\n    opacity: 1;\n    -webkit-transition: opacity .2s ease-out;\n    -moz-transition: opacity .2s ease-out;\n    transition: opacity .2s ease-out\n}`, 
  {});
  expect(error, [{
    "key" : `init`,
    "value" : function() {
      this.createDom();
      this.addEvent();
    }
  }, {
    "key" : "createDom",
    "value" : function() {
      var container = document.createElement("div");
      container.classList.add("scene3d-mousedownview");
      var bezierPreviewContainer = document.createElement("div");
      bezierPreviewContainer.classList.add("scene3d-mousedownview-img");
      container.appendChild(bezierPreviewContainer);
      this.$container = container;
      this.viewer.cesiumWidget.container.append(container);
    }
  }, {
    "key" : `addEvent`,
    "value" : function() {
      var mem = this;
      this.viewer.scene.postRender.addEventListener(this.postRenderEvent, this);
      var handler = new Cesium["ScreenSpaceEventHandler"](this.viewer.scene.canvas);
      handler.setInputAction(function(end_position) {
        var $ = hahaha;
        if (1 != mem[$(391)]) {
          end_position = end_position[$(2840)];
          mem[$(1878)][$(1998)][$(3190)] = end_position.y + "px";
          mem[$(1878)][$(1998)][$(1838)] = end_position.x + "px";
          mem.$container[$(2209)][$(508)]("scene3d-mousedownview-show");
        }
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
      handler.setInputAction(function(canCreateDiscussions, isSlidingUp) {
        var $ = hahaha;
        mem[$(1878)][$(2209)][$(3010)]($(2835));
      }, Cesium.ScreenSpaceEventType.WHEEL);
      handler.setInputAction(function(position) {
        var $ = hahaha;
        mem[$(1878)][$(2209)].add($(2835));
        mem[$(391)] = true;
        position = position.position;
        mem[$(1878)][$(1998)][$(3190)] = position.y + "px";
        mem[$(1878)][$(1998)][$(1838)] = position.x + "px";
      }, Cesium.ScreenSpaceEventType.MIDDLE_DOWN);
      handler.setInputAction(function(canCreateDiscussions) {
        var $ = hahaha;
        mem[$(1878)][$(2209)].remove($(2835));
        mem[$(391)] = false;
      }, Cesium.ScreenSpaceEventType.MIDDLE_UP);
      this.viewer.camera.moveEnd.addEventListener(this.cameraMoveEndHanle, this);
      this.handler = handler;
    }
  }, {
    "key" : "cameraMoveEndHanle",
    "value" : function() {
      this.$container.classList.remove("scene3d-mousedownview-show");
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.viewer.camera.moveEnd.addEventListener(this.cameraMoveEndHanle);
      this.$container.remove();
      this.handler.destroy();
    }
  }]);
  mode = error;
  expect(HorizontalArranger, [{
    "key" : `setAlpha`,
    "value" : function(name) {
      this.viewer.scene.globe.translucency.frontFaceAlpha = name;
    }
  }, {
    "key" : `activate`,
    "value" : function() {
      this.viewer.scene.screenSpaceCameraController.enableCollisionDetection = false;
      this.viewer.scene.globe.translucency.enabled = true;
      this.viewer.scene.globe.translucency.frontFaceAlpha = 0.8;
    }
  }, {
    "key" : `deactivate`,
    "value" : function() {
      this.viewer.scene.screenSpaceCameraController.enableCollisionDetection = true;
      this.viewer.scene.globe.translucency.enabled = false;
    }
  }]);
  exports = HorizontalArranger;
  expect(display, [{
    "key" : `init`,
    "value" : function() {
      this.viewer.scene.skyBox.show = false;
      this.viewer.scene.backgroundColor = new Cesium.Color(0, 0, 0, 0);
      this.viewer.container.style.cssText = "background: url(" + this.bgUrl + ");  background-size: cover;";
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.viewer.scene.skyBox.show = true;
      this.viewer.scene.backgroundColor = new Cesium["Color"](0, 0, 0, 0);
      this.viewer.container.style.cssText = "";
    }
  }]);
  output = display;
  expect(prop, [{
    "key" : "addSnowEffect",
    "value" : function() {
      this.removeEffect();
      this.wfStage = new Cesium.PostProcessStage({
        "fragmentShader" : this.getSnow_fs()
      });
      this.viewer.scene.postProcessStages.add(this.wfStage);
    }
  }, {
    "key" : "addRainEffect",
    "value" : function() {
      this.removeEffect();
      this.wfStage = new Cesium["PostProcessStage"]({
        "fragmentShader" : this.getRain_fs()
      });
      this.viewer.scene.postProcessStages.add(this.wfStage);
    }
  }, {
    "key" : "addFogEffect",
    "value" : function() {
      this.removeEffect();
      this.wfStage = new Cesium["PostProcessStage"]({
        "fragmentShader" : this.getFog_fs()
      });
      this.viewer.scene.postProcessStages.add(this.wfStage);
    }
  }, {
    "key" : `removeEffect`,
    "value" : function() {
      if (this.wfStage) {
        this.viewer.scene.postProcessStages.remove(this.wfStage);
        this.wfStage = void 0;
      }
    }
  }, {
    "key" : `getSnow_fs`,
    "value" : function() {
      return "uniform sampler2D colorTexture;\nvarying vec2 v_textureCoordinates;\nfloat snow(vec2 uv,float scale)\n{\n    float time = czm_frameNumber / 60.0;\n    float w=smoothstep(1.,0.,-uv.y*(scale/10.));if(w<.1)return 0.;\n    uv+=time/scale;uv.y+=time*2./scale;uv.x+=sin(uv.y+time*.5)/scale;\n    uv*=scale;vec2 s=floor(uv),f=fract(uv),p;float k=3.,d;\n    p=.5+.35*sin(11.*fract(sin((s+p+scale)*mat2(7,3,6,5))*5.))-f;d=length(p);k=min(d,k);\n    k=smoothstep(0.,k,sin(f.x+f.y)*0.01);\n    return k*w;\n}\nvoid main(void){\n     vec2 resolution = czm_viewport.zw;\n     vec2 uv=(gl_FragCoord.xy*2.-resolution.xy)/min(resolution.x,resolution.y);\n     vec3 finalColor=vec3(0);\n     float c = 0.0;\n     c+=snow(uv,30.)*.0;\n     c+=snow(uv,20.)*.0;\n     c+=snow(uv,15.)*.0;\n     c+=snow(uv,10.);\n     c+=snow(uv,8.);\n     c+=snow(uv,6.);\n     c+=snow(uv,5.);\n     finalColor=(vec3(c));\n     gl_FragColor = mix(texture2D(colorTexture, v_textureCoordinates), vec4(finalColor,1), 0.5);\n}";
    }
  }, {
    "key" : `getRain_fs`,
    "value" : function() {
      return "uniform sampler2D colorTexture;\nvarying vec2 v_textureCoordinates;\n\tfloat hash(float x){\n\t     return fract(sin(x*133.3)*13.13);\n\t }\n\tvoid main(void){\n\t     float time = czm_frameNumber / 600.0;\n\t     vec2 resolution = czm_viewport.zw; \n\t     vec2 uv=(gl_FragCoord.xy*2.-resolution.xy)/min(resolution.x,resolution.y);\n\t     vec3 c=vec3(.6,.7,.8); \n\t     float a=-.4;\n\t     float si=sin(a),co=cos(a);\n\t     uv*=mat2(co,-si,si,co);\n\t     uv*=length(uv+vec2(0,4.9))*.3+1.;\n\t     float v=1.-sin(hash(floor(uv.x*100.))*2.);\n\t     float b=clamp(abs(sin(20.*time*v+uv.y*(5./(2.+v))))-.95,0.,1.)*20.;\n\t     c*=v*b; \n\t     gl_FragColor = mix(texture2D(colorTexture, v_textureCoordinates), vec4(c,1), 0.5); \n\t}";
    }
  }, {
    "key" : `getFog_fs`,
    "value" : function() {
      return "uniform sampler2D colorTexture;\n  uniform sampler2D depthTexture;\n  varying vec2 v_textureCoordinates;\n  void main(void)\n  {\n      vec4 origcolor=texture2D(colorTexture, v_textureCoordinates);\n      vec4 fogcolor=vec4(0.8,0.8,0.8,0.5);\n      float depth = czm_readDepth(depthTexture, v_textureCoordinates);\n      vec4 depthcolor=texture2D(depthTexture, v_textureCoordinates);\n      float f=(depthcolor.r-0.7)/0.2;\n      if(f<0.0) f=0.0;\n      else if(f>1.0) f=1.0;\n      gl_FragColor = mix(origcolor,fogcolor,f);\n   }";
    }
  }]);
  definition = prop;
  !function() {
    function SkyBox(images) {
      var parseInt = hahaha;
      this[parseInt(2377)] = images[parseInt(2377)];
      this[parseInt(2065)] = void 0;
      this[parseInt(2752)] = defaultValue(images[parseInt(2752)], true);
      this[parseInt(2909)] = new DrawCommand({
        "modelMatrix" : variable[parseInt(788)](variable[parseInt(1618)]),
        "owner" : this
      });
      this[parseInt(2605)] = void 0;
      this[parseInt(1817)] = void 0;
      this[parseInt(2216)] = void 0;
    }
    var options = window.Cesium;
    var BoxGeometry = options.BoxGeometry;
    var Cartesian3 = options.Cartesian3;
    var defaultValue = options.defaultValue;
    var defined = options.defined;
    var stopTransmitter = options.destroyObject;
    var Sakura = options.DeveloperError;
    var masterStore = options.GeometryPipeline;
    var VDocumentFragment = options.Matrix3;
    var variable = options.Matrix4;
    var json = options.Transforms;
    var obj = options.VertexFormat;
    var payload = options.BufferUsage;
    var CubeMap = options.CubeMap;
    var DrawCommand = options.DrawCommand;
    var readOnlyFn = options.loadCubeMap;
    var lbit_id = options.RenderState;
    var VertexArray = options.VertexArray;
    var original = options.BlendingState;
    var li = options.SceneMode;
    var data = options.ShaderProgram;
    var ShaderSource = options.ShaderSource;
    if (!options.defined(options.Matrix4.getRotation)) {
      options.Matrix4.getRotation = options.Matrix4.getMatrix3;
    }
    var vdomDocFragment = new VDocumentFragment;
    SkyBox.prototype.update = function(target, position) {
      var pluralize = hahaha;
      var that = this;
      if (this[pluralize(2752)] && (target.mode === li[pluralize(602)] || target[pluralize(2598)] === li.MORPHING) && target.passes[pluralize(3081)]) {
        var handler = target[pluralize(2470)];
        if (this[pluralize(2065)] !== this.sources) {
          this[pluralize(2065)] = this.sources;
          var urls = this[pluralize(2377)];
          if (!(defined(urls[pluralize(3133)]) && defined(urls[pluralize(2269)]) && defined(urls[pluralize(550)]) && defined(urls.negativeY) && defined(urls[pluralize(2799)]) && defined(urls.negativeZ))) {
            throw new Sakura(pluralize(3152));
          }
          if (loadImage(urls[pluralize(3133)]) !== loadImage(urls[pluralize(2269)]) || loadImage(urls[pluralize(3133)]) !== loadImage(urls[pluralize(550)]) || loadImage(urls[pluralize(3133)]) !== loadImage(urls[pluralize(2528)]) || loadImage(urls[pluralize(3133)]) !== loadImage(urls[pluralize(2799)]) || loadImage(urls.positiveX) !== loadImage(urls.negativeZ)) {
            throw new Sakura("this.sources properties must all be the same type.");
          }
          if (pluralize(2583) == typeof urls[pluralize(3133)]) {
            readOnlyFn(handler, this[pluralize(2065)])[pluralize(862)](function(activityType) {
              var countNewLineCharacters = pluralize;
              that[countNewLineCharacters(2605)] = that[countNewLineCharacters(2605)] && that._cubeMap.destroy();
              that[countNewLineCharacters(2605)] = activityType;
            });
          } else {
            this[pluralize(2605)] = this._cubeMap && this[pluralize(2605)].destroy();
            this._cubeMap = new CubeMap({
              "context" : handler,
              "source" : urls
            });
          }
        }
        var fs;
        var command = this[pluralize(2909)];
        if (command.modelMatrix = json[pluralize(968)](target[pluralize(1306)][pluralize(1743)]), defined(command[pluralize(2461)]) || (command[pluralize(774)] = {
          "u_cubeMap" : function() {
            var gotoNewOfflinePage = pluralize;
            return that[gotoNewOfflinePage(2605)];
          },
          "u_rotateMatrix" : function() {
            var parseInt = pluralize;
            return variable[parseInt(1311)](command.modelMatrix, vdomDocFragment);
          }
        }, target = BoxGeometry[pluralize(857)](BoxGeometry.fromDimensions({
          "dimensions" : new Cartesian3(2, 2, 2),
          "vertexFormat" : obj[pluralize(576)]
        })), fs = this._attributeLocations = masterStore[pluralize(494)](target), command.vertexArray = VertexArray.fromGeometry({
          "context" : handler,
          "geometry" : target,
          "attributeLocations" : fs,
          "bufferUsage" : payload[pluralize(1450)]
        }), command.renderState = lbit_id[pluralize(2520)]({
          "blending" : original[pluralize(3052)]
        })), defined(command[pluralize(1501)]) && this[pluralize(2216)] === position || (fs = new ShaderSource({
          "defines" : [position ? pluralize(1193) : ""],
          "sources" : [pluralize(2898)]
        }), command[pluralize(1501)] = data[pluralize(2520)]({
          "context" : handler,
          "vertexShaderSource" : `attribute vec3 position;\n    varying vec3 v_texCoord;\n    uniform mat3 u_rotateMatrix;\n    void main()\n    {\n    vec3 p = czm_viewRotation * u_rotateMatrix * (czm_temeToPseudoFixed * (czm_entireFrustum.y * position));\n    gl_Position = czm_projection * vec4(p, 1.0);\n    v_texCoord = position.xyz;\n    }\n    `,
          "fragmentShaderSource" : fs,
          "attributeLocations" : this[pluralize(1817)]
        }), this[pluralize(2216)] = position), defined(this[pluralize(2605)])) {
          return command;
        }
      }
    };
    SkyBox.prototype.isDestroyed = function() {
      return false;
    };
    SkyBox.prototype.destroy = function() {
      var parseInt = hahaha;
      var map = this[parseInt(2909)];
      return map[parseInt(2461)] = map.vertexArray && map[parseInt(2461)].destroy(), map[parseInt(1501)] = map.shaderProgram && map[parseInt(1501)][parseInt(1701)](), this[parseInt(2605)] = this._cubeMap && this[parseInt(2605)].destroy(), stopTransmitter(this);
    };
    window.Cesium.GroundSkyBox = SkyBox;
  }();
  Object.defineProperties(SpirographPositionProperty.prototype, {
    "isConstant" : {
      "get" : function() {
        return false;
      }
    },
    "definitionChanged" : {
      "get" : function() {
        return this._definitionChanged;
      }
    },
    "color" : Cesium.createPropertyDescriptor(`color`)
  });
  SpirographPositionProperty.prototype.getType = function(original_full_html) {
    return "Cloud";
  };
  SpirographPositionProperty.prototype.getValue = function(time, result) {
    return Cesium.defined(result) || (result = {}), result.color = Cesium.Property.getValueOrClonedDefault(this.color, time, Cesium.Color.WHITE, result.color), result.image = this.url, result.time = ((new Date).getTime() - this._time) % this.duration / this.duration, result;
  };
  SpirographPositionProperty.prototype.equals = function(other) {
    return this === other || other instanceof SpirographPositionProperty && Cesium.Property.equals(this.color, other.color);
  };
  Cesium.CloudMaterialProperty = SpirographPositionProperty;
  Cesium.Material.CloudType = "Cloud";
  Cesium.Material.CloudSource = `czm_material czm_getMaterial(czm_materialInput materialInput)\n{\n     czm_material material = czm_getDefaultMaterial(materialInput);\n     vec2 st = materialInput.st;\n     vec4 colorImage = texture2D(image,   vec2(fract(st.s + time),fract(st.t)));\n     material.alpha = colorImage.a * color.a  ;\n     material.diffuse =  1.3 * color.rgb  ;\n     return material;\n }`;
  Cesium.Material._materialCache.addMaterial(Cesium.Material.CloudType, {
    "fabric" : {
      "type" : Cesium.Material.CloudType,
      "uniforms" : {
        "color" : new Cesium[`Color`](1, 0, 0, 0.5),
        "image" : "",
        "time" : 0
      },
      "source" : Cesium.Material.CloudSource
    },
    "translucent" : function(material) {
      return true;
    }
  });
  expect(option, [{
    "key" : "addCloudEntity",
    "value" : function() {
      this.cloudEntity = this.viewer.entities.add({
        "rectangle" : {
          "coordinates" : Cesium.Rectangle.fromDegrees(-180, -90, 180, 90),
          "material" : new Cesium["CloudMaterialProperty"]({
            "color" : Cesium.Color.WHITE.withAlpha(0.8),
            "duration" : this.options.duration || 1E5,
            "imgUrl" : this.options.imgUrl
          }),
          "height" : this.options.height || 8E3,
          "distanceDisplayCondition" : new Cesium["DistanceDisplayCondition"](3E6, 1E8)
        }
      });
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.viewer.entities.remove(this.cloudEntity);
    }
  }]);
  obj = option;
  expect(defaults, [{
    "key" : `initEvent`,
    "value" : function() {
      var nums = this;
      this.map.getView().on("change:center", function(canCreateDiscussions) {
        var parseInt = hahaha;
        if (parseInt(1331) == nums[parseInt(1288)]) {
          nums[parseInt(2242)]();
        }
      });
      this.viewer.scene.postRender.addEventListener(function(canCreateDiscussions) {
        var put_rows = hahaha;
        if (put_rows(2276) == nums.activateContainer) {
          nums[put_rows(2916)]();
        }
      });
    }
  }, {
    "key" : "activate",
    "value" : function() {
      var rpm_traffic = this;
      this.viewer.container.onmouseenter = function(handler) {
        var now = hahaha;
        rpm_traffic[now(1288)] = now(2276);
      };
      this.map.getViewport().onmouseenter = function(handler) {
        var now = hahaha;
        rpm_traffic[now(1288)] = now(1331);
      };
    }
  }, {
    "key" : `deactivate`,
    "value" : function() {
      this.viewer.container.onmouseenter = void 0;
      this.map.getViewport().onmouseenter = void 0;
      this.activateContainer = void 0;
    }
  }, {
    "key" : `map2scene`,
    "value" : function() {
      var rectangle = this.viewer.camera.computeViewRectangle();
      if (!rectangle) {
        return console.log("rec is undefined"), void this.setMapCenterByCameraPosition();
      }
      rectangle = [Cesium.Math.toDegrees(rectangle.west), Cesium.Math.toDegrees(rectangle.south), Cesium.Math.toDegrees(rectangle.east), Cesium.Math.toDegrees(rectangle.north)];
      if (ol.extent.isEmpty(rectangle)) {
        return console.log("extent is empty"), void this.setMapCenterByCameraPosition();
      }
      this.map.getView().fit(rectangle);
    }
  }, {
    "key" : "scene2map",
    "value" : function() {
      var parts = this.map.getView().calculateExtent(this.map.getSize());
      this.viewer.camera.setView({
        "destination" : Cesium.Rectangle.fromDegrees(parts[0], parts[1], parts[2], parts[3])
      });
    }
  }, {
    "key" : `setMapCenterByCameraPosition`,
    "value" : function() {
      var x = this.viewer.camera.position;
      var lon = Cesium.Cartographic.fromCartesian(x);
      x = Cesium.Math.toDegrees(lon.longitude);
      lon = Cesium.Math.toDegrees(lon.latitude);
      this.map.getView().setCenter([x, lon]);
    }
  }]);
  descriptor = defaults;
  appendCSS(`.div-mask {\n    background: #0000;\n    position: absolute;\n    left: 0px;\n    top: 0px;\n    width: 100%;\n    height: 100%;\n    box-shadow: inset 1px 0px 500px 170px #000000;\n    pointer-events: none;\n    z-index: 999;\n}`, {});
  var date;
  var time;
  var pluginProvider;
  var cityCollection;
  name = (expect(setPosition, [{
    "key" : "remove",
    "value" : function() {
      this.viewer.cesiumWidget.container.removeChild(this.container);
    }
  }]), setPosition);
  var none = `\nvec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\n\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\n\nconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\nconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\n\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\n\nconst float ShiftRight8 = 1. / 256.;\n\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\n\treturn r * PackUpscale;\n}\n\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\n\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\n\n// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\n\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\n\n// NOTE: https://twitter.com/gonnavis/status/1377183786949959682\n\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n`;
  var packages = `uniform sampler2D czm_selectedIdTexture; \nuniform float czm_selectedIdTextureStep; \nuniform float czm_selectedIdTextureWidth; \nbool czm_selected(vec4 id) \n{ \n    bool selected = false;\n    for (int i = 0; i < 1024000; i++) \n    { \n        vec4 selectedId = texture2D(czm_selectedIdTexture, vec2((float(i) + 0.5) * czm_selectedIdTextureStep, 0.5)); \n        if (all(equal(id, selectedId))) \n        { \n            return true; \n        } \n       if(float(i)>czm_selectedIdTextureWidth)break;\n    } \n    return false; \n} \n\n`;
  var basic_frag = `\nvarying vec2 v_textureCoordinates;\nuniform sampler2D colorTexture;\nuniform vec2 colorTextureDimensions;\nuniform vec2 direction;\nuniform float kernelRadius;\n\nfloat gaussianPdf(in float x, in float sigma) {\n    return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n}\nvoid main() {    vec2 vUv=v_textureCoordinates;\n    vec2 invSize = 1.0 / colorTextureDimensions;    float weightSum = gaussianPdf(0.0, kernelRadius);    vec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;    vec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);    vec2 uvOffset = delta;    for( int i = 1; i <= MAX_RADIUS; i ++ ) {        float w = gaussianPdf(uvOffset.x, kernelRadius);        vec4 sample1 = texture2D( colorTexture, vUv + uvOffset);        vec4 sample2 = texture2D( colorTexture, vUv - uvOffset);        diffuseSum += ((sample1 + sample2) * w);        weightSum += (2.0 * w);        uvOffset += delta;    }    gl_FragColor = diffuseSum/weightSum;}`;
  expect(link, [{
    "key" : "init",
    "value" : function() {
      var colData = this;
      this.stages = [];
      var list = function(id) {
        function callback(obj) {
          var i = parseInt;
          Object[i(780)](obj, {
            "showGlow" : {
              "get" : function() {
                return attrObjValue;
              },
              "set" : function(name) {
                attrObjValue = name;
              }
            },
            "edgeGlow" : {
              "get" : function() {
                return lastSetVal;
              },
              "set" : function(name) {
                lastSetVal = name;
              }
            },
            "edgeStrength" : {
              "get" : function() {
                return _f0;
              },
              "set" : function(name) {
                _f0 = name;
              }
            },
            "thresholdAngle" : {
              "get" : function() {
                return PWall;
              },
              "set" : function(name) {
                PWall = name;
              }
            },
            "showOutlineOnly" : {
              "get" : function() {
                return bottomAlign;
              },
              "set" : function(value) {
                bottomAlign = value;
              }
            },
            "edgeOnly" : {
              "get" : function() {
                return suffixedName;
              },
              "set" : function(name) {
                suffixedName = name;
              }
            },
            "useSingleColor" : {
              "get" : function() {
                return decryptedValue;
              },
              "set" : function(name) {
                decryptedValue = name;
              }
            },
            "outlineWidth" : {
              "get" : function() {
                return expectedDataTransfer;
              },
              "set" : function(name) {
                expectedDataTransfer = name;
              }
            },
            "visibleEdgeColor" : {
              "get" : function() {
                return expectedDropEffect;
              },
              "set" : function(name) {
                expectedDropEffect = name;
              }
            },
            "hiddenEdgeColor" : {
              "get" : function() {
                return complete_id;
              },
              "set" : function(name) {
                complete_id = name;
              }
            }
          });
        }
        var parseInt = hahaha;
        id = id || parseInt(2105);
        var Shader = (data = Cesium)[parseInt(2223)];
        var Model = data[parseInt(2108)];
        var Sampler = (data[parseInt(1973)], data[parseInt(2694)]);
        var result = data.TextureMagnificationFilter;
        var data = data[parseInt(2897)];
        var expectedDataTransfer = 2;
        var PWall = 12 * Math.PI / 180;
        var decryptedValue = false;
        var bottomAlign = false;
        var expectedDropEffect = Cesium[parseInt(2292)][parseInt(2515)][parseInt(788)]();
        var complete_id = Cesium[parseInt(2292)].DARKRED.clone();
        var attrObjValue = false;
        var lastSetVal = 1;
        var _f0 = 3;
        var suffixedName = false;
        var options = new create({
          "name" : id + "Pass",
          "vertexShader" : parseInt(868),
          "fragmentShader" : `\n        varying vec3 vOutlineNormal;\n        void main(){\n            if(!czm_selected())discard; \n            if(length(vOutlineNormal)>0.)gl_FragColor=vec4( vOutlineNormal ,gl_FragColor.a); \n        }\n        `,
          "sampler" : new Sampler({
            "minificationFilter" : data[parseInt(2427)],
            "magnificationFilter" : result[parseInt(2427)]
          })
        });
        Sampler = new Shader({
          "name" : id + parseInt(2201),
          "uniforms" : {
            "outlineWidth" : function() {
              return expectedDataTransfer;
            },
            "devicePixelRatio" : devicePixelRatio,
            "thresholdAngle" : function() {
              return PWall;
            },
            "useSingleColor" : function() {
              return decryptedValue;
            },
            "showOutlineOnly" : function() {
              return bottomAlign;
            },
            "visibleEdgeColor" : function() {
              return expectedDropEffect;
            },
            "hiddenEdgeColor" : function() {
              return complete_id;
            },
            "maskTexture" : function() {
              var toInt = parseInt;
              return options[toInt(763)];
            },
            "maskDepthTexture" : function() {
              return options.depthTexture;
            }
          },
          "fragmentShader" : parseInt(760)
        });
        return options[parseInt(2851)] = Sampler, data = out(id + parseInt(2411), 4, 1, 0.75), result = new Model({
          "name" : id + parseInt(1498),
          "stages" : [Sampler, data, out(id + parseInt(2173), 4, 4, 0.5)],
          "inputPreviousStageTexture" : true
        }), callback(result = new Model({
          "name" : id + parseInt(1044),
          "stages" : [result, new Shader({
            "name" : id + parseInt(2436),
            "uniforms" : {
              "showGlow" : function() {
                return attrObjValue;
              },
              "edgeGlow" : function() {
                return lastSetVal;
              },
              "edgeStrength" : function() {
                return _f0;
              },
              "edgeOnly" : function() {
                return suffixedName;
              },
              "maskTexture" : function() {
                return options.texture;
              },
              "lineTexture" : Sampler[parseInt(2696)],
              "edgeTexture1" : data.name,
              "edgeTexture2" : result[parseInt(2696)]
            },
            "fragmentShader" : parseInt(2369)
          })],
          "inputPreviousStageTexture" : false
        })), result[parseInt(2135)] = result._uniforms || {}, callback(result[parseInt(2135)]), result;
      }();
      list.visibleEdgeColor = Cesium.Color.fromCssColorString("#FFFF00");
      list.hiddenEdgeColor = Cesium.Color.fromCssColorString("#FFFF00");
      list.selected = [];
      list.enabled = false;
      this.viewer.postProcessStages.add(list);
      this.stages.push(list);
      var s = Cesium.PostProcessStageLibrary.createSilhouetteStage();
      s.enabled = false;
      this.viewer.postProcessStages.add(s);
      this.stages.push(s);
      this.handler = new Cesium["ScreenSpaceEventHandler"](this.viewer.scene.canvas);
      this.handler.setInputAction(function(item) {
        var parseInt = hahaha;
        var id = item[parseInt(586)];
        var obj = colData[parseInt(2276)][parseInt(2758)][parseInt(1708)](id);
        list[parseInt(872)] = [];
        list.enabled = false;
        if (obj && obj[parseInt(1023)]) {
          item = obj[parseInt(1023)][parseInt(400)];
          if (!((id = obj[parseInt(1375)]) || item || !obj.content)) {
            item = obj.content[parseInt(2546)][parseInt(400)];
          }
          if (!id) {
            if (obj.id) {
              id = item[parseInt(2110)](function(n) {
                return n.object == obj;
              });
            } else {
              if (item) {
                id = item[0];
              }
            }
          }
          if (id) {
            id = {
              "pickId" : id
            };
            list[parseInt(872)] = [id];
            s.selected = [id];
            list[parseInt(2622)] = !s.enabled;
          } else {
            console[parseInt(1012)](parseInt(2773));
          }
        }
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
    }
  }, {
    "key" : "remove",
    "value" : function() {
      var same = this;
      if (this.handler) {
        this.handler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_CLICK);
        this.handler.destroy();
        this.handler = void 0;
        this.stages.forEach(function(mmCoreSplitViewBlock) {
          var rel2Mstr = hahaha;
          same[rel2Mstr(2276)][rel2Mstr(3141)][rel2Mstr(508)](mmCoreSplitViewBlock);
        });
        this.stages = [];
      }
    }
  }]);
  location = link;
  expect(group, [{
    "key" : `remove`,
    "value" : function() {
      this.viewer.scene.postProcessStages.remove(this.stage);
    }
  }, {
    "key" : "enabled",
    "set" : function(name) {
      this.stage.enabled = name;
    },
    "get" : function() {
      return this.stage.enabled;
    }
  }]);
  frame = group;
  expect(dragEnter, [{
    "key" : `remove`,
    "value" : function() {
      this.viewer.scene.postProcessStages.remove(this.stage);
    }
  }, {
    "key" : `enabled`,
    "set" : function(name) {
      this.stage.enabled = name;
    },
    "get" : function() {
      return this.stage.enabled;
    }
  }]);
  init = dragEnter;
  expect(PlaneWizard, [{
    "key" : `remove`,
    "value" : function() {
      this.viewer.scene.postProcessStages.remove(this.stage);
    }
  }, {
    "key" : "enabled",
    "set" : function(name) {
      this.stage.enabled = name;
    },
    "get" : function() {
      return this.stage.enabled;
    }
  }]);
  ID = PlaneWizard;
  expect(loop, [{
    "key" : "updateStyle",
    "value" : function(obj) {
      this.stage.uniforms.focalDistance = obj.focalDistance;
      this.stage.uniforms.delta = obj.delta;
      this.stage.uniforms.sigma = obj.sigma;
      this.stage.uniforms.stepSize = obj.stepSize;
    }
  }, {
    "key" : "getStyle",
    "value" : function() {
      return {
        "focalDistance" : this.stage.uniforms.focalDistance,
        "delta" : this.stage.uniforms.delta,
        "sigma" : this.stage.uniforms.sigma,
        "stepSize" : this.stage.uniforms.stepSize
      };
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.viewer.scene.postProcessStages.remove(this.stage);
    }
  }, {
    "key" : "enabled",
    "set" : function(name) {
      this.stage.enabled = name;
    },
    "get" : function() {
      return this.stage.enabled;
    }
  }]);
  data = loop;
  xt3d.SceneDominate = {
    "ExportFile" : forced,
    "MouseDownView" : mode,
    "UnderGround" : exports,
    "CustomBgImage" : output,
    "WeatherEffect" : definition,
    "DynamicCloud" : obj,
    "MapLink23d" : descriptor,
    "DivMask" : name,
    "GroundSkyBox" : window.Cesium.GroundSkyBox,
    "OutlineEffect" : location,
    "NightVisionEffect" : frame,
    "BlackAndWhiteEffect" : init,
    "MosaicEffect" : ID,
    "DepthOfFieldEffect" : data
  };
  expect(to, [{
    "key" : `addCylinder`,
    "value" : function() {
      var positionOnEllipsoid = Cesium.Cartesian3.fromDegrees(this.lng, this.lat);
      var geometries = Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(positionOnEllipsoid), new Cesium.Cartesian3(0, 0, 0.5 * this.height), new Cesium["Matrix4"]);
      positionOnEllipsoid = new Cesium["CylinderGeometry"]({
        "length" : this.height,
        "topRadius" : 0,
        "bottomRadius" : this.bottomRadius,
        "vertexFormat" : Cesium.MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat
      });
      geometries = new Cesium["GeometryInstance"]({
        "geometry" : positionOnEllipsoid,
        "modelMatrix" : geometries
      });
      this.addGeometry(geometries);
    }
  }, {
    "key" : `addGeometry`,
    "value" : function(name) {
      if (1 == this.materialType) {
        this.radar = this.viewer.scene.primitives.add(new Cesium["Primitive"]({
          "geometryInstances" : [name],
          "appearance" : new Cesium["MaterialAppearance"]({
            "material" : new Cesium.Material({
              "fabric" : {
                "type" : "VtxfShader1",
                "uniforms" : {
                  "color" : new Cesium["Color"](0.2, 1, 0, 1),
                  "repeat" : 30,
                  "offset" : 0,
                  "thickness" : 0.3
                },
                "source" : `\n                                uniform vec4 color;\n                                uniform float repeat;\n                                uniform float offset;\n                                uniform float thickness;\n                                czm_material czm_getMaterial(czm_materialInput materialInput)\n                                {\n                                    czm_material material = czm_getDefaultMaterial(materialInput);\n                                    float sp = 1.0/repeat;\n                                    vec2 st = materialInput.st;\n                                    float dis = distance(st, vec2(0.5));\n                                    float m = mod(dis + offset, sp);\n                                    float a = step(sp*(1.0-thickness), m);\n                                    material.diffuse = color.rgb;\n                                    material.alpha = a * color.a;\n                                    return material;\n                                }\n                            `
              },
              "translucent" : false
            }),
            "faceForward" : false,
            "closed" : true
          })
        }));
        this.viewer.scene.preUpdate.addEventListener(this.preUpdateHandle1, this);
      } else {
        this.radar = this.viewer.scene.primitives.add(new Cesium["Primitive"]({
          "geometryInstances" : [name],
          "appearance" : new Cesium.MaterialAppearance({
            "material" : new Cesium["Material"]({
              "fabric" : {
                "type" : "VtxfShader1",
                "uniforms" : {
                  "color" : new Cesium["Color"](0.2, 1, 0, 1),
                  "repeat" : 1,
                  "offset" : 0,
                  "thickness" : 0.8
                },
                "source" : `\n                                uniform vec4 color;\n                                uniform float repeat;\n                                uniform float offset;\n                                uniform float thickness;\n                                czm_material czm_getMaterial(czm_materialInput materialInput)\n                                {\n                                    czm_material material = czm_getDefaultMaterial(materialInput);\n                                    float sp = 1.0/repeat;\n                                    vec2 st = materialInput.st;\n                                    float dis = distance(st, vec2(0.5));\n                                    float m = mod(dis + offset, sp);\n                                    float a = step(sp*(1.0-thickness), m);\n                                    material.diffuse = color.rgb;\n                                    material.alpha = a * color.a * dis * 1.2;\n                                    return material;\n                                }\n                            `
              },
              "translucent" : false
            }),
            "faceForward" : false,
            "closed" : true
          })
        }));
        this.viewer.scene.preUpdate.addEventListener(this.preUpdateHandle2, this);
      }
    }
  }, {
    "key" : `preUpdateHandle1`,
    "value" : function() {
      var prevOffset = this.radar.appearance.material.uniforms.offset;
      if (1 < (prevOffset = prevOffset - 0.001)) {
        prevOffset = 0;
      }
      this.radar.appearance.material.uniforms.offset = prevOffset;
    }
  }, {
    "key" : `preUpdateHandle2`,
    "value" : function() {
      var prevOffset = this.radar.appearance.material.uniforms.offset;
      if (1 < (prevOffset = prevOffset - 0.015)) {
        prevOffset = 0;
      }
      this.radar.appearance.material.uniforms.offset = prevOffset;
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.viewer.scene.preUpdate.removeEventListener(this.preUpdateHandle);
      this.viewer.scene.primitives.remove(this.radar);
    }
  }]);
  exports = to;
  expect(build, [{
    "key" : `addEllipsoid`,
    "value" : function() {
      this.ellipsoid = this.viewer.entities.add({
        "position" : this.position,
        "ellipsoid" : {
          "radii" : this.radii,
          "maximumCone" : Cesium.Math.toRadians(90),
          "material" : this.color,
          "subdivisions" : 128,
          "stackPartitions" : 32,
          "slicePartitions" : 32,
          "outline" : true,
          "outlineColor" : this.color.withAlpha(1)
        }
      });
    }
  }, {
    "key" : "addFanBlad",
    "value" : function() {
      this.addFan1();
      this.addFan2();
      this.addFan3();
    }
  }, {
    "key" : `addFan1`,
    "value" : function() {
      var primaryReplicas = this;
      var heading = 0;
      var locale = new Cesium.HeadingPitchRoll(Cesium.Math.toRadians(heading), 0, 0);
      this.fan1 = this.viewer.entities.add({
        "position" : this.position,
        "orientation" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
          var stringify = hahaha;
          return 1 == primaryReplicas[stringify(899)] ? heading = heading + (primaryReplicas.scanSpeed || 0.8) : heading = heading - (primaryReplicas[stringify(2626)] || 0.8), 360 < heading && (heading = 0), heading < 0 && (heading = 360), locale.heading = Cesium[stringify(2090)][stringify(1544)](heading), Cesium.Transforms[stringify(1806)](primaryReplicas[stringify(586)], locale);
        }, false),
        "ellipsoid" : {
          "radii" : this.radii,
          "innerRadii" : new Cesium.Cartesian3(0.001, 0.001, 0.001),
          "minimumClock" : Cesium.Math.toRadians(-0.001),
          "maximumClock" : Cesium.Math.toRadians(0.001),
          "minimumCone" : Cesium.Math.toRadians(75),
          "maximumCone" : Cesium.Math.toRadians(90),
          "material" : this.fanBladColor,
          "outline" : false
        }
      });
    }
  }, {
    "key" : "addFan2",
    "value" : function() {
      var artic = this;
      var rotation = 120;
      var camera_dir = new Cesium["HeadingPitchRoll"](Cesium.Math.toRadians(rotation), 0, 0);
      this.fan2 = this.viewer.entities.add({
        "position" : this.position,
        "orientation" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
          var put_rows = hahaha;
          return 360 < (rotation = rotation + 0.8) && (rotation = 0), camera_dir[put_rows(1604)] = Cesium[put_rows(2090)][put_rows(1544)](rotation), Cesium[put_rows(942)][put_rows(1806)](artic.position, camera_dir);
        }, false),
        "ellipsoid" : {
          "radii" : this.radii,
          "innerRadii" : new Cesium["Cartesian3"](0.001, 0.001, 0.001),
          "minimumClock" : Cesium.Math.toRadians(-0.001),
          "maximumClock" : Cesium.Math.toRadians(0.001),
          "minimumCone" : Cesium.Math.toRadians(75),
          "maximumCone" : Cesium.Math.toRadians(90),
          "material" : this.fanBladColor,
          "outline" : false
        }
      });
    }
  }, {
    "key" : `addFan3`,
    "value" : function() {
      var primaryReplicas = this;
      var heading = 240;
      var locale = new Cesium["HeadingPitchRoll"](Cesium.Math.toRadians(heading), 0, 0);
      this.fan3 = this.viewer.entities.add({
        "position" : this.position,
        "orientation" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
          var stringify = hahaha;
          return 360 < (heading = heading + 0.8) && (heading = 0), locale.heading = Cesium[stringify(2090)].toRadians(heading), Cesium[stringify(942)][stringify(1806)](primaryReplicas[stringify(586)], locale);
        }, false),
        "ellipsoid" : {
          "radii" : this.radii,
          "innerRadii" : new Cesium.Cartesian3(0.001, 0.001, 0.001),
          "minimumClock" : Cesium.Math.toRadians(-0.001),
          "maximumClock" : Cesium.Math.toRadians(0.001),
          "minimumCone" : Cesium.Math.toRadians(75),
          "maximumCone" : Cesium.Math.toRadians(90),
          "material" : this.fanBladColor,
          "outline" : false
        }
      });
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.viewer.entities.remove(this.ellipsoid);
      this.viewer.entities.remove(this.fan1);
      this.viewer.entities.remove(this.fan2);
      this.viewer.entities.remove(this.fan3);
    }
  }]);
  output = build;
  expect(element, [{
    "key" : "addEllipsoid",
    "value" : function() {
      this.ellipsoid = this.viewer.entities.add({
        "position" : this.position,
        "ellipsoid" : {
          "radii" : this.radii,
          "maximumCone" : Cesium.Math.toRadians(90),
          "material" : this.color,
          "subdivisions" : 128,
          "stackPartitions" : 32,
          "slicePartitions" : 32,
          "outline" : true,
          "outlineColor" : this.color.withAlpha(1)
        }
      });
    }
  }, {
    "key" : `addScan1`,
    "value" : function() {
      var leftBranch = this;
      var i = -90;
      var nodes = new Cesium["HeadingPitchRoll"](Cesium.Math.toRadians(this.heading), 0, 0);
      this.scanEllipsoid = this.viewer.entities.add({
        "position" : this.position,
        "orientation" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
          var findMiddlePosition = hahaha;
          return 1 == leftBranch[findMiddlePosition(899)] ? i = i + (leftBranch[findMiddlePosition(2626)] || 0.6) : i = i - (leftBranch[findMiddlePosition(2626)] || 0.6), 360 < i && (i = 0), i < 0 && (i = 360), nodes[findMiddlePosition(1604)] = Cesium[findMiddlePosition(2090)][findMiddlePosition(1544)](i), Cesium[findMiddlePosition(942)][findMiddlePosition(1806)](leftBranch[findMiddlePosition(586)], nodes);
        }, false),
        "ellipsoid" : {
          "radii" : this.radii,
          "innerRadii" : new Cesium["Cartesian3"](0.001, 0.001, 0.001),
          "minimumClock" : Cesium.Math.toRadians(-0.00001),
          "maximumClock" : Cesium.Math.toRadians(0.00001),
          "minimumCone" : Cesium.Math.toRadians(0),
          "maximumCone" : Cesium.Math.toRadians(90),
          "material" : this.fanBladColor,
          "outline" : false
        }
      });
    }
  }, {
    "key" : "addScan2",
    "value" : function() {
      var primaryReplicas = this;
      var col = -90;
      var maxes = new Cesium["HeadingPitchRoll"](Cesium.Math.toRadians(0), 0, Cesium.Math.toRadians(col));
      this.scanEllipsoid = this.viewer.entities.add({
        "position" : this.position,
        "orientation" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
          var stringify = hahaha;
          return 1 == primaryReplicas[stringify(899)] ? col = col + (primaryReplicas[stringify(2626)] || 0.6) : col = col - (primaryReplicas[stringify(2626)] || 0.6), 90 < col && (col = -90), col < -90 && (col = 90), maxes[stringify(453)] = Cesium.Math[stringify(1544)](col), Cesium[stringify(942)][stringify(1806)](primaryReplicas.position, maxes);
        }, false),
        "ellipsoid" : {
          "radii" : this.radii,
          "innerRadii" : new Cesium["Cartesian3"](0.001, 0.001, 0.001),
          "minimumClock" : Cesium.Math.toRadians(-0.00001),
          "maximumClock" : Cesium.Math.toRadians(0.00001),
          "minimumCone" : Cesium.Math.toRadians(-90),
          "maximumCone" : Cesium.Math.toRadians(90),
          "material" : this.fanBladColor,
          "outline" : false
        }
      });
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.viewer.entities.remove(this.scanEllipsoid);
    }
  }]);
  definition = element;
  expect(type, [{
    "key" : `createFrusum`,
    "value" : function() {
      this.getOrientation();
      this.createPerspectiveFrustum();
      this.addFillFrustum();
      this.addOutlineFrustum();
    }
  }, {
    "key" : "createPerspectiveFrustum",
    "value" : function() {
      this.frustum = new Cesium["PerspectiveFrustum"]({
        "fov" : Cesium.Math.toRadians(this.fov),
        "aspectRatio" : 1,
        "near" : this.near,
        "far" : this.getFar()
      });
    }
  }, {
    "key" : `updateTargetPosition`,
    "value" : function(name) {
      if (name) {
        this.targetPosition = name;
        this.clear();
        this.createFrusum();
      }
    }
  }, {
    "key" : `getFar`,
    "value" : function() {
      var panDistance = Cesium.Cartesian3.distance(this.originPosition, this.targetPosition);
      return 0 < panDistance ? panDistance : 0.03;
    }
  }, {
    "key" : `getOrientation`,
    "value" : function() {
      var event = this.getModelMatrix(this.originPosition, this.targetPosition);
      event = this.getHeadingPitchRoll(event);
      return event.pitch = event.pitch + Math.PI / 2 + Math.PI, this.orientation = Cesium.Transforms.headingPitchRollQuaternion(this.originPosition, event), this.orientation;
    }
  }, {
    "key" : `getModelMatrix`,
    "value" : function(value, target) {
      return target = Cesium.Cartesian3.subtract(target, value, new Cesium["Cartesian3"]), target = Cesium.Cartesian3.normalize(target, new Cesium["Cartesian3"]), target = Cesium.Transforms.rotationMatrixFromPositionVelocity(value, target, Cesium.Ellipsoid.WGS84), Cesium.Matrix4.fromRotationTranslation(target, value);
    }
  }, {
    "key" : `getHeadingPitchRoll`,
    "value" : function(value) {
      var matrix = Cesium.Transforms.eastNorthUpToFixedFrame(Cesium.Matrix4.getTranslation(value, new Cesium["Cartesian3"]), Cesium.Ellipsoid.WGS84, new Cesium["Matrix4"]);
      value = Cesium.Matrix4.multiply(Cesium.Matrix4.inverse(matrix, new Cesium.Matrix4), value, new Cesium["Matrix4"]);
      value = Cesium.Matrix4.getMatrix3(value, new Cesium.Matrix3);
      value = Cesium.Quaternion.fromRotationMatrix(value);
      return Cesium.HeadingPitchRoll.fromQuaternion(value);
    }
  }, {
    "key" : `addFillFrustum`,
    "value" : function() {
      this.fillFrustum = new Cesium["Primitive"]({
        "geometryInstances" : new Cesium["GeometryInstance"]({
          "geometry" : new Cesium["FrustumGeometry"]({
            "origin" : this.originPosition,
            "orientation" : this.orientation,
            "frustum" : this.frustum
          })
        }),
        "appearance" : new Cesium["MaterialAppearance"]({
          "material" : Cesium.Material.fromType("Color")
        }),
        "asynchronous" : false,
        "show" : true
      });
      this.fillFrustum.appearance.material.uniforms.color = this.color;
      this.viewer.scene.primitives.add(this.fillFrustum);
    }
  }, {
    "key" : `addOutlineFrustum`,
    "value" : function() {
      this.outlineFrustum = new Cesium["Primitive"]({
        "geometryInstances" : new Cesium.GeometryInstance({
          "geometry" : new Cesium["FrustumOutlineGeometry"]({
            "origin" : this.originPosition,
            "orientation" : this.orientation,
            "frustum" : this.frustum,
            "_drawNearPlane" : true
          }),
          "attributes" : {
            "color" : Cesium.ColorGeometryInstanceAttribute.fromColor(this.outlineColor)
          }
        }),
        "appearance" : new Cesium["PerInstanceColorAppearance"]({
          "translucent" : true,
          "flat" : true
        }),
        "asynchronous" : false,
        "show" : true
      });
      this.viewer.scene.primitives.add(this.outlineFrustum);
    }
  }, {
    "key" : "clear",
    "value" : function() {
      this.viewer.scene.primitives.remove(this.fillFrustum);
      this.viewer.scene.primitives.remove(this.outlineFrustum);
    }
  }, {
    "key" : "remove",
    "value" : function() {
      this.clear();
    }
  }]);
  obj = type;
  expect(traverse, [{
    "key" : "updateTargetPosition",
    "value" : function(name) {
      this.targetPosition = name;
    }
  }, {
    "key" : "addCone",
    "value" : function() {
      var op = this;
      this.cone = this.viewer.entities.add({
        "orientation" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
          var put_rows = hahaha;
          var event = op[put_rows(1089)](op[put_rows(2695)], op[put_rows(2431)]);
          event = op[put_rows(2647)](event);
          return event.pitch = event[put_rows(2420)] + Math.PI / 2 + Math.PI, Cesium[put_rows(942)][put_rows(1806)](op[put_rows(2695)], event);
        }, false),
        "position" : new Cesium.CallbackProperty(function(canCreateDiscussions) {
          var put_rows = hahaha;
          return Cesium[put_rows(3131)][put_rows(884)](op[put_rows(2695)], op.targetPosition, new (Cesium[put_rows(3131)]));
        }, false),
        "cylinder" : {
          "length" : new Cesium.CallbackProperty(function(canCreateDiscussions) {
            var put_rows = hahaha;
            return Cesium.Cartesian3.distance(op[put_rows(2695)], op.targetPosition);
          }, false),
          "topRadius" : this.bottomRadius,
          "bottomRadius" : 0,
          "material" : this.color
        }
      });
    }
  }, {
    "key" : `getModelMatrix`,
    "value" : function(value, target) {
      return target = Cesium.Cartesian3.subtract(target, value, new Cesium["Cartesian3"]), target = Cesium.Cartesian3.normalize(target, new Cesium["Cartesian3"]), target = Cesium.Transforms.rotationMatrixFromPositionVelocity(value, target, Cesium.Ellipsoid.WGS84), Cesium.Matrix4.fromRotationTranslation(target, value);
    }
  }, {
    "key" : `getHeadingPitchRoll`,
    "value" : function(value) {
      var matrix = Cesium.Transforms.eastNorthUpToFixedFrame(Cesium.Matrix4.getTranslation(value, new Cesium["Cartesian3"]), Cesium.Ellipsoid.WGS84, new Cesium["Matrix4"]);
      value = Cesium.Matrix4.multiply(Cesium.Matrix4.inverse(matrix, new Cesium["Matrix4"]), value, new Cesium["Matrix4"]);
      value = Cesium.Matrix4.getMatrix3(value, new Cesium.Matrix3);
      value = Cesium.Quaternion.fromRotationMatrix(value);
      return Cesium.HeadingPitchRoll.fromQuaternion(value);
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.viewer.entities.remove(this.cone);
      this.cone = void 0;
    }
  }]);
  descriptor = traverse;
  expect(animate, [{
    "key" : `createFrusum`,
    "value" : function() {
      this.createPerspectiveFrustum();
      this.createOrientation();
      this.addFillFrustum();
      this.addOutlineFrustum();
    }
  }, {
    "key" : `createPerspectiveFrustum`,
    "value" : function() {
      var r = Cesium.Math.toRadians(this.angle1);
      var sampleRate = Cesium.Math.toRadians(this.angle2);
      var fov = r;
      r = r / sampleRate;
      if (r < 1) {
        fov = sampleRate;
      }
      this.frustum = new Cesium.PerspectiveFrustum({
        "fov" : fov,
        "aspectRatio" : r,
        "near" : this.near,
        "far" : this.far
      });
    }
  }, {
    "key" : `getStyle`,
    "value" : function() {
      return {
        "far" : this.far,
        "near" : this.near,
        "angle1" : this.angle1,
        "angle2" : this.angle2,
        "heading" : this.heading,
        "pitch" : this.pitch,
        "roll" : this.roll
      };
    }
  }, {
    "key" : "updateStyle",
    "value" : function(value) {
      this.far = value.far;
      this.near = 0.01;
      this.angle1 = value.angle1 || 20;
      this.angle2 = value.angle2 || 20;
      this.heading = value.heading || 0;
      this.pitch = value.pitch || -180;
      this.roll = value.roll || 0;
      this.clear();
      this.createFrusum();
      this.gltfEntity.orientation = this.orientation;
    }
  }, {
    "key" : `createOrientation`,
    "value" : function() {
      var basisY = new Cesium.HeadingPitchRoll(Cesium.Math.toRadians(this.heading), Cesium.Math.toRadians(this.pitch), Cesium.Math.toRadians(this.roll));
      this.orientation = Cesium.Transforms.headingPitchRollQuaternion(this.position, basisY);
    }
  }, {
    "key" : `addFillFrustum`,
    "value" : function() {
      this.fillFrustum = new Cesium["Primitive"]({
        "geometryInstances" : new Cesium["GeometryInstance"]({
          "geometry" : new Cesium["FrustumGeometry"]({
            "origin" : this.position,
            "orientation" : this.orientation,
            "frustum" : this.frustum
          })
        }),
        "appearance" : new Cesium.MaterialAppearance({
          "material" : Cesium.Material.fromType("Color")
        }),
        "asynchronous" : false,
        "show" : true
      });
      this.fillFrustum.appearance.material.uniforms.color = this.color;
      this.viewer.scene.primitives.add(this.fillFrustum);
    }
  }, {
    "key" : "addOutlineFrustum",
    "value" : function() {
      this.outlineFrustum = new Cesium["Primitive"]({
        "geometryInstances" : new Cesium["GeometryInstance"]({
          "geometry" : new Cesium.FrustumOutlineGeometry({
            "origin" : this.position,
            "orientation" : this.orientation,
            "frustum" : this.frustum,
            "_drawNearPlane" : true
          }),
          "attributes" : {
            "color" : Cesium.ColorGeometryInstanceAttribute.fromColor(this.outlineColor)
          }
        }),
        "appearance" : new Cesium["PerInstanceColorAppearance"]({
          "translucent" : true,
          "flat" : true
        }),
        "asynchronous" : false,
        "show" : true
      });
      this.viewer.scene.primitives.add(this.outlineFrustum);
    }
  }, {
    "key" : `addSatellite`,
    "value" : function() {
      this.gltfEntity = this.viewer.entities.add({
        "position" : this.position,
        "orientation" : this.orientation,
        "model" : {
          "uri" : this.modelUrl,
          "colorBlendMode" : Cesium.ColorBlendMode.HIGHLIGHT,
          "color" : Cesium.Color.WHITE,
          "scale" : this.scale,
          "maximumScale" : 200
        }
      });
    }
  }, {
    "key" : `clear`,
    "value" : function() {
      this.viewer.scene.primitives.remove(this.fillFrustum);
      this.viewer.scene.primitives.remove(this.outlineFrustum);
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.viewer.entities.remove(this.gltfEntity);
      this.viewer.scene.primitives.remove(this.fillFrustum);
      this.viewer.scene.primitives.remove(this.outlineFrustum);
    }
  }]);
  name = animate;
  expect(size, [{
    "key" : `addEllipsoid`,
    "value" : function() {
      var primaryReplicas = this;
      var orientation = new Cesium["CallbackProperty"](function(canCreateDiscussions) {
        var stringify = hahaha;
        return primaryReplicas[stringify(2907)]();
      }, false);
      var radii = new Cesium.Cartesian3(this.style.radius, this.style.radius, this.style.radius);
      var _0x3549dc = new Cesium["Cartesian3"](0.1, 0.1, 0.1);
      var _0x13299b = Cesium.Math.toRadians(90 - this.style.hAngle);
      var _0x2fe0af = Cesium.Math.toRadians(90 + this.style.hAngle);
      var _0x1312db = Cesium.Math.toRadians(90 - this.style.vAngle);
      var _0x27dfbd = Cesium.Math.toRadians(90);
      var material = (this.style.color || Cesium.Color.DODGERBLUE).withAlpha(0.5);
      this.ellipsoidFill = this.viewer.entities.add({
        "position" : this.position,
        "orientation" : orientation,
        "ellipsoid" : {
          "radii" : radii,
          "innerRadii" : _0x3549dc,
          "minimumClock" : _0x13299b,
          "maximumClock" : _0x2fe0af,
          "minimumCone" : _0x1312db,
          "maximumCone" : _0x27dfbd,
          "material" : material,
          "outline" : false
        }
      });
      this.ellipsoidStroke = this.viewer.entities.add({
        "position" : this.position,
        "orientation" : orientation,
        "ellipsoid" : {
          "radii" : radii,
          "innerRadii" : _0x3549dc,
          "minimumClock" : _0x13299b,
          "maximumClock" : _0x2fe0af,
          "minimumCone" : _0x1312db,
          "maximumCone" : _0x27dfbd,
          "material" : material,
          "outline" : true,
          "fill" : false,
          "outlineColor" : (this.style.color || Cesium.Color.DODGERBLUE).withAlpha(0.8)
        }
      });
    }
  }, {
    "key" : `addScan`,
    "value" : function() {
      var _0x3583d8 = this;
      this.scanHeading = this.style.heading;
      this.ellipsoidScan = this.viewer.entities.add({
        "position" : this.position,
        "orientation" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
          return _0x3583d8.getScanOrientation();
        }, false),
        "ellipsoid" : {
          "radii" : new Cesium["Cartesian3"](this.style.radius, this.style.radius, this.style.radius),
          "innerRadii" : new Cesium["Cartesian3"](0.1, 0.1, 0.1),
          "minimumClock" : Cesium.Math.toRadians(89.9),
          "maximumClock" : Cesium.Math.toRadians(90.1),
          "minimumCone" : Cesium.Math.toRadians(90 - this.style.vAngle),
          "maximumCone" : Cesium.Math.toRadians(90),
          "material" : (this.style.color || Cesium.Color.DODGERBLUE).withAlpha(0.5),
          "outline" : false
        }
      });
    }
  }, {
    "key" : `getOrientation`,
    "value" : function() {
      var position = this.position;
      return this.position instanceof Cesium.SampledPositionProperty && (position = this.position.getValue(this.viewer.clock.currentTime)), Cesium.Transforms.headingPitchRollQuaternion(position, this.hpr);
    }
  }, {
    "key" : "getScanOrientation",
    "value" : function() {
      var position = this.position;
      return this.position instanceof Cesium.SampledPositionProperty && (position = this.position.getValue(this.viewer.clock.currentTime)), this.scanHeading++, this.scanHeading > this.style.heading + this.style.hAngle && (this.scanHeading = this.style.heading - this.style.hAngle), Cesium.Transforms.headingPitchRollQuaternion(position, Cesium.HeadingPitchRoll.fromDegrees(this.scanHeading, 0, 0));
    }
  }, {
    "key" : `setHeading`,
    "value" : function(target) {
      this.style.heading = target;
      this.hpr.heading = Cesium.Math.toRadians(target);
    }
  }, {
    "key" : "remove",
    "value" : function() {
      this.viewer.entities.remove(this.ellipsoidFill);
      this.viewer.entities.remove(this.ellipsoidStroke);
      this.viewer.entities.remove(this.ellipsoidScan);
    }
  }]);
  location = size;
  expect(Component, [{
    "key" : `addEllipsoid`,
    "value" : function() {
      var primaryReplicas = this;
      var orientation = new Cesium["CallbackProperty"](function(canCreateDiscussions) {
        var stringify = hahaha;
        return primaryReplicas[stringify(2907)]();
      }, false);
      var radii = new Cesium["Cartesian3"](this.style.radius, this.style.radius, this.style.radius);
      var _0x2c44b6 = new Cesium.Cartesian3(0.1, 0.1, 0.1);
      var _0x220555 = Cesium.Math.toRadians(90 - this.style.hAngle);
      var _0x2750c2 = Cesium.Math.toRadians(90 + this.style.hAngle);
      var _0x5dd98c = Cesium.Math.toRadians(90 + this.style.bankAngle - this.style.vAngle);
      var _0x2cb2a4 = Cesium.Math.toRadians(90 + this.style.bankAngle + this.style.vAngle);
      var material = (this.style.color || Cesium.Color.DODGERBLUE).withAlpha(0.5);
      this.ellipsoidFill = this.viewer.entities.add({
        "position" : this.position,
        "orientation" : orientation,
        "ellipsoid" : {
          "radii" : radii,
          "innerRadii" : _0x2c44b6,
          "minimumClock" : _0x220555,
          "maximumClock" : _0x2750c2,
          "minimumCone" : _0x5dd98c,
          "maximumCone" : _0x2cb2a4,
          "material" : material,
          "outline" : false
        }
      });
      this.ellipsoidStroke = this.viewer.entities.add({
        "position" : this.position,
        "orientation" : orientation,
        "ellipsoid" : {
          "radii" : radii,
          "innerRadii" : _0x2c44b6,
          "minimumClock" : _0x220555,
          "maximumClock" : _0x2750c2,
          "minimumCone" : _0x5dd98c,
          "maximumCone" : _0x2cb2a4,
          "material" : material,
          "outline" : true,
          "fill" : false,
          "outlineColor" : (this.style.color || Cesium.Color.DODGERBLUE).withAlpha(0.8)
        }
      });
    }
  }, {
    "key" : `addScan`,
    "value" : function() {
      if (2 == this.style.scanDirection) {
        this.addScan2();
      } else {
        this.addScan1();
      }
    }
  }, {
    "key" : `addScan1`,
    "value" : function() {
      var primaryReplicas = this;
      this.scanHeading = this.style.heading;
      this.ellipsoidScan = this.viewer.entities.add({
        "position" : this.position,
        "orientation" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
          var stringify = hahaha;
          return primaryReplicas[stringify(1120)]();
        }, false),
        "ellipsoid" : {
          "radii" : new Cesium["Cartesian3"](this.style.radius, this.style.radius, this.style.radius),
          "innerRadii" : new Cesium.Cartesian3(0.1, 0.1, 0.1),
          "minimumClock" : Cesium.Math.toRadians(89.9),
          "maximumClock" : Cesium.Math.toRadians(90.1),
          "minimumCone" : Cesium.Math.toRadians(90 + this.style.bankAngle - this.style.vAngle),
          "maximumCone" : Cesium.Math.toRadians(90 + this.style.bankAngle + this.style.vAngle),
          "material" : (this.style.color || Cesium.Color.DODGERBLUE).withAlpha(0.5),
          "outline" : false
        }
      });
    }
  }, {
    "key" : `addScan2`,
    "value" : function() {
      var same = this;
      var orientation = new Cesium.CallbackProperty(function(canCreateDiscussions) {
        return same.getOrientation();
      }, false);
      this.scanRadius = 0.1;
      var positionENU = new Cesium["Cartesian3"](0.1, 0.1, 0.1);
      this.ellipsoidScan = this.viewer.entities.add({
        "position" : this.position,
        "orientation" : orientation,
        "ellipsoid" : {
          "radii" : new Cesium.CallbackProperty(function(canCreateDiscussions) {
            var rel2Mstr = hahaha;
            return same[rel2Mstr(1548)] += same[rel2Mstr(1998)].speed, same[rel2Mstr(1548)] > same[rel2Mstr(1998)][rel2Mstr(2423)] && (same.scanRadius = 0.1), positionENU.x = positionENU.y = positionENU.z = same[rel2Mstr(1548)], positionENU;
          }, false),
          "minimumClock" : Cesium.Math.toRadians(90 - this.style.hAngle),
          "maximumClock" : Cesium.Math.toRadians(90 + this.style.hAngle),
          "minimumCone" : Cesium.Math.toRadians(90 + this.style.bankAngle - this.style.vAngle),
          "maximumCone" : Cesium.Math.toRadians(90 + this.style.bankAngle + this.style.vAngle),
          "material" : (this.style.color || Cesium.Color.DODGERBLUE).withAlpha(0.8),
          "outline" : false,
          "slicePartitions" : 516
        }
      });
    }
  }, {
    "key" : `getOrientation`,
    "value" : function() {
      var position = this.position;
      return this.position instanceof Cesium.SampledPositionProperty && (position = this.position.getValue(this.viewer.clock.currentTime)), Cesium.Transforms.headingPitchRollQuaternion(position, this.hpr);
    }
  }, {
    "key" : "getScanOrientation",
    "value" : function() {
      var position = this.position;
      return this.position instanceof Cesium.SampledPositionProperty && (position = this.position.getValue(this.viewer.clock.currentTime)), this.scanHeading++, this.scanHeading > this.style.heading + this.style.hAngle && (this.scanHeading = this.style.heading - this.style.hAngle), Cesium.Transforms.headingPitchRollQuaternion(position, Cesium.HeadingPitchRoll.fromDegrees(this.scanHeading, 0, 0));
    }
  }, {
    "key" : `setHeading`,
    "value" : function(target) {
      this.style.heading = target;
      this.hpr.heading = Cesium.Math.toRadians(target);
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.viewer.entities.remove(this.ellipsoidFill);
      this.viewer.entities.remove(this.ellipsoidStroke);
      this.viewer.entities.remove(this.ellipsoidScan);
    }
  }]);
  frame = Component;
  expect(process, [{
    "key" : `addEllipsoid`,
    "value" : function() {
      var same = this;
      var orientation = new Cesium["CallbackProperty"](function(canCreateDiscussions) {
        var rel2Mstr = hahaha;
        return same[rel2Mstr(1010)][rel2Mstr(849)](same[rel2Mstr(2276)][rel2Mstr(617)][rel2Mstr(2846)]);
      }, false);
      var radii = new Cesium.Cartesian3(this.style.radius, this.style.radius, this.style.radius);
      var _0x2b38bb = new Cesium.Cartesian3(0.1, 0.1, 0.1);
      var _0x3c4989 = Cesium.Math.toRadians(360 - this.style.hAngle);
      var _0x29df02 = Cesium.Math.toRadians(360 + this.style.hAngle);
      var _0x7d35b4 = Cesium.Math.toRadians(90 - this.style.vAngle);
      var _0x24100b = Cesium.Math.toRadians(90);
      var material = (this.style.color || Cesium.Color.DODGERBLUE).withAlpha(0.5);
      this.ellipsoidFill = this.viewer.entities.add({
        "position" : this.property,
        "orientation" : orientation,
        "model" : this.style.model,
        "ellipsoid" : {
          "radii" : radii,
          "innerRadii" : _0x2b38bb,
          "minimumClock" : _0x3c4989,
          "maximumClock" : _0x29df02,
          "minimumCone" : _0x7d35b4,
          "maximumCone" : _0x24100b,
          "material" : material,
          "outline" : false
        }
      });
      this.ellipsoidStroke = this.viewer.entities.add({
        "position" : this.property,
        "orientation" : orientation,
        "ellipsoid" : {
          "radii" : radii,
          "innerRadii" : _0x2b38bb,
          "minimumClock" : _0x3c4989,
          "maximumClock" : _0x29df02,
          "minimumCone" : _0x7d35b4,
          "maximumCone" : _0x24100b,
          "material" : material,
          "outline" : true,
          "fill" : false,
          "outlineColor" : (this.style.color || Cesium.Color.DODGERBLUE).withAlpha(0.8)
        }
      });
    }
  }, {
    "key" : "remove",
    "value" : function() {
      this.viewer.entities.remove(this.ellipsoidFill);
      this.viewer.entities.remove(this.ellipsoidStroke);
    }
  }]);
  init = process;
  expect(animation, [{
    "key" : "addCylinder",
    "value" : function() {
      var positionOnEllipsoid = Cesium.Cartesian3.fromDegrees(this.lng, this.lat);
      var instanceModelMatrix = Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(positionOnEllipsoid), new Cesium["Cartesian3"](0, 0, 0.5 * this.height), new Cesium["Matrix4"]);
      var meteorPoint = new Cesium["CylinderGeometry"]({
        "length" : this.height,
        "topRadius" : 0,
        "bottomRadius" : this.bottomRadius,
        "vertexFormat" : Cesium.MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat
      });
      meteorPoint = new Cesium["GeometryInstance"]({
        "geometry" : meteorPoint,
        "modelMatrix" : instanceModelMatrix
      });
      instanceModelMatrix = Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(positionOnEllipsoid), new Cesium["Cartesian3"](0, 0, 10), new Cesium["Matrix4"]);
      positionOnEllipsoid = new Cesium.CylinderGeometry({
        "length" : 0.001,
        "topRadius" : 0,
        "bottomRadius" : this.bottomRadius,
        "vertexFormat" : Cesium.MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat
      });
      instanceModelMatrix = new Cesium["GeometryInstance"]({
        "geometry" : positionOnEllipsoid,
        "modelMatrix" : instanceModelMatrix
      });
      this.addGeometry(meteorPoint, instanceModelMatrix);
    }
  }, {
    "key" : `addGeometry`,
    "value" : function(name, x) {
      if (1 == this.materialType) {
        this.appearance = new Cesium.MaterialAppearance({
          "material" : new Cesium["Material"]({
            "fabric" : {
              "uniforms" : {
                "color" : new Cesium["Color"](0.2, 1, 0, 1),
                "repeat" : 30,
                "offset" : 0,
                "thickness" : 0.3
              },
              "source" : "\n                            uniform vec4 color;\n                            uniform float repeat;\n                            uniform float offset;\n                            uniform float thickness;\n                            czm_material czm_getMaterial(czm_materialInput materialInput)\n                            {\n                                czm_material material = czm_getDefaultMaterial(materialInput);\n                                float sp = 1.0/repeat;\n                                vec2 st = materialInput.st;\n                                float dis = distance(st, vec2(0.5));\n                                float m = mod(dis + offset, sp);\n                                float a = step(sp*(1.0-thickness), m);\n                                material.diffuse = color.rgb;\n                                material.alpha = a * color.a;\n                                return material;\n                            }\n                        "
            },
            "translucent" : false
          }),
          "faceForward" : false,
          "closed" : true
        });
        this.appearance1 = new Cesium.MaterialAppearance({
          "material" : new Cesium.Material({
            "fabric" : {
              "uniforms" : {
                "color" : new Cesium["Color"](0.2, 1, 0, 1),
                "repeat" : 30,
                "offset" : 0,
                "thickness" : 0.3
              },
              "source" : "\n                            uniform vec4 color;\n                            uniform float repeat;\n                            uniform float offset;\n                            uniform float thickness;\n                            czm_material czm_getMaterial(czm_materialInput materialInput)\n                            {\n                                czm_material material = czm_getDefaultMaterial(materialInput);\n                                float sp = 1.0/repeat;\n                                vec2 st = materialInput.st;\n                                float dis = distance(st, vec2(0.5));\n                                float m = mod(dis + offset, sp);\n                                float a = step(sp*(1.0-thickness), m);\n                                material.diffuse = color.rgb;\n                                material.alpha = a * color.a;\n                                return material;\n                            }\n                        "
            },
            "translucent" : false
          }),
          "faceForward" : false,
          "closed" : true
        });
        this.radar1 = this.viewer.scene.primitives.add(new Cesium["Primitive"]({
          "geometryInstances" : [x],
          "appearance" : this.appearance1
        }));
        this.radar = this.viewer.scene.primitives.add(new Cesium["Primitive"]({
          "geometryInstances" : [name],
          "appearance" : this.appearance
        }));
        this.viewer.scene.preUpdate.addEventListener(this.preUpdateHandle1, this);
      } else {
        this.appearance = new Cesium.MaterialAppearance({
          "material" : new Cesium["Material"]({
            "fabric" : {
              "uniforms" : {
                "color" : new Cesium["Color"](0.2, 1, 0, 1),
                "repeat" : 1,
                "offset" : 0,
                "thickness" : 0.8
              },
              "source" : "\n                            uniform vec4 color;\n                            uniform float repeat;\n                            uniform float offset;\n                            uniform float thickness;\n                            czm_material czm_getMaterial(czm_materialInput materialInput)\n                            {\n                                czm_material material = czm_getDefaultMaterial(materialInput);\n                                float sp = 1.0/repeat;\n                                vec2 st = materialInput.st;\n                                float dis = distance(st, vec2(0.5));\n                                float m = mod(dis + offset, sp);\n                                float a = step(sp*(1.0-thickness), m);\n                                material.diffuse = color.rgb;\n                                material.alpha = a * color.a * dis * 1.2;\n                                return material;\n                            }\n                        "
            },
            "translucent" : false
          }),
          "faceForward" : false,
          "closed" : true
        });
        this.appearance1 = new Cesium["MaterialAppearance"]({
          "material" : new Cesium["Material"]({
            "fabric" : {
              "uniforms" : {
                "color" : new Cesium.Color(0.2, 1, 0, 1),
                "repeat" : 1,
                "offset" : 0,
                "thickness" : 0.8
              },
              "source" : "\n                            uniform vec4 color;\n                            uniform float repeat;\n                            uniform float offset;\n                            uniform float thickness;\n                            czm_material czm_getMaterial(czm_materialInput materialInput)\n                            {\n                                czm_material material = czm_getDefaultMaterial(materialInput);\n                                float sp = 1.0/repeat;\n                                vec2 st = materialInput.st;\n                                float dis = distance(st, vec2(0.5));\n                                float m = mod(dis + offset, sp);\n                                float a = step(sp*(1.0-thickness), m);\n                                material.diffuse = color.rgb;\n                                material.alpha = a * color.a * dis * 1.2;\n                                return material;\n                            }\n                        "
            },
            "translucent" : false
          }),
          "faceForward" : false,
          "closed" : true
        });
        this.radar1 = this.viewer.scene.primitives.add(new Cesium["Primitive"]({
          "geometryInstances" : [x],
          "appearance" : this.appearance1
        }));
        this.radar = this.viewer.scene.primitives.add(new Cesium["Primitive"]({
          "geometryInstances" : [name],
          "appearance" : this.appearance
        }));
        this.viewer.scene.preUpdate.addEventListener(this.preUpdateHandle2, this);
      }
    }
  }, {
    "key" : "preUpdateHandle1",
    "value" : function() {
      var prevOffset = this.appearance.material.uniforms.offset;
      if (1 < (prevOffset = prevOffset - 0.001)) {
        prevOffset = 0;
      }
      this.appearance.material.uniforms.offset = prevOffset;
      this.appearance1.material.uniforms.offset = prevOffset;
    }
  }, {
    "key" : `preUpdateHandle2`,
    "value" : function() {
      var prevOffset = this.appearance.material.uniforms.offset;
      if (1 < (prevOffset = prevOffset - 0.015)) {
        prevOffset = 0;
      }
      this.appearance.material.uniforms.offset = prevOffset;
      this.appearance1.material.uniforms.offset = prevOffset;
    }
  }, {
    "key" : "remove",
    "value" : function() {
      this.viewer.scene.preUpdate.removeEventListener(this.preUpdateHandle);
      this.viewer.scene.primitives.remove(this.radar);
      this.viewer.scene.primitives.remove(this.radar1);
    }
  }]);
  ID = animation;
  var BoundingSphere = Cesium.BoundingSphere;
  var Cartesian3 = Cesium.Cartesian3;
  var requestURL = Cesium.Color;
  var combine = Cesium.combine;
  var ComponentDatatype = Cesium.ComponentDatatype;
  var defaultValue = Cesium.defaultValue;
  var defined = Cesium.defined;
  var Sakura = Cesium.DeveloperError;
  var PrimitiveType = Cesium.PrimitiveType;
  var Buffer = Cesium.Buffer;
  var BufferUsage = Cesium.BufferUsage;
  var DrawCommand = Cesium.DrawCommand;
  var Pass = Cesium.Pass;
  var RenderState = Cesium.RenderState;
  var ShaderProgram = Cesium.ShaderProgram;
  var ShaderSource = Cesium.ShaderSource;
  var VertexArray = Cesium.VertexArray;
  var BlendingState = Cesium.BlendingState;
  var CullFace = Cesium.CullFace;
  var Material = Cesium.Material;
  var SceneMode = Cesium.SceneMode;
  var VertexFormat = Cesium.VertexFormat;
  var SVGPoint = Cesium.Math;
  var Matrix3 = Cesium.Matrix3;
  var Matrix4 = Cesium.Matrix4;
  var JulianDate = Cesium.JulianDate;
  var sin = Math.sin;
  var round = Math.cos;
  var abs = Math.tan;
  var parseInt = Math.atan;
  var attributeLocations = {
    "position" : 0,
    "normal" : 1
  };
  var PolylineCommon = `uniform vec4 u_intersectionColor;\nuniform float u_intersectionWidth;\nuniform vec4 u_lineColor;\n\nbool inSensorShadow(vec3 coneVertexWC, vec3 pointWC)\n{\n    // Diagonal matrix from the unscaled ellipsoid space to the scaled space.    \n    vec3 D = czm_ellipsoidInverseRadii;\n\n    // Sensor vertex in the scaled ellipsoid space\n    vec3 q = D * coneVertexWC;\n    float qMagnitudeSquared = dot(q, q);\n    float test = qMagnitudeSquared - 1.0;\n    \n    // Sensor vertex to fragment vector in the ellipsoid's scaled space\n    vec3 temp = D * pointWC - q;\n    float d = dot(temp, q);\n    \n    // Behind silhouette plane and inside silhouette cone\n    return (d < -test) && (d / length(temp) < -sqrt(test));\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\nvec4 getLineColor()\n{\n    return u_lineColor;\n}\n\nvec4 getIntersectionColor()\n{\n    return u_intersectionColor;\n}\n\nfloat getIntersectionWidth()\n{\n    return u_intersectionWidth;\n}\n\nvec2 sensor2dTextureCoordinates(float sensorRadius, vec3 pointMC)\n{\n    // (s, t) both in the range [0, 1]\n    float t = pointMC.z / sensorRadius;\n    float s = 1.0 + (atan(pointMC.y, pointMC.x) / czm_twoPi);\n    s = s - floor(s);\n    \n    return vec2(s, t);\n}\n`;
  var currentRelations = `attribute vec4 position;\nattribute vec3 normal;\n\nvarying vec3 v_position;\nvarying vec3 v_positionWC;\nvarying vec3 v_positionEC;\nvarying vec3 v_normalEC;\n\nvoid main()\n{\n    gl_Position = czm_modelViewProjection * position;\n    v_position = vec3(position);\n    v_positionWC = (czm_model * position).xyz;\n    v_positionEC = (czm_modelView * position).xyz;\n    v_normalEC = czm_normal * normal;\n}`;
  var get2DYPositionFraction = `#ifdef GL_OES_standard_derivatives\n    #extension GL_OES_standard_derivatives : enable\n#endif\n\nuniform bool u_showIntersection;\nuniform bool u_showThroughEllipsoid;\n\nuniform float u_radius;\nuniform float u_xHalfAngle;\nuniform float u_yHalfAngle;\nuniform float u_normalDirection;\nuniform vec4 u_color;\n\nvarying vec3 v_position;\nvarying vec3 v_positionWC;\nvarying vec3 v_positionEC;\nvarying vec3 v_normalEC;\n\nvec4 getColor(float sensorRadius, vec3 pointEC)\n{\n    czm_materialInput materialInput;\n\n    vec3 pointMC = (czm_inverseModelView * vec4(pointEC, 1.0)).xyz;\n    materialInput.st = sensor2dTextureCoordinates(sensorRadius, pointMC);\n    materialInput.str = pointMC / sensorRadius;\n\n    vec3 positionToEyeEC = -v_positionEC;\n    materialInput.positionToEyeEC = positionToEyeEC;\n\n    vec3 normalEC = normalize(v_normalEC);\n    materialInput.normalEC = u_normalDirection * normalEC;\n\n    czm_material material = czm_getMaterial(materialInput);\n\n    material.diffuse = u_color.rgb;\n    material.alpha = u_color.a;\n    // czm_lightDirectionEC\u5728cesium1.66\u5f00\u59cb\u52a0\u5165\u7684\n    return mix(czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC), vec4(material.diffuse, material.alpha), 0.4);\n\n}\n\nbool isOnBoundary(float value, float epsilon)\n{\n    float width = getIntersectionWidth();\n    float tolerance = width * epsilon;\n\n#ifdef GL_OES_standard_derivatives\n    float delta = max(abs(dFdx(value)), abs(dFdy(value)));\n    float pixels = width * delta;\n    float temp = abs(value);\n    // There are a couple things going on here.\n    // First we test the value at the current fragment to see if it is within the tolerance.\n    // We also want to check if the value of an adjacent pixel is within the tolerance,\n    // but we don't want to admit points that are obviously not on the surface.\n    // For example, if we are looking for "value" to be close to 0, but value is 1 and the adjacent value is 2,\n    // then the delta would be 1 and "temp - delta" would be "1 - 1" which is zero even though neither of\n    // the points is close to zero.\n    return temp < tolerance && temp < pixels || (delta < 10.0 * tolerance && temp - delta < tolerance && temp < pixels);\n#else\n    return abs(value) < tolerance;\n#endif\n}\n\nvec4 shade(bool isOnBoundary)\n{\n    if (u_showIntersection && isOnBoundary)\n    {\n        return getIntersectionColor();\n    }\n    return getColor(u_radius, v_positionEC);\n}\n\nfloat ellipsoidSurfaceFunction(vec3 point)\n{\n    vec3 scaled = czm_ellipsoidInverseRadii * point;\n    return dot(scaled, scaled) - 1.0;\n}\n\nvoid main()\n{\n    vec3 sensorVertexWC = czm_model[3].xyz;      // (0.0, 0.0, 0.0) in model coordinates\n    vec3 sensorVertexEC = czm_modelView[3].xyz;  // (0.0, 0.0, 0.0) in model coordinates\n\n    //vec3 pixDir = normalize(v_position);\n    float positionX = v_position.x;\n    float positionY = v_position.y;\n    float positionZ = v_position.z;\n\n    vec3 zDir = vec3(0.0, 0.0, 1.0);\n    vec3 lineX = vec3(positionX, 0 ,positionZ);\n    vec3 lineY = vec3(0, positionY, positionZ);\n    float resX = dot(normalize(lineX), zDir);\n    if(resX < cos(u_xHalfAngle) - 0.0001){\n        discard;\n    }\n    float resY = dot(normalize(lineY), zDir);\n    if(resY < cos(u_yHalfAngle)- 0.0001){\n        discard;\n    }\n\n\n    float ellipsoidValue = ellipsoidSurfaceFunction(v_positionWC);\n\n    // Occluded by the ellipsoid?\n\tif (!u_showThroughEllipsoid)\n\t{\n\t    // Discard if in the ellipsoid\n\t    // PERFORMANCE_IDEA: A coarse check for ellipsoid intersection could be done on the CPU first.\n\t    if (ellipsoidValue < 0.0)\n\t    {\n            discard;\n\t    }\n\n\t    // Discard if in the sensor's shadow\n\t    if (inSensorShadow(sensorVertexWC, v_positionWC))\n\t    {\n\t        discard;\n\t    }\n    }\n\n    // Notes: Each surface functions should have an associated tolerance based on the floating point error.\n    bool isOnEllipsoid = isOnBoundary(ellipsoidValue, czm_epsilon3);\n    gl_FragColor = shade(isOnEllipsoid);\n\n}`;
  var CustomSensorVolumeFS = `#ifdef GL_OES_standard_derivatives\n    #extension GL_OES_standard_derivatives : enable\n#endif\n\nuniform bool u_showIntersection;\nuniform bool u_showThroughEllipsoid;\n\nuniform float u_radius;\nuniform float u_xHalfAngle;\nuniform float u_yHalfAngle;\nuniform float u_normalDirection;\nuniform float u_type;\n\nvarying vec3 v_position;\nvarying vec3 v_positionWC;\nvarying vec3 v_positionEC;\nvarying vec3 v_normalEC;\n\nvec4 getColor(float sensorRadius, vec3 pointEC)\n{\n    czm_materialInput materialInput;\n\n    vec3 pointMC = (czm_inverseModelView * vec4(pointEC, 1.0)).xyz;\n    materialInput.st = sensor2dTextureCoordinates(sensorRadius, pointMC);\n    materialInput.str = pointMC / sensorRadius;\n\n    vec3 positionToEyeEC = -v_positionEC;\n    materialInput.positionToEyeEC = positionToEyeEC;\n\n    vec3 normalEC = normalize(v_normalEC);\n    materialInput.normalEC = u_normalDirection * normalEC;\n\n    czm_material material = czm_getMaterial(materialInput);\n    // czm_lightDirectionEC\u5728cesium1.66\u5f00\u59cb\u52a0\u5165\u7684\n    return mix(czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC), vec4(material.diffuse, material.alpha), 0.4);\n\n}\n\nbool isOnBoundary(float value, float epsilon)\n{\n    float width = getIntersectionWidth();\n    float tolerance = width * epsilon;\n\n#ifdef GL_OES_standard_derivatives\n    float delta = max(abs(dFdx(value)), abs(dFdy(value)));\n    float pixels = width * delta;\n    float temp = abs(value);\n    // There are a couple things going on here.\n    // First we test the value at the current fragment to see if it is within the tolerance.\n    // We also want to check if the value of an adjacent pixel is within the tolerance,\n    // but we don't want to admit points that are obviously not on the surface.\n    // For example, if we are looking for "value" to be close to 0, but value is 1 and the adjacent value is 2,\n    // then the delta would be 1 and "temp - delta" would be "1 - 1" which is zero even though neither of\n    // the points is close to zero.\n    return temp < tolerance && temp < pixels || (delta < 10.0 * tolerance && temp - delta < tolerance && temp < pixels);\n#else\n    return abs(value) < tolerance;\n#endif\n}\n\nvec4 shade(bool isOnBoundary)\n{\n    if (u_showIntersection && isOnBoundary)\n    {\n        return getIntersectionColor();\n    }\n    if(u_type == 1.0){\n        return getLineColor();\n    }\n    return getColor(u_radius, v_positionEC);\n}\n\nfloat ellipsoidSurfaceFunction(vec3 point)\n{\n    vec3 scaled = czm_ellipsoidInverseRadii * point;\n    return dot(scaled, scaled) - 1.0;\n}\n\nvoid main()\n{\n    vec3 sensorVertexWC = czm_model[3].xyz;      // (0.0, 0.0, 0.0) in model coordinates\n    vec3 sensorVertexEC = czm_modelView[3].xyz;  // (0.0, 0.0, 0.0) in model coordinates\n\n    //vec3 pixDir = normalize(v_position);\n    float positionX = v_position.x;\n    float positionY = v_position.y;\n    float positionZ = v_position.z;\n\n    vec3 zDir = vec3(0.0, 0.0, 1.0);\n    vec3 lineX = vec3(positionX, 0 ,positionZ);\n    vec3 lineY = vec3(0, positionY, positionZ);\n    float resX = dot(normalize(lineX), zDir);\n    if(resX < cos(u_xHalfAngle)-0.00001){\n        discard;\n    }\n    float resY = dot(normalize(lineY), zDir);\n    if(resY < cos(u_yHalfAngle)-0.00001){\n        discard;\n    }\n\n\n    float ellipsoidValue = ellipsoidSurfaceFunction(v_positionWC);\n\n    // Occluded by the ellipsoid?\n\tif (!u_showThroughEllipsoid)\n\t{\n\t    // Discard if in the ellipsoid\n\t    // PERFORMANCE_IDEA: A coarse check for ellipsoid intersection could be done on the CPU first.\n\t    if (ellipsoidValue < 0.0)\n\t    {\n            discard;\n\t    }\n\n\t    // Discard if in the sensor's shadow\n\t    if (inSensorShadow(sensorVertexWC, v_positionWC))\n\t    {\n\t        discard;\n\t    }\n    }\n\n    // Notes: Each surface functions should have an associated tolerance based on the floating point error.\n    bool isOnEllipsoid = isOnBoundary(ellipsoidValue, czm_epsilon3);\n    //isOnEllipsoid = false;\n    //if((resX >= 0.8 && resX <= 0.81)||(resY >= 0.8 && resY <= 0.81)){\n    /*if(false){\n        gl_FragColor = vec4(1.0,0.0,0.0,1.0);\n    }else{\n        gl_FragColor = shade(isOnEllipsoid);\n    }\n*/\n    gl_FragColor = shade(isOnEllipsoid);\n\n}`;
  CustomSensorVolume.prototype.update = function(config) {
    var value = config.mode;
    if (this.show && value === SceneMode.SCENE3D) {
      var context = false;
      var inputWin = false;
      var winRef = false;
      var height = this.xHalfAngle;
      var width = this.yHalfAngle;
      if (height < 0 || width < 0) {
        throw new Sakura("halfAngle must be greater than or equal to zero.");
      }
      if (0 != height && 0 != width) {
        if (!(this._xHalfAngle === height && this._yHalfAngle === width)) {
          this._xHalfAngle = height;
          this._yHalfAngle = width;
          context = true;
        }
        var radius = this.radius;
        if (radius < 0) {
          throw new Sakura("this.radius must be greater than or equal to zero.");
        }
        var channels = false;
        if (this._radius !== radius) {
          channels = true;
          this._radius = radius;
          this._boundingSphere = new BoundingSphere(Cartesian3.ZERO, this.radius);
        }
        if (!(Matrix4.equals(this.modelMatrix, this._modelMatrix) && !channels)) {
          Matrix4.clone(this.modelMatrix, this._modelMatrix);
          Matrix4.multiplyByUniformScale(this.modelMatrix, this.radius, this._computedModelMatrix);
          BoundingSphere.transform(this._boundingSphere, this.modelMatrix, this._boundingSphereWC);
        }
        var newValue = this.showThroughEllipsoid;
        if (this._showThroughEllipsoid !== this.showThroughEllipsoid) {
          this._showThroughEllipsoid = newValue;
          inputWin = true;
        }
        var material = this.material;
        if (this._material !== material) {
          this._material = material;
          winRef = inputWin = true;
        }
        var options;
        var val;
        var src;
        var isActive;
        var primitive;
        var translucent = material.isTranslucent();
        if (this._translucent !== translucent) {
          this._translucent = translucent;
          inputWin = true;
        }
        if (this.showScanPlane) {
          value = config.time;
          if ((radius = JulianDate.secondsDifference(value, this._time)) < 0) {
            this._time = JulianDate.clone(value, this._time);
          }
          channels = Math.max(radius % this.scanPlaneRate / this.scanPlaneRate, 0);
          options = void 0;
          if ("horizontal" == this.scanPlaneMode) {
            value = round(options = 2 * width * channels - width);
            radius = abs(height);
            radius = parseInt(value * radius);
            this._scanePlaneXHalfAngle = radius;
            this._scanePlaneYHalfAngle = options;
            Cesium.Matrix3.fromRotationX(this._scanePlaneYHalfAngle, result);
          } else {
            options = 2 * height * channels - height;
            val = abs(width);
            width = round(options);
            val = parseInt(width * val);
            this._scanePlaneXHalfAngle = options;
            this._scanePlaneYHalfAngle = val;
            Cesium.Matrix3.fromRotationY(this._scanePlaneXHalfAngle, result);
          }
          Cesium.Matrix4.multiplyByMatrix3(this.modelMatrix, result, this._computedScanPlaneModelMatrix);
          Matrix4.multiplyByUniformScale(this._computedScanPlaneModelMatrix, this.radius, this._computedScanPlaneModelMatrix);
        }
        if (context) {
          options = this;
          context = (val = config).context;
          val = zoom(options, options.xHalfAngle, options.yHalfAngle);
          val = function(args, value) {
            var parseInt = hahaha;
            var angle = args[parseInt(1647)];
            var matrix = args[parseInt(1723)];
            var playerList = value[parseInt(638)];
            args = value.zox;
            value = [];
            var returnedResult = Matrix3[parseInt(3080)](angle, result);
            return value[parseInt(2008)](playerList.map(function(mmCoreSplitViewBlock) {
              var toInt = parseInt;
              return Matrix3[toInt(1159)](returnedResult, mmCoreSplitViewBlock, new Cesium.Cartesian3);
            })), returnedResult = Matrix3[parseInt(2547)](-matrix, result), value[parseInt(2008)](args[parseInt(1331)](function(right) {
              var toInt = parseInt;
              return Matrix3.multiplyByVector(returnedResult, right, new (Cesium[toInt(3131)]));
            })[parseInt(2444)]()), returnedResult = Matrix3.fromRotationY(-angle, result), value[parseInt(2008)](playerList[parseInt(1331)](function(mmCoreSplitViewBlock) {
              var toInt = parseInt;
              return Matrix3[toInt(1159)](returnedResult, mmCoreSplitViewBlock, new Cesium.Cartesian3);
            })[parseInt(2444)]()), returnedResult = Matrix3[parseInt(2547)](matrix, result), value[parseInt(2008)](args[parseInt(1331)](function(mmCoreSplitViewBlock) {
              var toInt = parseInt;
              return Matrix3[toInt(1159)](returnedResult, mmCoreSplitViewBlock, new (Cesium[toInt(3131)]));
            })), value;
          }(options, val);
          if (options.showLateralSurfaces) {
            options._sectorVA = function(context, obj) {
              var pluralize = hahaha;
              var strideInBytes = Array[pluralize(447)][pluralize(439)][pluralize(1318)]([], obj)[pluralize(2189)] - obj.length;
              var positions = new Float32Array(18 * strideInBytes);
              var j = 0;
              var oldPath = 0;
              var redis = obj[pluralize(2189)];
              for (; oldPath < redis; oldPath++) {
                var data = obj[oldPath];
                var globalBonePosition = Cartesian3[pluralize(1251)](Cartesian3[pluralize(2482)](data[0], data[data[pluralize(2189)] - 1], scratchEyeTranslation), scratchEyeTranslation);
                var i = 0;
                var choicesQuantity = data.length - 1;
                for (; i < choicesQuantity; i++) {
                  positions[j++] = 0;
                  positions[j++] = 0;
                  positions[j++] = 0;
                  positions[j++] = -globalBonePosition.x;
                  positions[j++] = -globalBonePosition.y;
                  positions[j++] = -globalBonePosition.z;
                  positions[j++] = data[i].x;
                  positions[j++] = data[i].y;
                  positions[j++] = data[i].z;
                  positions[j++] = -globalBonePosition.x;
                  positions[j++] = -globalBonePosition.y;
                  positions[j++] = -globalBonePosition.z;
                  positions[j++] = data[i + 1].x;
                  positions[j++] = data[i + 1].y;
                  positions[j++] = data[i + 1].z;
                  positions[j++] = -globalBonePosition.x;
                  positions[j++] = -globalBonePosition.y;
                  positions[j++] = -globalBonePosition.z;
                }
              }
              var vertexBuffer = Buffer.createVertexBuffer({
                "context" : context,
                "typedArray" : positions,
                "usage" : BufferUsage.STATIC_DRAW
              });
              strideInBytes = 6 * Float32Array.BYTES_PER_ELEMENT;
              strideInBytes = [{
                "index" : attributeLocations[pluralize(586)],
                "vertexBuffer" : vertexBuffer,
                "componentsPerAttribute" : 3,
                "componentDatatype" : ComponentDatatype[pluralize(1279)],
                "offsetInBytes" : 0,
                "strideInBytes" : strideInBytes
              }, {
                "index" : attributeLocations[pluralize(871)],
                "vertexBuffer" : vertexBuffer,
                "componentsPerAttribute" : 3,
                "componentDatatype" : ComponentDatatype[pluralize(1279)],
                "offsetInBytes" : 3 * Float32Array[pluralize(781)],
                "strideInBytes" : strideInBytes
              }];
              return new VertexArray({
                "context" : context,
                "attributes" : strideInBytes
              });
            }(context, val);
          }
          if (options.showSectorLines) {
            options._sectorLineVA = function(context, result) {
              var format = hahaha;
              var n = result[format(2189)];
              var positions = new Float32Array(9 * n);
              var j = 0;
              var letter = 0;
              var trlen = result.length;
              for (; letter < trlen; letter++) {
                var data = result[letter];
                positions[j++] = 0;
                positions[j++] = 0;
                positions[j++] = 0;
                positions[j++] = data[0].x;
                positions[j++] = data[0].y;
                positions[j++] = data[0].z;
              }
              var vertexBuffer = Buffer[format(2356)]({
                "context" : context,
                "typedArray" : positions,
                "usage" : BufferUsage[format(2465)]
              });
              n = 3 * Float32Array[format(781)];
              n = [{
                "index" : attributeLocations[format(586)],
                "vertexBuffer" : vertexBuffer,
                "componentsPerAttribute" : 3,
                "componentDatatype" : ComponentDatatype.FLOAT,
                "offsetInBytes" : 0,
                "strideInBytes" : n
              }];
              return new VertexArray({
                "context" : context,
                "attributes" : n
              });
            }(context, val);
          }
          if (options.showSectorSegmentLines) {
            options._sectorSegmentLineVA = function(context, obj) {
              var pluralize = hahaha;
              var strideInBytes = Array[pluralize(447)].concat[pluralize(1318)]([], obj)[pluralize(2189)] - obj.length;
              var positions = new Float32Array(9 * strideInBytes);
              var j = 0;
              var oldPath = 0;
              var analyzeType = obj[pluralize(2189)];
              for (; oldPath < analyzeType; oldPath++) {
                var data = obj[oldPath];
                var i = 0;
                var cell_amount = data[pluralize(2189)] - 1;
                for (; i < cell_amount; i++) {
                  positions[j++] = data[i].x;
                  positions[j++] = data[i].y;
                  positions[j++] = data[i].z;
                  positions[j++] = data[i + 1].x;
                  positions[j++] = data[i + 1].y;
                  positions[j++] = data[i + 1].z;
                }
              }
              var vertexBuffer = Buffer[pluralize(2356)]({
                "context" : context,
                "typedArray" : positions,
                "usage" : BufferUsage[pluralize(2465)]
              });
              strideInBytes = 3 * Float32Array[pluralize(781)];
              strideInBytes = [{
                "index" : attributeLocations.position,
                "vertexBuffer" : vertexBuffer,
                "componentsPerAttribute" : 3,
                "componentDatatype" : ComponentDatatype[pluralize(1279)],
                "offsetInBytes" : 0,
                "strideInBytes" : strideInBytes
              }];
              return new VertexArray({
                "context" : context,
                "attributes" : strideInBytes
              });
            }(context, val);
          }
          if (options.showDomeSurfaces) {
            options._domeVA = function(context) {
              var countNewLineCharacters = hahaha;
              var D_geometry = Cesium.EllipsoidGeometry[countNewLineCharacters(857)](new (Cesium[countNewLineCharacters(785)])({
                "vertexFormat" : VertexFormat.POSITION_ONLY,
                "stackPartitions" : 32,
                "slicePartitions" : 32
              }));
              return VertexArray[countNewLineCharacters(454)]({
                "context" : context,
                "geometry" : D_geometry,
                "attributeLocations" : attributeLocations,
                "bufferUsage" : BufferUsage[countNewLineCharacters(2465)],
                "interleave" : false
              });
            }(context);
          }
          if (options.showDomeLines) {
            options._domeLineVA = function(context) {
              var countNewLineCharacters = hahaha;
              var D_geometry = Cesium[countNewLineCharacters(644)][countNewLineCharacters(857)](new (Cesium[countNewLineCharacters(644)])({
                "vertexFormat" : VertexFormat[countNewLineCharacters(576)],
                "stackPartitions" : 32,
                "slicePartitions" : 32
              }));
              return VertexArray.fromGeometry({
                "context" : context,
                "geometry" : D_geometry,
                "attributeLocations" : attributeLocations,
                "bufferUsage" : BufferUsage.STATIC_DRAW,
                "interleave" : false
              });
            }(context);
          }
          if (options.showScanPlane) {
            if ("horizontal" == options.scanPlaneMode) {
              src = zoom(options, SVGPoint.PI_OVER_TWO, 0);
              options._scanPlaneVA = createVertexArray(context, src.zox);
            } else {
              src = zoom(options, 0, SVGPoint.PI_OVER_TWO);
              options._scanPlaneVA = createVertexArray(context, src.zoy);
            }
          }
        }
        if (inputWin) {
          primitive = this;
          isActive = newValue;
          if (translucent) {
            primitive._frontFaceRS = RenderState.fromCache({
              "depthTest" : {
                "enabled" : !isActive
              },
              "depthMask" : false,
              "blending" : BlendingState.ALPHA_BLEND,
              "cull" : {
                "enabled" : true,
                "face" : CullFace.BACK
              }
            });
            primitive._backFaceRS = RenderState.fromCache({
              "depthTest" : {
                "enabled" : !isActive
              },
              "depthMask" : false,
              "blending" : BlendingState.ALPHA_BLEND,
              "cull" : {
                "enabled" : true,
                "face" : CullFace.FRONT
              }
            });
            primitive._pickRS = RenderState.fromCache({
              "depthTest" : {
                "enabled" : !isActive
              },
              "depthMask" : false,
              "blending" : BlendingState.ALPHA_BLEND
            });
          } else {
            primitive._frontFaceRS = RenderState.fromCache({
              "depthTest" : {
                "enabled" : !isActive
              },
              "depthMask" : true
            });
            primitive._pickRS = RenderState.fromCache({
              "depthTest" : {
                "enabled" : true
              },
              "depthMask" : true
            });
          }
        }
        if (winRef) {
          (function(primitive, fs, fragmentShaderSource) {
            var countNewLineCharacters = hahaha;
            var original = fs[countNewLineCharacters(2470)];
            var addedRelations = currentRelations;
            fs = new ShaderSource({
              "sources" : [PolylineCommon, fragmentShaderSource[countNewLineCharacters(1079)], CustomSensorVolumeFS]
            });
            primitive[countNewLineCharacters(3097)] = ShaderProgram.replaceCache({
              "context" : original,
              "shaderProgram" : primitive[countNewLineCharacters(3097)],
              "vertexShaderSource" : addedRelations,
              "fragmentShaderSource" : fs,
              "attributeLocations" : attributeLocations
            });
            fragmentShaderSource = new ShaderSource({
              "sources" : [PolylineCommon, fragmentShaderSource[countNewLineCharacters(1079)], CustomSensorVolumeFS],
              "pickColorQualifier" : "uniform"
            });
            primitive[countNewLineCharacters(445)] = ShaderProgram[countNewLineCharacters(2326)]({
              "context" : original,
              "shaderProgram" : primitive._pickSP,
              "vertexShaderSource" : addedRelations,
              "fragmentShaderSource" : fragmentShaderSource,
              "attributeLocations" : attributeLocations
            });
          })(isActive = this, primitive = config, material = material);
          if (isActive.showScanPlane) {
            (function(menuAlreadyActive, window, fs) {
              var callCodePush = hahaha;
              var chart = window[callCodePush(2470)];
              window = currentRelations;
              fs = new ShaderSource({
                "sources" : [PolylineCommon, fs[callCodePush(1079)], get2DYPositionFraction]
              });
              menuAlreadyActive._scanePlaneSP = ShaderProgram[callCodePush(2326)]({
                "context" : chart,
                "shaderProgram" : menuAlreadyActive[callCodePush(1223)],
                "vertexShaderSource" : window,
                "fragmentShaderSource" : fs,
                "attributeLocations" : attributeLocations
              });
            })(isActive, primitive, material);
          }
        }
        if (inputWin || winRef) {
          (function(obj, translucent) {
            var parseInt = hahaha;
            obj[parseInt(3069)][parseInt(2189)] = 0;
            var uniformMap = translucent ? Pass.TRANSLUCENT : Pass[parseInt(2066)];
            if (obj[parseInt(3076)]) {
              createCommandLists(obj, obj[parseInt(1264)], obj._sectorBackCommand, obj[parseInt(1733)], obj[parseInt(680)], obj[parseInt(3097)], obj[parseInt(3103)], obj[parseInt(2135)], obj._computedModelMatrix, translucent, uniformMap);
            }
            if (obj[parseInt(2164)]) {
              createCommandLists(obj, obj[parseInt(1561)], void 0, obj[parseInt(1733)], obj[parseInt(680)], obj._sp, obj._sectorLineVA, obj[parseInt(2135)], obj._computedModelMatrix, translucent, uniformMap, true);
            }
            if (obj[parseInt(1553)]) {
              createCommandLists(obj, obj._sectorSegmentLineCommand, void 0, obj[parseInt(1733)], obj[parseInt(680)], obj[parseInt(3097)], obj[parseInt(1246)], obj[parseInt(2135)], obj[parseInt(2299)], translucent, uniformMap, true);
            }
            if (obj.showDomeSurfaces) {
              createCommandLists(obj, obj[parseInt(1172)], obj[parseInt(706)], obj._frontFaceRS, obj[parseInt(680)], obj[parseInt(3097)], obj._domeVA, obj._uniforms, obj._computedModelMatrix, translucent, uniformMap);
            }
            if (obj.showDomeLines) {
              createCommandLists(obj, obj[parseInt(2378)], void 0, obj._frontFaceRS, obj[parseInt(680)], obj[parseInt(3097)], obj[parseInt(2563)], obj[parseInt(2135)], obj[parseInt(2299)], translucent, uniformMap, true);
            }
            if (obj[parseInt(3013)]) {
              createCommandLists(obj, obj[parseInt(2808)], obj[parseInt(2775)], obj[parseInt(1733)], obj[parseInt(680)], obj._scanePlaneSP, obj[parseInt(2913)], obj[parseInt(1227)], obj[parseInt(1718)], translucent, uniformMap);
            }
          })(this, translucent);
        }
        var commandList = config.commandList;
        config = config.passes;
        var colorCommands = this._colorCommands;
        if (config.render) {
          var j = 0;
          var colorLength = colorCommands.length;
          for (; j < colorLength; j++) {
            var command = colorCommands[j];
            commandList.push(command);
          }
        }
      }
    }
  };
  CustomSensorVolume.prototype.destroy = function() {
  };
  var result = new Matrix3;
  var scratchEyeTranslation = new Cartesian3;
  expect(last, [{
    "key" : `initPrimitive`,
    "value" : function() {
      var material = new Cesium.HeadingPitchRoll(Cesium.Math.toRadians(this.options.heading), Cesium.Math.toRadians(this.options.pitch), Cesium.Math.toRadians(this.options.roll));
      var orientation = Cesium.Transforms.headingPitchRollQuaternion(this.position, material);
      var dir = Cesium.Matrix4.fromRotationTranslation(Cesium.Matrix3.fromQuaternion(orientation), this.position);
      material = Cesium.Material.fromType("Color");
      orientation = Cesium.Color.fromCssColorString("#00ffff").withAlpha(0.3);
      material.uniforms.color = this.options.color || orientation;
      dir = new CustomSensorVolume({
        "modelMatrix" : dir,
        "radius" : this.options.radius || 100,
        "xHalfAngle" : this.options.xHalfAngle || 50,
        "yHalfAngle" : this.options.yHalfAngle || 50,
        "material" : material,
        "lineColor" : this.options.lineColor || new Cesium.Color(1, 1, 1, 1),
        "slice" : this.options.slice || 20,
        "scanPlaneColor" : this.options.scanPlaneColor || material.uniforms.color.withAlpha(0.8),
        "showScanPlane" : this.options.showScanPlane,
        "showThroughEllipsoid" : false,
        "showLateralSurfaces" : this.options.showLateralSurfaces,
        "showDomeSurfaces" : this.options.showDomeSurfaces,
        "scanPlaneMode" : this.options.scanPlaneMode || "vertical"
      });
      this.options.scanPlaneColor = this.options.scanPlaneColor || material.uniforms.color.withAlpha(0.8);
      this.viewer.scene.primitives.add(dir);
      this.primitive = dir;
    }
  }, {
    "key" : `getStyle`,
    "value" : function() {
      return {
        "heading" : this.options.heading,
        "pitch" : this.options.pitch,
        "roll" : this.options.roll,
        "xHalfAngle" : this.options.xHalfAngle,
        "yHalfAngle" : this.options.yHalfAngle,
        "radius" : this.options.radius,
        "color" : this.options.color,
        "lineColor" : this.options.lineColor || new Cesium.Color(1, 1, 1, 1),
        "slice" : this.options.slice || 20,
        "scanPlaneColor" : this.options.scanPlaneColor,
        "showScanPlane" : this.options.showScanPlane || true,
        "showLateralSurfaces" : true,
        "showDomeSurfaces" : true,
        "scanPlaneMode" : this.options.scanPlaneMode || "vertical"
      };
    }
  }, {
    "key" : "updateStyle",
    "value" : function(value) {
      this.options = value;
      this.remove();
      this.initPrimitive();
    }
  }, {
    "key" : "remove",
    "value" : function() {
      this.viewer.scene.primitives.remove(this.primitive);
      this.primitive = void 0;
    }
  }]);
  data = last;
  xt3d.SpacePlugin = {
    "CylinderWave" : exports,
    "CylinderWaveExt" : ID,
    "FanBladeScan" : output,
    "ScanEllipsoid" : definition,
    "PyramidSensor" : obj,
    "ConicSensor" : descriptor,
    "SatellitePyramid" : name,
    "ScanSector" : location,
    "ScanSectorExt" : frame,
    "SectorVisualField" : init,
    "RectangularSensor" : data
  };
  expect(line, [{
    "key" : `addModels`,
    "value" : function() {
      this.models = [];
      var key = 0;
      for (; key < this.style.count + 1; key++) {
        var current = this.style.url;
        if (key == this.style.count) {
          if (!this.style.topUrl) {
            return;
          }
          current = this.style.topUrl;
        }
        var result = Cesium.HeadingPitchRoll.fromDegrees(this.style.heading || 0, 0, 0);
        var modelMatrix = Cesium.Transforms.headingPitchRollToFixedFrame(this.position, result);
        result = new Cesium.Cartesian3(0, 0, key * this.style.spacing);
        result = Cesium.Matrix4.fromTranslation(result, result);
        Cesium.Matrix4.multiply(modelMatrix, result, modelMatrix);
        current = this.viewer.scene.primitives.add(Cesium.Model.fromGltf({
          "url" : current,
          "modelMatrix" : modelMatrix
        }));
        this.models.push({
          "primitive" : current,
          "originMat4" : modelMatrix.clone()
        });
      }
    }
  }, {
    "key" : "openAll",
    "value" : function(type, value) {
      var oldState = this;
      if (!this.isOpening && !this.isOpened) {
        var quantity = (value = value || 3E3) / 10;
        var index = 1;
        for (; index < this.models.length; index++) {
          var item = this.models[index];
          item.openHeight = 1 == index ? this.style.spacing + type : this.models[index - 1].openHeight + this.style.spacing + type;
          item.increment = item.openHeight / quantity;
          item.currentOpenHeight = 0;
        }
        var chat_retry = setInterval(function(canCreateDiscussions) {
          var parseInt = hahaha;
          var index = 1;
          for (; index < oldState[parseInt(1856)].length; index++) {
            var values = oldState[parseInt(1856)][index];
            var originalMatrix = values[parseInt(1023)][parseInt(1978)];
            var result = new (Cesium[parseInt(3131)])(0, 0, values[parseInt(584)]);
            result = Cesium[parseInt(1030)].fromTranslation(result, result);
            Cesium[parseInt(1030)][parseInt(1703)](originalMatrix, result, originalMatrix);
            values[parseInt(1023)].modelMatrix = originalMatrix;
            values.currentOpenHeight = values[parseInt(2592)] + values[parseInt(584)];
            if (values[parseInt(2592)] >= values[parseInt(2698)]) {
              clearInterval(chat_retry);
              oldState[parseInt(2526)] = void 0;
              oldState[parseInt(1361)] = true;
              oldState[parseInt(2099)] = false;
            }
          }
        }, 10);
        this.clearIntervalNum = chat_retry;
      }
    }
  }, {
    "key" : `mergeAll`,
    "value" : function() {
      var initializeCheckTimer;
      var values = this;
      if (this.isOpened) {
        initializeCheckTimer = setInterval(function(canCreateDiscussions) {
          var parseInt = hahaha;
          var i = 1;
          for (; i < values[parseInt(1856)][parseInt(2189)]; i++) {
            var map = values[parseInt(1856)][i];
            var artistTrack = map[parseInt(1023)][parseInt(1978)];
            var result = new (Cesium[parseInt(3131)])(0, 0, -map[parseInt(584)]);
            result = Cesium[parseInt(1030)].fromTranslation(result, result);
            Cesium[parseInt(1030)][parseInt(1703)](artistTrack, result, artistTrack);
            map[parseInt(1023)][parseInt(1978)] = artistTrack;
            map.currentOpenHeight = map[parseInt(2592)] - map[parseInt(584)];
            if (map[parseInt(2592)] <= 0) {
              clearInterval(initializeCheckTimer);
              values[parseInt(2526)] = void 0;
              values.isOpened = false;
            }
          }
        }, 10);
        this.clearIntervalNum = initializeCheckTimer;
      }
    }
  }, {
    "key" : `showFloor`,
    "value" : function(name) {
      var i = 0;
      for (; i < this.models.length; i++) {
        this.models[i].primitive.show = i + 1 <= name;
      }
    }
  }, {
    "key" : "reset",
    "value" : function() {
      if (this.clearIntervalNum) {
        clearInterval(this.clearIntervalNum);
        this.clearIntervalNum = void 0;
      }
      var i = 1;
      for (; i < this.models.length; i++) {
        var node = this.models[i];
        node.primitive.modelMatrix = node.originMat4.clone();
        node.primitive.show = true;
      }
      this.isOpened = false;
      this.isOpening = false;
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      var same = this;
      this.reset();
      this.models.forEach(function(mmCoreSplitViewBlock) {
        var rel2Mstr = hahaha;
        same[rel2Mstr(2276)][rel2Mstr(2758)][rel2Mstr(2798)][rel2Mstr(508)](mmCoreSplitViewBlock);
      });
    }
  }]);
  definition = line;
  expect(object, [{
    "key" : `addModel`,
    "value" : function() {
      var primaryReplicas = this;
      var o = new Cesium["HeadingPitchRoll"](Cesium.Math.toRadians(0), Cesium.Math.toRadians(0), Cesium.Math.toRadians(0));
      var TAB = Cesium.Math.toRadians(this.style.speed || 2);
      this.modelEntity = this.viewer.entities.add({
        "position" : this.position,
        "orientation" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
          var stringify = hahaha;
          return o.heading += TAB, Cesium[stringify(942)][stringify(1806)](primaryReplicas[stringify(586)], o);
        }, false),
        "model" : {
          "uri" : this.style.modelUrl,
          "scale" : this.style.scale || 1
        }
      });
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.viewer.entities.remove(this.modelEntity);
    }
  }]);
  obj = object;
  expect(model, [{
    "key" : `initEvents`,
    "value" : function() {
      this.DrawEndEvent = new Cesium.Event;
    }
  }, {
    "key" : "activate",
    "value" : function() {
      this.registerEvents();
      this.plotDrawTip = new Map(this.viewer);
      this.plotDrawTip.setContent(["\u5de6\u952e\u70b9\u51fb\u786e\u5b9a\u6a21\u578b\u4f4d\u7f6e", "\u53f3\u952e\u70b9\u51fb\u53d6\u6d88"]);
      this.mousePoint = new Date(this.viewer);
      this.viewer.enableCursorStyle = false;
      this.viewer._element.style.cursor = "default";
    }
  }, {
    "key" : "registerEvents",
    "value" : function() {
      var primaryReplicas = this;
      this.eventHandler = new Cesium["ScreenSpaceEventHandler"](this.viewer.scene.canvas);
      this.initLeftClickEvent();
      this.initMouseMoveEvent();
      this.eventHandler.setInputAction(function(canCreateDiscussions) {
        var stringify = hahaha;
        primaryReplicas[stringify(1983)]();
      }, Cesium.ScreenSpaceEventType.RIGHT_CLICK);
    }
  }, {
    "key" : "initLeftClickEvent",
    "value" : function() {
      var o = this;
      this.eventHandler.setInputAction(function(currentItems) {
        var parseInt = hahaha;
        var artistTrack = o[parseInt(2276)][parseInt(2758)][parseInt(1238)](currentItems[parseInt(586)]);
        if (artistTrack = artistTrack || o[parseInt(2276)][parseInt(2758)][parseInt(1306)].pickEllipsoid(currentItems[parseInt(1108)], o.viewer[parseInt(2758)][parseInt(2359)][parseInt(1923)])) {
          o[parseInt(1495)][parseInt(2477)](artistTrack);
          o[parseInt(1983)]();
        }
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
    }
  }, {
    "key" : `initMouseMoveEvent`,
    "value" : function() {
      var self = this;
      this.eventHandler.setInputAction(function(currentItems) {
        var parseInt = hahaha;
        var latlng = self[parseInt(2276)][parseInt(2758)][parseInt(1238)](currentItems[parseInt(1108)]);
        if (latlng = latlng || self.viewer[parseInt(2758)][parseInt(1306)][parseInt(1080)](currentItems[parseInt(1108)], self[parseInt(2276)][parseInt(2758)][parseInt(2359)][parseInt(1923)])) {
          self.plotDrawTip.updatePosition(latlng);
          self[parseInt(825)][parseInt(3164)](latlng);
        }
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
    }
  }, {
    "key" : `unRegisterEvents`,
    "value" : function() {
      this.eventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_CLICK);
      this.eventHandler.removeInputAction(Cesium.ScreenSpaceEventType.MOUSE_MOVE);
      this.eventHandler.removeInputAction(Cesium.ScreenSpaceEventType.RIGHT_CLICK);
    }
  }, {
    "key" : `deactivate`,
    "value" : function() {
      this.unRegisterEvents();
      this.plotDrawTip.remove();
      this.plotDrawTip = void 0;
      this.mousePoint.remove();
      this.mousePoint = void 0;
      this.viewer._element.style.cursor = "pointer";
      this.viewer.enableCursorStyle = true;
    }
  }]);
  descriptor = model;
  expect(left, [{
    "key" : `registerMouseEvents`,
    "value" : function() {
      this.eventHandler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas);
      this.initLeftDownEventHandler();
      this.initMouseMoveEventHandler();
      this.initLeftUpEventHandler();
    }
  }, {
    "key" : "unRegisterMouseEvents",
    "value" : function() {
      this.eventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOWN);
      this.eventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_UP);
      this.eventHandler.removeInputAction(Cesium.ScreenSpaceEventType.MOUSE_MOVE);
    }
  }, {
    "key" : `destroy`,
    "value" : function() {
      this.unRegisterMouseEvents();
      this.viewer = void 0;
      this.gltfPlotLayer = void 0;
      this.eventHandler = void 0;
    }
  }, {
    "key" : `initLeftDownEventHandler`,
    "value" : function() {
      var data = this;
      this.eventHandler.setInputAction(function(result) {
        var String = hahaha;
        if (!!data[String(2038)][String(1277)]) {
          if ((result = data[String(2276)].scene[String(1708)](result[String(586)])) && result.id && String(2360) === result.id[String(1720)] && data[String(2038)].selectedPlot.properties[String(2717)] == result.id[String(2717)]) {
            data[String(2276)][String(1633)] = false;
            document.body[String(1998)][String(737)] = String(367);
            data.moveing = true;
            data[String(2038)][String(1277)][String(2556)](false);
            data[String(825)] = new Date(data[String(2276)]);
            data.viewer[String(2758)].screenSpaceCameraController.enableRotate = false;
          }
        }
      }, Cesium.ScreenSpaceEventType.LEFT_DOWN);
    }
  }, {
    "key" : `initLeftUpEventHandler`,
    "value" : function() {
      var self = this;
      this.eventHandler.setInputAction(function(canCreateDiscussions) {
        if (self.moveing) {
          self.viewer.enableCursorStyle = true;
          document.body.style.cursor = "default";
          self.moveing = false;
          self.viewer.scene.screenSpaceCameraController.enableRotate = true;
          self.mousePoint.remove();
          self.mousePoint = void 0;
          if (self.gltfPlotLayer.selectedPlot) {
            self.gltfPlotLayer.selectedPlot.setVisible(true);
          }
        }
      }, Cesium.ScreenSpaceEventType.LEFT_UP);
    }
  }, {
    "key" : `initMouseMoveEventHandler`,
    "value" : function() {
      var self = this;
      this.eventHandler.setInputAction(function(event) {
        var put_rows = hahaha;
        if (!!self.moveing) {
          if (event = self.viewer[put_rows(2758)][put_rows(1238)](event.endPosition)) {
            self.mousePoint[put_rows(3164)](event);
            self.gltfPlotLayer[put_rows(1277)].updatePosition(event);
          }
        }
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
    }
  }]);
  name = left;
  var Type = (expect(_update, [{
    "key" : `addGltfEntity`,
    "value" : function() {
      this.gltfEntity = this.viewer.entities.add({
        "type" : "GltfPlot",
        "plotCode" : this.properties.plotCode,
        "position" : this.position,
        "orientation" : this.orientation,
        "model" : {
          "uri" : this.properties.modelUrl,
          "colorBlendMode" : Cesium.ColorBlendMode.HIGHLIGHT,
          "color" : Cesium.Color.WHITE,
          "scale" : this.style.scale,
          "maximumScale" : this.style.scale
        }
      });
    }
  }, {
    "key" : "setVisible",
    "value" : function(value) {
      this.gltfEntity.show = value;
    }
  }, {
    "key" : `setSelected`,
    "value" : function(name) {
      if (name) {
        this.gltfEntity.model.silhouetteColor = Cesium.Color.fromAlpha(Cesium.Color.YELLOW, 1);
        this.gltfEntity.model.silhouetteSize = 4;
      } else {
        this.gltfEntity.model.silhouetteColor = Cesium.Color.fromAlpha(Cesium.Color.YELLOW, 1);
        this.gltfEntity.model.silhouetteSize = 0;
      }
    }
  }, {
    "key" : `setScale`,
    "value" : function(value) {
      this.gltfEntity.model.scale = value;
      this.gltfEntity.model.maximumScale = value;
      this.style.scale = value;
    }
  }, {
    "key" : `getPosition`,
    "value" : function() {
      return this.gltfEntity.position;
    }
  }, {
    "key" : `updatePosition`,
    "value" : function(value) {
      this.gltfEntity.position = value;
      value = Cesium.Cartographic.fromCartesian(value);
      this.coordinates = [Cesium.Math.toDegrees(value.longitude), Cesium.Math.toDegrees(value.latitude), value.height];
    }
  }, {
    "key" : `updateHeading`,
    "value" : function(value) {
      this.style.heading = value;
      value = new Cesium["HeadingPitchRoll"](Cesium.Math.toRadians(value), Cesium.Math.toRadians(0), Cesium.Math.toRadians(0));
      this.gltfEntity.orientation = Cesium.Transforms.headingPitchRollQuaternion(this.position, value);
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.viewer.entities.remove(this.gltfEntity);
    }
  }, {
    "key" : "toGeoJson",
    "value" : function() {
      return {
        "type" : "Feature",
        "properties" : this.properties,
        "geometry" : {
          "type" : "Point",
          "coordinates" : this.coordinates
        }
      };
    }
  }]), _update);
  _inherits(ContributorList, meta);
  expect(ContributorList, [{
    "key" : `addPlot`,
    "value" : function(type) {
      type = new Type(this.viewer, type);
      this.plots.push(type);
    }
  }, {
    "key" : `selectedEntityChanged`,
    "value" : function(type) {
      if (this.plotSelecteable) {
        if (!type) {
          return this.clearSelectedPlot(), void this.selectedPlotChanged.raiseEvent(void 0);
        }
        type = this.getByPlotCode(type.plotCode);
        if (!type) {
          return this.clearSelectedPlot(), void this.selectedPlotChanged.raiseEvent(void 0);
        }
        if (this.selectedPlot) {
          if (this.selectedPlot.properties.plotCode == type.properties.plotCode) {
            return;
          }
          this.clearSelectedPlot();
        }
        this.selectedPlot = type;
        this.selectedPlot.setSelected(true);
        this.selectedPlotChanged.raiseEvent(type);
      }
    }
  }, {
    "key" : `flyToByPlotCode`,
    "value" : function(name) {
      var t = this.getByPlotCode(name);
      if (t) {
        this.viewer.flyTo(t.gltfEntity);
        this.setSelectedPlotByCode(name);
      }
    }
  }, {
    "key" : `setSelectedPlotByCode`,
    "value" : function(name) {
      this.clearSelectedPlot();
      name = this.getByPlotCode(name);
      if (name) {
        this.viewer.selectedEntity = name.gltfEntity;
        this.selectedPlot = name;
        this.selectedPlot.setSelected(true);
      }
    }
  }, {
    "key" : `clearSelectedPlot`,
    "value" : function() {
      if (this.selectedPlot) {
        this.selectedPlot.setVisible(true);
        this.selectedPlot.setSelected(false);
        this.selectedPlot = void 0;
      }
    }
  }]);
  location = ContributorList;
  xt3d.GltfModel = {
    "FloorManager" : definition,
    "RotatingModel" : obj,
    "getPlotCode" : createIntervalElements,
    "cartesian3ToCoordinates" : compute,
    "GltfPlot" : {
      "PlotDraw" : descriptor,
      "PlotEdit" : name,
      "PlotLayer" : location
    }
  };
  expect(offset, [{
    "key" : `init`,
    "value" : function() {
      this.viewer.scene.invertClassification = true;
      this.viewer.scene.invertClassificationColor = this.style.color || new Cesium["Color"](1, 1, 1, 1);
      this.addBottomPolygon();
      this.addPrimitive();
    }
  }, {
    "key" : `addBottomPolygon`,
    "value" : function() {
      var cssChanges = this;
      this.bottomPolygon = this.viewer.entities.add({
        "polygon" : {
          "hierarchy" : new Cesium["PolygonHierarchy"](Cesium.Cartesian3.fromDegreesArray(this.degreesArray)),
          "height" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
            return cssChanges.height;
          }, false),
          "material" : Cesium.Color.YELLOW.withAlpha(0.2),
          "outline" : true,
          "outlineColor" : Cesium.Color.RED
        }
      });
    }
  }, {
    "key" : `addPrimitive`,
    "value" : function() {
      var promiseGeom = this.createGeometry();
      this.addClassificationPrimitive(promiseGeom);
    }
  }, {
    "key" : `setHeight`,
    "value" : function(name) {
      this.height = name || 100;
      this.removePrimitive();
      this.addPrimitive();
    }
  }, {
    "key" : `createGeometry`,
    "value" : function() {
      return new Cesium.PolygonGeometry({
        "polygonHierarchy" : new Cesium["PolygonHierarchy"](Cesium.Cartesian3.fromDegreesArray(this.degreesArray)),
        "perPositionHeight" : true,
        "height" : this.height,
        "extrudedHeight" : 2E5
      });
    }
  }, {
    "key" : `addClassificationPrimitive`,
    "value" : function(name) {
      this.cPrimitive = this.viewer.scene.primitives.add(new Cesium.ClassificationPrimitive({
        "geometryInstances" : new Cesium["GeometryInstance"]({
          "geometry" : Cesium.PolygonGeometry.createGeometry(name),
          "attributes" : {
            "color" : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.RED.withAlpha(0.6)),
            "show" : new Cesium.ShowGeometryInstanceAttribute(true)
          }
        }),
        "classificationType" : Cesium.ClassificationType.CESIUM_3D_TILE,
        "asynchronous" : false
      }));
    }
  }, {
    "key" : `removePrimitive`,
    "value" : function() {
      this.viewer.scene.primitives.remove(this.cPrimitive);
    }
  }, {
    "key" : "remove",
    "value" : function() {
      this.viewer.scene.invertClassification = false;
      this.viewer.entities.remove(this.bottomPolygon);
    }
  }]);
  frame = offset;
  expect(u, [{
    "key" : `activate`,
    "value" : function() {
      this.deactivate();
      this.clear();
      this.positions = [];
      this.tempPositions = [];
      this.registerEvents();
      this.viewer.enableCursorStyle = false;
      this.viewer._element.style.cursor = "default";
    }
  }, {
    "key" : `deactivate`,
    "value" : function() {
      this.unRegisterEvents();
      this.viewer._element.style.cursor = "pointer";
      this.viewer.enableCursorStyle = true;
    }
  }, {
    "key" : `clear`,
    "value" : function() {
      var same = this;
      if (this.circleEntity) {
        this.viewer.entities.remove(this.circleEntity);
        this.circleEntity = void 0;
      }
      if (this.viewEntity) {
        this.viewer.entities.remove(this.viewEntity);
        this.viewEntity = void 0;
      }
      if (this.resultPolylines) {
        this.resultPolylines.forEach(function(tObject3d) {
          var rel2Mstr = hahaha;
          same[rel2Mstr(2276)][rel2Mstr(1319)].remove(tObject3d);
        });
      }
    }
  }, {
    "key" : `initEvents`,
    "value" : function() {
      this.handler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas);
    }
  }, {
    "key" : `registerEvents`,
    "value" : function() {
      this.leftClickEvent();
      this.rightClickEvent();
      this.mouseMoveEvent();
    }
  }, {
    "key" : `leftClickEvent`,
    "value" : function() {
      var objects = this;
      this.handler.setInputAction(function(primaryReplicas) {
        var stringify = hahaha;
        objects[stringify(2276)]._element[stringify(1998)].cursor = stringify(1654);
        var falseySection = objects[stringify(2276)].scene[stringify(1238)](primaryReplicas[stringify(586)]);
        if (falseySection = falseySection || objects[stringify(2276)][stringify(2758)][stringify(1306)].pickEllipsoid(primaryReplicas[stringify(586)], objects[stringify(2276)][stringify(2758)][stringify(2359)][stringify(1923)])) {
          objects[stringify(1707)].push(falseySection);
          if (1 == objects[stringify(1707)][stringify(2189)]) {
            objects[stringify(3119)][stringify(2008)](falseySection);
            objects[stringify(2724)]();
          } else {
            objects.drawEnd();
          }
        }
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
    }
  }, {
    "key" : `handleFirstPosition`,
    "value" : function() {
      this.generateView();
      this.generateCircle();
    }
  }, {
    "key" : `generateCircle`,
    "value" : function() {
      var rpm_traffic = this;
      this.circleEntity = this.viewer.entities.add({
        "position" : this.positions[0],
        "ellipse" : {
          "semiMinorAxis" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
            var now = hahaha;
            return rpm_traffic[now(2424)]();
          }, false),
          "semiMajorAxis" : new Cesium.CallbackProperty(function(canCreateDiscussions) {
            var now = hahaha;
            return rpm_traffic[now(2424)]();
          }, false),
          "material" : Cesium.Color.RED.withAlpha(0.6),
          "classificationType" : Cesium.ClassificationType.BOTH
        }
      });
    }
  }, {
    "key" : `getRadius`,
    "value" : function() {
      var a = this.tempPositions[0];
      var value = this.tempPositions[0];
      return 1 < this.tempPositions.length && (value = this.tempPositions[1]), value = Cesium.Cartesian3.distance(a, value), 0 == value ? 0.000001 : value;
    }
  }, {
    "key" : `generateView`,
    "value" : function() {
      this.viewEntity = this.viewer.entities.add({
        "position" : this.positions[0],
        "label" : {
          "text" : "\u89c2\u5bdf\u4f4d\u7f6e",
          "fillColor" : Cesium.Color.WHITE,
          "scale" : 0.5,
          "font" : "normal 34px MicroSoft YaHei",
          "distanceDisplayCondition" : new Cesium.DistanceDisplayCondition(0, 5E3),
          "scaleByDistance" : new Cesium["NearFarScalar"](500, 1, 1500, 0.4),
          "verticalOrigin" : Cesium.VerticalOrigin.BOTTOM,
          "style" : Cesium.LabelStyle.FILL_AND_OUTLINE,
          "pixelOffset" : new Cesium["Cartesian2"](0, -20),
          "outlineWidth" : 3,
          "outlineColor" : Cesium.Color.BLACK
        },
        "point" : {
          "color" : Cesium.Color.DODGERBLUE,
          "pixelSize" : 5,
          "outlineColor" : Cesium.Color.WHITE,
          "outlineWidth" : 2,
          "scaleByDistance" : new Cesium["NearFarScalar"](1E3, 1, 4200, 0.4),
          "disableDepthTestDistance" : 500
        }
      });
    }
  }, {
    "key" : "mouseMoveEvent",
    "value" : function() {
      var obj = this;
      this.handler.setInputAction(function(currentItems) {
        var parseInt = hahaha;
        obj[parseInt(2276)]._element.style[parseInt(737)] = parseInt(1654);
        var member = obj[parseInt(2276)][parseInt(2758)][parseInt(1238)](currentItems[parseInt(2840)]);
        if ((member = member || obj[parseInt(2276)][parseInt(2758)][parseInt(1306)].pickEllipsoid(currentItems[parseInt(1108)], obj[parseInt(2276)][parseInt(2758)][parseInt(2359)][parseInt(1923)])) && obj[parseInt(2983)]) {
          obj[parseInt(3119)] = obj[parseInt(1707)][parseInt(439)]([member]);
        }
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
    }
  }, {
    "key" : "rightClickEvent",
    "value" : function() {
      var receiver = this;
      this.handler.setInputAction(function(canCreateDiscussions) {
        var toPythonCase = hahaha;
        if (receiver[toPythonCase(2983)]) {
          if (receiver[toPythonCase(1707)][toPythonCase(2189)] < 2) {
            receiver.clear();
            receiver[toPythonCase(1983)]();
          }
        } else {
          receiver[toPythonCase(1983)]();
        }
      }, Cesium.ScreenSpaceEventType.RIGHT_CLICK);
    }
  }, {
    "key" : `unRegisterEvents`,
    "value" : function() {
      this.handler.removeInputAction(Cesium.ScreenSpaceEventType.RIGHT_CLICK);
      this.handler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_CLICK);
      this.handler.removeInputAction(Cesium.ScreenSpaceEventType.MOUSE_MOVE);
      this.handler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);
    }
  }, {
    "key" : `drawEnd`,
    "value" : function() {
      this.startnalysis();
      this.viewer.entities.remove(this.circleEntity);
      this.deactivate();
    }
  }, {
    "key" : "startnalysis",
    "value" : function() {
      var result = Cesium.Cartographic.fromCartesian(this.positions[0]);
      result = val([Cesium.Math.toDegrees(result.longitude), Cesium.Math.toDegrees(result.latitude)], this.getRadius());
      var points = this.point2dToPoint3d(result);
      this.resultPolylines = [];
      var lat;
      var gridPoint;
      var lastviewmatrix;
      var newNodeLists;
      var i = 0;
      for (; i < points.length; i++) {
        lat = Cesium.Cartesian3.normalize(Cesium.Cartesian3.subtract(points[i], this.positions[0], new Cesium["Cartesian3"]), new Cesium["Cartesian3"]);
        gridPoint = new Cesium.Ray(this.positions[0], lat);
        lastviewmatrix = this.viewer.scene.pickFromRay(gridPoint, [this.viewEntity, this.targetEntity]);
        newNodeLists = this.showIntersection(lastviewmatrix, points[i], this.positions[0]);
        this.resultPolylines = this.resultPolylines.concat(newNodeLists);
      }
    }
  }, {
    "key" : `point2dToPoint3d`,
    "value" : function(name) {
      var that = [];
      var i = 0;
      for (; i < name.length; i++) {
        var particle = name[i];
        particle = Cesium.Cartesian3.fromDegrees(particle[0], particle[1], 0);
        particle = this.viewer.scene.clampToHeight(particle);
        that.push(particle);
      }
      return that;
    }
  }, {
    "key" : `showIntersection`,
    "value" : function(value, obj, tag) {
      var past = [];
      var present = void 0;
      present = Cesium.defined(value) && Cesium.defined(value.object) ? (present = this.drawResultLine(value.position, tag, Cesium.Color.CHARTREUSE), past.push(present), this.drawResultLine(value.position, obj, Cesium.Color.RED)) : this.drawResultLine(tag, obj, Cesium.Color.CHARTREUSE);
      return past.push(present), past;
    }
  }, {
    "key" : "drawResultLine",
    "value" : function(name, source, type) {
      return this.viewer.entities.add({
        "polyline" : {
          "positions" : [name, source],
          "width" : 2,
          "material" : type,
          "depthFailMaterial" : type
        }
      });
    }
  }]);
  init = u;
  expect(pattern, [{
    "key" : `activate`,
    "value" : function() {
      this.deactivate();
      this.clear();
      this.positions = [];
      this.tempPositions = [];
      this.registerEvents();
      this.viewer.enableCursorStyle = false;
      this.viewer._element.style.cursor = "default";
    }
  }, {
    "key" : `deactivate`,
    "value" : function() {
      this.unRegisterEvents();
      this.viewer._element.style.cursor = "pointer";
      this.viewer.enableCursorStyle = true;
    }
  }, {
    "key" : "clear",
    "value" : function() {
      var same = this;
      if (this.polylineEntity) {
        this.viewer.entities.remove(this.polylineEntity);
        this.polylineEntity = void 0;
      }
      if (this.viewEntity) {
        this.viewer.entities.remove(this.viewEntity);
        this.viewEntity = void 0;
      }
      if (this.targetEntity) {
        this.viewer.entities.remove(this.targetEntity);
        this.targetEntity = void 0;
      }
      if (this.resultPolylines) {
        this.resultPolylines.forEach(function(mmCoreSplitViewBlock) {
          var rel2Mstr = hahaha;
          same[rel2Mstr(2276)][rel2Mstr(1319)][rel2Mstr(508)](mmCoreSplitViewBlock);
        });
      }
    }
  }, {
    "key" : `initEvents`,
    "value" : function() {
      this.handler = new Cesium["ScreenSpaceEventHandler"](this.viewer.scene.canvas);
    }
  }, {
    "key" : `registerEvents`,
    "value" : function() {
      this.leftClickEvent();
      this.rightClickEvent();
      this.mouseMoveEvent();
    }
  }, {
    "key" : `leftClickEvent`,
    "value" : function() {
      var obj = this;
      this.handler.setInputAction(function(pBufferSet) {
        var parseInt = hahaha;
        obj[parseInt(2276)]._element[parseInt(1998)][parseInt(737)] = parseInt(1654);
        var artistTrack = obj[parseInt(2276)].scene[parseInt(1238)](pBufferSet.position);
        if (artistTrack = artistTrack || obj[parseInt(2276)][parseInt(2758)][parseInt(1306)][parseInt(1080)](pBufferSet[parseInt(586)], obj[parseInt(2276)][parseInt(2758)][parseInt(2359)][parseInt(1923)])) {
          obj[parseInt(1707)][parseInt(2008)](artistTrack);
          if (1 == obj.positions[parseInt(2189)]) {
            obj[parseInt(2724)]();
          } else {
            obj[parseInt(2788)]();
          }
        }
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
    }
  }, {
    "key" : `handleFirstPosition`,
    "value" : function() {
      this.generateView();
      this.generatePolyline();
    }
  }, {
    "key" : `generatePolyline`,
    "value" : function() {
      var primaryReplicas = this;
      this.polylineEntity = this.viewer.entities.add({
        "polyline" : {
          "positions" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
            var stringify = hahaha;
            return primaryReplicas[stringify(3119)];
          }, false),
          "width" : 2,
          "material" : new Cesium["PolylineDashMaterialProperty"]({
            "color" : Cesium.Color.YELLOW
          }),
          "depthFailMaterial" : new Cesium["PolylineDashMaterialProperty"]({
            "color" : Cesium.Color.YELLOW
          })
        }
      });
    }
  }, {
    "key" : `generateView`,
    "value" : function() {
      this.viewEntity = this.viewer.entities.add({
        "position" : this.positions[0],
        "label" : {
          "text" : "\u89c2\u5bdf\u4f4d\u7f6e",
          "fillColor" : Cesium.Color.WHITE,
          "scale" : 0.5,
          "font" : "normal 34px MicroSoft YaHei",
          "distanceDisplayCondition" : new Cesium.DistanceDisplayCondition(0, 5E3),
          "scaleByDistance" : new Cesium.NearFarScalar(500, 1, 1500, 0.4),
          "verticalOrigin" : Cesium.VerticalOrigin.BOTTOM,
          "style" : Cesium.LabelStyle.FILL_AND_OUTLINE,
          "pixelOffset" : new Cesium["Cartesian2"](0, -20),
          "outlineWidth" : 3,
          "outlineColor" : Cesium.Color.BLACK
        },
        "point" : {
          "color" : Cesium.Color.DODGERBLUE,
          "pixelSize" : 5,
          "outlineColor" : Cesium.Color.WHITE,
          "outlineWidth" : 2,
          "scaleByDistance" : new Cesium["NearFarScalar"](1E3, 1, 4200, 0.4),
          "disableDepthTestDistance" : 500
        }
      });
    }
  }, {
    "key" : `generateEndPoint`,
    "value" : function() {
      this.targetEntity = this.viewer.entities.add({
        "position" : this.positions[1],
        "label" : {
          "text" : "\u76ee\u6807\u4f4d\u7f6e",
          "fillColor" : Cesium.Color.WHITE,
          "scale" : 0.5,
          "font" : "normal 34px MicroSoft YaHei",
          "distanceDisplayCondition" : new Cesium["DistanceDisplayCondition"](0, 5E3),
          "scaleByDistance" : new Cesium["NearFarScalar"](500, 1, 1500, 0.4),
          "verticalOrigin" : Cesium.VerticalOrigin.BOTTOM,
          "style" : Cesium.LabelStyle.FILL_AND_OUTLINE,
          "pixelOffset" : new Cesium.Cartesian2(0, -20),
          "outlineWidth" : 3,
          "outlineColor" : Cesium.Color.BLACK
        },
        "point" : {
          "color" : Cesium.Color.DODGERBLUE,
          "pixelSize" : 5,
          "outlineColor" : Cesium.Color.WHITE,
          "outlineWidth" : 2,
          "scaleByDistance" : new Cesium["NearFarScalar"](1E3, 1, 4200, 0.4),
          "disableDepthTestDistance" : 500
        }
      });
    }
  }, {
    "key" : `mouseMoveEvent`,
    "value" : function() {
      var TYPES_RE = this;
      this.handler.setInputAction(function(primaryReplicas) {
        var stringify = hahaha;
        TYPES_RE[stringify(2276)][stringify(2530)][stringify(1998)][stringify(737)] = stringify(1654);
        var type = TYPES_RE[stringify(2276)][stringify(2758)][stringify(1238)](primaryReplicas[stringify(2840)]);
        if ((type = type || TYPES_RE[stringify(2276)][stringify(2758)][stringify(1306)].pickEllipsoid(primaryReplicas[stringify(1108)], TYPES_RE[stringify(2276)].scene.globe[stringify(1923)])) && TYPES_RE[stringify(1808)]) {
          TYPES_RE[stringify(3119)] = TYPES_RE[stringify(1707)][stringify(439)]([type]);
        }
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
    }
  }, {
    "key" : "rightClickEvent",
    "value" : function() {
      var same = this;
      this.handler.setInputAction(function(canCreateDiscussions) {
        var rel2Mstr = hahaha;
        if (same[rel2Mstr(1808)]) {
          if (same[rel2Mstr(1707)][rel2Mstr(2189)] < 2) {
            same[rel2Mstr(2822)]();
            same[rel2Mstr(1983)]();
          }
        } else {
          same[rel2Mstr(1983)]();
        }
      }, Cesium.ScreenSpaceEventType.RIGHT_CLICK);
    }
  }, {
    "key" : `unRegisterEvents`,
    "value" : function() {
      this.handler.removeInputAction(Cesium.ScreenSpaceEventType.RIGHT_CLICK);
      this.handler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_CLICK);
      this.handler.removeInputAction(Cesium.ScreenSpaceEventType.MOUSE_MOVE);
      this.handler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);
    }
  }, {
    "key" : `drawEnd`,
    "value" : function() {
      this.generateEndPoint();
      this.startnalysis();
      this.viewer.entities.remove(this.polylineEntity);
      this.deactivate();
    }
  }, {
    "key" : `startnalysis`,
    "value" : function() {
      var orientation = Cesium.Cartesian3.normalize(Cesium.Cartesian3.subtract(this.positions[1], this.positions[0], new Cesium.Cartesian3), new Cesium.Cartesian3);
      orientation = new Cesium.Ray(this.positions[0], orientation);
      orientation = this.viewer.scene.pickFromRay(orientation, [this.viewEntity, this.targetEntity]);
      this.resultPolylines = this.showIntersection(orientation, this.positions[1], this.positions[0]);
    }
  }, {
    "key" : `showIntersection`,
    "value" : function(value, obj, tag) {
      var past = [];
      var present = void 0;
      present = Cesium.defined(value) && Cesium.defined(value.object) ? (present = this.drawResultLine(value.position, tag, Cesium.Color.CHARTREUSE), past.push(present), this.drawResultLine(value.position, obj, Cesium.Color.RED)) : this.drawResultLine(tag, obj, Cesium.Color.CHARTREUSE);
      return past.push(present), past;
    }
  }, {
    "key" : `drawResultLine`,
    "value" : function(name, source, type) {
      return this.viewer.entities.add({
        "polyline" : {
          "positions" : [name, source],
          "width" : 2,
          "material" : type,
          "depthFailMaterial" : type
        }
      });
    }
  }]);
  data = pattern;
  var RotateControl = (expect(cycle, [{
    "key" : `updateEndPosition`,
    "value" : function(name) {
      this.viewPositionEnd = name;
    }
  }, {
    "key" : `getViewHeading`,
    "value" : function() {
      var matrix;
      var right;
      var p;
      return this.viewHeading = (matrix = this.viewPosition, right = this.viewPositionEnd, p = new Cesium["Cartesian3"], matrix = Cesium.Transforms.eastNorthUpToFixedFrame(matrix), Cesium.Matrix4.inverse(matrix, matrix), Cesium.Matrix4.multiplyByPoint(matrix, right, p), Cesium.Cartesian3.normalize(p, p), Cesium.Math.toDegrees(Math.atan2(p.x, p.y))), this.viewHeading;
    }
  }, {
    "key" : "getViewPitch",
    "value" : function() {
      var matrix;
      var right;
      var center;
      return this.viewPitch = (matrix = this.viewPosition, right = this.viewPositionEnd, center = new Cesium["Cartesian3"], matrix = Cesium.Transforms.eastNorthUpToFixedFrame(matrix), Cesium.Matrix4.inverse(matrix, matrix), Cesium.Matrix4.multiplyByPoint(matrix, right, center), Cesium.Cartesian3.normalize(center, center), Cesium.Math.toDegrees(Math.asin(center.z))), this.viewPitch;
    }
  }, {
    "key" : `getDistance`,
    "value" : function() {
      return this.viewDistance = Cesium.Cartesian3.distance(this.viewPosition, this.viewPositionEnd), this.viewDistance;
    }
  }, {
    "key" : "getOptions",
    "value" : function() {
      return {
        "viewPosition" : this.viewPosition,
        "viewPositionEnd" : this.viewPositionEnd,
        "viewDistance" : this.viewDistance,
        "viewHeading" : this.viewHeading,
        "viewPitch" : this.viewPitch,
        "horizontalViewAngle" : this.horizontalViewAngle,
        "verticalViewAngle" : this.verticalViewAngle
      };
    }
  }, {
    "key" : `drawFrustumOutline`,
    "value" : function() {
      var primaryReplicas = this;
      this.frustumOutline = this.viewer.entities.add({
        "name" : "frustumOutline",
        "position" : this.viewPosition,
        "orientation" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
          var stringify = hahaha;
          return Cesium[stringify(942)][stringify(1806)](primaryReplicas.viewPosition, Cesium[stringify(3172)][stringify(2770)](primaryReplicas[stringify(1477)]() - primaryReplicas[stringify(408)], primaryReplicas[stringify(1349)](), 0));
        }, false),
        "ellipsoid" : {
          "radii" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
            var stringify = hahaha;
            var _0x18d247 = primaryReplicas[stringify(883)]();
            return new (Cesium[stringify(3131)])(_0x18d247, _0x18d247, _0x18d247);
          }, false),
          "innerRadii" : new Cesium["Cartesian3"](0.01, 0.01, 0.01),
          "minimumClock" : Cesium.Math.toRadians(-this.horizontalViewAngle / 2),
          "maximumClock" : Cesium.Math.toRadians(this.horizontalViewAngle / 2),
          "minimumCone" : Cesium.Math.toRadians(this.verticalViewAngle + 7.75),
          "maximumCone" : Cesium.Math.toRadians(180 - this.verticalViewAngle - 7.75),
          "fill" : false,
          "outline" : true,
          "outlineColor" : Cesium.Color.AQUA
        }
      });
    }
  }, {
    "key" : "drawSketch",
    "value" : function() {
      var rpm_traffic = this;
      this.sketch = this.viewer.entities.add({
        "name" : "sketch",
        "position" : this.viewPosition,
        "orientation" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
          var now = hahaha;
          return Cesium[now(942)][now(1806)](rpm_traffic[now(662)], Cesium[now(3172)][now(2770)](rpm_traffic[now(1477)]() - rpm_traffic[now(408)], rpm_traffic[now(1349)](), 0));
        }, false),
        "ellipsoid" : {
          "radii" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
            var now = hahaha;
            var _0x3dff46 = rpm_traffic[now(883)]();
            return new (Cesium[now(3131)])(_0x3dff46, _0x3dff46, _0x3dff46);
          }, false),
          "minimumClock" : Cesium.Math.toRadians(-this.horizontalViewAngle / 2),
          "maximumClock" : Cesium.Math.toRadians(this.horizontalViewAngle / 2),
          "minimumCone" : Cesium.Math.toRadians(this.verticalViewAngle + 7.75),
          "maximumCone" : Cesium.Math.toRadians(180 - this.verticalViewAngle - 7.75),
          "fill" : false,
          "outline" : true,
          "subdivisions" : 256,
          "stackPartitions" : 64,
          "slicePartitions" : 64,
          "outlineColor" : Cesium.Color.AQUA
        }
      });
    }
  }, {
    "key" : "remove",
    "value" : function() {
      if (this.sketch) {
        this.viewer.entities.remove(this.sketch);
        this.sketch = null;
      }
      if (this.frustumOutline) {
        this.viewer.entities.remove(this.frustumOutline);
        this.frustumOutline = null;
      }
    }
  }]), cycle);
  var PressComposer = (expect(setValue, [{
    "key" : "add",
    "value" : function() {
      this.createLightCamera();
      this.createShadowMap();
      this.createPostStage();
      this.drawFrustumOutline();
      this.drawSketch();
    }
  }, {
    "key" : "getStyle",
    "value" : function() {
      return {
        "viewHeading" : this.viewHeading,
        "viewDistance" : this.viewDistance,
        "horizontalViewAngle" : this.horizontalViewAngle,
        "verticalViewAngle" : this.verticalViewAngle
      };
    }
  }, {
    "key" : `updateStyle`,
    "value" : function(name) {
      this.viewHeading = name.viewHeading;
      this.viewDistance = name.viewDistance;
      this.horizontalViewAngle = name.horizontalViewAngle;
      this.verticalViewAngle = name.verticalViewAngle;
      this.clear();
      this.add();
    }
  }, {
    "key" : "remove",
    "value" : function() {
      this.clear();
    }
  }, {
    "key" : `clear`,
    "value" : function() {
      if (this.sketch) {
        this.viewer.entities.removeById(this.sketch.id);
        this.sketch = null;
      }
      if (this.frustumOutline) {
        this.viewer.entities.remove(this.frustumOutline);
        this.frustumOutline = null;
      }
      if (this.postStage) {
        this.viewer.scene.postProcessStages.remove(this.postStage);
        this.postStage = null;
      }
    }
  }, {
    "key" : `createLightCamera`,
    "value" : function() {
      this.lightCamera = new Cesium["Camera"](this.viewer.scene);
      this.lightCamera.position = this.viewPosition;
      this.lightCamera.frustum.near = 0.001 * this.viewDistance;
      this.lightCamera.frustum.far = this.viewDistance;
      var min = Cesium.Math.toRadians(this.horizontalViewAngle);
      var maxItems = Cesium.Math.toRadians(this.verticalViewAngle);
      var aspectRatio = this.viewDistance * Math.tan(min / 2) * 2 / (this.viewDistance * Math.tan(maxItems / 2) * 2);
      this.lightCamera.frustum.aspectRatio = aspectRatio;
      this.lightCamera.frustum.fov = maxItems < min ? min : maxItems;
      this.lightCamera.setView({
        "destination" : this.viewPosition,
        "orientation" : {
          "heading" : Cesium.Math.toRadians(this.viewHeading || 0),
          "pitch" : Cesium.Math.toRadians(this.viewPitch || 0),
          "roll" : 0
        }
      });
    }
  }, {
    "key" : `createShadowMap`,
    "value" : function() {
      this.shadowMap = new Cesium["ShadowMap"]({
        "context" : this.viewer.scene.context,
        "lightCamera" : this.lightCamera,
        "enabled" : this.enabled,
        "isPointLight" : true,
        "pointLightRadius" : this.viewDistance,
        "cascadesEnabled" : false,
        "size" : this.size,
        "softShadows" : this.softShadows,
        "normalOffset" : false,
        "fromLightSource" : false
      });
      this.viewer.scene.shadowMap = this.shadowMap;
    }
  }, {
    "key" : `createPostStage`,
    "value" : function() {
      var rpm_traffic = this;
      var endColorCoords = new Cesium["PostProcessStage"]({
        "fragmentShader" : "\n#define USE_CUBE_MAP_SHADOW true\nuniform sampler2D colorTexture;\nuniform sampler2D depthTexture;\nvarying vec2 v_textureCoordinates;\nuniform mat4 camera_projection_matrix;\nuniform mat4 camera_view_matrix;\nuniform samplerCube shadowMap_textureCube;\nuniform mat4 shadowMap_matrix;\nuniform vec4 shadowMap_lightPositionEC;\nuniform vec4 shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness;\nuniform vec4 shadowMap_texelSizeDepthBiasAndNormalShadingSmooth;\nuniform float x_viewDistance; \nuniform vec4 x_visibleAreaColor;\nuniform vec4 x_invisibleAreaColor;\nstruct zx_shadowParameters\n{\n    vec3 texCoords;\n    float depthBias;\n    float depth;\n    float nDotL;\n    vec2 texelStepSize;\n    float normalShadingSmooth;\n    float darkness;\n};\nfloat czm_shadowVisibility(samplerCube shadowMap, zx_shadowParameters shadowParameters)\n{\n    float depthBias = shadowParameters.depthBias;\n    float depth = shadowParameters.depth;\n    float nDotL = shadowParameters.nDotL;\n    float normalShadingSmooth = shadowParameters.normalShadingSmooth;\n    float darkness = shadowParameters.darkness;\n    vec3 uvw = shadowParameters.texCoords;\n    depth -= depthBias;\n    float visibility = czm_shadowDepthCompare(shadowMap, uvw, depth);\n    return czm_private_shadowVisibility(visibility, nDotL, normalShadingSmooth, darkness);\n}\nvec4 getPositionEC(){\n    return czm_windowToEyeCoordinates(gl_FragCoord);\n}\nvec3 getNormalEC(){\n    return vec3(1.);\n}\nvec4 toEye(in vec2 uv,in float depth){\n    vec2 xy=vec2((uv.x*2.-1.),(uv.y*2.-1.));\n    vec4 posInCamera=czm_inverseProjection*vec4(xy,depth,1.);\n    posInCamera=posInCamera/posInCamera.w;\n    return posInCamera;\n}\nvec3 pointProjectOnPlane(in vec3 planeNormal,in vec3 planeOrigin,in vec3 point){\n    vec3 v01=point-planeOrigin;\n    float d=dot(planeNormal,v01);\n    return(point-planeNormal*d);\n}\nfloat getDepth(in vec4 depth){\n    float z_window=czm_unpackDepth(depth);\n    z_window=czm_reverseLogDepth(z_window);\n    float n_range=czm_depthRange.near;\n    float f_range=czm_depthRange.far;\n    return(2.*z_window-n_range-f_range)/(f_range-n_range);\n}\nfloat shadow(in vec4 positionEC){\n    vec3 normalEC=getNormalEC();\n    zx_shadowParameters shadowParameters;\n    shadowParameters.texelStepSize=shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.xy;\n    shadowParameters.depthBias=shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.z;\n    shadowParameters.normalShadingSmooth=shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.w;\n    shadowParameters.darkness=shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.w;\n    vec3 directionEC=positionEC.xyz-shadowMap_lightPositionEC.xyz;\n    float distance=length(directionEC);\n    directionEC=normalize(directionEC);\n    float radius=shadowMap_lightPositionEC.w;\n    if(distance>radius)\n    {\n        return 2.0;\n    }\n    vec3 directionWC=czm_inverseViewRotation*directionEC;\n    shadowParameters.depth=distance/radius-0.0003;\n    shadowParameters.nDotL=clamp(dot(normalEC,-directionEC),0.,1.);\n    shadowParameters.texCoords=directionWC;\n    float visibility=czm_shadowVisibility(shadowMap_textureCube,shadowParameters);\n    return visibility;\n}\nbool visible(in vec4 result)\n{\n    result.x/=result.w;\n    result.y/=result.w;\n    result.z/=result.w;\n    return result.x>=-1.&&result.x<=1.\n    &&result.y>=-1.&&result.y<=1.\n    &&result.z>=-1.&&result.z<=1.;\n}\nvoid main(){\n    // \u91c9\u8272 = \u7ed3\u6784\u4e8c\u7ef4(\u989c\u8272\u7eb9\u7406, \u7eb9\u7406\u5750\u6807)\n    gl_FragColor = texture2D(colorTexture, v_textureCoordinates);\n    // \u6df1\u5ea6 = \u83b7\u53d6\u6df1\u5ea6(\u7ed3\u6784\u4e8c\u7ef4(\u6df1\u5ea6\u7eb9\u7406, \u7eb9\u7406\u5750\u6807))\n    float depth = getDepth(texture2D(depthTexture, v_textureCoordinates));\n    // \u89c6\u89d2 = (\u7eb9\u7406\u5750\u6807, \u6df1\u5ea6)\n    vec4 viewPos = toEye(v_textureCoordinates, depth);\n    // \u4e16\u754c\u5750\u6807\n    vec4 wordPos = czm_inverseView * viewPos;\n    // \u865a\u62df\u76f8\u673a\u4e2d\u5750\u6807\n    vec4 vcPos = camera_view_matrix * wordPos;\n    float near = .001 * x_viewDistance;\n    float dis = length(vcPos.xyz);\n    if(dis > near && dis < x_viewDistance){\n        // \u900f\u89c6\u6295\u5f71\n        vec4 posInEye = camera_projection_matrix * vcPos;\n        // \u53ef\u89c6\u533a\u989c\u8272\n        //  vec4 x_visibleAreaColor=vec4(0.,1.,0.,1.0);\n        //  vec4 x_invisibleAreaColor=vec4(1.,0.,0.,1.0);\n        if(visible(posInEye)){\n            float vis = shadow(viewPos);\n            if(vis > 0.3){\n                gl_FragColor = mix(gl_FragColor,x_visibleAreaColor,.7);\n            } else{\n                gl_FragColor = mix(gl_FragColor,x_invisibleAreaColor,.7);\n            }\n        }\n    }\n}",
        "uniforms" : {
          "shadowMap_textureCube" : function() {
            var now = hahaha;
            return rpm_traffic[now(1839)].update(Reflect[now(3127)](rpm_traffic[now(2276)][now(2758)], "_frameState")), Reflect[now(3127)](rpm_traffic[now(1839)], "_shadowMapTexture");
          },
          "shadowMap_matrix" : function() {
            var now = hahaha;
            return rpm_traffic.shadowMap[now(553)](Reflect[now(3127)](rpm_traffic[now(2276)][now(2758)], now(389))), Reflect[now(3127)](rpm_traffic[now(1839)], now(1944));
          },
          "shadowMap_lightPositionEC" : function() {
            var now = hahaha;
            return rpm_traffic.shadowMap.update(Reflect.get(rpm_traffic[now(2276)][now(2758)], now(389))), Reflect[now(3127)](rpm_traffic[now(1839)], now(801));
          },
          "shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness" : function() {
            var now = hahaha;
            rpm_traffic[now(1839)].update(Reflect[now(3127)](rpm_traffic[now(2276)][now(2758)], "_frameState"));
            var result = rpm_traffic.shadowMap[now(2827)];
            return Cesium[now(2399)].fromElements(result.normalOffsetScale, rpm_traffic[now(1839)][now(2942)], rpm_traffic.shadowMap.maximumDistance, 0, new (Cesium[now(2399)]));
          },
          "shadowMap_texelSizeDepthBiasAndNormalShadingSmooth" : function() {
            var edgeId = hahaha;
            rpm_traffic.shadowMap[edgeId(553)](Reflect[edgeId(3127)](rpm_traffic[edgeId(2276)][edgeId(2758)], edgeId(389)));
            var updatedEdgesById = rpm_traffic[edgeId(1839)]._pointBias;
            var xhair = new (Cesium[edgeId(2689)]);
            return xhair.x = 1 / rpm_traffic[edgeId(1839)][edgeId(1351)].x, xhair.y = 1 / rpm_traffic[edgeId(1839)][edgeId(1351)].y, Cesium[edgeId(2399)][edgeId(1740)](xhair.x, xhair.y, updatedEdgesById.depthBias, updatedEdgesById[edgeId(1702)], new (Cesium[edgeId(2399)]));
          },
          "camera_projection_matrix" : function() {
            var now = hahaha;
            return rpm_traffic[now(2338)][now(1841)][now(2273)];
          },
          "camera_view_matrix" : function() {
            var now = hahaha;
            return rpm_traffic[now(2338)][now(1438)];
          },
          "x_viewDistance" : function() {
            var now = hahaha;
            return rpm_traffic[now(3015)];
          },
          "x_visibleAreaColor" : this.visibleAreaColor,
          "x_invisibleAreaColor" : this.invisibleAreaColor
        }
      });
      this.postStage = this.viewer.scene.postProcessStages.add(endColorCoords);
    }
  }, {
    "key" : `drawFrustumOutline`,
    "value" : function() {
      var value = this;
      this.frustumOutline = this.viewer.entities.add({
        "name" : "frustumOutline",
        "position" : this.viewPosition,
        "orientation" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
          var put_rows = hahaha;
          return Cesium[put_rows(942)].headingPitchRollQuaternion(value[put_rows(662)], Cesium.HeadingPitchRoll[put_rows(2770)](value[put_rows(1730)] - 90, value[put_rows(1489)], 0));
        }, false),
        "ellipsoid" : {
          "radii" : new Cesium.CallbackProperty(function(canCreateDiscussions) {
            var put_rows = hahaha;
            return new Cesium.Cartesian3(value[put_rows(3015)], value[put_rows(3015)], value.viewDistance);
          }, false),
          "innerRadii" : new Cesium["Cartesian3"](0.01, 0.01, 0.01),
          "minimumClock" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
            var put_rows = hahaha;
            return Cesium[put_rows(2090)].toRadians(-value.horizontalViewAngle / 2);
          }, false),
          "maximumClock" : new Cesium.CallbackProperty(function(canCreateDiscussions) {
            var put_rows = hahaha;
            return Cesium[put_rows(2090)][put_rows(1544)](value[put_rows(408)] / 2);
          }, false),
          "minimumCone" : Cesium.Math.toRadians(this.verticalViewAngle + 7.75),
          "maximumCone" : Cesium.Math.toRadians(180 - this.verticalViewAngle - 7.75),
          "fill" : false,
          "slicePartitions" : 1,
          "stackPartitions" : 1,
          "outline" : true,
          "outlineColor" : Cesium.Color.AQUA
        }
      });
    }
  }, {
    "key" : `drawSketch`,
    "value" : function() {
      var primaryReplicas = this;
      this.sketch = this.viewer.entities.add({
        "name" : "sketch",
        "position" : this.viewPosition,
        "orientation" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
          var stringify = hahaha;
          return Cesium[stringify(942)].headingPitchRollQuaternion(primaryReplicas[stringify(662)], Cesium[stringify(3172)][stringify(2770)](primaryReplicas[stringify(1730)] - 90, primaryReplicas.viewPitch, 0));
        }, false),
        "ellipsoid" : {
          "radii" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
            var stringify = hahaha;
            return new (Cesium[stringify(3131)])(primaryReplicas[stringify(3015)], primaryReplicas.viewDistance, primaryReplicas[stringify(3015)]);
          }, false),
          "minimumClock" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
            var stringify = hahaha;
            return Cesium[stringify(2090)][stringify(1544)](-primaryReplicas[stringify(408)] / 2);
          }, false),
          "maximumClock" : new Cesium.CallbackProperty(function(canCreateDiscussions) {
            var stringify = hahaha;
            return Cesium.Math[stringify(1544)](primaryReplicas[stringify(408)] / 2);
          }, false),
          "minimumCone" : Cesium.Math.toRadians(this.verticalViewAngle + 7.75),
          "maximumCone" : Cesium.Math.toRadians(180 - this.verticalViewAngle - 7.75),
          "fill" : false,
          "outline" : true,
          "subdivisions" : 256,
          "stackPartitions" : 64,
          "slicePartitions" : 64,
          "outlineColor" : Cesium.Color.AQUA
        }
      });
    }
  }]), setValue);
  expect(response, [{
    "key" : "activate",
    "value" : function() {
      this.deactivate();
      this.clear();
      this.firstPosition = void 0;
      this.registerEvents();
      this.viewer.enableCursorStyle = false;
      this.viewer._element.style.cursor = "default";
    }
  }, {
    "key" : `deactivate`,
    "value" : function() {
      this.unRegisterEvents();
      this.viewer._element.style.cursor = "pointer";
      this.viewer.enableCursorStyle = true;
    }
  }, {
    "key" : "clear",
    "value" : function() {
      if (this.cameraLine) {
        this.cameraLine.remove();
        this.cameraLine = void 0;
      }
    }
  }, {
    "key" : `initEvents`,
    "value" : function() {
      this.handler = new Cesium["ScreenSpaceEventHandler"](this.viewer.scene.canvas);
      this.DrawEndEvent = new Cesium.Event;
    }
  }, {
    "key" : `registerEvents`,
    "value" : function() {
      this.leftClickEvent();
      this.rightClickEvent();
      this.mouseMoveEvent();
    }
  }, {
    "key" : `leftClickEvent`,
    "value" : function() {
      var _this = this;
      this.handler.setInputAction(function(pBufferSet) {
        var put_rows = hahaha;
        _this[put_rows(2276)][put_rows(2530)][put_rows(1998)][put_rows(737)] = put_rows(1654);
        var selector = _this.viewer[put_rows(2758)][put_rows(1238)](pBufferSet.position);
        if (selector = selector || _this[put_rows(2276)][put_rows(2758)][put_rows(1306)][put_rows(1080)](pBufferSet[put_rows(586)], _this[put_rows(2276)][put_rows(2758)][put_rows(2359)][put_rows(1923)])) {
          if (_this.firstPosition) {
            _this.drawEnd();
          } else {
            _this[put_rows(2481)] = _this[put_rows(3051)](selector);
          }
        }
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
    }
  }, {
    "key" : "getFirstPosition",
    "value" : function(type) {
      var ne = Cesium.Cartographic.fromCartesian(type);
      var longitude = Cesium.Math.toDegrees(ne.longitude);
      type = Cesium.Math.toDegrees(ne.latitude);
      ne = ne.height + 1;
      return Cesium.Cartesian3.fromDegrees(longitude, type, ne);
    }
  }, {
    "key" : `createCameraLine`,
    "value" : function(name) {
      this.cameraLine = new RotateControl(this.viewer, {
        "viewPosition" : this.firstPosition,
        "viewPositionEnd" : name
      });
    }
  }, {
    "key" : "mouseMoveEvent",
    "value" : function() {
      var obj = this;
      this.handler.setInputAction(function(result) {
        var parseInt = hahaha;
        obj[parseInt(2276)][parseInt(2530)][parseInt(1998)].cursor = "default";
        var member = obj[parseInt(2276)][parseInt(2758)][parseInt(1238)](result.endPosition);
        if ((member = member || obj[parseInt(2276)][parseInt(2758)][parseInt(1306)][parseInt(1080)](result.startPosition, obj.viewer[parseInt(2758)].globe[parseInt(1923)])) && obj[parseInt(2481)]) {
          if (obj[parseInt(648)]) {
            obj.cameraLine.updateEndPosition(member);
          } else {
            obj.createCameraLine(member);
          }
        }
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
    }
  }, {
    "key" : `rightClickEvent`,
    "value" : function() {
      var primaryReplicas = this;
      this.handler.setInputAction(function(canCreateDiscussions) {
        var stringify = hahaha;
        if (primaryReplicas[stringify(2481)]) {
          primaryReplicas[stringify(2822)]();
        }
        primaryReplicas[stringify(1983)]();
      }, Cesium.ScreenSpaceEventType.RIGHT_CLICK);
    }
  }, {
    "key" : "unRegisterEvents",
    "value" : function() {
      this.handler.removeInputAction(Cesium.ScreenSpaceEventType.RIGHT_CLICK);
      this.handler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_CLICK);
      this.handler.removeInputAction(Cesium.ScreenSpaceEventType.MOUSE_MOVE);
      this.handler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);
    }
  }, {
    "key" : `drawEnd`,
    "value" : function() {
      this.viewShedStage = new PressComposer(this.viewer, this.cameraLine.getOptions());
      this.DrawEndEvent.raiseEvent(this.viewShedStage);
      this.cameraLine.remove();
      this.deactivate();
    }
  }]);
  definition = response;
  obj = {
    "pointBuffer" : function(pt, duration, unit) {
      return pt = turf.point(pt), unit = unit || {
        "units" : "meters",
        "z" : 0
      }, duration = turf.buffer(pt, duration || 100, unit).geometry.coordinates[0], unit = this.pointsToDegreesArray(duration, unit.z || 0), Cesium.Cartesian3.fromDegreesArrayHeights(unit);
    },
    "polylineBuffer" : function(line, callback, key) {
      var feature = turf.lineString(line);
      return key = key || {
        "units" : "meters",
        "z" : 0
      }, line = turf.buffer(feature, callback || 100, key).geometry.coordinates[0], key = this.pointsToDegreesArray(line, key.z || 0), Cesium.Cartesian3.fromDegreesArrayHeights(key);
    },
    "polygonBuffer" : function(polygon, reorder, areaPositive) {
      return this.polylineBuffer(polygon, reorder, areaPositive);
    },
    "pointsToDegreesArray" : function(pattern, expr) {
      var tokens = [];
      return pattern.map(function(word) {
        tokens.push(word[0]);
        tokens.push(word[1]);
        tokens.push(expr);
      }), tokens;
    }
  };
  expect(Example, [{
    "key" : "init",
    "value" : function() {
      this._defaultColorTexture = new Cesium.Texture({
        "context" : this.viewer.scene.context,
        "source" : {
          "width" : 1,
          "height" : 1,
          "arrayBufferView" : new Uint8Array([0, 0, 0, 0])
        },
        "flipY" : false
      });
      if (this.cameraPosition && this.viewPosition) {
        this.addToScene();
      } else {
        this.bindMouseEvent();
      }
    }
  }, {
    "key" : `bindMouseEvent`,
    "value" : function() {
      var options = this;
      var obj = this.viewer;
      var handler = new Cesium["ScreenSpaceEventHandler"](this.viewer.scene.canvas);
      handler.setInputAction(function(currentItems) {
        var parseInt = hahaha;
        var data = (data = obj[parseInt(2758)].pickPosition(currentItems[parseInt(586)])) || obj[parseInt(2758)][parseInt(1306)][parseInt(1080)](currentItems[parseInt(586)], obj[parseInt(2758)].globe[parseInt(1923)]);
        if (data) {
          if (options.cameraPosition) {
            if (options[parseInt(2257)] && !options[parseInt(662)]) {
              if (5E3 < Cesium[parseInt(3131)][parseInt(1473)](options[parseInt(2257)], data)) {
                data = options[parseInt(2741)](options[parseInt(2257)], data, 5E3);
              }
              options[parseInt(662)] = data;
              options[parseInt(1834)]();
              options[parseInt(2567)]();
              options[parseInt(1248)](false);
            }
          } else {
            data = options[parseInt(3051)](data, options[parseInt(1278)]);
            options[parseInt(2257)] = data;
          }
        }
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
      handler.setInputAction(function(result) {
        var parseInt = hahaha;
        var value;
        var data = (data = obj[parseInt(2758)][parseInt(1238)](result[parseInt(2840)])) || obj[parseInt(2758)].camera.pickEllipsoid(result[parseInt(2840)], obj.scene[parseInt(2359)][parseInt(1923)]);
        if (!!data) {
          if (value = options[parseInt(2257)]) {
            if (0.1 < (result = Cesium[parseInt(3131)][parseInt(1473)](value, data))) {
              if (!options[parseInt(1841)]) {
                options.addFrustum(value);
              }
            }
            if (5E3 < result) {
              data = options[parseInt(2741)](value, data, 5E3);
              options[parseInt(2688)] = options[parseInt(952)](value, data);
              options[parseInt(1473)] = 5E3;
            } else {
              options[parseInt(2688)] = options.getFrustumQuaternion(value, data);
              options[parseInt(1473)] = Number(result[parseInt(374)](1));
            }
          }
        }
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
      this._handler = handler;
      this.setCursor(true);
    }
  }, {
    "key" : "unbindMouseEvent",
    "value" : function() {
      if (this._handler) {
        this._handler.destroy();
        delete this._handler;
      }
      this.setCursor(false);
    }
  }, {
    "key" : `addToScene`,
    "value" : function() {
      this.frustumQuaternion = this.getFrustumQuaternion(this.cameraPosition, this.viewPosition);
      this.createShadowMap(this.cameraPosition, this.viewPosition);
      this.addPostProcess();
      if (!this.frustum) {
        this.addFrustum(this.cameraPosition);
      }
      this.viewer.scene.primitives.add(this);
    }
  }, {
    "key" : `addFrustum`,
    "value" : function(obj) {
      var vec = this;
      this.frustum = this.viewer.entities.add({
        "position" : obj,
        "orientation" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
          var put_rows = hahaha;
          var artistTrack = Cesium[put_rows(500)][put_rows(1050)](new (Cesium[put_rows(3131)])(0, 1, 0), Cesium[put_rows(2090)][put_rows(1544)](-90));
          return Cesium.Quaternion[put_rows(1703)](vec[put_rows(2688)], artistTrack, new (Cesium[put_rows(500)]));
        }, false),
        "ellipsoid" : {
          "radii" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
            var put_rows = hahaha;
            return new (Cesium[put_rows(3131)])(vec[put_rows(1473)] + 1, vec[put_rows(1473)] + 1, vec.distance + 1);
          }, false),
          "innerRadii" : new Cesium["Cartesian3"](0.01, 0.01, 0.01),
          "minimumClock" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
            var put_rows = hahaha;
            return Cesium[put_rows(2090)][put_rows(1544)](-(vec[put_rows(2306)] / 2 + 1));
          }, false),
          "maximumClock" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
            var put_rows = hahaha;
            return Cesium.Math[put_rows(1544)](vec[put_rows(2306)] / 2 + 1);
          }, false),
          "minimumCone" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
            var put_rows = hahaha;
            return Cesium[put_rows(2090)][put_rows(1544)](90 - vec[put_rows(1059)] / 2);
          }, false),
          "maximumCone" : new Cesium.CallbackProperty(function(canCreateDiscussions) {
            var put_rows = hahaha;
            return Cesium[put_rows(2090)][put_rows(1544)](90 + vec.horizontalAngle / 2);
          }, false),
          "fill" : true,
          "outline" : false,
          "material" : Cesium.Color.CYAN.withAlpha(0.3)
        }
      });
    }
  }, {
    "key" : `removeFrustum`,
    "value" : function() {
      this.viewer.entities.remove(this.frustum);
      this.frustum = void 0;
    }
  }, {
    "key" : `createShadowMap`,
    "value" : function(object, data, uri) {
      var value = object;
      var p = data;
      object = this.viewer.scene;
      data = new Cesium["Camera"](object);
      data.position = value;
      data.direction = Cesium.Cartesian3.subtract(p, value, new Cesium["Cartesian3"](0, 0, 0));
      data.up = Cesium.Cartesian3.normalize(value, new Cesium["Cartesian3"](0, 0, 0));
      value = Number(Cesium.Cartesian3.distance(p, value).toFixed(1));
      this.distance = value;
      data.frustum = new Cesium["PerspectiveFrustum"]({
        "fov" : Cesium.Math.toRadians(120),
        "aspectRatio" : object.canvas.clientWidth / object.canvas.clientHeight,
        "near" : 0.1,
        "far" : 5E3
      });
      this.viewShadowMap = new Cesium["ShadowMap"]({
        "lightCamera" : data,
        "enable" : false,
        "isPointLight" : false,
        "isSpotLight" : true,
        "cascadesEnabled" : false,
        "context" : object.context,
        "pointLightRadius" : value,
        "darkness" : 1,
        "maximumDistance" : this._maximumDistance
      });
    }
  }, {
    "key" : `addPostProcess`,
    "value" : function() {
      var vector = this;
      var rpm_traffic = vector.viewShadowMap._isPointLight ? vector.viewShadowMap._pointBias : vector.viewShadowMap._primitiveBias;
      this.postProcess = new Cesium["PostProcessStage"]({
        "fragmentShader" : `uniform float czzj;\nuniform float dis;\nuniform float spzj;\nuniform vec3 visibleColor;\nuniform vec3 disVisibleColor;\nuniform float mixNum;\nuniform sampler2D colorTexture;\nuniform sampler2D marsShadow; \nuniform sampler2D depthTexture;\nuniform mat4 _shadowMap_matrix; \nuniform vec4 shadowMap_lightPositionEC; \nuniform vec3 shadowMap_lightPositionWC;\nuniform vec4 shadowMap_lightDirectionEC;\nuniform vec3 shadowMap_lightUp;\nuniform vec3 shadowMap_lightDir;\nuniform vec3 shadowMap_lightRight;\nuniform vec4 shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness; \nuniform vec4 shadowMap_texelSizeDepthBiasAndNormalShadingSmooth; \nvarying vec2 v_textureCoordinates;\nvec4 toEye(in vec2 uv, in float depth){\n    vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));\n    vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0);\n    posInCamera =posInCamera / posInCamera.w;\n    return posInCamera;\n}\nfloat getDepth(in vec4 depth){\n    float z_window = czm_unpackDepth(depth);\n    z_window = czm_reverseLogDepth(z_window);\n    float n_range = czm_depthRange.near;\n    float f_range = czm_depthRange.far;\n    return (2.0 * z_window - n_range - f_range) / (f_range - n_range);\n}\nfloat _czm_sampleShadowMap(sampler2D shadowMap, vec2 uv){\n    return texture2D(shadowMap, uv).r;\n}\nfloat _czm_shadowDepthCompare(sampler2D shadowMap, vec2 uv, float depth){\n    return step(depth, _czm_sampleShadowMap(shadowMap, uv));\n}\nfloat _czm_shadowVisibility(sampler2D shadowMap, czm_shadowParameters shadowParameters){\n    float depthBias = shadowParameters.depthBias;\n    float depth = shadowParameters.depth;\n    float nDotL = shadowParameters.nDotL;\n    float normalShadingSmooth = shadowParameters.normalShadingSmooth;\n    float darkness = shadowParameters.darkness;\n    vec2 uv = shadowParameters.texCoords;\n    depth -= depthBias;\n    vec2 texelStepSize = shadowParameters.texelStepSize;\n    float radius = 1.0;\n    float dx0 = -texelStepSize.x * radius;\n    float dy0 = -texelStepSize.y * radius;\n    float dx1 = texelStepSize.x * radius;\n    float dy1 = texelStepSize.y * radius;\n    float visibility = \n    (\n    _czm_shadowDepthCompare(shadowMap, uv, depth)\n    +_czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy0), depth) +\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy0), depth) +\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy0), depth) +\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, 0.0), depth) +\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, 0.0), depth) +\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy1), depth) +\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy1), depth) +\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy1), depth)\n    ) * (1.0 / 9.0)\n    ;\n    return visibility;\n}\nvec3 pointProjectOnPlane(in vec3 planeNormal, in vec3 planeOrigin, in vec3 point){\n    vec3 v01 = point -planeOrigin;\n    float d = dot(planeNormal, v01) ;\n    return (point - planeNormal * d);\n}\nfloat ptm(vec3 pt){\n    return sqrt(pt.x*pt.x + pt.y*pt.y + pt.z*pt.z);\n}\nvoid main() \n{ \n    const float PI = 3.141592653589793;\n    vec4 color = texture2D(colorTexture, v_textureCoordinates);\n    vec4 currD = texture2D(depthTexture, v_textureCoordinates);\n\n    // vec4 stcc = texture2D(marsShadow, v_textureCoordinates);\n    // gl_FragColor = currD;\n    // return;\n    if(currD.r>=1.0){\n        gl_FragColor = color;\n        return;\n    }\n    \n    float depth = getDepth(currD);\n    // gl_FragColor = vec4(depth,0.0,0.0,1.0);\n    // return;\n    // float depth = czm_unpackDepth(texture2D(depthTexture, v_textureCoordinates));\n    vec4 positionEC = toEye(v_textureCoordinates, depth);\n    vec3 normalEC = vec3(1.0);\n    czm_shadowParameters shadowParameters; \n    shadowParameters.texelStepSize = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.xy; \n    shadowParameters.depthBias = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.z; \n    shadowParameters.normalShadingSmooth = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.w; \n    shadowParameters.darkness = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.w; \n    shadowParameters.depthBias *= max(depth * 0.01, 1.0); \n    vec3 directionEC = normalize(positionEC.xyz - shadowMap_lightPositionEC.xyz); \n    float nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); \n    vec4 shadowPosition = _shadowMap_matrix * positionEC; \n    shadowPosition /= shadowPosition.w; \n    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) \n    { \n        gl_FragColor = color;\n        return;\n    }\n\n    //\u5750\u6807\u4e0e\u89c6\u70b9\u4f4d\u7f6e\u8ddd\u79bb\uff0c\u5927\u4e8e\u6700\u5927\u8ddd\u79bb\u5219\u820d\u5f03\u9634\u5f71\u6548\u679c\n    vec4 lw = vec4(shadowMap_lightPositionWC,1.0);\n    vec4 vw = czm_inverseView* vec4(positionEC.xyz, 1.0);\n    if(distance(lw.xyz,vw.xyz)>dis){\n        gl_FragColor = color;\n        return;\n    }\n\n\n    //\u6c34\u5e73\u5939\u89d2\u9650\u5236\n    vec3 ptOnSP = pointProjectOnPlane(shadowMap_lightUp,lw.xyz,vw.xyz);\n    directionEC = ptOnSP - lw.xyz;\n    float directionECMO = ptm(directionEC.xyz);\n    float shadowMap_lightDirMO = ptm(shadowMap_lightDir.xyz);\n    float cosJJ = dot(directionEC,shadowMap_lightDir)/(directionECMO*shadowMap_lightDirMO);\n    float degJJ = acos(cosJJ)*(180.0 / PI);\n    degJJ = abs(degJJ);\n    if(degJJ>spzj/2.0){\n        gl_FragColor = color;\n        return;\n    }\n\n    //\u5782\u76f4\u5939\u89d2\u9650\u5236\n    vec3 ptOnCZ = pointProjectOnPlane(shadowMap_lightRight,lw.xyz,vw.xyz);\n    vec3 dirOnCZ = ptOnCZ - lw.xyz;\n    float dirOnCZMO = ptm(dirOnCZ);\n    float cosJJCZ = dot(dirOnCZ,shadowMap_lightDir)/(dirOnCZMO*shadowMap_lightDirMO);\n    float degJJCZ = acos(cosJJCZ)*(180.0 / PI);\n    degJJCZ = abs(degJJCZ);\n    if(degJJCZ>czzj/2.0){\n        gl_FragColor = color;\n        return;\n    }\n\n    shadowParameters.texCoords = shadowPosition.xy; \n    shadowParameters.depth = shadowPosition.z; \n    shadowParameters.nDotL = nDotL; \n    float visibility = _czm_shadowVisibility(marsShadow, shadowParameters); \n    if(visibility==1.0){\n        gl_FragColor = mix(color,vec4(visibleColor,1.0),mixNum);\n    }else{\n        // if(abs(shadowPosition.z-0.0)<0.01){\n        //     return;\n        // }\n        gl_FragColor = mix(color,vec4(disVisibleColor,1.0),mixNum);\n    }\n} `,
        "uniforms" : {
          "czzj" : function() {
            return vector.verticalAngle;
          },
          "dis" : function() {
            return vector.distance;
          },
          "spzj" : function() {
            return vector.horizontalAngle;
          },
          "visibleColor" : function() {
            var gotoNewOfflinePage = hahaha;
            return vector[gotoNewOfflinePage(615)];
          },
          "disVisibleColor" : function() {
            return vector.hiddenAreaColor;
          },
          "mixNum" : function() {
            var gotoNewOfflinePage = hahaha;
            return vector[gotoNewOfflinePage(1470)];
          },
          "marsShadow" : function() {
            var gotoNewOfflinePage = hahaha;
            return vector[gotoNewOfflinePage(1153)][gotoNewOfflinePage(2156)] || vector[gotoNewOfflinePage(2222)];
          },
          "_shadowMap_matrix" : function() {
            var gotoNewOfflinePage = hahaha;
            return vector.viewShadowMap[gotoNewOfflinePage(1944)];
          },
          "shadowMap_lightPositionEC" : function() {
            var gotoNewOfflinePage = hahaha;
            return vector[gotoNewOfflinePage(1153)][gotoNewOfflinePage(801)];
          },
          "shadowMap_lightPositionWC" : function() {
            var gotoNewOfflinePage = hahaha;
            return vector[gotoNewOfflinePage(1153)][gotoNewOfflinePage(1687)].position;
          },
          "shadowMap_lightDirectionEC" : function() {
            var gotoNewOfflinePage = hahaha;
            return vector[gotoNewOfflinePage(1153)]._lightDirectionEC;
          },
          "shadowMap_lightUp" : function() {
            var gotoNewOfflinePage = hahaha;
            return vector[gotoNewOfflinePage(1153)][gotoNewOfflinePage(1687)].up;
          },
          "shadowMap_lightDir" : function() {
            var gotoNewOfflinePage = hahaha;
            return vector.viewShadowMap[gotoNewOfflinePage(1687)][gotoNewOfflinePage(2792)];
          },
          "shadowMap_lightRight" : function() {
            var gotoNewOfflinePage = hahaha;
            return vector[gotoNewOfflinePage(1153)][gotoNewOfflinePage(1687)][gotoNewOfflinePage(379)];
          },
          "shadowMap_texelSizeDepthBiasAndNormalShadingSmooth" : function() {
            var now = hahaha;
            var xhair = new (Cesium[now(2689)]);
            return xhair.x = 1 / vector.viewShadowMap._textureSize.x, xhair.y = 1 / vector[now(1153)][now(1351)].y, Cesium.Cartesian4[now(1740)](xhair.x, xhair.y, rpm_traffic[now(1746)], rpm_traffic[now(1702)], this[now(811)]);
          },
          "shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness" : function() {
            var now = hahaha;
            return Cesium[now(2399)][now(1740)](rpm_traffic[now(975)], vector[now(1153)]._distance, vector.viewShadowMap.maximumDistance, vector[now(1153)][now(2624)], this[now(2174)]);
          },
          "depthTexture1" : function() {
            var gotoNewOfflinePage = hahaha;
            return vector[gotoNewOfflinePage(2255)](vector[gotoNewOfflinePage(2276)]);
          }
        }
      });
      if (this.show) {
        this.viewer.scene.postProcessStages.add(this.postProcess);
      }
    }
  }, {
    "key" : `getSceneDepthTexture`,
    "value" : function(target) {
      var data = target.scene;
      target = data._environmentState;
      data = data._view;
      target = target.useGlobeDepthFramebuffer ? data.globeDepth.framebuffer : void 0;
      data = data.sceneFramebuffer.getFramebuffer();
      return Cesium.defaultValue(target, data).depthStencilTexture;
    }
  }, {
    "key" : `setCursor`,
    "value" : function(value) {
      this.viewer._container.style.cursor = value ? "crosshair" : "";
    }
  }, {
    "key" : `getFrustumQuaternion`,
    "value" : function(name, target) {
      var fov = Cesium.Cartesian3.normalize(Cesium.Cartesian3.subtract(target, name, new Cesium["Cartesian3"]), new Cesium["Cartesian3"]);
      var value = Cesium.Cartesian3.normalize(name, new Cesium.Cartesian3);
      var camera = new Cesium["Camera"](this.viewer.scene);
      camera.position = name;
      camera.direction = fov;
      camera.up = value;
      fov = camera.directionWC;
      value = camera.upWC;
      var pos = camera.rightWC;
      target = new Cesium["Cartesian3"];
      name = new Cesium.Matrix3;
      camera = new Cesium["Quaternion"];
      pos = Cesium.Cartesian3.negate(pos, target);
      name = name;
      return Cesium.Matrix3.setColumn(name, 0, pos, name), Cesium.Matrix3.setColumn(name, 1, value, name), Cesium.Matrix3.setColumn(name, 2, fov, name), Cesium.Quaternion.fromRotationMatrix(name, camera);
    }
  }, {
    "key" : `getFirstPosition`,
    "value" : function(type, value) {
      var ne = Cesium.Cartographic.fromCartesian(type);
      var longitude = Cesium.Math.toDegrees(ne.longitude);
      type = Cesium.Math.toDegrees(ne.latitude);
      value = ne.height + value;
      return Cesium.Cartesian3.fromDegrees(longitude, type, value);
    }
  }, {
    "key" : `getOnLinePointByLen`,
    "value" : function(target, x, data, searchTerm) {
      var item = Cesium.Transforms.eastNorthUpToFixedFrame(target);
      var left = Cesium.Matrix4.inverse(item, new Cesium["Matrix4"]);
      return target = Cesium.Matrix4.multiplyByPoint(left, target, new Cesium["Cartesian3"]), x = Cesium.Matrix4.multiplyByPoint(left, x, new Cesium["Cartesian3"]), left = Cesium.Cartesian3.subtract(x, target, new Cesium["Cartesian3"]), x = data / Cesium.Cartesian3.distance(target, x), searchTerm && (x = x + 1), x = Cesium.Cartesian3.multiplyByScalar(left, x, new Cesium["Cartesian3"]), x = Cesium.Matrix4.multiplyByPoint(item, x, new Cesium["Cartesian3"]);
    }
  }, {
    "key" : "update",
    "value" : function(type) {
      if (this.viewShadowMap) {
        type.shadowMaps.push(this.viewShadowMap);
      }
    }
  }, {
    "key" : `destroy`,
    "value" : function() {
      this.viewer.terrainShadows = Cesium.ShadowMode.DISABLED;
      this.unbindMouseEvent();
      if (this.postProcess) {
        this.viewer.scene.postProcessStages.remove(this.postProcess);
        delete this.postProcess;
      }
      this.removeFrustum();
      this.viewer.scene.primitives.remove(this);
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.destroy();
    }
  }, {
    "key" : `distance`,
    "get" : function() {
      return this._distance;
    },
    "set" : function(value) {
      this._distance = value;
    }
  }, {
    "key" : `maximumDistance`,
    "get" : function() {
      return this._maximumDistance;
    },
    "set" : function(name) {
      this._maximumDistance = name;
    }
  }, {
    "key" : "horizontalAngle",
    "get" : function() {
      return this._horizontalAngle;
    },
    "set" : function(name) {
      this._horizontalAngle = name;
    }
  }, {
    "key" : "verticalAngle",
    "get" : function() {
      return this._verticalAngle;
    },
    "set" : function(name) {
      this._verticalAngle = name;
    }
  }, {
    "key" : `visibleAreaColor`,
    "get" : function() {
      return this._visibleAreaColor;
    },
    "set" : function(name) {
      this._visibleAreaColor = name;
    }
  }, {
    "key" : `hiddenAreaColor`,
    "get" : function() {
      return this._hiddenAreaColor;
    },
    "set" : function(name) {
      this._hiddenAreaColor = name;
    }
  }, {
    "key" : `alpha`,
    "get" : function() {
      return this._alpha;
    },
    "set" : function(value) {
      this._alpha = value;
    }
  }, {
    "key" : `offsetHeight`,
    "get" : function() {
      return this._offsetHeight;
    },
    "set" : function(name) {
      this._offsetHeight = name;
    }
  }, {
    "key" : "debugFrustum",
    "get" : function() {
      return this._debugFrustum;
    },
    "set" : function(name) {
      this._debugFrustum = name;
    }
  }, {
    "key" : `show`,
    "get" : function() {
      return this._show;
    },
    "set" : function(value) {
      this._show = value;
    }
  }]);
  descriptor = Example;
  expect(Model, [{
    "key" : `addPostProcess`,
    "value" : function() {
      var rpm_traffic = this;
      this.postProcess = new Cesium["PostProcessStage"]({
        "fragmentShader" : "#extension GL_OES_standard_derivatives : enable\r\nuniform sampler2D colorTexture;\r\nuniform sampler2D depthTexture;\r\nuniform float lineWidth;\r\nuniform float height;\r\nuniform bvec3 strokeType;\r\nuniform vec3 tjxColor;\r\nuniform vec3 bjColor;\r\nuniform vec3 cameraPos;\r\nuniform float mbDis;\r\nvarying vec2 v_textureCoordinates;\r\nvec4 toEye(in vec2 uv, in float depth){\r\n    vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));\r\n    vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0);\r\n    posInCamera =posInCamera / posInCamera.w;\r\n    return posInCamera;\r\n}\r\nfloat getDepth(in vec4 depth){\r\n    float z_window = czm_unpackDepth(depth);\r\n    z_window = czm_reverseLogDepth(z_window);\r\n    float n_range = czm_depthRange.near;\r\n    float f_range = czm_depthRange.far;\r\n    return (2.0 * z_window - n_range - f_range) / (f_range - n_range);\r\n}\r\nbool isTJX(vec2 uv,float lw){\r\n    vec2 pixelSize = lw / czm_viewport.zw;\r\n    float dx0 = -pixelSize.x;\r\n    float dy0 = -pixelSize.y;\r\n    float dx1 = pixelSize.x;\r\n    float dy1 = pixelSize.y;\r\n\r\n    vec2 currUV = uv + vec2(dx0, dy0);\r\n    vec4 currDepth = texture2D(depthTexture, currUV);\r\n    float depth = getDepth(currDepth);\r\n    if(depth>=1.0)return true;\r\n\r\n    currUV = uv + vec2(0.0, dy0);\r\n    currDepth = texture2D(depthTexture, currUV);\r\n    depth = getDepth(currDepth);\r\n    if(depth>=1.0)return true;\r\n\r\n    currUV = uv + vec2(dx1, dy0);\r\n    currDepth = texture2D(depthTexture, currUV);\r\n    depth = getDepth(currDepth);\r\n    if(depth>=1.0)return true;\r\n\r\n    currUV = uv + vec2(dx0, 0.0);\r\n    currDepth = texture2D(depthTexture, currUV);\r\n    depth = getDepth(currDepth);\r\n    if(depth>=1.0)return true;\r\n\r\n    currUV = uv + vec2(dx1, 0.0);\r\n    currDepth = texture2D(depthTexture, currUV);\r\n    depth = getDepth(currDepth);\r\n    if(depth>=1.0)return true;\r\n\r\n    currUV = uv + vec2(dx0, dy1);\r\n    currDepth = texture2D(depthTexture, currUV);\r\n    depth = getDepth(currDepth);\r\n    if(depth>=1.0)return true;\r\n\r\n    currUV = uv + vec2(0.0, dy1);\r\n    currDepth = texture2D(depthTexture, currUV);\r\n    depth = getDepth(currDepth);\r\n    if(depth>=1.0)return true;\r\n\r\n    currUV = uv + vec2(dx1, dy1);\r\n    currDepth = texture2D(depthTexture, currUV);\r\n    depth = getDepth(currDepth);\r\n    if(depth>=1.0)return true;\r\n\r\n    return false;\r\n}\r\nvoid main(){\r\n\r\n\r\n    vec4 color = texture2D(colorTexture, v_textureCoordinates);\r\n    if(height>14102.0){\r\n        gl_FragColor = color;\r\n        return;\r\n    }\r\n    vec4 currD = texture2D(depthTexture, v_textureCoordinates);\r\n    if(currD.r>=1.0){\r\n        gl_FragColor = color;\r\n        return;\r\n    }\r\n    float depth = getDepth(currD);\r\n    vec4 positionEC = toEye(v_textureCoordinates, depth);\r\n    vec3 dx = dFdx(positionEC.xyz);\r\n    vec3 dy = dFdy(positionEC.xyz);\r\n    vec3 normal = normalize(cross(dx,dy));\r\n\r\n    if(strokeType.y||strokeType.z){\r\n        vec4 wp = czm_inverseView * positionEC;\r\n        if(distance(wp.xyz,cameraPos)>mbDis){\r\n            gl_FragColor = color;\r\n        }else{\r\n            float dotNum = abs(dot(normal,normalize(positionEC.xyz)));\r\n            if(dotNum<0.05){\r\n                gl_FragColor = vec4(bjColor,1.0);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    if(strokeType.x||strokeType.z){\r\n        bool tjx = isTJX(v_textureCoordinates,lineWidth);\r\n        if(tjx){\r\n            gl_FragColor = vec4(tjxColor,1.0);\r\n            return;\r\n        }\r\n    }\r\n    gl_FragColor = color;\r\n}",
        "uniforms" : {
          "height" : function() {
            var now = hahaha;
            return rpm_traffic[now(2276)][now(1306)][now(1323)][now(1132)];
          },
          "lineWidth" : function() {
            var now = hahaha;
            return rpm_traffic[now(396)];
          },
          "strokeType" : function() {
            var now = hahaha;
            return rpm_traffic[now(1134)];
          },
          "tjxColor" : function() {
            var now = hahaha;
            return rpm_traffic[now(950)];
          },
          "bjColor" : function() {
            var now = hahaha;
            return rpm_traffic[now(1865)];
          },
          "cameraPos" : function() {
            var gotoNewOfflinePage = hahaha;
            return rpm_traffic.viewer[gotoNewOfflinePage(2758)][gotoNewOfflinePage(1306)][gotoNewOfflinePage(586)];
          },
          "mbDis" : function() {
            var now = hahaha;
            return rpm_traffic[now(1472)];
          }
        }
      });
      this.postProcess.enabled = true;
      this.viewer.scene.postProcessStages.add(this.postProcess);
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.viewer.scene.postProcessStages.remove(this.postProcess);
      this.postProcess.destroy();
      delete this.postProcess;
    }
  }]);
  name = Model;
  xt3d.SpatialAnalysis = {
    "LimitHeight" : frame,
    "SightLine" : {
      "Circle" : init,
      "SingleLine" : data
    },
    "ViewShed3D" : definition,
    "ViewField" : PressComposer,
    "Buffer" : obj,
    "ViewShedExt" : descriptor,
    "Skyline" : name
  };
  expect(render, [{
    "key" : `updateHeatmap`,
    "value" : function() {
      var rMax = this.viewer.camera.getMagnitude();
      var opt = this.autoRadiusConfig;
      var min = opt.min;
      var max = opt.max;
      var height = opt.minRadius;
      opt = opt.maxRadius;
      var rad = parseInt(height + (opt - height) * (rMax - min) / (max - min));
      this.heatmap.setData({
        "max" : this.max,
        "min" : this.min,
        "data" : this.data.map(function(markerCoord) {
          var put_rows = hahaha;
          return {
            "x" : markerCoord.x,
            "y" : markerCoord.y,
            "value" : markerCoord[put_rows(1573)],
            "radius" : rad
          };
        })
      });
    }
  }, {
    "key" : `updateCesium`,
    "value" : function(name) {
      if (name) {
        this.updateHeatmap();
      }
      if (this.rectangleEntity) {
        this.rectangleEntity.polygon.material = this.heatmap.getDataURL();
      }
    }
  }, {
    "key" : `recToPolygon`,
    "value" : function() {
      return [this.bbox[0], this.bbox[1], this.bbox[2], this.bbox[1], this.bbox[2], this.bbox[3], this.bbox[0], this.bbox[3], this.bbox[0], this.bbox[1]];
    }
  }, {
    "key" : `convertData`,
    "value" : function(target) {
      var target1 = target.x;
      var pos = target.y;
      target = target.z;
      pos = this.gps2point([target1, pos]);
      pos = clone(pos, 2);
      return {
        "x" : pos[0],
        "y" : pos[1],
        "value" : target
      };
    }
  }, {
    "key" : `updateMaxMin`,
    "value" : function(value) {
      if (void 0 === this.max) {
        this.max = value;
      } else {
        this.max = Math.max(value, this.max);
      }
      if (void 0 === this.min) {
        this.min = value;
      } else {
        this.min = Math.min(value, this.min);
      }
    }
  }, {
    "key" : `gps2point`,
    "value" : function() {
      var width = clone(0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : [], 2);
      var h2 = width[0];
      var maxWidth = width[1];
      var canvas = this.boxMeta;
      var y = canvas.top;
      var h1 = canvas.left;
      var height = canvas.height;
      width = canvas.width;
      canvas = this.canvasConfig;
      return [parseInt((h2 - h1) / width * canvas.width), parseInt((y - maxWidth) / height * canvas.height)];
    }
  }, {
    "key" : `newDiv`,
    "value" : function(obj, target) {
      var key;
      var type = document.createElement("div");
      for (key in target && target.append(type), obj) {
        if ("number" != typeof obj[key]) {
          type.style[key] = obj[key];
        } else {
          type.style[key] = obj[key] + "px";
        }
      }
      return type;
    }
  }, {
    "key" : `destroy`,
    "value" : function() {
      this.viewer.camera.moveEnd.removeEventListener(this.cameraMoveEnd);
      if (this.rectangleEntity) {
        this.viewer.entities.remove(this.rectangleEntity);
      }
      if (this.mountPoint) {
        this.mountPoint.remove();
      }
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.destroy();
    }
  }]);
  location = render;
  expect(verify, [{
    "key" : `activate`,
    "value" : function() {
      this.deactivate();
      this.axisList = [];
      this.createAxis();
      this.registerEvents();
    }
  }, {
    "key" : `deactivate`,
    "value" : function() {
      var same = this;
      if (this.eventHandler) {
        this.eventHandler.destroy();
        this.eventHandler = void 0;
        this.axisList.forEach(function(tObject3d) {
          var rel2Mstr = hahaha;
          same[rel2Mstr(2276)][rel2Mstr(1319)].remove(tObject3d);
        });
      }
    }
  }, {
    "key" : `createAxis`,
    "value" : function() {
      var falseySection = this.createXaxis();
      this.axisList.push(falseySection);
      falseySection = this.createYaxis();
      this.axisList.push(falseySection);
      falseySection = this.createZaxis();
      this.axisList.push(falseySection);
    }
  }, {
    "key" : `createXaxis`,
    "value" : function() {
      var obj = this;
      return this.viewer.entities.add({
        "type" : "axis",
        "subType" : "xaxis",
        "polyline" : {
          "positions" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
            var parseInt = hahaha;
            return Cesium[parseInt(3131)][parseInt(2951)]([obj.params[parseInt(2596)], obj[parseInt(1390)][parseInt(480)], obj[parseInt(1390)].height, obj[parseInt(1390)][parseInt(2596)] + 0.001, obj[parseInt(1390)][parseInt(480)], obj.params[parseInt(1132)]]);
          }, false),
          "width" : 20,
          "material" : new Cesium["PolylineArrowMaterialProperty"](Cesium.Color.BLUE)
        }
      });
    }
  }, {
    "key" : `createYaxis`,
    "value" : function() {
      var obj = this;
      return this.viewer.entities.add({
        "type" : "axis",
        "subType" : "yaxis",
        "polyline" : {
          "positions" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
            var parseInt = hahaha;
            return Cesium[parseInt(3131)][parseInt(2951)]([obj.params[parseInt(2596)], obj[parseInt(1390)][parseInt(480)], obj[parseInt(1390)].height, obj[parseInt(1390)][parseInt(2596)], obj[parseInt(1390)][parseInt(480)] + 0.001, obj.params[parseInt(1132)]]);
          }, false),
          "width" : 20,
          "material" : new Cesium["PolylineArrowMaterialProperty"](Cesium.Color.GREEN)
        }
      });
    }
  }, {
    "key" : `createZaxis`,
    "value" : function() {
      var obj = this;
      return this.viewer.entities.add({
        "type" : "axis",
        "subType" : "zaxis",
        "polyline" : {
          "positions" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
            var parseInt = hahaha;
            return Cesium[parseInt(3131)].fromDegreesArrayHeights([obj[parseInt(1390)].longitude, obj[parseInt(1390)][parseInt(480)], obj.params[parseInt(1132)], obj[parseInt(1390)][parseInt(2596)], obj.params[parseInt(480)], obj[parseInt(1390)][parseInt(1132)] + 60]);
          }, false),
          "width" : 20,
          "material" : new Cesium["PolylineArrowMaterialProperty"](Cesium.Color.RED)
        }
      });
    }
  }, {
    "key" : `registerEvents`,
    "value" : function() {
      this.eventHandler = new Cesium["ScreenSpaceEventHandler"](this.viewer.scene.canvas);
      this.registerLeftDownEvent();
      this.registerLeftUpEvent();
      this.registerMouseMoveEvent();
    }
  }, {
    "key" : `registerLeftDownEvent`,
    "value" : function() {
      var o = this;
      this.eventHandler.setInputAction(function(module) {
        var parseInt = hahaha;
        module = o.viewer[parseInt(2758)][parseInt(1708)](module[parseInt(586)]);
        if (module && module.id && parseInt(3130) === module.id[parseInt(1720)]) {
          o.moveType = module.id[parseInt(745)];
          o[parseInt(2494)].color = module.id.polyline.material[parseInt(2240)];
          o[parseInt(2494)][parseInt(1562)] = module.id[parseInt(1562)];
          o[parseInt(2494)][parseInt(1562)][parseInt(1187)][parseInt(2240)] = Cesium[parseInt(2292)][parseInt(2537)];
          o[parseInt(2276)][parseInt(1633)] = false;
          document[parseInt(1494)][parseInt(1998)][parseInt(737)] = parseInt(367);
          o[parseInt(591)] = true;
          o[parseInt(2276)][parseInt(2758)][parseInt(2190)][parseInt(1218)] = false;
        }
      }, Cesium.ScreenSpaceEventType.LEFT_DOWN);
    }
  }, {
    "key" : "registerLeftUpEvent",
    "value" : function() {
      var same = this;
      this.eventHandler.setInputAction(function(canCreateDiscussions) {
        var rel2Mstr = hahaha;
        if (same[rel2Mstr(591)]) {
          same.viewer.enableCursorStyle = true;
          document[rel2Mstr(1494)][rel2Mstr(1998)][rel2Mstr(737)] = rel2Mstr(1654);
          same[rel2Mstr(2494)][rel2Mstr(1562)][rel2Mstr(1187)][rel2Mstr(2240)] = same[rel2Mstr(2494)][rel2Mstr(2240)];
          same[rel2Mstr(2494)] = {};
          same[rel2Mstr(591)] = false;
          same[rel2Mstr(2276)][rel2Mstr(2758)][rel2Mstr(2190)].enableRotate = true;
        }
      }, Cesium.ScreenSpaceEventType.LEFT_UP);
    }
  }, {
    "key" : `registerMouseMoveEvent`,
    "value" : function() {
      var obj = this;
      this.eventHandler.setInputAction(function(from) {
        var parseInt = hahaha;
        if (obj[parseInt(591)]) {
          if ("zaxis" == obj.moveType) {
            return obj.params[parseInt(1132)] += from[parseInt(1108)].y - from.endPosition.y, void obj[parseInt(561)]();
          }
          var to = obj[parseInt(2276)][parseInt(2758)][parseInt(1238)](from[parseInt(2840)]);
          from = obj[parseInt(2276)].scene[parseInt(1238)](from.startPosition);
          if (to && from) {
            to = Cesium[parseInt(1543)][parseInt(2206)](to);
            from = Cesium[parseInt(1543)][parseInt(2206)](from);
            if (parseInt(1284) == obj[parseInt(539)]) {
              return obj[parseInt(1390)][parseInt(2596)] += Cesium[parseInt(2090)][parseInt(1611)](to[parseInt(2596)] - from[parseInt(2596)]), void obj[parseInt(561)]();
            }
            if ("yaxis" == obj.moveType) {
              obj[parseInt(1390)][parseInt(480)] += Cesium[parseInt(2090)][parseInt(1611)](to.latitude - from.latitude);
              obj[parseInt(561)]();
            }
          }
        }
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
    }
  }, {
    "key" : "updateModelMatrix",
    "value" : function() {
      var exp;
      var out;
      var target;
      var m;
      if (this.tileset) {
        out = Cesium.Matrix3.fromRotationX(Cesium.Math.toRadians(this.params.rx));
        m = Cesium.Matrix3.fromRotationY(Cesium.Math.toRadians(this.params.ry));
        target = Cesium.Matrix3.fromRotationZ(Cesium.Math.toRadians(this.params.rz));
        exp = Cesium.Matrix4.fromRotationTranslation(out);
        out = Cesium.Matrix4.fromRotationTranslation(m);
        m = Cesium.Matrix4.fromRotationTranslation(target);
        target = Cesium.Cartesian3.fromDegrees(this.params.longitude, this.params.latitude, this.params.height);
        target = Cesium.Transforms.eastNorthUpToFixedFrame(target);
        Cesium.Matrix4.multiply(target, exp, target);
        Cesium.Matrix4.multiply(target, out, target);
        Cesium.Matrix4.multiply(target, m, target);
        m = Cesium.Matrix4.fromUniformScale(this.params.scale);
        Cesium.Matrix4.multiply(target, m, target);
        this.tileset._root.transform = target;
      }
    }
  }, {
    "key" : `getParams`,
    "value" : function() {
      return this.params;
    }
  }]);
  frame = verify;
  expect(Server, [{
    "key" : `add`,
    "value" : function(name, obj) {
      this.tiles = obj;
      this.clear();
      if (this.booleanClockwise(name)) {
        name = name.reverse();
      }
      this.addClippingPlanes(name);
    }
  }, {
    "key" : "addClippingPlanes",
    "value" : function(target) {
      var hasSelected = this.getInverseTransform(this.tiles);
      var len = target.length;
      var planes = [];
      var k = 0;
      for (; k < len; ++k) {
        var j = (k + 1) % len;
        var z = target[k];
        var method = target[j];
        var p = this.createPlane(z, method, hasSelected);
        planes.push(p);
      }
      this.tiles.clippingPlanes = new Cesium["ClippingPlaneCollection"]({
        "planes" : planes,
        "edgeWidth" : 1,
        "edgeColor" : Cesium.Color.WHITE
      });
    }
  }, {
    "key" : "getInverseTransform",
    "value" : function(obj) {
      var matrix = void 0;
      var opts = obj.root.transform;
      matrix = opts && opts.equals(Cesium.Matrix4.IDENTITY) || !opts ? Cesium.Transforms.eastNorthUpToFixedFrame(obj.boundingSphere.center) : Cesium.Matrix4.fromArray(obj.root.transform);
      return Cesium.Matrix4.inverseTransformation(matrix, new Cesium["Matrix4"]);
    }
  }, {
    "key" : "getOriginCoordinateSystemPoint",
    "value" : function(type, obj) {
      return Cesium.Matrix4.multiplyByPoint(obj, type, new Cesium.Cartesian3(0, 0, 0));
    }
  }, {
    "key" : `createPlane`,
    "value" : function(value, x, s) {
      return value = this.getOriginCoordinateSystemPoint(value, s), x = this.getOriginCoordinateSystemPoint(x, s), s = new Cesium["Cartesian3"](0, 0, 10), x = Cesium.Cartesian3.subtract(x, value, new Cesium["Cartesian3"]), s = Cesium.Cartesian3.cross(x, s, new Cesium.Cartesian3), s = Cesium.Cartesian3.normalize(s, s), s = Cesium.Plane.fromPointNormal(value, s), Cesium.ClippingPlane.fromPlane(s);
    }
  }, {
    "key" : `booleanClockwise`,
    "value" : function(type) {
      var primaryReplicas = this;
      var line = [];
      return type.map(function(value) {
        var stringify = hahaha;
        line.push(primaryReplicas[stringify(2852)](value));
      }), line.push(line[0]), type = turf.lineString(line), turf.booleanClockwise(type);
    }
  }, {
    "key" : "cartesian3ToDegrees",
    "value" : function(value) {
      return value = Cesium.Cartographic.fromCartesian(value), [Cesium.Math.toDegrees(value.longitude), Cesium.Math.toDegrees(value.latitude)];
    }
  }, {
    "key" : "clear",
    "value" : function() {
      if (this.tiles) {
        this.tiles.clippingPlanes = new Cesium["ClippingPlaneCollection"]({
          "planes" : [],
          "edgeWidth" : 1,
          "edgeColor" : Cesium.Color.WHITE
        });
      }
    }
  }]);
  init = Server;
  expect(results, [{
    "key" : `addVisibleRegion`,
    "value" : function(name) {
      name = this.createGeometry(name, 1E5);
      name = this.addPrimitive(name);
      this.primitives.push(name);
      this.viewer.scene.invertClassification = true;
      this.viewer.scene.invertClassificationColor = this.invisibleColor;
    }
  }, {
    "key" : "setInvisibleColorAlpha",
    "value" : function(name) {
      this.viewer.scene.invertClassificationColor = this.invisibleColor.withAlpha(name);
    }
  }, {
    "key" : "activate",
    "value" : function() {
      this.viewer.scene.invertClassification = true;
    }
  }, {
    "key" : `deactivate`,
    "value" : function() {
      this.viewer.scene.invertClassification = false;
    }
  }, {
    "key" : `addPrimitive`,
    "value" : function(name) {
      return this.viewer.scene.primitives.add(new Cesium.ClassificationPrimitive({
        "geometryInstances" : new Cesium["GeometryInstance"]({
          "geometry" : Cesium.PolygonGeometry.createGeometry(name),
          "attributes" : {
            "color" : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.fromRandom({
              "alpha" : 0.8
            })),
            "show" : new Cesium["ShowGeometryInstanceAttribute"](false)
          }
        }),
        "classificationType" : Cesium.ClassificationType.CESIUM_3D_TILE
      }));
    }
  }, {
    "key" : `createGeometry`,
    "value" : function(target, value) {
      return new Cesium.PolygonGeometry({
        "polygonHierarchy" : new Cesium.PolygonHierarchy(target),
        "perPositionHeight" : true,
        "extrudedHeight" : value
      });
    }
  }, {
    "key" : "removeAll",
    "value" : function() {
      var primaryReplicas = this;
      this.viewer.scene.invertClassification = false;
      this.primitives.forEach(function(mmCoreSplitViewBlock) {
        var stringify = hahaha;
        primaryReplicas[stringify(2276)].scene[stringify(2798)][stringify(508)](mmCoreSplitViewBlock);
      });
    }
  }]);
  data = results;
  xt3d.TilesetPlugin = {
    "Heatmap" : location,
    "PositionEditor" : frame,
    "TilesetClip" : init,
    "PartVisible" : data,
    "setTilesetHeight" : function(model, value) {
      var position = Cesium.Cartographic.fromCartesian(model.boundingSphere.center);
      var result = Cesium.Cartesian3.fromRadians(position.longitude, position.latitude, position.height);
      value = Cesium.Cartesian3.fromRadians(position.longitude, position.latitude, value);
      result = Cesium.Cartesian3.subtract(value, result, new Cesium.Cartesian3);
      model.modelMatrix = Cesium.Matrix4.fromTranslation(result);
    }
  };
  expect(destroy, [{
    "key" : "initEvents",
    "value" : function() {
      this.AnimateStartEvent = new Cesium.Event;
      this.StopsArrivedEvent = new Cesium.Event;
      this.AnimateEndEvent = new Cesium.Event;
    }
  }, {
    "key" : `play`,
    "value" : function(name, value) {
      this.stop();
      this.stops = name;
      this.speed = value;
      this.addTrailLine(this.getPositions());
      this.addTickEvent();
      this.isAnimating = true;
      this.nextStopsIndex = 0;
    }
  }, {
    "key" : "getPositions",
    "value" : function() {
      var formats = [];
      return this.stops.forEach(function(data) {
        var parseInt = hahaha;
        formats[parseInt(2008)](data[parseInt(586)]);
      }), formats;
    }
  }, {
    "key" : `addTrailLine`,
    "value" : function(name) {
      this.trailLineInfo = this.getTrailLineInfo(name, this.speed || 25);
      var start = Cesium.JulianDate.fromDate(new Date(2015, 2, 25, 16));
      var phantomStart = Cesium.JulianDate.addSeconds(start, this.trailLineInfo.timeInfo.timeSum, new Cesium["JulianDate"]);
      this.viewer.clock.startTime = start.clone();
      this.viewer.clock.stopTime = phantomStart.clone();
      this.viewer.clock.currentTime = start.clone();
      this.viewer.clock.clockRange = Cesium.ClockRange.CLAMPED;
      name = this.computeCirclularFlight(name, start, this.trailLineInfo.timeInfo.siteTimes);
      this.addAminateModel(start, phantomStart, name);
      this.addAnimateLine();
      this.calStopsTimes(start, this.trailLineInfo.timeInfo.siteTimes);
    }
  }, {
    "key" : `computeCirclularFlight`,
    "value" : function(name, target, prop) {
      var data = new Cesium["SampledPositionProperty"];
      var i = 0;
      for (; i < name.length; i++) {
        var stop = Cesium.JulianDate.addSeconds(target, prop[i], new Cesium["JulianDate"]);
        data.addSample(stop, name[i]);
      }
      return data;
    }
  }, {
    "key" : `calStopsTimes`,
    "value" : function(type, obj) {
      var primaryReplicas = this;
      this.stopsTimes = [];
      obj.forEach(function(date) {
        var stringify = hahaha;
        date = Cesium.JulianDate.addSeconds(type, date, new (Cesium[stringify(2994)]));
        primaryReplicas[stringify(742)].push(date);
      });
    }
  }, {
    "key" : `addAminateModel`,
    "value" : function(name, key, data) {
      this.animateModel = this.viewer.entities.add({
        "availability" : new Cesium["TimeIntervalCollection"]([new Cesium.TimeInterval({
          "start" : name,
          "stop" : key
        })]),
        "position" : data,
        "orientation" : new Cesium["VelocityOrientationProperty"](data),
        "model" : {
          "uri" : this.style.modelUrl,
          "scale" : this.style.scale
        }
      });
    }
  }, {
    "key" : "addAnimateLine",
    "value" : function() {
      var values = this;
      this.linePositions = [];
      this.animateLine = this.viewer.entities.add({
        "polyline" : {
          "positions" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
            var parseInt = hahaha;
            return values[parseInt(3126)][parseInt(2008)](values[parseInt(2524)].position[parseInt(849)](values[parseInt(2276)][parseInt(617)].currentTime)), values[parseInt(3126)];
          }, false),
          "width" : 3,
          "material" : Cesium.Color.YELLOW,
          "clampToGround" : true
        }
      });
    }
  }, {
    "key" : `stop`,
    "value" : function() {
      this.clear();
      this.removeTickEvent();
      this.isAnimating = false;
    }
  }, {
    "key" : `addTickEvent`,
    "value" : function() {
      this.viewer.clock.onTick.addEventListener(this.tickEventHandler, this);
    }
  }, {
    "key" : `removeTickEvent`,
    "value" : function() {
      this.viewer.clock.onTick.removeEventListener(this.tickEventHandler, this);
    }
  }, {
    "key" : `tickEventHandler`,
    "value" : function() {
      var p = this.viewer.clock.currentTime;
      var maxHeight = this.stopsTimes[this.nextStopsIndex];
      if (Cesium.JulianDate.equalsEpsilon(p, maxHeight, 0.1)) {
        this.StopsArrivedEvent.raiseEvent(this.stops[this.nextStopsIndex], this.nextStopsIndex);
        this.nextStopsIndex++;
        if (this.nextStopsIndex == this.stopsTimes.length) {
          this.removeTickEvent();
          this.isAnimating = false;
          this.AnimateEndEvent.raiseEvent();
        }
      }
    }
  }, {
    "key" : "clear",
    "value" : function() {
      this.viewer.entities.remove(this.animateModel);
      this.animateModel = void 0;
      this.viewer.entities.remove(this.animateLine);
      this.animateLine = void 0;
    }
  }, {
    "key" : `spaceDistance`,
    "value" : function(name) {
      var start;
      var end;
      var psisq;
      var c2Score = 0;
      var geodesic = void 0;
      var i = 0;
      for (; i < name.length - 1; i++) {
        start = Cesium.Cartographic.fromCartesian(name[i]);
        end = Cesium.Cartographic.fromCartesian(name[i + 1]);
        (geodesic = new Cesium["EllipsoidGeodesic"]).setEndPoints(start, end);
        psisq = geodesic.surfaceDistance;
        c2Score = c2Score + Math.sqrt(Math.pow(psisq, 2) + Math.pow(end.height - start.height, 2));
      }
      return c2Score.toFixed(3);
    }
  }, {
    "key" : "fromCoordinatesToCartesian3",
    "value" : function(name) {
      var newNodeLists = [];
      return name.forEach(function(tmp) {
        newNodeLists.push(Cesium.Cartesian3.fromDegrees(tmp[0], tmp[1], tmp[2]));
      }), newNodeLists;
    }
  }, {
    "key" : `getTrailLineInfo`,
    "value" : function(type, obj) {
      var result = {};
      return result.timeInfo = this.getSiteTimes(type, obj), result.startTime = Cesium.JulianDate.fromDate(new Date(2015, 2, 25, 16)), result.stopTime = Cesium.JulianDate.addSeconds(result.startTime, result.timeInfo.timeSum, new Cesium["JulianDate"]), result;
    }
  }, {
    "key" : `getSiteTimes`,
    "value" : function(name, obj) {
      var cfgArr = [0];
      var val = 0;
      var i = 1;
      for (; i < name.length; i++) {
        val = val + this.spaceDistance([name[i - 1], name[i]]) / obj;
        cfgArr.push(val);
      }
      return {
        "timeSum" : val,
        "siteTimes" : cfgArr
      };
    }
  }]);
  definition = destroy;
  expect(timeout, [{
    "key" : `start`,
    "value" : function() {
      this.stop();
      this.addRoamLine(this.positions, this.style.speed);
    }
  }, {
    "key" : "addRoamLine",
    "value" : function(type, obj) {
      var map = this;
      var addition = this.getSiteTimes(type, obj);
      var time = Cesium.JulianDate.fromDate(new Date(2015, 2, 25, 16));
      obj = Cesium.JulianDate.addSeconds(time, addition.timeSum, new Cesium.JulianDate);
      this.viewer.clock.startTime = time.clone();
      this.viewer.clock.stopTime = obj.clone();
      this.viewer.clock.currentTime = time.clone();
      this.viewer.clock.clockRange = Cesium.ClockRange.LOOP_STOP;
      type = this.getSampledPositionProperty(type, time, addition.siteTimes);
      this.addModel(time, obj, type);
      this.addEvent();
      this.timoutId = setTimeout(function(canCreateDiscussions) {
        var parseInt = hahaha;
        map.stop();
        map[parseInt(1968)][parseInt(2477)]();
      }, 1E3 * addition.timeSum);
    }
  }, {
    "key" : `addModel`,
    "value" : function(name, key, data) {
      this.animateEntity = this.viewer.entities.add({
        "availability" : new Cesium["TimeIntervalCollection"]([new Cesium.TimeInterval({
          "start" : name,
          "stop" : key
        })]),
        "position" : data,
        "orientation" : new Cesium["VelocityOrientationProperty"](data),
        "model" : {
          "uri" : this.style.modelUrl,
          "scale" : this.style.scale
        },
        "path" : {
          "resolution" : 1,
          "material" : new Cesium.PolylineGlowMaterialProperty({
            "glowPower" : 0.1,
            "color" : Cesium.Color.YELLOW
          }),
          "width" : 10
        }
      });
    }
  }, {
    "key" : `addEvent`,
    "value" : function() {
      if (0 != this.style.role) {
        if (1 != this.style.role) {
          this.viewer.clock.onTick.addEventListener(this.traceHandler, this);
        } else {
          this.viewer.trackedEntity = this.animateEntity;
        }
      }
    }
  }, {
    "key" : `traceHandler`,
    "value" : function() {
      var center = this.animateEntity.position.getValue(this.viewer.clock.currentTime);
      var orientation = this.animateEntity.orientation.getValue(this.viewer.clock.currentTime);
      var transform = Cesium.Transforms.eastNorthUpToFixedFrame(center);
      transform = Cesium.Matrix4.fromRotationTranslation(Cesium.Matrix3.fromQuaternion(orientation), center);
      if (2 == this.style.role) {
        this.viewer.camera.lookAtTransform(transform, new Cesium["Cartesian3"](-100, 0, 50));
      } else {
        this.viewer.camera.lookAtTransform(transform, new Cesium["Cartesian3"](-50, 0, 250));
      }
    }
  }, {
    "key" : `removeEvent`,
    "value" : function() {
      this.viewer.clock.onTick.removeEventListener(this.traceHandler, this);
      this.viewer.camera.lookAtTransform(Cesium.Matrix4.IDENTITY);
    }
  }, {
    "key" : "stop",
    "value" : function() {
      this.removeEvent();
      if (this.animateEntity) {
        this.viewer.entities.remove(this.animateEntity);
        this.animateEntity = void 0;
      }
      clearTimeout(this.timoutId);
    }
  }, {
    "key" : `getSampledPositionProperty`,
    "value" : function(name, target, prop) {
      var data = new Cesium.SampledPositionProperty;
      var i = 0;
      for (; i < name.length; i++) {
        var stop = Cesium.JulianDate.addSeconds(target, prop[i], new Cesium["JulianDate"]);
        data.addSample(stop, name[i]);
      }
      return data;
    }
  }, {
    "key" : `getSiteTimes`,
    "value" : function(name, obj) {
      var errorMessage_1 = 0;
      var errors = [];
      var i = 0;
      for (; i < name.length; i++) {
        if (0 != i) {
          errorMessage_1 = errorMessage_1 + this.spaceDistance([name[i - 1], name[i]]) / obj;
          errors.push(errorMessage_1);
        } else {
          errors.push(0);
        }
      }
      return {
        "timeSum" : errorMessage_1,
        "siteTimes" : errors
      };
    }
  }, {
    "key" : "spaceDistance",
    "value" : function(name) {
      var count = 0;
      var i = 0;
      for (; i < name.length - 1; i++) {
        var start = Cesium.Cartographic.fromCartesian(name[i]);
        var end = Cesium.Cartographic.fromCartesian(name[i + 1]);
        var n = new Cesium["EllipsoidGeodesic"];
        n.setEndPoints(start, end);
        n = n.surfaceDistance;
        count = count + (n = Math.sqrt(Math.pow(n, 2) + Math.pow(end.height - start.height, 2)));
      }
      return count.toFixed(2);
    }
  }]);
  obj = timeout;
  expect(move, [{
    "key" : "start",
    "value" : function() {
      this.addRoamLine(this.positions);
    }
  }, {
    "key" : `addRoamLine`,
    "value" : function(obj) {
      var global = this;
      this.clearAnimateEntity();
      var renderState = this.getSiteTimes(obj, this.style.speed || 10);
      var date = Cesium.JulianDate.fromDate(new Date(2015, 2, 25, 16));
      var i = Cesium.JulianDate.addSeconds(date, renderState.timeSum, new Cesium["JulianDate"]);
      this.viewer.clock.startTime = date.clone();
      this.viewer.clock.stopTime = i.clone();
      this.viewer.clock.currentTime = date.clone();
      this.viewer.clock.clockRange = Cesium.ClockRange.LOOP_STOP;
      obj = this.computeCirclularFlight(obj, date, renderState.siteTimes);
      this.animateEntity = this.viewer.entities.add({
        "availability" : new Cesium.TimeIntervalCollection([new Cesium["TimeInterval"]({
          "start" : date,
          "stop" : i
        })]),
        "position" : obj,
        "orientation" : new Cesium["VelocityOrientationProperty"](obj),
        "model" : {
          "uri" : this.style.modelUrl,
          "scale" : this.style.scale
        }
      });
      this.viewer.trackedEntity = this.animateEntity;
      this.viewer.clock.onTick.addEventListener(this.traceHandler, this);
      this.timoutId = setTimeout(function(canCreateDiscussions) {
        var put_rows = hahaha;
        global.clearAnimateEntity();
        global[put_rows(2276)].clock[put_rows(1825)][put_rows(1091)](global[put_rows(666)], global);
      }, 1E3 * renderState.timeSum);
      this.ePosition = this.positions[0];
      if (this.style.waveCircleShow) {
        this.addEllipse();
      }
    }
  }, {
    "key" : `addEllipse`,
    "value" : function() {
      var rpm_traffic = this;
      this.eEntity = this.viewer.entities.add({
        "position" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
          var now = hahaha;
          return rpm_traffic[now(1882)];
        }, false),
        "ellipse" : {
          "height" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
            var now = hahaha;
            return rpm_traffic[now(933)]();
          }, false),
          "semiMinorAxis" : 20,
          "semiMajorAxis" : 20,
          "material" : new Animation({
            "duration" : 5E3,
            "gradient" : 0,
            "color" : Cesium.Color.YELLOW,
            "count" : 3
          })
        }
      });
    }
  }, {
    "key" : "getHeight",
    "value" : function() {
      return Cesium.Cartographic.fromCartesian(this.ePosition).height;
    }
  }, {
    "key" : `traceHandler`,
    "value" : function() {
      this.ePosition = this.animateEntity.position.getValue(this.viewer.clock.currentTime);
    }
  }, {
    "key" : `clearAnimateEntity`,
    "value" : function() {
      if (this.animateEntity) {
        this.viewer.clock.onTick.removeEventListener(this.traceHandler, this);
        this.viewer.entities.remove(this.animateEntity);
        this.animateEntity = void 0;
        this.viewer.entities.remove(this.eEntity);
        this.eEntity = void 0;
      }
      clearTimeout(this.timoutId);
    }
  }, {
    "key" : `stop`,
    "value" : function() {
      this.clearAnimateEntity();
    }
  }, {
    "key" : `computeCirclularFlight`,
    "value" : function(name, target, prop) {
      var data = new Cesium.SampledPositionProperty;
      var i = 0;
      for (; i < name.length; i++) {
        var stop = Cesium.JulianDate.addSeconds(target, prop[i], new Cesium["JulianDate"]);
        data.addSample(stop, name[i]);
      }
      return data;
    }
  }, {
    "key" : "getSiteTimes",
    "value" : function(name, obj) {
      var errorMessage_1 = 0;
      var errors = [];
      var i = 0;
      for (; i < name.length; i++) {
        if (0 != i) {
          errorMessage_1 = errorMessage_1 + this.spaceDistance([name[i - 1], name[i]]) / obj;
          errors.push(errorMessage_1);
        } else {
          errors.push(0);
        }
      }
      return {
        "timeSum" : errorMessage_1,
        "siteTimes" : errors
      };
    }
  }, {
    "key" : `spaceDistance`,
    "value" : function(name) {
      var count = 0;
      var i = 0;
      for (; i < name.length - 1; i++) {
        var start = Cesium.Cartographic.fromCartesian(name[i]);
        var end = Cesium.Cartographic.fromCartesian(name[i + 1]);
        var n = new Cesium["EllipsoidGeodesic"];
        n.setEndPoints(start, end);
        n = n.surfaceDistance;
        count = count + (n = Math.sqrt(Math.pow(n, 2) + Math.pow(end.height - start.height, 2)));
      }
      return count.toFixed(2);
    }
  }]);
  descriptor = move;
  xt3d.TrackRoam = {
    "TrackLine" : definition,
    "Roam" : obj,
    "WalkMan" : descriptor
  };
  appendCSS(` .video-popup3d-container {\n     min-width: 250px;\n     min-height: 200px;\n     max-width: 400px;\n     max-height: 400px;\n     background: #14193399;\n     position: absolute;\n     left: 0px;\n     bottom: 0px;\n     cursor: default;\n }\n \n .video-popup3d-container::before {\n     content: "";\n     width: calc(100% + 22px);\n     height: 39px;\n     position: absolute;\n     bottom: -39px;\n     left: -22px;\n     background: url(../../../../static/images/popup3d/popup3d.png) 0px 0px no-repeat;\n     background-position: 0px 0px;\n }\n \n .video-popup3d-header {\n     height: 30px;\n     color: white;\n     background: #1f3f8e;\n     line-height: 30px;\n }\n \n .video-popup3d-header-title {\n     display: inline-block;\n     height: 100%;\n     margin-left: 5px;\n }\n \n .video-popup3d-close {\n     position: absolute;\n     right: 1px;\n     font-size: 25px;\n     cursor: pointer;\n     width: 29px;\n     text-align: center;\n }\n \n .video-popup3d-close:hover {\n     background: #dc2929b9;\n }\n \n .video-jd-temp {\n     width: 400px;\n     height: 240px;\n }`, 
  {});
  expect(Class, [{
    "key" : `init`,
    "value" : function() {
      this.createDom();
      this.addEvent();
    }
  }, {
    "key" : `createDom`,
    "value" : function() {
      var rejectingServer = this;
      var container = document.createElement("div");
      container.classList.add("video-popup3d-container");
      var storyContainerDiv = document.createElement("div");
      storyContainerDiv.classList.add("video-popup3d-header");
      container.appendChild(storyContainerDiv);
      var title = document.createElement("span");
      title.innerHTML = this.videoInfo.name;
      title.classList.add("video-popup3d-header-title");
      storyContainerDiv.appendChild(title);
      title = document.createElement("span");
      title.innerHTML = "\u00d7";
      title.classList.add("video-popup3d-close");
      storyContainerDiv.appendChild(title);
      storyContainerDiv = document.createElement("div");
      storyContainerDiv.classList.add("video-popup3d-body");
      container.appendChild(storyContainerDiv);
      this.$container = container;
      this.$body = storyContainerDiv;
      this.viewer.cesiumWidget.container.append(container);
      title.onclick = function(branch) {
        rejectingServer.close();
      };
      this.createVideo();
    }
  }, {
    "key" : `createVideo`,
    "value" : function() {
      var img = document.createElement("video");
      img.classList.add("video-jd-temp");
      img.setAttribute("controls", true);
      img.setAttribute("autoplay", "autoplay");
      img.setAttribute("src", this.videoInfo.url);
      this.$body.appendChild(img);
      var BOOL_IMAGE = "vid" + (new Date).getTime();
      img.setAttribute("id", BOOL_IMAGE);
    }
  }, {
    "key" : `addEvent`,
    "value" : function() {
      this.viewer.scene.postRender.addEventListener(this.postRenderEvent, this);
    }
  }, {
    "key" : `postRenderEvent`,
    "value" : function() {
      var len = this.viewer.scene.canvas.height;
      var result = new Cesium.Cartesian2;
      Cesium.SceneTransforms.wgs84ToWindowCoordinates(this.viewer.scene, this.position, result);
      this.$container.style.bottom = len - result.y + 80 + "px";
      this.$container.style.left = result.x + 20 + "px";
    }
  }, {
    "key" : `close`,
    "value" : function() {
      this.viewer.scene.postRender.removeEventListener(this.postRenderEvent, this);
      this.$container.remove();
    }
  }]);
  name = Class;
  appendCSS(`.video-popup3d-container {\n    min-width: 250px;\n    min-height: 200px;\n    max-width: 400px;\n    max-height: 400px;\n    background: #14193399;\n    position: absolute;\n    left: 0px;\n    bottom: 0px;\n    cursor: default;\n}\n\n.video-popup3d-container::before {\n    content: "";\n    width: calc(100% + 22px);\n    height: 39px;\n    position: absolute;\n    bottom: -39px;\n    left: -22px;\n    background: url(../../../../static/images/popup3d/popup3d.png) 0px 0px no-repeat;\n    background-position: 0px 0px;\n}\n\n.video-popup3d-header {\n    height: 30px;\n    color: white;\n    background: #1f3f8e;\n    line-height: 30px;\n}\n\n.video-popup3d-header-title {\n    display: inline-block;\n    height: 100%;\n    margin-left: 5px;\n}\n\n.video-popup3d-close {\n    position: absolute;\n    right: 1px;\n    font-size: 25px;\n    cursor: pointer;\n    width: 29px;\n    text-align: center;\n}\n\n.video-popup3d-close:hover {\n    background: #dc2929b9;\n}\n\n.video-jd-temp {\n    width: 400px;\n    height: 240px;\n}`, 
  {});
  expect(position, [{
    "key" : "init",
    "value" : function() {
      this.createDom();
      this.addEvent();
    }
  }, {
    "key" : "createDom",
    "value" : function() {
      var rejectingServer = this;
      var container = document.createElement("div");
      container.classList.add("video-popup3d-container");
      var storyContainerDiv = document.createElement("div");
      storyContainerDiv.classList.add("video-popup3d-header");
      container.appendChild(storyContainerDiv);
      var title = document.createElement("span");
      title.innerHTML = this.videoInfo.name;
      title.classList.add("video-popup3d-header-title");
      storyContainerDiv.appendChild(title);
      title = document.createElement("span");
      title.innerHTML = "\u00d7";
      title.classList.add("video-popup3d-close");
      storyContainerDiv.appendChild(title);
      storyContainerDiv = document.createElement("div");
      storyContainerDiv.classList.add("video-popup3d-body");
      container.appendChild(storyContainerDiv);
      this.$container = container;
      this.$body = storyContainerDiv;
      this.viewer.cesiumWidget.container.append(container);
      title.onclick = function(branch) {
        rejectingServer.close();
      };
      this.createVideo();
    }
  }, {
    "key" : `createVideo`,
    "value" : function() {
      var same = this;
      var element = document.createElement("video");
      element.classList.add("video-js");
      element.classList.add("vjs-default-skin");
      element.setAttribute("controls", true);
      element.setAttribute("autoplay", "autoplay");
      element.setAttribute("preload", "auto");
      element.setAttribute("muted", true);
      this.$body.appendChild(element);
      var id = "vid" + (new Date).getTime();
      element.setAttribute("id", id);
      var player = videojs(id);
      player.ready(function(canCreateDiscussions) {
        var rel2Mstr = hahaha;
        var afterend = [{
          "src" : same[rel2Mstr(2143)][rel2Mstr(649)],
          "type" : rel2Mstr(2150)
        }];
        player[rel2Mstr(2967)](afterend);
        player[rel2Mstr(2300)]();
      });
      this.player = player;
    }
  }, {
    "key" : `addEvent`,
    "value" : function() {
      this.viewer.scene.postRender.addEventListener(this.postRenderEvent, this);
    }
  }, {
    "key" : `postRenderEvent`,
    "value" : function() {
      var len = this.viewer.scene.canvas.height;
      var result = new Cesium["Cartesian2"];
      Cesium.SceneTransforms.wgs84ToWindowCoordinates(this.viewer.scene, this.position, result);
      this.$container.style.bottom = len - result.y + 80 + "px";
      this.$container.style.left = result.x + 20 + "px";
    }
  }, {
    "key" : `close`,
    "value" : function() {
      if (!this.isDestroy) {
        this.player.dispose();
        this.viewer.scene.postRender.removeEventListener(this.postRenderEvent, this);
        this.$container.remove();
        this.isDestroy = true;
      }
    }
  }]);
  location = position;
  appendCSS(`.video-popup3d-container {\n    min-width: 250px;\n    min-height: 200px;\n    max-width: 400px;\n    max-height: 400px;\n    background: #14193399;\n    position: absolute;\n    left: 0px;\n    bottom: 0px;\n    cursor: default;\n}\n\n.video-popup3d-container::before {\n    content: "";\n    width: calc(100% + 22px);\n    height: 39px;\n    position: absolute;\n    bottom: -39px;\n    left: -22px;\n    background: url(../../../../static/images/popup3d/popup3d.png) 0px 0px no-repeat;\n    background-position: 0px 0px;\n}\n\n.video-popup3d-header {\n    height: 30px;\n    color: white;\n    background: #1f3f8e;\n    line-height: 30px;\n}\n\n.video-popup3d-header-title {\n    display: inline-block;\n    height: 100%;\n    margin-left: 5px;\n}\n\n.video-popup3d-close {\n    position: absolute;\n    right: 1px;\n    font-size: 25px;\n    cursor: pointer;\n    width: 29px;\n    text-align: center;\n}\n\n.video-popup3d-close:hover {\n    background: #dc2929b9;\n}\n\n.video-jd-temp {\n    width: 400px;\n    height: 240px;\n}`, 
  {});
  expect(max, [{
    "key" : `init`,
    "value" : function() {
      this.createDom();
      this.addEvent();
    }
  }, {
    "key" : `createDom`,
    "value" : function() {
      var frontpageItems = this;
      var container = document.createElement("div");
      container.classList.add("video-popup3d-container");
      var storyContainerDiv = document.createElement("div");
      storyContainerDiv.classList.add("video-popup3d-header");
      container.appendChild(storyContainerDiv);
      var title = document.createElement("span");
      title.innerHTML = this.videoInfo.name;
      title.classList.add("video-popup3d-header-title");
      storyContainerDiv.appendChild(title);
      title = document.createElement("span");
      title.innerHTML = "\u00d7";
      title.classList.add("video-popup3d-close");
      storyContainerDiv.appendChild(title);
      storyContainerDiv = document.createElement("div");
      storyContainerDiv.classList.add("video-popup3d-body");
      container.appendChild(storyContainerDiv);
      this.$container = container;
      this.$body = storyContainerDiv;
      this.viewer.cesiumWidget.container.append(container);
      title.onclick = function(branch) {
        var parseInt = hahaha;
        frontpageItems[parseInt(1471)]();
      };
      this.createVideo();
    }
  }, {
    "key" : `createVideo`,
    "value" : function() {
      var video = document.createElement("video");
      video.classList.add("video-js");
      video.classList.add("vjs-default-skin");
      video.classList.add("vjs-big-play-centered");
      video.classList.add("video-jd-temp");
      video.setAttribute("controls", true);
      video.setAttribute("autoplay", "autoplay");
      video.setAttribute("preload", "auto");
      var vid = document.createElement("source");
      vid.setAttribute("type", "rtmp/flv");
      vid.setAttribute("src", this.videoInfo.url);
      video.appendChild(vid);
      this.$body.appendChild(video);
      vid = "vid" + (new Date).getTime();
      video.setAttribute("id", vid);
      var player = videojs(vid);
      player.ready(function(canCreateDiscussions) {
        player.play();
      });
      this.player = player;
    }
  }, {
    "key" : `addEvent`,
    "value" : function() {
      this.viewer.scene.postRender.addEventListener(this.postRenderEvent, this);
    }
  }, {
    "key" : `postRenderEvent`,
    "value" : function() {
      var len = this.viewer.scene.canvas.height;
      var result = new Cesium["Cartesian2"];
      Cesium.SceneTransforms.wgs84ToWindowCoordinates(this.viewer.scene, this.position, result);
      this.$container.style.bottom = len - result.y + 80 + "px";
      this.$container.style.left = result.x + 20 + "px";
    }
  }, {
    "key" : `close`,
    "value" : function() {
      if (!this.isDestroy) {
        this.player.dispose();
        this.viewer.scene.postRender.removeEventListener(this.postRenderEvent, this);
        this.$container.remove();
        this.isDestroy = true;
      }
    }
  }]);
  frame = max;
  Matrix2D.prototype.CalculateCoordinates = function(data, t, u, y) {
    var yMax = y * Math.sin(2 * this.PI / 360 * u);
    y = y * Math.cos(2 * this.PI / 360 * u);
    if (360 < t) {
      t = t % 360;
    }
    if (t < 0) {
      t = 360 + t % 360;
    }
    var w;
    var h;
    u = this.lonLat2WebMercator(data);
    data = null;
    data = t <= 90 ? (w = y * Math.cos(2 * this.PI / 360 * t), h = y * Math.sin(2 * this.PI / 360 * t), {
      "x" : u.x + w,
      "y" : u.y - h
    }) : 90 < t && t <= 180 ? (w = y * Math.sin(2 * this.PI / 360 * (t - 90)), h = y * Math.cos(2 * this.PI / 360 * (t - 90)), {
      "x" : u.x - w,
      "y" : u.y - h
    }) : 180 < t && t <= 270 ? (w = y * Math.cos(2 * this.PI / 360 * (t - 180)), h = y * Math.sin(2 * this.PI / 360 * (t - 180)), {
      "x" : u.x - w,
      "y" : u.y + h
    }) : (w = y * Math.sin(2 * this.PI / 360 * (t - 270)), h = y * Math.cos(2 * this.PI / 360 * (t - 270)), {
      "x" : u.x + w,
      "y" : u.y + h
    });
    return {
      "lng" : (data = this.webMercator2LonLat(data)).x,
      "lat" : data.y,
      "height" : yMax
    };
  };
  Matrix2D.prototype.lonLat2WebMercator = function(matrix) {
    return {
      "x" : matrix.x * this.a / 180,
      "y" : Math.log(Math.tan((90 + matrix.y) * this.PI / 360)) / (this.PI / 180) * this.a / 180
    };
  };
  Matrix2D.prototype.webMercator2LonLat = function(y) {
    var audioOffsetX = y.x / this.a * 180;
    y = y.y / this.a * 180;
    return {
      "x" : audioOffsetX,
      "y" : y = 180 / this.PI * (2 * Math.exp(y * this.PI / 180) - this.PI / 2)
    };
  };
  Matrix2D.prototype.get_atan = function(value, oldValue) {
    var bits = void 0;
    return 0 == value ? bits = this.PI / 2 : 0 == oldValue ? bits = this.PI : (bits = Math.atan(Math.abs(oldValue / value)), 0 < oldValue && value < 0 ? bits = this.PI - bits : oldValue < 0 && value < 0 ? bits = this.PI + bits : oldValue < 0 && 0 < value && (bits = 2 * this.M_PI - bits)), bits;
  };
  Matrix2D.prototype.ConvertLLAToXYZ = function(c) {
    var newangle2 = this.PI / 180 * c.longitude;
    var bearingRad = this.PI / 180 * c.latitude;
    var h = c.altitude;
    c = this.a / Math.sqrt(1 - this.ee * Math.sin(bearingRad) * Math.sin(bearingRad));
    return {
      "x" : (c + h) * Math.cos(bearingRad) * Math.cos(newangle2),
      "y" : (c + h) * Math.cos(bearingRad) * Math.sin(newangle2),
      "z" : (c * (1 - this.ee) + h) * Math.sin(bearingRad)
    };
  };
  Matrix2D.prototype.ConvertXYZToLLA = function(axis) {
    var _0x4c78cb = this.get_atan(axis.x, axis.y);
    if (_0x4c78cb < 0) {
      _0x4c78cb = _0x4c78cb + this.PI;
    }
    var startAngle;
    var endAngle = this.get_atan(Math.sqrt(axis.x * axis.x + axis.y * axis.y), axis.z);
    var touchesLength = Math.sqrt(1 - this.WGSe2 * Math.sin(endAngle) * Math.sin(endAngle));
    var touchesY = (this.WGSa, 0);
    for (; startAngle = endAngle, touchesLength = Math.sqrt(1 - this.WGSe2 * Math.sin(startAngle) * Math.sin(startAngle)), touchesY = this.WGSa / touchesLength, endAngle = this.get_atan(Math.sqrt(axis.x * axis.x + axis.y * axis.y), axis.z + touchesY * this.WGSe2 * Math.sin(startAngle)), Math.abs(endAngle - startAngle) > this.EPSILON;) {
    }
    var altitude = Math.sqrt(axis.x * axis.x + axis.y * axis.y) / Math.cos(endAngle) - this.WGSa / Math.sqrt(1 - this.WGSe2 * Math.sin(endAngle) * Math.sin(endAngle));
    return {
      "longitude" : 180 * _0x4c78cb / this.PI,
      "latitude" : 180 * endAngle / this.PI,
      "altitude" : altitude
    };
  };
  Matrix2D.prototype.enu_to_ecef = function(a, p) {
    var b = p.distance;
    var k = p.azimuth;
    var f = p.elevation;
    var cosDeltaPhi = 0 <= f ? b * Math.sin(this.PI / 180 * f) : -1 * b * Math.sin(this.PI / 180 * Math.abs(f));
    var x = b * Math.cos(this.PI / 180 * Math.abs(f));
    var d = void 0;
    var sinDeltaPhi = void 0;
    sinDeltaPhi = k <= 90 ? (d = x * Math.sin(this.PI / 180 * k), x * Math.cos(this.PI / 180 * k)) : 90 < k && k < 180 ? (d = x * Math.cos(this.PI / 180 * (k - 90)), -1 * x * Math.sin(this.PI / 180 * (k - 90))) : 180 < k && k < 270 ? (d = -1 * x * Math.sin(this.PI / 180 * (k - 180)), -1 * x * Math.cos(this.PI / 180 * (k - 180))) : (d = -1 * x * Math.sin(this.PI / 180 * (360 - k)), x * Math.cos(this.PI / 180 * (360 - k)));
    var i = this.radians(a.latitude);
    var r = this.radians(a.longitude);
    p = a.altitude;
    b = Math.sin(i);
    f = this.a / Math.sqrt(1 - this.e_sq * b * b);
    x = Math.sin(i);
    k = Math.cos(i);
    a = Math.sin(r);
    b = Math.cos(r);
    i = (p + f) * k * b;
    r = (p + f) * k * a;
    p = (p + (1 - this.e_sq) * f) * x;
    f = k * cosDeltaPhi - x * sinDeltaPhi;
    k = x * cosDeltaPhi + k * sinDeltaPhi;
    sinDeltaPhi = b * f - a * d;
    d = a * f + b * d;
    return this.ConvertXYZToLLA({
      "x" : sinDeltaPhi + i,
      "y" : d + r,
      "z" : k + p
    });
  };
  Matrix2D.prototype.radians = function(a) {
    return this.PI / 180 * a;
  };
  init = function(value, options) {
    this.viewer = value;
    this.CT = new Matrix2D;
    this.options = options;
    value = this.initCameraParam();
    this.near = value.near || 0.1;
    this.cameraPosition = value.cameraPosition;
    this.position = value.position;
    this.alpha = value.alpha || 1;
    this.video = options.video;
    this.debugFrustum = Cesium.defaultValue(value.debugFrustum, true);
    this.aspectRatio = value.aspectRatio || 1;
    this.fov = value.fov || 40;
    if (this.cameraPosition && this.position) {
      this.activeVideo();
      this.getOrientation();
      this.createShadowMap();
      this.addCameraFrustum();
      this.addPostProcess();
      this.viewer.scene.primitives.add(this);
    } else {
      console.log("\u4f4d\u7f6e\u5750\u6807\u9519\u8bef");
    }
  };
  init.prototype.getStyle = function() {
    return this.options;
  };
  init.prototype.updateStyle = function(opts) {
    this.viewer.scene.primitives.remove(this.cameraFrustum);
    this.options = opts;
    var options = this.initCameraParam();
    this.near = options.near || 0.1;
    this.cameraPosition = options.cameraPosition;
    this.position = options.position;
    this.alpha = options.alpha || 1;
    this.debugFrustum = Cesium.defaultValue(options.debugFrustum, true);
    this.aspectRatio = opts.aspectRatio || 1;
    this.fov = options.fov || 400;
    if (this.cameraPosition && this.position) {
      this.getOrientation();
      this.createShadowMap();
      this.addCameraFrustum();
    } else {
      console.log("\u4f4d\u7f6e\u5750\u6807\u9519\u8bef");
    }
  };
  init.prototype.initCameraParam = function() {
    var point = this.CT.enu_to_ecef({
      "longitude" : +this.options.position.x,
      "latitude" : +this.options.position.y,
      "altitude" : +this.options.position.z
    }, {
      "distance" : this.options.far,
      "azimuth" : +this.options.rotation.y,
      "elevation" : +this.options.rotation.x
    });
    point = Cesium.Cartesian3.fromDegrees(point.longitude, point.latitude, point.altitude);
    return {
      "cameraPosition" : Cesium.Cartesian3.fromDegrees(+this.options.position.x, +this.options.position.y, +this.options.position.z),
      "position" : point,
      "alpha" : this.options.alpha,
      "near" : this.options.near,
      "fov" : this.options.fov,
      "debugFrustum" : this.options.debugFrustum
    };
  };
  init.prototype.activeVideo = function() {
    var video = this.video;
    var same = this;
    if (video) {
      if (!this.activeVideoListener) {
        this.activeVideoListener = function() {
          var rel2Mstr = hahaha;
          if (same[rel2Mstr(1073)]) {
            same[rel2Mstr(1073)][rel2Mstr(1701)]();
          }
          same[rel2Mstr(1073)] = new (Cesium[rel2Mstr(2002)])({
            "context" : same[rel2Mstr(2276)][rel2Mstr(2758)].context,
            "source" : video,
            "width" : 1,
            "height" : 1,
            "pixelFormat" : Cesium[rel2Mstr(1106)][rel2Mstr(1058)],
            "pixelDatatype" : Cesium.PixelDatatype.UNSIGNED_BYTE
          });
        };
      }
      this.viewer.clock.onTick.addEventListener(this.activeVideoListener);
    }
  };
  init.prototype.deActiveVideo = function() {
    if (this.activeVideoListener) {
      this.viewer.clock.onTick.removeEventListener(this.activeVideoListener);
      delete this.activeVideoListener;
    }
  };
  init.prototype.update = function(fullName) {
    if (this.viewShadowMap) {
      this.viewer.scene.frameState.shadowMaps.push(this.viewShadowMap);
    }
  };
  init.prototype.createShadowMap = function() {
    var camera = new Cesium.Camera(this.viewer.scene);
    camera.position = this.cameraPosition;
    camera.direction = Cesium.Cartesian3.subtract(this.position, this.cameraPosition, new Cesium.Cartesian3(0, 0, 0));
    camera.up = Cesium.Cartesian3.normalize(this.cameraPosition, new Cesium["Cartesian3"](0, 0, 0));
    var far = Cesium.Cartesian3.distance(this.position, this.cameraPosition);
    camera.frustum = new Cesium["PerspectiveFrustum"]({
      "fov" : Cesium.Math.toRadians(this.fov),
      "aspectRatio" : this.aspectRatio,
      "near" : this.near,
      "far" : far
    });
    this.viewShadowMap = new Cesium.ShadowMap({
      "lightCamera" : camera,
      "enable" : false,
      "darkness" : 1,
      "isPointLight" : false,
      "isSpotLight" : true,
      "cascadesEnabled" : false,
      "context" : this.viewer.scene.context,
      "pointLightRadius" : far
    });
  };
  init.prototype.getOrientation = function() {
    var i = Cesium.Cartesian3.normalize(Cesium.Cartesian3.subtract(this.position, this.cameraPosition, new Cesium["Cartesian3"]), new Cesium["Cartesian3"]);
    var state = Cesium.Cartesian3.normalize(this.cameraPosition, new Cesium["Cartesian3"]);
    var result = new Cesium["Camera"](this.viewer.scene);
    result.position = this.cameraPosition;
    result.direction = i;
    result.up = state;
    i = result.directionWC;
    state = result.upWC;
    var dir = result.rightWC;
    var relativeYDiff = new Cesium["Cartesian3"];
    var matrix = new Cesium["Matrix3"];
    result = new Cesium["Quaternion"];
    dir = Cesium.Cartesian3.negate(dir, relativeYDiff);
    return Cesium.Matrix3.setColumn(matrix, 0, dir, matrix), Cesium.Matrix3.setColumn(matrix, 1, state, matrix), Cesium.Matrix3.setColumn(matrix, 2, i, matrix), result = Cesium.Quaternion.fromRotationMatrix(matrix, result), this.orientation = result;
  };
  init.prototype.addCameraFrustum = function() {
    this.cameraFrustum = new Cesium["Primitive"]({
      "geometryInstances" : new Cesium.GeometryInstance({
        "geometry" : new Cesium.FrustumOutlineGeometry({
          "origin" : this.cameraPosition,
          "orientation" : this.orientation,
          "frustum" : this.viewShadowMap._lightCamera.frustum,
          "_drawNearPlane" : true
        }),
        "attributes" : {
          "color" : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.YELLOW.withAlpha(0.5))
        }
      }),
      "appearance" : new Cesium["PerInstanceColorAppearance"]({
        "translucent" : false,
        "flat" : true
      }),
      "asynchronous" : false,
      "show" : this.debugFrustum
    });
    this.viewer.scene.primitives.add(this.cameraFrustum);
  };
  init.prototype.setFrustumVisible = function(canCreateDiscussions) {
    if (this.cameraFrustum) {
      this.debugFrustum = canCreateDiscussions;
      this.cameraFrustum.show = this.debugFrustum;
    }
  };
  init.prototype.addPostProcess = function() {
    var rpm_traffic = this;
    var matrix = rpm_traffic.viewShadowMap._isPointLight ? rpm_traffic.viewShadowMap._pointBias : rpm_traffic.viewShadowMap._primitiveBias;
    this.postProcess = new Cesium["PostProcessStage"]({
      "fragmentShader" : "uniform float mixNum;uniform sampler2D colorTexture;uniform sampler2D stcshadow; uniform sampler2D videoTexture;uniform sampler2D depthTexture;uniform mat4 _shadowMap_matrix; uniform vec4 shadowMap_lightPositionEC; uniform vec4 shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness; uniform vec4 shadowMap_texelSizeDepthBiasAndNormalShadingSmooth; varying vec2 v_textureCoordinates;vec4 toEye(in vec2 uv, in float depth){  vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));  vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0);  posInCamera =posInCamera / posInCamera.w;  return posInCamera;}float getDepth(in vec4 depth){  float z_window = czm_unpackDepth(depth);  z_window = czm_reverseLogDepth(z_window);  float n_range = czm_depthRange.near;  float f_range = czm_depthRange.far;  return (2.0 * z_window - n_range - f_range) / (f_range - n_range);}float _czm_sampleShadowMap(sampler2D shadowMap, vec2 uv){  return texture2D(shadowMap, uv).r;}float _czm_shadowDepthCompare(sampler2D shadowMap, vec2 uv, float depth){  return step(depth, _czm_sampleShadowMap(shadowMap, uv));}float _czm_shadowVisibility(sampler2D shadowMap, czm_shadowParameters shadowParameters){  float depthBias = shadowParameters.depthBias;  float depth = shadowParameters.depth;  float nDotL = shadowParameters.nDotL;  float normalShadingSmooth = shadowParameters.normalShadingSmooth;  float darkness = shadowParameters.darkness;  vec2 uv = shadowParameters.texCoords;  depth -= depthBias;  vec2 texelStepSize = shadowParameters.texelStepSize;  float radius = 1.0;  float dx0 = -texelStepSize.x * radius;  float dy0 = -texelStepSize.y * radius;  float dx1 = texelStepSize.x * radius;  float dy1 = texelStepSize.y * radius;  float visibility =   (  _czm_shadowDepthCompare(shadowMap, uv, depth)  +_czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy0), depth) +  _czm_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy0), depth) +  _czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy0), depth) +  _czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, 0.0), depth) +  _czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, 0.0), depth) +  _czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy1), depth) +  _czm_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy1), depth) +  _czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy1), depth)  ) * (1.0 / 9.0)  ;  return visibility;}vec3 pointProjectOnPlane(in vec3 planeNormal, in vec3 planeOrigin, in vec3 point){  vec3 v01 = point -planeOrigin;  float d = dot(planeNormal, v01) ;  return (point - planeNormal * d);}float ptm(vec3 pt){  return sqrt(pt.x*pt.x + pt.y*pt.y + pt.z*pt.z);}void main() {   const float PI = 3.141592653589793;  vec4 color = texture2D(colorTexture, v_textureCoordinates);  vec4 currD = texture2D(depthTexture, v_textureCoordinates);  if(currD.r>=1.0){ gl_FragColor = color; return;  } float depth = getDepth(currD);  vec4 positionEC = toEye(v_textureCoordinates, depth);  vec3 normalEC = vec3(1.0);  czm_shadowParameters shadowParameters;   shadowParameters.texelStepSize = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.xy;   shadowParameters.depthBias = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.z;   shadowParameters.normalShadingSmooth = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.w;   shadowParameters.darkness = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.w;   shadowParameters.depthBias *= max(depth * 0.01, 1.0);   vec3 directionEC = normalize(positionEC.xyz - shadowMap_lightPositionEC.xyz);   float nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0);   vec4 shadowPosition = _shadowMap_matrix * positionEC;   shadowPosition /= shadowPosition.w;   if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0))))   {  gl_FragColor = color; return;  }  shadowParameters.texCoords = shadowPosition.xy;   shadowParameters.depth = shadowPosition.z;   shadowParameters.nDotL = nDotL;   float visibility = _czm_shadowVisibility(stcshadow, shadowParameters);   vec4 videoColor = texture2D(videoTexture,shadowPosition.xy);  if(visibility==1.0){ gl_FragColor = mix(color,vec4(videoColor.xyz,1.0),mixNum*videoColor.a);  }else{  if(abs(shadowPosition.z-0.0)<0.01){   return; } gl_FragColor = color; }}",
      "uniforms" : {
        "mixNum" : function() {
          var now = hahaha;
          return rpm_traffic[now(1470)];
        },
        "stcshadow" : function() {
          var now = hahaha;
          return rpm_traffic[now(1153)][now(2156)];
        },
        "videoTexture" : function() {
          return rpm_traffic.videoTexture;
        },
        "_shadowMap_matrix" : function() {
          var now = hahaha;
          return rpm_traffic[now(1153)][now(1944)];
        },
        "shadowMap_lightPositionEC" : function() {
          var now = hahaha;
          return rpm_traffic[now(1153)]._lightPositionEC;
        },
        "shadowMap_texelSizeDepthBiasAndNormalShadingSmooth" : function() {
          var now = hahaha;
          var scratchPosition = new Cesium.Cartesian2;
          return scratchPosition.x = 1 / rpm_traffic.viewShadowMap[now(1351)].x, scratchPosition.y = 1 / rpm_traffic[now(1153)][now(1351)].y, Cesium[now(2399)].fromElements(scratchPosition.x, scratchPosition.y, matrix[now(1746)], matrix[now(1702)], this.combinedUniforms1);
        },
        "shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness" : function() {
          var now = hahaha;
          return Cesium[now(2399)][now(1740)](matrix[now(975)], rpm_traffic[now(1153)][now(2942)], rpm_traffic.viewShadowMap[now(1267)], rpm_traffic[now(1153)][now(2624)], this[now(2174)]);
        }
      }
    });
    this.viewer.scene.postProcessStages.add(this.postProcess);
  };
  init.prototype.destroy = function() {
    this.viewer.scene.postProcessStages.remove(this.postProcess);
    this.viewer.scene.primitives.remove(this.cameraFrustum);
    if (this.activeVideoListener) {
      this.viewer.clock.onTick.removeEventListener(this.activeVideoListener);
    }
    if (this.activeVideoListener) {
      delete this.activeVideoListener;
    }
    delete this.postProcess;
    delete this.viewShadowMap;
    delete this.cameraPosition;
    delete this.position;
    delete this.alpha;
    delete this._camerafov;
    delete this._cameraPosition;
    delete this.videoTexture;
    delete this.cameraFrustum;
    delete this._debugFrustum;
    delete this._position;
    delete this._aspectRatio;
    delete this.url;
    delete this.orientation;
    this.viewer.scene.primitives.remove(this);
    delete this.viewer;
  };
  init.prototype.remove = function() {
    this.destroy();
  };
  var T = {
    "POLYGON" : `polygon`,
    "WALL" : `wall`
  };
  data = (expect(reviewFeature, [{
    "key" : "generatePositions",
    "value" : function() {
      var same = this;
      this.positions = [];
      var coordinates = void 0;
      switch(this.geometry.type) {
        case "LineString":
          coordinates = this.coordinates;
          break;
        case "Polygon":
          coordinates = this.coordinates[0];
      }
      coordinates.forEach(function(canCreateDiscussions) {
        var rel2Mstr = hahaha;
        same[rel2Mstr(1707)][rel2Mstr(2008)](Cesium.Cartesian3[rel2Mstr(2770)](canCreateDiscussions[0], canCreateDiscussions[1], canCreateDiscussions[2]));
      });
    }
  }, {
    "key" : `setPositions`,
    "value" : function(name) {
      switch(this.positions = name || [], this.coordinates = [], this.geometry.type) {
        case "LineString":
          this.setLineStringCoordinates();
          break;
        case "Polygon":
          this.setPolygonCoordinates();
      }
      if (this.updatePositionAction) {
        this.updatePositionAction();
      }
    }
  }, {
    "key" : `setLineStringCoordinates`,
    "value" : function() {
      var colData = this;
      this.positions.forEach(function(result) {
        var parseInt = hahaha;
        result = Cesium[parseInt(1543)][parseInt(2206)](result);
        result = [Cesium[parseInt(2090)][parseInt(1611)](result[parseInt(2596)]), Cesium[parseInt(2090)].toDegrees(result[parseInt(480)]), result[parseInt(1132)]];
        colData[parseInt(2656)][parseInt(2008)](result);
      });
    }
  }, {
    "key" : `setPolygonCoordinates`,
    "value" : function() {
      var primaryReplicas = this;
      this.coordinates.push([]);
      this.positions.forEach(function(promise) {
        var stringify = hahaha;
        promise = Cesium.Cartographic[stringify(2206)](promise);
        promise = [Cesium[stringify(2090)][stringify(1611)](promise[stringify(2596)]), Cesium[stringify(2090)][stringify(1611)](promise[stringify(480)]), promise[stringify(1132)]];
        primaryReplicas[stringify(2656)][0][stringify(2008)](promise);
      });
    }
  }, {
    "key" : `getPositions`,
    "value" : function() {
      var primaryReplicas = [];
      var coordinates = void 0;
      switch(this.geometry.type) {
        case "LineString":
          coordinates = this.coordinates;
          break;
        case "Polygon":
          coordinates = this.coordinates[0];
      }
      return coordinates.forEach(function(tmp) {
        var stringify = hahaha;
        primaryReplicas[stringify(2008)](Cesium[stringify(3131)].fromDegrees(tmp[0], tmp[1], tmp[2]));
      }), primaryReplicas;
    }
  }, {
    "key" : `getPositionCount`,
    "value" : function() {
      return this.positions.length;
    }
  }, {
    "key" : "setSelected",
    "value" : function(name) {
    }
  }, {
    "key" : `openEditMode`,
    "value" : function(name) {
    }
  }, {
    "key" : "remove",
    "value" : function() {
    }
  }]), reviewFeature);
  var AsyncVDOMBuilder = (_inherits(LeanKitNotifier, data), expect(LeanKitNotifier, [{
    "key" : "createEntity",
    "value" : function() {
      this.initHeights();
      this.initWall();
    }
  }, {
    "key" : `getStyle`,
    "value" : function() {
      return this.style;
    }
  }, {
    "key" : "updateStyle",
    "value" : function() {
      this.initHeights();
    }
  }, {
    "key" : `updatePositionAction`,
    "value" : function() {
      this.initHeights();
    }
  }, {
    "key" : `initHeights`,
    "value" : function() {
      this.style.baseHeight = geocode(this.positions, this.style.baseHeight);
      if (this.style.baseHeight < 0) {
        this.style.baseHeight = 0;
      }
      var crossfilterable_layers = (new Array(this.positions.length)).fill(this.style.baseHeight);
      var newNodeLists = [];
      var layer_i = 0;
      for (; layer_i < crossfilterable_layers.length; layer_i++) {
        newNodeLists.push(crossfilterable_layers[layer_i] + this.style.wallHeight);
      }
      this.minimumHeights = crossfilterable_layers;
      this.maximumHeights = newNodeLists;
    }
  }, {
    "key" : "initWall",
    "value" : function() {
      var primaryReplicas = this;
      this.wallEntity = this.viewer.entities.add({
        "plotType" : this.properties.plotBase,
        "plotCode" : this.properties.plotCode,
        "wall" : {
          "positions" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
            var stringify = hahaha;
            return primaryReplicas[stringify(1707)];
          }, false),
          "minimumHeights" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
            return primaryReplicas.minimumHeights;
          }, false),
          "maximumHeights" : new Cesium.CallbackProperty(function(canCreateDiscussions) {
            var stringify = hahaha;
            return primaryReplicas[stringify(441)];
          }, false),
          "material" : Cesium.Color.DARKGREEN.withAlpha(0.5),
          "outline" : false,
          "outlineWidth" : 10,
          "outlineColor" : Cesium.Color.AQUA
        }
      });
    }
  }, {
    "key" : "setSelected",
    "value" : function(value) {
      this.wallEntity.wall.outline = value;
    }
  }, {
    "key" : `playVideo`,
    "value" : function() {
      if (this.style.url) {
        this.createVideo();
      }
    }
  }, {
    "key" : "stopVideo",
    "value" : function() {
    }
  }, {
    "key" : `createVideo`,
    "value" : function() {
      var same = this;
      if (this.$video) {
        this.$video.remove();
      }
      var video = document.createElement("video");
      video.classList.add("video-jd-temp");
      video.setAttribute("controls", true);
      video.setAttribute("autoplay", "autoplay");
      video.setAttribute("src", this.style.url);
      var _videoPath = "vid" + (new Date).getTime();
      video.setAttribute("id", _videoPath);
      this.viewer.cesiumWidget.container.append(video);
      video.addEventListener("play", function() {
        var rel2Mstr = hahaha;
        same[rel2Mstr(1133)][rel2Mstr(3092)][rel2Mstr(1187)] = video;
      });
      this.$video = video;
    }
  }, {
    "key" : `getDefaultStyle`,
    "value" : function() {
      return {
        "wallHeight" : 10,
        "fontSize" : 84,
        "text" : "\u7acb\u4f53\u89c6\u9891\u5899",
        "url" : "../../static/lukou.mp4"
      };
    }
  }, {
    "key" : `toGeoJson`,
    "value" : function() {
      return {
        "type" : "Feature",
        "properties" : this.properties,
        "geometry" : {
          "type" : "LineString",
          "coordinates" : this.coordinates
        }
      };
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.viewer.entities.remove(this.wallEntity);
      if (this.$video) {
        this.$video.remove();
      }
    }
  }]), LeanKitNotifier);
  var _render = function(globalData, config, parent) {
    if (config === T.WALL) {
      return new AsyncVDOMBuilder(globalData, parent);
    }
  };
  definition = (_inherits(AudioStyleControls, meta), expect(AudioStyleControls, [{
    "key" : `addPlot`,
    "value" : function(obj) {
      return obj = _render(this.viewer, obj.properties.plotType, obj), this.plots.push(obj), obj;
    }
  }, {
    "key" : `flyToByPlotCode`,
    "value" : function(name) {
      var e = this.getByPlotCode(name);
      if (e) {
        if (e.properties.plotType === T.WALL) {
          this.viewer.flyTo(e.wallEntity);
        }
        this.setSelectedPlotByCode(name);
      }
    }
  }, {
    "key" : `initEvent`,
    "value" : function() {
      var obj = this;
      (new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas)).setInputAction(function(e) {
        var parseInt = hahaha;
        if (obj[parseInt(455)]) {
          if ((e = obj[parseInt(2276)][parseInt(2758)][parseInt(1708)](e.position)) && e.id) {
            if (!(e.id && e.id.type && parseInt(2843) == e.id[parseInt(1720)])) {
              if (obj[parseInt(1277)]) {
                obj[parseInt(1277)].setSelected(false);
                obj[parseInt(1277)] = void 0;
                obj[parseInt(1346)].raiseEvent(void 0);
              }
            }
            if (!(obj.selectedPlot && obj[parseInt(1277)][parseInt(2931)][parseInt(2717)] == e.id[parseInt(2717)])) {
              if (e = obj[parseInt(2426)](e.id[parseInt(2717)])) {
                obj.clearSelectedPlot();
                obj[parseInt(1277)] = e;
                obj[parseInt(1277)][parseInt(1666)](true);
                obj[parseInt(1346)][parseInt(2477)](e);
              } else {
                if (obj[parseInt(1277)]) {
                  obj.selectedPlot.setSelected(false);
                  obj[parseInt(1277)] = void 0;
                }
                obj[parseInt(1346)][parseInt(2477)](void 0);
              }
            }
          } else {
            if (obj[parseInt(1277)]) {
              obj.selectedPlot[parseInt(1666)](false);
              obj[parseInt(1277)] = void 0;
              obj[parseInt(1346)][parseInt(2477)](void 0);
            }
          }
        }
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
    }
  }, {
    "key" : `setSelectedPlotByCode`,
    "value" : function(type) {
      this.clearSelectedPlot();
      type = this.getByPlotCode(type);
      if (type) {
        this.selectedPlot = type;
        this.selectedPlot.setSelected(true);
        this.selectedPlotChanged.raiseEvent(type);
      }
    }
  }, {
    "key" : `clearSelectedPlot`,
    "value" : function() {
      if (this.selectedPlot) {
        this.selectedPlot.setSelected(false);
        this.selectedPlot = void 0;
      }
    }
  }]), AudioStyleControls);
  expect(iframe, [{
    "key" : `initEventHandler`,
    "value" : function() {
      this.eventHandler = new Cesium["ScreenSpaceEventHandler"](this.viewer.scene.canvas);
    }
  }, {
    "key" : `activate`,
    "value" : function() {
      this.deactivate();
      this.initLeftClickEventHandler();
    }
  }, {
    "key" : `deactivate`,
    "value" : function() {
      this.eventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_CLICK);
      this.unRegisterEvents();
      this.clear();
    }
  }, {
    "key" : `clear`,
    "value" : function() {
      if (this.editVideoWallPlot) {
        this.editVideoWallPlot.openEditMode(true);
      }
      this.clearEditVertex();
      this.clearMidVertex();
    }
  }, {
    "key" : `initLeftClickEventHandler`,
    "value" : function() {
      var self = this;
      this.eventHandler.setInputAction(function(data) {
        var String = hahaha;
        data = self.viewer[String(2758)].pick(data[String(586)]);
        if (data) {
          if (data.id && "VideoWallPlot" == data.id[String(549)]) {
            if (!(self.editVideoWallPlot && self[String(2948)].plotCode == data.id.plotCode)) {
              self.handleEditVideoWallPlot();
              self.handlePickVideoWallPlot(data.id);
            }
          } else {
            self[String(2822)]();
          }
        } else {
          self[String(890)]();
        }
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
    }
  }, {
    "key" : `handleEditVideoWallPlot`,
    "value" : function() {
      this.clear();
      this.editVideoWallPlot = void 0;
      if (this.isEdited) {
        this.isEdited = false;
        this.isEditing = false;
      }
    }
  }, {
    "key" : "handlePickVideoWallPlot",
    "value" : function(name) {
      this.editVideoWallPlot = this.textMapPlotLayer.getByPlotCode(name.plotCode);
      if (this.editVideoWallPlot) {
        this.isEditing = false;
        this.isEdited = false;
        this.editVideoWallPlot.openEditMode(true);
        this.editPositions = this.editVideoWallPlot.getPositions();
        this.EditMoveCenterPositoin = this.getVideoWallPlotCenterPosition();
        this.clear();
        this.createEditVertex();
        this.createMidVertex();
        this.registerEvents();
      }
    }
  }, {
    "key" : `registerEvents`,
    "value" : function() {
      this.initLeftDownEventHandler();
      this.initMouseMoveEventHandler();
      this.initLeftUpEventHandler();
    }
  }, {
    "key" : `unRegisterEvents`,
    "value" : function() {
      this.eventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOWN);
      this.eventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_UP);
      this.eventHandler.removeInputAction(Cesium.ScreenSpaceEventType.MOUSE_MOVE);
    }
  }, {
    "key" : `initLeftDownEventHandler`,
    "value" : function() {
      var obj = this;
      this.eventHandler.setInputAction(function(options) {
        var parseInt = hahaha;
        options = obj.viewer[parseInt(2758)][parseInt(1708)](options[parseInt(586)]);
        if (options && options.id && options.id[parseInt(1720)]) {
          if (parseInt(2760) == options.id[parseInt(1720)] || "VideoWallPlotEditMove" == options.id[parseInt(1720)]) {
            obj[parseInt(3088)] = true;
            obj[parseInt(2276)][parseInt(2758)][parseInt(2190)][parseInt(1218)] = false;
            obj[parseInt(2276)][parseInt(1633)] = false;
            obj.viewer[parseInt(2530)][parseInt(1998)][parseInt(737)] = "";
            document.body.style[parseInt(737)] = parseInt(367);
            obj[parseInt(1670)] = options.id;
            obj[parseInt(1670)][parseInt(2752)] = false;
            obj[parseInt(1521)]();
          } else {
            if ("VideoWallPlotEditMidVertex" == options.id[parseInt(1720)]) {
              obj[parseInt(1484)][parseInt(2998)](options.id.vertexIndex, 0, options.id[parseInt(586)]._value);
              obj[parseInt(2948)][parseInt(2631)](obj[parseInt(1484)]);
              obj[parseInt(2822)]();
              obj[parseInt(1779)]();
              obj[parseInt(2142)]();
              obj[parseInt(581)] = true;
            }
          }
        }
      }, Cesium.ScreenSpaceEventType.LEFT_DOWN);
    }
  }, {
    "key" : `initLeftUpEventHandler`,
    "value" : function() {
      var options = this;
      this.eventHandler.setInputAction(function(canCreateDiscussions) {
        var extname = hahaha;
        if (options.isEditing) {
          options[extname(2276)][extname(1633)] = true;
          document[extname(1494)][extname(1998)][extname(737)] = "default";
          options.viewer[extname(2758)].screenSpaceCameraController[extname(1218)] = true;
          options[extname(1670)][extname(2752)] = true;
          options[extname(3088)] = false;
          options[extname(1521)]();
          options.createMidVertex();
          if (extname(2442) == options.editVideoWallPlot.PlotType) {
            options.editVideoWallPlot[extname(1013)]();
          }
        }
      }, Cesium.ScreenSpaceEventType.LEFT_UP);
    }
  }, {
    "key" : `initMouseMoveEventHandler`,
    "value" : function() {
      var map = this;
      this.eventHandler.setInputAction(function(key) {
        var parseInt = hahaha;
        var mouseMoveFunction = map[parseInt(2276)].scene[parseInt(1238)](key.endPosition);
        if (mouseMoveFunction && map[parseInt(3088)]) {
          if ("VideoWallPlotEditMove" == map[parseInt(1670)][parseInt(1720)]) {
            key = map[parseInt(1054)];
            if (!key) {
              return;
            }
            map.moveEntityByOffset(key, mouseMoveFunction);
          } else {
            map[parseInt(1484)][map[parseInt(1670)][parseInt(1593)]] = mouseMoveFunction;
            map[parseInt(2948)][parseInt(2631)](map[parseInt(1484)]);
          }
          map[parseInt(581)] = true;
          map[parseInt(1054)] = map[parseInt(797)]();
        }
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
    }
  }, {
    "key" : `getVideoWallPlotCenterPosition`,
    "value" : function() {
      var line = [];
      var z = 0;
      this.editPositions.forEach(function(x) {
        var put_rows = hahaha;
        x = require(x);
        line[put_rows(2008)]([x.x, x.y]);
        if (z < x.z) {
          z = x.z;
        }
      });
      var tmp = turf.lineString(line);
      tmp = turf.bbox(tmp);
      tmp = turf.bboxPolygon(tmp);
      tmp = turf.center(tmp).geometry.coordinates;
      return Cesium.Cartesian3.fromDegrees(tmp[0], tmp[1], z);
    }
  }, {
    "key" : `moveEntityByOffset`,
    "value" : function(target, source) {
      target = require(target);
      source = require(source);
      var mergeAxisLength = source.x - target.x;
      var SHIP_SPEED = source.y - target.y;
      var z = source.z - target.z;
      var movmethod = this.editVideoWallPlot.properties.plotType;
      var json = void 0;
      var i = 0;
      for (; i < this.editPositions.length; i++) {
        (json = require(this.editPositions[i])).x += mergeAxisLength;
        json.y += SHIP_SPEED;
        if (!(movmethod != T.CIRCLE && movmethod != T.RECTANGLE)) {
          json.z += z;
        }
        this.editPositions[i] = Cesium.Cartesian3.fromDegrees(json.x, json.y, json.z);
      }
      this.editVideoWallPlot.setPositions(this.editPositions);
    }
  }, {
    "key" : `createEditVertex`,
    "value" : function() {
      var same = this;
      this.vertexEntities = [];
      this.editVideoWallPlot.getPositions().forEach(function(canCreateDiscussions, key) {
        var rel2Mstr = hahaha;
        var artistTrack = same[rel2Mstr(2276)][rel2Mstr(1319)].add({
          "position" : new (Cesium[rel2Mstr(1679)])(function(canCreateDiscussions) {
            var now = rel2Mstr;
            return same[now(1484)][key];
          }, false),
          "type" : rel2Mstr(2760),
          "vertexIndex" : key,
          "point" : {
            "color" : Cesium[rel2Mstr(2292)].DARKBLUE.withAlpha(0.4),
            "pixelSize" : 10,
            "outlineColor" : Cesium[rel2Mstr(2292)][rel2Mstr(2537)][rel2Mstr(2265)](0.4),
            "outlineWidth" : 3,
            "disableDepthTestDistance" : 2E3
          }
        });
        same[rel2Mstr(1220)][rel2Mstr(2008)](artistTrack);
      });
      if (1 != this.editPositions.length) {
        this.createEditMoveCenterEntity();
      }
    }
  }, {
    "key" : "createEditMoveCenterEntity",
    "value" : function() {
      var _0x58a33c = this;
      this.EditMoveCenterEntity = this.viewer.entities.add({
        "position" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
          return _0x58a33c.EditMoveCenterPositoin;
        }, false),
        "type" : "VideoWallPlotEditMove",
        "point" : {
          "color" : Cesium.Color.RED.withAlpha(0.4),
          "pixelSize" : 10,
          "outlineColor" : Cesium.Color.WHITE.withAlpha(0.3),
          "outlineWidth" : 3,
          "disableDepthTestDistance" : 2E3
        }
      });
    }
  }, {
    "key" : `clearEditVertex`,
    "value" : function() {
      var lithe = this;
      if (this.vertexEntities) {
        this.vertexEntities.forEach(function(mmCoreSplitViewBlock) {
          var resolve = hahaha;
          lithe.viewer[resolve(1319)][resolve(508)](mmCoreSplitViewBlock);
        });
      }
      this.vertexEntities = [];
      this.viewer.entities.remove(this.EditMoveCenterEntity);
    }
  }, {
    "key" : `createMidVertex`,
    "value" : function() {
      if (this.editVideoWallPlot.properties.plotType != T.WALL) {
        this.midVertexEntities = [];
        var layer_i = 0;
        for (; layer_i < this.editPositions.length; layer_i++) {
          var gridPosition = geodeticToGeocentric(this.editPositions[layer_i], this.editPositions[layer_i + 1]);
          gridPosition = this.viewer.entities.add({
            "position" : gridPosition,
            "type" : "VideoWallPlotEditMidVertex",
            "vertexIndex" : layer_i + 1,
            "point" : {
              "color" : Cesium.Color.LIMEGREEN.withAlpha(0.4),
              "pixelSize" : 10,
              "outlineColor" : Cesium.Color.YELLOW.withAlpha(0.4),
              "outlineWidth" : 3,
              "disableDepthTestDistance" : 2E3
            }
          });
          this.midVertexEntities.push(gridPosition);
        }
      }
    }
  }, {
    "key" : "clearMidVertex",
    "value" : function() {
      var primaryReplicas = this;
      if (this.midVertexEntities) {
        this.midVertexEntities.forEach(function(mmCoreSplitViewBlock) {
          var stringify = hahaha;
          primaryReplicas[stringify(2276)].entities[stringify(508)](mmCoreSplitViewBlock);
        });
      }
      this.midVertexEntities = [];
    }
  }]);
  obj = iframe;
  expect(d, [{
    "key" : `activate`,
    "value" : function(name) {
      this.deactivate();
      this.clear();
      this.plotType = name;
      this.positions = [];
      this.plotDrawTip = new Map(this.viewer);
      this.MousePoint = new Date(this.viewer);
      this.registerEvents();
      this.viewer.enableCursorStyle = false;
      this.viewer._element.style.cursor = "default";
      this.initTip();
    }
  }, {
    "key" : `initTip`,
    "value" : function() {
      if (this.plotType === T.WALL) {
        this.plotDrawTip.setContent(["\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a\u89c6\u9891\u5899\uff0c\u9700\u89812\u4e2a\u70b9", "\u6309\u4e0b\u9f20\u6807\u5de6\u952e\u786e\u5b9a\u7b2c1\u4e2a\u70b9", "\u6309\u4e0b\u9f20\u6807\u53f3\u952e\u53d6\u6d88\u7ed8\u5236"]);
      }
    }
  }, {
    "key" : "deactivate",
    "value" : function() {
      this.unRegisterEvents();
      this.plotType = void 0;
      this.viewer._element.style.cursor = "pointer";
      this.viewer.enableCursorStyle = true;
      if (this.plotDrawTip) {
        this.plotDrawTip.remove();
        this.MousePoint.remove();
        this.plotDrawTip = void 0;
        this.MousePoint = void 0;
      }
    }
  }, {
    "key" : "clear",
    "value" : function() {
      if (this.plot) {
        this.plot.remove();
        this.plot = void 0;
      }
    }
  }, {
    "key" : "generatePlot",
    "value" : function(name) {
      var nsReg = createIntervalElements();
      name = this.generateGeoFeature(nsReg, name);
      this.plot = _render(this.viewer, this.plotType, name);
      this.plot.openEditMode(true);
    }
  }, {
    "key" : "generateGeoFeature",
    "value" : function(type, obj) {
      var geomType = void 0;
      var data = void 0;
      switch(this.plotType) {
        case T.WALL:
          geomType = "LineString";
          data = this.getLineStringCoordinates(obj);
          break;
        case T.POLYGON:
          geomType = "Polygon";
          data = this.getPolygonCoordinates(obj);
      }
      return {
        "type" : "Feature",
        "properties" : {
          "plotCode" : type,
          "style" : void 0
        },
        "geometry" : {
          "type" : geomType,
          "coordinates" : data
        }
      };
    }
  }, {
    "key" : `getLineStringCoordinates`,
    "value" : function(name) {
      var primaryReplicas = [];
      return name.forEach(function(data) {
        var stringify = hahaha;
        data = Cesium.Cartographic[stringify(2206)](data);
        data = [Cesium[stringify(2090)][stringify(1611)](data[stringify(2596)]), Cesium.Math[stringify(1611)](data[stringify(480)]), data[stringify(1132)]];
        primaryReplicas[stringify(2008)](data);
      }), primaryReplicas;
    }
  }, {
    "key" : `getPolygonCoordinates`,
    "value" : function(name) {
      var el = [[]];
      return name.forEach(function(result) {
        var property = hahaha;
        result = Cesium[property(1543)][property(2206)](result);
        result = [Cesium[property(2090)][property(1611)](result[property(2596)]), Cesium.Math[property(1611)](result[property(480)]), result[property(1132)]];
        el[0][property(2008)](result);
      }), el;
    }
  }, {
    "key" : `initEvents`,
    "value" : function() {
      this.handler = new Cesium["ScreenSpaceEventHandler"](this.viewer.scene.canvas);
      this.PlotDrawStartEvent = new Cesium.Event;
      this.PlotDrawEndEvent = new Cesium.Event;
    }
  }, {
    "key" : `registerEvents`,
    "value" : function() {
      this.leftClickEvent();
      this.rightClickEvent();
      this.mouseMoveEvent();
    }
  }, {
    "key" : `leftClickEvent`,
    "value" : function() {
      var _this = this;
      this.handler.setInputAction(function(bShowArray) {
        var parseInt = hahaha;
        _this.viewer[parseInt(2530)][parseInt(1998)].cursor = parseInt(1654);
        bShowArray = _this[parseInt(2276)][parseInt(2758)][parseInt(1238)](bShowArray[parseInt(586)]);
        if (bShowArray) {
          _this[parseInt(1707)][parseInt(2008)](bShowArray);
          if (1 == _this.positions[parseInt(2189)]) {
            _this[parseInt(2700)](_this.positions);
          } else {
            _this[parseInt(1298)][parseInt(2631)](_this[parseInt(1707)]);
          }
          _this.setTipContent();
          if (_this[parseInt(1298)][parseInt(2862)] == _this[parseInt(1707)][parseInt(2189)]) {
            _this.drawEnd();
            _this[parseInt(1983)]();
          }
        }
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
    }
  }, {
    "key" : "setTipContent",
    "value" : function() {
      if (this.plotType === T.WALL) {
        this.plotDrawTip.setContent(["\u5f53\u524d\u7ed8\u5236\u7c7b\u578b\uff1a\u89c6\u9891\u5899\uff0c\u9700\u89812\u4e2a\u70b9\u3002", "\u5df2\u6709" + this.positions.length + "\u4e2a\u70b9\uff0c\u6309\u4e0b\u9f20\u6807\u5de6\u952e\u786e\u5b9a\u7b2c" + (this.positions.length + 1) + "\u4e2a\u70b9", this.positions.length < 2 ? "\u6309\u4e0b\u9f20\u6807\u53f3\u952e\u53d6\u6d88\u7ed8\u5236" : "\u6309\u4e0b\u9f20\u6807\u53f3\u952e\u7ed3\u675f\u7ed8\u5236"]);
      }
    }
  }, {
    "key" : "mouseMoveEvent",
    "value" : function() {
      var obj = this;
      this.handler.setInputAction(function(bShowArray) {
        var parseInt = hahaha;
        obj[parseInt(2276)]._element[parseInt(1998)][parseInt(737)] = parseInt(1654);
        bShowArray = obj[parseInt(2276)][parseInt(2758)][parseInt(1238)](bShowArray[parseInt(2840)]);
        if (bShowArray) {
          obj.plotDrawTip[parseInt(3164)](bShowArray);
          obj.MousePoint[parseInt(3164)](bShowArray);
          if (obj[parseInt(1298)]) {
            bShowArray = obj[parseInt(1707)][parseInt(439)]([bShowArray]);
            obj[parseInt(1298)][parseInt(2631)](bShowArray);
          }
        }
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
    }
  }, {
    "key" : `rightClickEvent`,
    "value" : function() {
      var obj = this;
      this.handler.setInputAction(function(canCreateDiscussions) {
        var parseInt = hahaha;
        if (0 != obj[parseInt(1707)][parseInt(2189)]) {
          if (obj[parseInt(1298)][parseInt(2862)]) {
            if (obj[parseInt(1707)][parseInt(2189)] == obj[parseInt(1298)].fixPositionCount) {
              obj.plot.setPositions(obj[parseInt(1707)]);
              obj[parseInt(2788)]();
              obj[parseInt(1983)]();
            } else {
              obj[parseInt(1983)]();
              obj[parseInt(2822)]();
            }
          } else {
            if (obj.positions[parseInt(2189)] >= obj[parseInt(1298)][parseInt(3107)]) {
              obj[parseInt(1298)][parseInt(2631)](obj.positions);
              obj.drawEnd();
              obj.deactivate();
            } else {
              obj[parseInt(1983)]();
              obj[parseInt(2822)]();
            }
          }
        } else {
          obj[parseInt(1983)]();
        }
      }, Cesium.ScreenSpaceEventType.RIGHT_CLICK);
    }
  }, {
    "key" : `unRegisterEvents`,
    "value" : function() {
      this.handler.removeInputAction(Cesium.ScreenSpaceEventType.RIGHT_CLICK);
      this.handler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_CLICK);
      this.handler.removeInputAction(Cesium.ScreenSpaceEventType.MOUSE_MOVE);
      this.handler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);
    }
  }, {
    "key" : `drawEnd`,
    "value" : function() {
      this.plot.openEditMode(false);
      this.PlotDrawEndEvent.raiseEvent(this.plot, this.plotType);
    }
  }]);
  descriptor = d;
  _getMatrixAsString.prototype.CalculateCoordinates = function(data, t, u, y) {
    var yMax = y * Math.sin(2 * this.PI / 360 * u);
    y = y * Math.cos(2 * this.PI / 360 * u);
    if (360 < t) {
      t = t % 360;
    }
    if (t < 0) {
      t = 360 + t % 360;
    }
    var w;
    var h;
    u = this.lonLat2WebMercator(data);
    data = null;
    data = t <= 90 ? (w = y * Math.cos(2 * this.PI / 360 * t), h = y * Math.sin(2 * this.PI / 360 * t), {
      "x" : u.x + w,
      "y" : u.y - h
    }) : 90 < t && t <= 180 ? (w = y * Math.sin(2 * this.PI / 360 * (t - 90)), h = y * Math.cos(2 * this.PI / 360 * (t - 90)), {
      "x" : u.x - w,
      "y" : u.y - h
    }) : 180 < t && t <= 270 ? (w = y * Math.cos(2 * this.PI / 360 * (t - 180)), h = y * Math.sin(2 * this.PI / 360 * (t - 180)), {
      "x" : u.x - w,
      "y" : u.y + h
    }) : (w = y * Math.sin(2 * this.PI / 360 * (t - 270)), h = y * Math.cos(2 * this.PI / 360 * (t - 270)), {
      "x" : u.x + w,
      "y" : u.y + h
    });
    return {
      "lng" : (data = this.webMercator2LonLat(data)).x,
      "lat" : data.y,
      "height" : yMax
    };
  };
  _getMatrixAsString.prototype.lonLat2WebMercator = function(matrix) {
    return {
      "x" : matrix.x * this.a / 180,
      "y" : Math.log(Math.tan((90 + matrix.y) * this.PI / 360)) / (this.PI / 180) * this.a / 180
    };
  };
  _getMatrixAsString.prototype.webMercator2LonLat = function(y) {
    var audioOffsetX = y.x / this.a * 180;
    y = y.y / this.a * 180;
    return {
      "x" : audioOffsetX,
      "y" : y = 180 / this.PI * (2 * Math.exp(y * this.PI / 180) - this.PI / 2)
    };
  };
  _getMatrixAsString.prototype.get_atan = function(value, oldValue) {
    var bits = void 0;
    return 0 == value ? bits = this.PI / 2 : 0 == oldValue ? bits = this.PI : (bits = Math.atan(Math.abs(oldValue / value)), 0 < oldValue && value < 0 ? bits = this.PI - bits : oldValue < 0 && value < 0 ? bits = this.PI + bits : oldValue < 0 && 0 < value && (bits = 2 * this.M_PI - bits)), bits;
  };
  _getMatrixAsString.prototype.ConvertLLAToXYZ = function(c) {
    var newangle2 = this.PI / 180 * c.longitude;
    var bearingRad = this.PI / 180 * c.latitude;
    var h = c.altitude;
    c = this.a / Math.sqrt(1 - this.ee * Math.sin(bearingRad) * Math.sin(bearingRad));
    return {
      "x" : (c + h) * Math.cos(bearingRad) * Math.cos(newangle2),
      "y" : (c + h) * Math.cos(bearingRad) * Math.sin(newangle2),
      "z" : (c * (1 - this.ee) + h) * Math.sin(bearingRad)
    };
  };
  _getMatrixAsString.prototype.ConvertXYZToLLA = function(axis) {
    var _0x362860 = this.get_atan(axis.x, axis.y);
    if (_0x362860 < 0) {
      _0x362860 = _0x362860 + this.PI;
    }
    var startAngle;
    var endAngle = this.get_atan(Math.sqrt(axis.x * axis.x + axis.y * axis.y), axis.z);
    var touchesLength = Math.sqrt(1 - this.WGSe2 * Math.sin(endAngle) * Math.sin(endAngle));
    var touchesY = (this.WGSa, 0);
    for (; startAngle = endAngle, touchesLength = Math.sqrt(1 - this.WGSe2 * Math.sin(startAngle) * Math.sin(startAngle)), touchesY = this.WGSa / touchesLength, endAngle = this.get_atan(Math.sqrt(axis.x * axis.x + axis.y * axis.y), axis.z + touchesY * this.WGSe2 * Math.sin(startAngle)), Math.abs(endAngle - startAngle) > this.EPSILON;) {
    }
    var altitude = Math.sqrt(axis.x * axis.x + axis.y * axis.y) / Math.cos(endAngle) - this.WGSa / Math.sqrt(1 - this.WGSe2 * Math.sin(endAngle) * Math.sin(endAngle));
    return {
      "longitude" : 180 * _0x362860 / this.PI,
      "latitude" : 180 * endAngle / this.PI,
      "altitude" : altitude
    };
  };
  _getMatrixAsString.prototype.enu_to_ecef = function(a, p) {
    var b = p.distance;
    var k = p.azimuth;
    var f = p.elevation;
    var cosDeltaPhi = 0 <= f ? b * Math.sin(this.PI / 180 * f) : -1 * b * Math.sin(this.PI / 180 * Math.abs(f));
    var x = b * Math.cos(this.PI / 180 * Math.abs(f));
    var d = void 0;
    var sinDeltaPhi = void 0;
    sinDeltaPhi = k <= 90 ? (d = x * Math.sin(this.PI / 180 * k), x * Math.cos(this.PI / 180 * k)) : 90 < k && k < 180 ? (d = x * Math.cos(this.PI / 180 * (k - 90)), -1 * x * Math.sin(this.PI / 180 * (k - 90))) : 180 < k && k < 270 ? (d = -1 * x * Math.sin(this.PI / 180 * (k - 180)), -1 * x * Math.cos(this.PI / 180 * (k - 180))) : (d = -1 * x * Math.sin(this.PI / 180 * (360 - k)), x * Math.cos(this.PI / 180 * (360 - k)));
    var i = this.radians(a.latitude);
    var r = this.radians(a.longitude);
    p = a.altitude;
    b = Math.sin(i);
    f = this.a / Math.sqrt(1 - this.e_sq * b * b);
    x = Math.sin(i);
    k = Math.cos(i);
    a = Math.sin(r);
    b = Math.cos(r);
    i = (p + f) * k * b;
    r = (p + f) * k * a;
    p = (p + (1 - this.e_sq) * f) * x;
    f = k * cosDeltaPhi - x * sinDeltaPhi;
    k = x * cosDeltaPhi + k * sinDeltaPhi;
    sinDeltaPhi = b * f - a * d;
    d = a * f + b * d;
    return this.ConvertXYZToLLA({
      "x" : sinDeltaPhi + i,
      "y" : d + r,
      "z" : k + p
    });
  };
  _getMatrixAsString.prototype.radians = function(a) {
    return this.PI / 180 * a;
  };
  data = function(value, options) {
    this.viewer = value;
    this.CT = new _getMatrixAsString;
    this.options = options;
    options = this.initCameraParam();
    this.near = options.near || 0.1;
    this.cameraPosition = options.cameraPosition;
    this.position = options.position;
    this.alpha = options.alpha || 1;
    this.url = options.url;
    this.debugFrustum = Cesium.defaultValue(options.debugFrustum, true);
    this.aspectRatio = options.aspectRatio || 1;
    this.fov = options.fov || 400;
    if (this.cameraPosition && this.position) {
      this.activeVideo(this.url);
      this.getOrientation();
      this.createShadowMap();
      this.addCameraFrustum();
      this.addPostProcess();
      this.viewer.scene.primitives.add(this);
    } else {
      console.log("\u4f4d\u7f6e\u5750\u6807\u9519\u8bef");
    }
  };
  data.prototype.getStyle = function() {
    return this.options;
  };
  data.prototype.updateStyle = function(options) {
    this.viewer.scene.primitives.remove(this.cameraFrustum);
    this.options = options;
    options = this.initCameraParam();
    this.near = options.near || 0.1;
    this.cameraPosition = options.cameraPosition;
    this.position = options.position;
    this.alpha = options.alpha || 1;
    this.url = options.url;
    this.debugFrustum = Cesium.defaultValue(options.debugFrustum, true);
    this.aspectRatio = options.aspectRatio || 1;
    this.fov = options.fov || 40;
    if (this.cameraPosition && this.position) {
      this.getOrientation();
      this.createShadowMap();
      this.addCameraFrustum();
    } else {
      console.log("\u4f4d\u7f6e\u5750\u6807\u9519\u8bef");
    }
  };
  data.prototype.initCameraParam = function() {
    var point = this.CT.enu_to_ecef({
      "longitude" : +this.options.position.x,
      "latitude" : +this.options.position.y,
      "altitude" : +this.options.position.z
    }, {
      "distance" : this.options.far,
      "azimuth" : +this.options.rotation.y,
      "elevation" : +this.options.rotation.x
    });
    var lastAngularDefinition = Cesium.Cartesian3.fromDegrees(point.longitude, point.latitude, point.altitude);
    point = Cesium.Cartesian3.fromDegrees(+this.options.position.x, +this.options.position.y, +this.options.position.z);
    return {
      "url" : this.options.url,
      "cameraPosition" : point,
      "position" : lastAngularDefinition,
      "alpha" : this.options.alpha,
      "near" : this.options.near,
      "fov" : this.options.fov,
      "debugFrustum" : this.options.debugFrustum
    };
  };
  data.prototype.createVideoEle = function(options) {
    var element = document.createElement("video");
    element.classList.add("video-js");
    element.classList.add("vjs-default-skin");
    element.setAttribute("controls", true);
    element.setAttribute("autoplay", "autoplay");
    element.setAttribute("preload", "auto");
    element.setAttribute("muted", true);
    document.body.appendChild(element);
    var id = "vid" + (new Date).getTime();
    element.setAttribute("id", id);
    var player = videojs(id);
    return player.ready(function(canCreateDiscussions) {
      var getTypeForAssociation = hahaha;
      var afterend = [{
        "src" : options,
        "type" : getTypeForAssociation(2150)
      }];
      player[getTypeForAssociation(2967)](afterend);
      player[getTypeForAssociation(2300)]();
    }), this.player = player, document.getElementById(id + "_html5_api");
  };
  data.prototype.activeVideo = function(level) {
    var cfg = this.createVideoEle(level);
    var obj = this;
    if (cfg) {
      if (!this.activeVideoListener) {
        this.activeVideoListener = function() {
          var parseInt = hahaha;
          if (obj.videoTexture) {
            obj.videoTexture.destroy();
          }
          obj[parseInt(1073)] = new (Cesium[parseInt(2002)])({
            "context" : obj[parseInt(2276)][parseInt(2758)][parseInt(2470)],
            "source" : cfg,
            "width" : 1,
            "height" : 1,
            "pixelFormat" : Cesium[parseInt(1106)][parseInt(1058)],
            "pixelDatatype" : Cesium[parseInt(2076)][parseInt(1358)]
          });
        };
      }
      this.viewer.clock.onTick.addEventListener(this.activeVideoListener);
    }
  };
  data.prototype.deActiveVideo = function() {
    if (this.activeVideoListener) {
      this.viewer.clock.onTick.removeEventListener(this.activeVideoListener);
      delete this.activeVideoListener;
    }
  };
  data.prototype.update = function(fullName) {
    if (this.viewShadowMap) {
      this.viewer.scene.frameState.shadowMaps.push(this.viewShadowMap);
    }
  };
  data.prototype.createShadowMap = function() {
    var camera = new Cesium["Camera"](this.viewer.scene);
    camera.position = this.cameraPosition;
    camera.direction = Cesium.Cartesian3.subtract(this.position, this.cameraPosition, new Cesium.Cartesian3(0, 0, 0));
    camera.up = Cesium.Cartesian3.normalize(this.cameraPosition, new Cesium.Cartesian3(0, 0, 0));
    var far = Cesium.Cartesian3.distance(this.position, this.cameraPosition);
    camera.frustum = new Cesium["PerspectiveFrustum"]({
      "fov" : Cesium.Math.toRadians(this.fov),
      "aspectRatio" : 1,
      "near" : this.near,
      "far" : far
    });
    this.viewShadowMap = new Cesium["ShadowMap"]({
      "lightCamera" : camera,
      "enable" : false,
      "isPointLight" : false,
      "isSpotLight" : true,
      "cascadesEnabled" : false,
      "context" : this.viewer.scene.context,
      "pointLightRadius" : far
    });
  };
  data.prototype.getOrientation = function() {
    var i = Cesium.Cartesian3.normalize(Cesium.Cartesian3.subtract(this.position, this.cameraPosition, new Cesium["Cartesian3"]), new Cesium["Cartesian3"]);
    var state = Cesium.Cartesian3.normalize(this.cameraPosition, new Cesium["Cartesian3"]);
    var result = new Cesium.Camera(this.viewer.scene);
    result.position = this.cameraPosition;
    result.direction = i;
    result.up = state;
    i = result.directionWC;
    state = result.upWC;
    var dir = result.rightWC;
    var relativeYDiff = new Cesium["Cartesian3"];
    var matrix = new Cesium["Matrix3"];
    result = new Cesium.Quaternion;
    dir = Cesium.Cartesian3.negate(dir, relativeYDiff);
    return Cesium.Matrix3.setColumn(matrix, 0, dir, matrix), Cesium.Matrix3.setColumn(matrix, 1, state, matrix), Cesium.Matrix3.setColumn(matrix, 2, i, matrix), result = Cesium.Quaternion.fromRotationMatrix(matrix, result), this.orientation = result;
  };
  data.prototype.addCameraFrustum = function() {
    this.cameraFrustum = new Cesium["Primitive"]({
      "geometryInstances" : new Cesium.GeometryInstance({
        "geometry" : new Cesium["FrustumGeometry"]({
          "origin" : this.cameraPosition,
          "orientation" : this.orientation,
          "frustum" : this.viewShadowMap._lightCamera.frustum
        })
      }),
      "appearance" : new Cesium.MaterialAppearance({
        "material" : Cesium.Material.fromType("Color")
      }),
      "asynchronous" : false,
      "show" : true
    });
    this.cameraFrustum.appearance.material.uniforms.color = Cesium.Color.AQUA.withAlpha(0.1);
    this.viewer.scene.primitives.add(this.cameraFrustum);
  };
  data.prototype.setFrustumVisible = function(canCreateDiscussions) {
    if (this.cameraFrustum) {
      this.debugFrustum = canCreateDiscussions;
      this.cameraFrustum.show = this.debugFrustum;
    }
  };
  data.prototype.addPostProcess = function() {
    var rpm_traffic = this;
    var updatedEdgesById = rpm_traffic.viewShadowMap._isPointLight ? rpm_traffic.viewShadowMap._pointBias : rpm_traffic.viewShadowMap._primitiveBias;
    this.postProcess = new Cesium.PostProcessStage({
      "fragmentShader" : "uniform float mixNum;uniform sampler2D colorTexture;uniform sampler2D stcshadow; uniform sampler2D videoTexture;uniform sampler2D depthTexture;uniform mat4 _shadowMap_matrix; uniform vec4 shadowMap_lightPositionEC; uniform vec4 shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness; uniform vec4 shadowMap_texelSizeDepthBiasAndNormalShadingSmooth; varying vec2 v_textureCoordinates;vec4 toEye(in vec2 uv, in float depth){  vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));  vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0);  posInCamera =posInCamera / posInCamera.w;  return posInCamera;}float getDepth(in vec4 depth){  float z_window = czm_unpackDepth(depth);  z_window = czm_reverseLogDepth(z_window);  float n_range = czm_depthRange.near;  float f_range = czm_depthRange.far;  return (2.0 * z_window - n_range - f_range) / (f_range - n_range);}float _czm_sampleShadowMap(sampler2D shadowMap, vec2 uv){  return texture2D(shadowMap, uv).r;}float _czm_shadowDepthCompare(sampler2D shadowMap, vec2 uv, float depth){  return step(depth, _czm_sampleShadowMap(shadowMap, uv));}float _czm_shadowVisibility(sampler2D shadowMap, czm_shadowParameters shadowParameters){  float depthBias = shadowParameters.depthBias;  float depth = shadowParameters.depth;  float nDotL = shadowParameters.nDotL;  float normalShadingSmooth = shadowParameters.normalShadingSmooth;  float darkness = shadowParameters.darkness;  vec2 uv = shadowParameters.texCoords;  depth -= depthBias;  vec2 texelStepSize = shadowParameters.texelStepSize;  float radius = 1.0;  float dx0 = -texelStepSize.x * radius;  float dy0 = -texelStepSize.y * radius;  float dx1 = texelStepSize.x * radius;  float dy1 = texelStepSize.y * radius;  float visibility =   (  _czm_shadowDepthCompare(shadowMap, uv, depth)  +_czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy0), depth) +  _czm_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy0), depth) +  _czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy0), depth) +  _czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, 0.0), depth) +  _czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, 0.0), depth) +  _czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy1), depth) +  _czm_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy1), depth) +  _czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy1), depth)  ) * (1.0 / 9.0)  ;  return visibility;}vec3 pointProjectOnPlane(in vec3 planeNormal, in vec3 planeOrigin, in vec3 point){  vec3 v01 = point -planeOrigin;  float d = dot(planeNormal, v01) ;  return (point - planeNormal * d);}float ptm(vec3 pt){  return sqrt(pt.x*pt.x + pt.y*pt.y + pt.z*pt.z);}void main() {   const float PI = 3.141592653589793;  vec4 color = texture2D(colorTexture, v_textureCoordinates);  vec4 currD = texture2D(depthTexture, v_textureCoordinates);  if(currD.r>=1.0){ gl_FragColor = color; return;  } float depth = getDepth(currD);  vec4 positionEC = toEye(v_textureCoordinates, depth);  vec3 normalEC = vec3(1.0);  czm_shadowParameters shadowParameters;   shadowParameters.texelStepSize = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.xy;   shadowParameters.depthBias = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.z;   shadowParameters.normalShadingSmooth = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.w;   shadowParameters.darkness = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.w;   shadowParameters.depthBias *= max(depth * 0.01, 1.0);   vec3 directionEC = normalize(positionEC.xyz - shadowMap_lightPositionEC.xyz);   float nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0);   vec4 shadowPosition = _shadowMap_matrix * positionEC;   shadowPosition /= shadowPosition.w;   if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0))))   {  gl_FragColor = color; return;  }  shadowParameters.texCoords = shadowPosition.xy;   shadowParameters.depth = shadowPosition.z;   shadowParameters.nDotL = nDotL;   float visibility = _czm_shadowVisibility(stcshadow, shadowParameters);   vec4 videoColor = texture2D(videoTexture,shadowPosition.xy);  if(visibility==1.0){ gl_FragColor = mix(color,vec4(videoColor.xyz,1.0),mixNum*videoColor.a);  }else{ if(abs(shadowPosition.z-0.0)<0.01){   return; } gl_FragColor = color;  }} ",
      "uniforms" : {
        "mixNum" : function() {
          var now = hahaha;
          return rpm_traffic[now(1470)];
        },
        "stcshadow" : function() {
          var now = hahaha;
          return rpm_traffic[now(1153)][now(2156)];
        },
        "videoTexture" : function() {
          return rpm_traffic.videoTexture;
        },
        "_shadowMap_matrix" : function() {
          var gotoNewOfflinePage = hahaha;
          return rpm_traffic.viewShadowMap[gotoNewOfflinePage(1944)];
        },
        "shadowMap_lightPositionEC" : function() {
          var now = hahaha;
          return rpm_traffic[now(1153)]._lightPositionEC;
        },
        "shadowMap_texelSizeDepthBiasAndNormalShadingSmooth" : function() {
          var edgeId = hahaha;
          var xhair = new (Cesium[edgeId(2689)]);
          return xhair.x = 1 / rpm_traffic[edgeId(1153)][edgeId(1351)].x, xhair.y = 1 / rpm_traffic[edgeId(1153)]._textureSize.y, Cesium[edgeId(2399)][edgeId(1740)](xhair.x, xhair.y, updatedEdgesById[edgeId(1746)], updatedEdgesById[edgeId(1702)], this[edgeId(811)]);
        },
        "shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness" : function() {
          var edgeId = hahaha;
          return Cesium[edgeId(2399)][edgeId(1740)](updatedEdgesById[edgeId(975)], rpm_traffic[edgeId(1153)][edgeId(2942)], rpm_traffic.viewShadowMap[edgeId(1267)], rpm_traffic[edgeId(1153)][edgeId(2624)], this.combinedUniforms2);
        }
      }
    });
    this.viewer.scene.postProcessStages.add(this.postProcess);
  };
  data.prototype.destroy = function() {
    this.viewer.scene.postProcessStages.remove(this.postProcess);
    this.viewer.scene.primitives.remove(this.cameraFrustum);
    if (this.activeVideoListener) {
      this.viewer.clock.onTick.removeEventListener(this.activeVideoListener);
    }
    if (this.activeVideoListener) {
      delete this.activeVideoListener;
    }
    delete this.postProcess;
    delete this.viewShadowMap;
    delete this.cameraPosition;
    delete this.position;
    delete this.alpha;
    delete this._camerafov;
    delete this._cameraPosition;
    delete this.videoTexture;
    delete this.cameraFrustum;
    delete this._debugFrustum;
    delete this._position;
    delete this._aspectRatio;
    delete this.url;
    delete this.orientation;
    this.viewer.scene.primitives.remove(this);
    delete this.viewer;
    if (this.player) {
      this.player.dispose();
    }
  };
  expect(Camera, [{
    "key" : `createVideoFrustum`,
    "value" : function(value) {
      var parent = new Cesium["HeadingPitchRoll"](Cesium.Math.toRadians(this.rotation.heading), Cesium.Math.toRadians(this.rotation.pitch), Cesium.Math.toRadians(this.rotation.roll));
      this.orientation = Cesium.Transforms.headingPitchRollQuaternion(value, parent);
      this.frustum = new Cesium["PerspectiveFrustum"]({
        "fov" : Cesium.Math.toRadians(this.fov),
        "aspectRatio" : this.aspectRatio,
        "near" : this.near,
        "far" : this.far
      });
      parent = this.createFrustumOutlineGeometry();
      this.outlineFrustum = this.addOutlineFrustum(parent);
      if (this.debugFrustum) {
        this.viewer.scene.primitives.add(this.outlineFrustum);
      }
      var spannedRow = new Float64Array(24);
      Cesium.FrustumGeometry._computeNearFarPlanes(parent._origin, parent._orientation, parent._frustumType, parent._frustum, spannedRow);
      var hierarchy = [];
      var columnPos = 12;
      for (; columnPos < 24; columnPos = columnPos + 3) {
        hierarchy.push(new Cesium["Cartesian3"](spannedRow[columnPos], spannedRow[columnPos + 1], spannedRow[columnPos + 2]));
      }
      this.hierarchy = hierarchy;
    }
  }, {
    "key" : `createFrustumOutlineGeometry`,
    "value" : function() {
      return new Cesium["FrustumOutlineGeometry"]({
        "origin" : this.position,
        "orientation" : this.orientation,
        "frustum" : this.frustum,
        "_drawNearPlane" : true
      });
    }
  }, {
    "key" : `addOutlineFrustum`,
    "value" : function(obj) {
      return new Cesium["Primitive"]({
        "geometryInstances" : new Cesium.GeometryInstance({
          "geometry" : obj,
          "attributes" : {
            "color" : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.BLUE)
          }
        }),
        "appearance" : new Cesium.PerInstanceColorAppearance({
          "translucent" : true,
          "flat" : true
        }),
        "asynchronous" : false,
        "show" : true
      });
    }
  }, {
    "key" : `getStyle`,
    "value" : function() {
      return {
        "fov" : this.fov,
        "near" : this.near,
        "far" : this.far,
        "aspectRatio" : this.aspectRatio,
        "rotation" : this.rotation,
        "debugFrustum" : this.debugFrustum,
        "stRotation" : this.stRotation
      };
    }
  }, {
    "key" : `updateStyle`,
    "value" : function(object) {
      this.rotation = object.rotation;
      this.fov = object.fov || 10;
      this.near = object.near || 0.1;
      this.far = object.far || 100;
      this.aspectRatio = object.aspectRatio || 1;
      this.debugFrustum = object.debugFrustum;
      this.stRotation = object.stRotation || 0;
      this.removeFrustunPrimitive();
      this.createVideoFrustum(this.position);
    }
  }, {
    "key" : `createVideoPolygon`,
    "value" : function() {
      var primaryReplicas = this;
      this.videoEntity = new Cesium.Entity({
        "polygon" : {
          "perPositionHeight" : true,
          "hierarchy" : new Cesium.CallbackProperty(function(canCreateDiscussions) {
            var stringify = hahaha;
            return new (Cesium[stringify(1433)])(primaryReplicas[stringify(753)]);
          }, false),
          "material" : this.videoElement,
          "stRotation" : new Cesium.CallbackProperty(function(canCreateDiscussions) {
            var put_rows = hahaha;
            return Cesium[put_rows(2090)][put_rows(1544)](primaryReplicas.stRotation);
          }, false)
        }
      });
      this.viewer.entities.add(this.videoEntity);
    }
  }, {
    "key" : `removeFrustunPrimitive`,
    "value" : function() {
      if (this.outlineFrustum) {
        this.viewer.scene.primitives.remove(this.outlineFrustum);
        this.outlineFrustum = void 0;
      }
    }
  }, {
    "key" : "remove",
    "value" : function() {
      this.removeFrustunPrimitive();
      if (this.videoEntity) {
        this.viewer.entities.remove(this.videoEntity);
        this.videoEntity = void 0;
      }
    }
  }]);
  meta = Camera;
  xt3d.VideoPlugin = {
    "CommonVideoWindow" : name,
    "HlsVideoWindow" : location,
    "RtmpVideoWindow" : frame,
    "VideoShed3d" : init,
    "HlsVideoFusion" : data,
    "VideoWallPlotLayer" : definition,
    "VideoWallPlotEdit" : obj,
    "VideoWallPlotDraw" : descriptor,
    "VideoPlane" : meta
  };
  expect(status, [{
    "key" : `setPositions`,
    "value" : function(name) {
      this.positions = name || [];
      this.initHeights();
    }
  }, {
    "key" : `initHeights`,
    "value" : function() {
      var types = [];
      this.positions.forEach(function(cache) {
        var put_rows = hahaha;
        cache = Cesium.Cartographic[put_rows(2206)](cache);
        types[put_rows(2008)](cache[put_rows(1132)]);
      });
      var newNodeLists = [];
      var _types = [];
      var i = 0;
      for (; i < types.length; i++) {
        newNodeLists.push(types[i] + this.wallHeight);
        _types.push(types[i]);
      }
      this.minimumHeights = types;
      this.maximumHeights = newNodeLists;
      this.dayMaximumHeights = _types;
    }
  }, {
    "key" : `createEntity`,
    "value" : function() {
      this.initWall();
      this.initDynamicWall();
    }
  }, {
    "key" : `initWall`,
    "value" : function() {
      var primaryReplicas = this;
      this.wallEntity = this.viewer.entities.add({
        "wall" : {
          "positions" : new Cesium.CallbackProperty(function(canCreateDiscussions) {
            var stringify = hahaha;
            return primaryReplicas[stringify(1707)];
          }, false),
          "minimumHeights" : new Cesium.CallbackProperty(function(canCreateDiscussions) {
            var stringify = hahaha;
            return primaryReplicas[stringify(3120)];
          }, false),
          "maximumHeights" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
            return primaryReplicas.maximumHeights;
          }, false),
          "material" : new Cesium.ImageMaterialProperty({
            "image" : "data:image/png;base64,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",
            "transparent" : true,
            "color" : this.wallColor || Cesium.Color.RED
          })
        }
      });
    }
  }, {
    "key" : `initDynamicWall`,
    "value" : function() {
      var obj = this;
      this.dynamicWallEntity = this.viewer.entities.add({
        "wall" : {
          "positions" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
            var put_rows = hahaha;
            return obj[put_rows(1707)];
          }, false),
          "minimumHeights" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
            return obj.minimumHeights;
          }, false),
          "maximumHeights" : new Cesium.CallbackProperty(function(canCreateDiscussions) {
            var parseInt = hahaha;
            var prop = 0;
            for (; prop < obj[parseInt(3120)][parseInt(2189)]; prop++) {
              obj[parseInt(927)][prop] += obj[parseInt(2980)] * obj[parseInt(895)];
              if (obj.dayMaximumHeights[prop] > obj[parseInt(441)][prop]) {
                obj[parseInt(927)][prop] = obj[parseInt(3120)][prop];
              }
            }
            return obj.dayMaximumHeights;
          }, false),
          "material" : new Cesium.ImageMaterialProperty({
            "image" : "data:image/png;base64,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",
            "transparent" : true,
            "color" : this.wallColor || Cesium.Color.RED
          })
        }
      });
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.viewer.entities.remove(this.wallEntity);
      this.viewer.entities.remove(this.dynamicWallEntity);
    }
  }]);
  location = status;
  var user_info = {
    "BASEGRADIENT" : 1,
    "LINEARGRADIENT" : 2,
    "LINEFLOW" : 3,
    "SCROLL" : 4
  };
  Object.defineProperties(Color.prototype, {
    "isConstant" : {
      "get" : function() {
        return false;
      }
    },
    "definitionChanged" : {
      "get" : function() {
        return this._definitionChanged;
      }
    },
    "color" : Cesium.createPropertyDescriptor("color")
  });
  Color.prototype.getType = function(original_full_html) {
    return "Gradient";
  };
  Color.prototype.getValue = function(time, result) {
    return Cesium.defined(result) || (result = {}), result.color = Cesium.Property.getValueOrClonedDefault(this._color, time, Cesium.Color.WHITE, result.color), result.image = Cesium.Material.GradientImage, result;
  };
  Color.prototype.equals = function(other) {
    return this === other || other instanceof Color && Cesium.Property.equals(this._color, other._color);
  };
  Cesium.Material.GradientType = "Gradient";
  Cesium.Material.GradientImage = "data:image/png;base64,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";
  Cesium.Material.GradientSource = `czm_material czm_getMaterial(czm_materialInput materialInput)\n{\n     czm_material material = czm_getDefaultMaterial(materialInput);\n     vec2 st = materialInput.st;\n     vec4 colorImage = texture2D(image, vec2(fract(st.t - time), st.t));\n     material.alpha = colorImage.a * color.a;\n     material.diffuse =  2.5 * color.rgb  ;\n     return material;\n }`;
  Cesium.Material._materialCache.addMaterial(Cesium.Material.GradientType, {
    "fabric" : {
      "type" : Cesium.Material.GradientType,
      "uniforms" : {
        "color" : new Cesium.Color(1, 0, 0, 0.5),
        "image" : Cesium.Material.GradientImage,
        "time" : 0
      },
      "source" : Cesium.Material.GradientSource
    },
    "translucent" : function(material) {
      return true;
    }
  });
  Object.defineProperties(f.prototype, {
    "isConstant" : {
      "get" : function() {
        return false;
      }
    },
    "definitionChanged" : {
      "get" : function() {
        return this._definitionChanged;
      }
    },
    "color" : Cesium.createPropertyDescriptor(`color`)
  });
  f.prototype.getType = function(original_full_html) {
    return "LinearGradient";
  };
  f.prototype.getValue = function(time, result) {
    return Cesium.defined(result) || (result = {}), result.color = Cesium.Property.getValueOrClonedDefault(this._color, time, Cesium.Color.WHITE, result.color), result.image = this.image, result;
  };
  f.prototype.equals = function(other) {
    return this === other || other instanceof f && Cesium.Property.equals(this._color, other._color);
  };
  Cesium.Material.LinearGradientType = `LinearGradient`;
  Cesium.Material.LinearGradientSource = `czm_material czm_getMaterial(czm_materialInput materialInput)\n{\n     czm_material material = czm_getDefaultMaterial(materialInput);\n     vec2 st = materialInput.st;\n     vec4 colorImage = texture2D(image, vec2(fract(st.t - time), st.t));\n     material.alpha = colorImage.a;\n     material.diffuse = colorImage.rgb * 1.3 ;\n     return material;\n }`;
  Cesium.Material._materialCache.addMaterial(Cesium.Material.LinearGradientType, {
    "fabric" : {
      "type" : Cesium.Material.LinearGradientType,
      "uniforms" : {
        "image" : "",
        "time" : 0
      },
      "source" : Cesium.Material.LinearGradientSource
    },
    "translucent" : function(material) {
      return true;
    }
  });
  Object.defineProperties(PolylineGlowMaterialProperty.prototype, {
    "isConstant" : {
      "get" : function() {
        return false;
      }
    },
    "definitionChanged" : {
      "get" : function() {
        return this._definitionChanged;
      }
    },
    "color" : Cesium.createPropertyDescriptor("color")
  });
  PolylineGlowMaterialProperty.prototype.getType = function(original_full_html) {
    return "LineFlowWall";
  };
  PolylineGlowMaterialProperty.prototype.getValue = function(time, result) {
    return Cesium.defined(result) || (result = {}), result.color = Cesium.Property.getValueOrClonedDefault(this._color, time, Cesium.Color.WHITE, result.color), result.image = Cesium.Material.LineFlowWallImage, result.time = ((new Date).getTime() - this._time) % this.duration / this.duration, result;
  };
  PolylineGlowMaterialProperty.prototype.equals = function(other) {
    return this === other || other instanceof PolylineGlowMaterialProperty && Cesium.Property.equals(this._color, other._color);
  };
  Cesium.Material.LineFlowWallType = "LineFlowWall";
  Cesium.Material.LineFlowWallImage = `data:image/octet-stream;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAABCAYAAAAo2wu9AAAAOklEQVQoU2P8//+/McMoIDsEfv/+zcLKysrOwMDAAcVg9t+/fzmYmZkxxP/9+8fBxMSEIc7AwAAWAwD/kwzHVTmPqQAAAABJRU5ErkJggg==`;
  Cesium.Material.LineFlowWallSource = `czm_material czm_getMaterial(czm_materialInput materialInput)\n {\n      czm_material material = czm_getDefaultMaterial(materialInput);\n      vec2 st = materialInput.st;\n      vec4 colorImage = texture2D(image, vec2(fract(st.t - time), st.t));\n      material.alpha = colorImage.a * color.a;\n      material.diffuse =  1.5* color.rgb  ;\n      return material;\n  }`;
  Cesium.Material._materialCache.addMaterial(Cesium.Material.LineFlowWallType, {
    "fabric" : {
      "type" : Cesium.Material.LineFlowWallType,
      "uniforms" : {
        "color" : new Cesium[`Color`](1, 0, 0, 0.5),
        "image" : Cesium.Material.LineFlowWallImage,
        "time" : 0
      },
      "source" : Cesium.Material.LineFlowWallSource
    },
    "translucent" : function(material) {
      return true;
    }
  });
  Object.defineProperties(fn.prototype, {
    "isConstant" : {
      "get" : function() {
        return false;
      }
    },
    "definitionChanged" : {
      "get" : function() {
        return this._definitionChanged;
      }
    },
    "color" : Cesium.createPropertyDescriptor("color")
  });
  fn.prototype.getType = function(original_full_html) {
    return "ScrollWall";
  };
  fn.prototype.getValue = function(time, result) {
    return Cesium.defined(result) || (result = {}), result.color = Cesium.Property.getValueOrClonedDefault(this._color, time, Cesium.Color.WHITE, result.color), result.image = Cesium.Material.ScrollWallImage, result.time = ((new Date).getTime() - this._time) % this.duration / this.duration, result.count = this.count, result;
  };
  fn.prototype.equals = function(other) {
    return this === other || other instanceof fn && Cesium.Property.equals(this._color, other._color);
  };
  Cesium.ScrollWallMaterialProperty = fn;
  Cesium.Material.ScrollWallType = `ScrollWall`;
  Cesium.Material.ScrollWallImage = `data:image/octet-stream;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAUCAYAAAB7wJiVAAACgklEQVRoQ9WZi27DIAxFIeGX9n53//9FBTy5rSNESDC2U2mVqkQRgc7X1wczDwC/zrmQUgrzPM+3a3DOzeVzvL99L89zzmGapss953k5pnG/rAcAwXuP83rH+AAAeO+Tc27km3POaZqmRNfB9/G9rHmf1osx5hDC8ts9AJzqoHKD1xm3Eos7/iYKSxDnHBTBzKOBbYxXz5FSypjbkt/iz+fzKYSwCh45pifWqFO2xhfOIMdNDIPQkO4fDwAZnaR0htpZJFaMMZXOIPHQIT/czKUyxnXQVvCZ62GScD+arNa8WyaCyTwoyDcGKMYYNE4hsbgiNBxxcWn1XCwIOQIAkoAxS6BrVgiZk1NK6Yro63WrnKEgX0VZWuBaZjG3fDEdtMUWMdgrjnTL1y0YFhltMUcqwU6CjAJ4CZ4VQ+oyJgW7kTPMWMF1RsmQT2ZNb7qnB32la0zB7pyzyOhD50CHfBzAkK6DmAxhg13pDLUjqAzWjOkxo2YJCTJasqzG77mO1hCD3cgRSxMo6StGeyQU5L0sK1sA33o+yhDulnm0Y5eCXdmXmHfsKMibkCGc7FaNkYLdyBmHsmJv2/tqwRArp9yrY6eASPsKrbO2OnZ0CApixYRyni7Ymc5kg13pDAtHYA+0bBAkzEFBXsrAjHbsWmcwd1tisNe7L2nnfq+OHQV53jsOZ2axihWVQ1tzSU5+/13Hju5CQZ72mrvOsUm3LHHPtkiU2jFSsCv7EhJzVX5GmUOs4HbsJIgVQ5pOGRWl4UrTjp3EktT40b6is8aKWyjIo4Yh3L5i4P8grVNfNtiVzjisY+eKj4I8HHwexXEfh0FisCt3X6ujeG5wN8bt7ub+ANZIqbIlvAh5AAAAAElFTkSuQmCC`;
  Cesium.Material.ScrollWallSource = `czm_material czm_getMaterial(czm_materialInput materialInput)\n    {\n         czm_material material = czm_getDefaultMaterial(materialInput);\n         vec2 st = materialInput.st;\n         vec4 colorImage = texture2D(image, vec2(fract(count*st.t - time), fract(st.s)));\n         material.alpha = colorImage.a * color.a;\n         material.diffuse =  1.5* color.rgb  ;\n         return material;\n     }`;
  Cesium.Material._materialCache.addMaterial(Cesium.Material.ScrollWallType, {
    "fabric" : {
      "type" : Cesium.Material.ScrollWallType,
      "uniforms" : {
        "color" : new Cesium[`Color`](1, 0, 0, 0.5),
        "image" : Cesium.Material.ScrollWallImage,
        "time" : 0,
        "count" : 1
      },
      "source" : Cesium.Material.ScrollWallSource
    },
    "translucent" : function(material) {
      return true;
    }
  });
  var res = {
    "createMaterial" : function(data, options) {
      switch(data) {
        case user_info.BASEGRADIENT:
          return new Color(options.color);
        case user_info.LINEARGRADIENT:
          return new f(options.colorStops);
        case user_info.LINEFLOW:
          return new PolylineGlowMaterialProperty(options);
        case user_info.SCROLL:
          return new fn(options);
      }
    }
  };
  frame = (expect(action, [{
    "key" : "generatePositions",
    "value" : function(type) {
      var result = Cesium.Cartographic.fromCartesian(type);
      if (result.height < 0) {
        result.height = 0;
      }
      type = [Cesium.Math.toDegrees(result.longitude), Cesium.Math.toDegrees(result.latitude), result.height];
      result = val([type[0], type[1]], this.radius);
      type = this.pointsToPositions(result, type[2]);
      this.setPositions(type);
    }
  }, {
    "key" : `pointsToPositions`,
    "value" : function(type, obj) {
      var primaryReplicas = [];
      return type.map(function(tmp) {
        var stringify = hahaha;
        primaryReplicas[stringify(2008)](Cesium.Cartesian3.fromDegrees(tmp[0], tmp[1], obj));
      }), primaryReplicas;
    }
  }, {
    "key" : `setPositions`,
    "value" : function(name) {
      this.positions = name || [];
      this.initHeights();
    }
  }, {
    "key" : "initHeights",
    "value" : function() {
      var frontpageItems = this;
      var formats = [];
      var BASAL_TYPES = [];
      this.positions.forEach(function(data) {
        var parseInt = hahaha;
        data = Cesium.Cartographic.fromCartesian(data);
        formats[parseInt(2008)](data[parseInt(1132)]);
        BASAL_TYPES[parseInt(2008)](data.height + frontpageItems[parseInt(2980)]);
      });
      this.minimumHeights = formats;
      this.maximumHeights = BASAL_TYPES;
    }
  }, {
    "key" : `addWall`,
    "value" : function() {
      this.wallEntity = this.viewer.entities.add({
        "wall" : {
          "positions" : this.positions,
          "minimumHeights" : this.minimumHeights,
          "maximumHeights" : this.maximumHeights,
          "material" : this.wallMaterial
        }
      });
    }
  }, {
    "key" : `addFlowWall`,
    "value" : function() {
      this.flowWallEntity = this.viewer.entities.add({
        "wall" : {
          "positions" : this.positions,
          "minimumHeights" : this.minimumHeights,
          "maximumHeights" : this.maximumHeights,
          "material" : this.flowWallMaterial
        }
      });
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.viewer.entities.remove(this.wallEntity);
      this.viewer.entities.remove(this.flowWallEntity);
    }
  }]), action);
  expect(success, [{
    "key" : `init`,
    "value" : function(value) {
      value = Cesium.Cartographic.fromCartesian(value);
      if (value.height < 0) {
        value.height = 0;
      }
      this.baseHeight = value.height;
      this.centerDegrees = [Cesium.Math.toDegrees(value.longitude), Cesium.Math.toDegrees(value.latitude), value.height];
      this.currentRadius = this.radius;
      this.rPositions = {};
      value = val([this.centerDegrees[0], this.centerDegrees[1]], this.currentRadius);
      value = this.pointsToPositions(value, this.centerDegrees[2]);
      this.rPositions[this.radius] = value;
      this.setPositions(value);
    }
  }, {
    "key" : "pointsToPositions",
    "value" : function(type, obj) {
      var primaryReplicas = [];
      return type.map(function(canCreateDiscussions) {
        var stringify = hahaha;
        primaryReplicas[stringify(2008)](Cesium[stringify(3131)][stringify(2770)](canCreateDiscussions[0], canCreateDiscussions[1], obj));
      }), primaryReplicas;
    }
  }, {
    "key" : `setPositions`,
    "value" : function(name) {
      this.positions = name || [];
      this.initHeights();
    }
  }, {
    "key" : "getPositions",
    "value" : function() {
      var primaryReplicas = this;
      if (this.currentRadius += this.speed, this.currentRadius >= this.radius && (this.currentRadius = 1), this.dMaximumHeights = this.maximumHeights.map(function(canCreateDiscussions) {
        var stringify = hahaha;
        return canCreateDiscussions * ((primaryReplicas[stringify(2423)] - primaryReplicas[stringify(946)]) / primaryReplicas[stringify(2423)]) + 0.01;
      }), this.rPositions[this.currentRadius]) {
        return this.rPositions[this.currentRadius];
      }
      var sharpness = val([this.centerDegrees[0], this.centerDegrees[1]], this.currentRadius);
      sharpness = this.pointsToPositions(sharpness, this.centerDegrees[2]);
      return this.rPositions[this.currentRadius] = sharpness, this.rPositions[this.currentRadius];
    }
  }, {
    "key" : `initHeights`,
    "value" : function() {
      this.minimumHeights = (new Array(this.positions.length)).fill(this.baseHeight);
      this.maximumHeights = (new Array(this.positions.length)).fill(this.baseHeight + this.wallHeight);
      this.dMaximumHeights = [].concat(array(this.maximumHeights));
    }
  }, {
    "key" : `createEntity`,
    "value" : function() {
      this.addWall();
    }
  }, {
    "key" : `addWall`,
    "value" : function() {
      var rpm_traffic = this;
      this.wallEntity = this.viewer.entities.add({
        "wall" : {
          "positions" : new Cesium.CallbackProperty(function(canCreateDiscussions) {
            var now = hahaha;
            return rpm_traffic[now(1951)]();
          }, false),
          "minimumHeights" : this.minimumHeights,
          "maximumHeights" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
            var now = hahaha;
            return rpm_traffic[now(625)];
          }, false),
          "material" : this.wallMaterial
        }
      });
    }
  }, {
    "key" : "remove",
    "value" : function() {
      this.viewer.entities.remove(this.wallEntity);
    }
  }]);
  init = success;
  expect(_init, [{
    "key" : `getPositions`,
    "value" : function() {
      var def = Cesium.Transforms.eastNorthUpToFixedFrame(this._position);
      var self = [];
      var hz = 0;
      for (; hz < this._slices; hz++) {
        var position = hz / this._slices * Cesium.Math.TWO_PI;
        var accelerateDelta = Math.cos(position);
        position = Math.sin(position);
        position = new Cesium["Cartesian3"](accelerateDelta * this.currentRadius, position * this.currentRadius, 0);
        self.push(Cesium.Matrix4.multiplyByPoint(def, position, new Cesium["Cartesian3"]));
      }
      return self.push(self[0]), self;
    }
  }, {
    "key" : "getHeights",
    "value" : function(type, value) {
      var result = [];
      var _0x2fae7e = 0;
      for (; _0x2fae7e < type; _0x2fae7e++) {
        result.push(value);
      }
      return result;
    }
  }, {
    "key" : `update`,
    "value" : function(name) {
      this.primitive = this.primitive && this.primitive.destroy();
      this.currentRadius += this.radius / this._speed / 20;
      this.currentHeight -= this._height / this._speed / 20;
      if (this.currentRadius > this.radius || this.currentHeight < this.minHeight) {
        this.currentRadius = this.minRadius;
        this.currentHeight = this._height;
      }
      var positions = this.getPositions();
      if (!positions || !positions.length) {
        return false;
      }
      positions = new Cesium.WallGeometry({
        "positions" : positions,
        "minimumHeights" : this.getHeights(positions.length, this.baseHeight),
        "maximumHeights" : this.getHeights(positions.length, this.baseHeight + this.currentHeight)
      });
      this.primitive = new Cesium["Primitive"]({
        "geometryInstances" : new Cesium.GeometryInstance({
          "geometry" : positions
        }),
        "appearance" : new Cesium.MaterialAppearance({
          "material" : new Cesium.Material({
            "fabric" : {
              "type" : "CircleDiffWall",
              "uniforms" : {
                "color" : this.color
              },
              "source" : `\n                            uniform vec4 color;\n                            czm_material czm_getMaterial(czm_materialInput materialInput){\n                              czm_material material = czm_getDefaultMaterial(materialInput);\n                              vec2 st = materialInput.st;\n                              material.diffuse = color.rgb * 2.5;\n                              material.alpha = color.a * (1.0-fract(st.t)) * 0.8;\n                              return material;\n                            }\n                        `
            },
            "translucent" : function(material) {
              return true;
            }
          }),
          "flat" : true
        }),
        "asynchronous" : false
      });
      this.primitive.update(name);
    }
  }]);
  data = _init;
  expect(_record, [{
    "key" : `setPositions`,
    "value" : function(name) {
      this.positions = name || [];
      this.initHeights();
    }
  }, {
    "key" : `initHeights`,
    "value" : function() {
      var frontpageItems = this;
      var formats = [];
      var sharedf = [];
      this.positions.forEach(function(data) {
        var parseInt = hahaha;
        data = Cesium[parseInt(1543)][parseInt(2206)](data);
        formats[parseInt(2008)](data[parseInt(1132)]);
        sharedf[parseInt(2008)](data.height + frontpageItems[parseInt(2980)]);
      });
      this.minimumHeights = formats;
      this.maximumHeights = sharedf;
    }
  }, {
    "key" : `addWall`,
    "value" : function() {
      this.wallEntity = this.viewer.entities.add({
        "wall" : {
          "positions" : this.positions,
          "minimumHeights" : this.minimumHeights,
          "maximumHeights" : this.maximumHeights,
          "material" : this.wallMaterial
        }
      });
    }
  }, {
    "key" : `addFlowWall`,
    "value" : function() {
      this.flowWallEntity = this.viewer.entities.add({
        "wall" : {
          "positions" : this.positions,
          "minimumHeights" : this.minimumHeights,
          "maximumHeights" : this.maximumHeights,
          "material" : this.flowWallMaterial
        }
      });
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.viewer.entities.remove(this.wallEntity);
      this.viewer.entities.remove(this.flowWallEntity);
    }
  }]);
  definition = _record;
  expect(Graph, [{
    "key" : "generatePositions",
    "value" : function(type) {
      var result = Cesium.Cartographic.fromCartesian(type);
      if (result.height < 0) {
        result.height = 0;
      }
      this.baseHeight = result.height;
      type = [Cesium.Math.toDegrees(result.longitude), Cesium.Math.toDegrees(result.latitude), result.height];
      result = val([type[0], type[1]], this.radius, this.edgeCount);
      type = this.pointsToPositions(result, type[2]);
      this.setPositions(type);
    }
  }, {
    "key" : "pointsToPositions",
    "value" : function(type, target) {
      var connectHandles = [];
      return type.map(function(canCreateDiscussions) {
        var put_rows = hahaha;
        connectHandles.push(Cesium[put_rows(3131)][put_rows(2770)](canCreateDiscussions[0], canCreateDiscussions[1], target));
      }), connectHandles;
    }
  }, {
    "key" : `setPositions`,
    "value" : function(name) {
      this.positions = name || [];
      this.initHeights();
    }
  }, {
    "key" : `initHeights`,
    "value" : function() {
      this.minimumHeights = (new Array(this.positions.length)).fill(this.baseHeight);
      this.maximumHeights = (new Array(this.positions.length)).fill(this.baseHeight + this.wallHeight);
    }
  }, {
    "key" : `addWall`,
    "value" : function() {
      this.wallEntity = this.viewer.entities.add({
        "wall" : {
          "positions" : this.positions,
          "minimumHeights" : this.minimumHeights,
          "maximumHeights" : this.maximumHeights,
          "material" : this.wallMaterial
        }
      });
    }
  }, {
    "key" : `addFlowWall`,
    "value" : function() {
      this.flowWallEntity = this.viewer.entities.add({
        "wall" : {
          "positions" : this.positions,
          "minimumHeights" : this.minimumHeights,
          "maximumHeights" : this.maximumHeights,
          "material" : this.flowWallMaterial
        }
      });
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      this.viewer.entities.remove(this.wallEntity);
      this.viewer.entities.remove(this.flowWallEntity);
    }
  }]);
  obj = Graph;
  expect(renderFunction, [{
    "key" : `init`,
    "value" : function(value) {
      value = Cesium.Cartographic.fromCartesian(value);
      if (value.height < 0) {
        value.height = 0;
      }
      this.baseHeight = value.height;
      this.centerDegrees = [Cesium.Math.toDegrees(value.longitude), Cesium.Math.toDegrees(value.latitude), value.height];
      this.currentRadius = this.radius;
      this.rPositions = {};
      value = val([this.centerDegrees[0], this.centerDegrees[1]], this.radius, this.edgeCount);
      value = this.pointsToPositions(value, this.centerDegrees[2]);
      this.rPositions[this.radius] = value;
      this.setPositions(value);
    }
  }, {
    "key" : `pointsToPositions`,
    "value" : function(type, target) {
      var connectHandles = [];
      return type.map(function(tmp) {
        connectHandles.push(Cesium.Cartesian3.fromDegrees(tmp[0], tmp[1], target));
      }), connectHandles;
    }
  }, {
    "key" : `setPositions`,
    "value" : function(name) {
      this.positions = name || [];
      this.initHeights();
    }
  }, {
    "key" : `getPositions`,
    "value" : function() {
      var datum = this;
      if (this.currentRadius += 5, this.currentRadius >= this.radius && (this.currentRadius = 1), this.dMaximumHeights = this.maximumHeights.map(function(canCreateDiscussions) {
        var put_rows = hahaha;
        return canCreateDiscussions * ((datum[put_rows(2423)] - datum[put_rows(946)]) / datum.radius) + 0.01;
      }), this.rPositions[this.currentRadius]) {
        return this.rPositions[this.currentRadius];
      }
      var sharpness = val([this.centerDegrees[0], this.centerDegrees[1]], this.currentRadius, this.edgeCount);
      sharpness = this.pointsToPositions(sharpness, this.centerDegrees[2]);
      return this.rPositions[this.currentRadius] = sharpness, this.rPositions[this.currentRadius];
    }
  }, {
    "key" : "initHeights",
    "value" : function() {
      this.minimumHeights = (new Array(this.positions.length)).fill(this.baseHeight);
      this.maximumHeights = (new Array(this.positions.length)).fill(this.baseHeight + this.wallHeight);
      this.dMaximumHeights = [].concat(array(this.maximumHeights));
    }
  }, {
    "key" : "createEntity",
    "value" : function() {
      this.addWall();
    }
  }, {
    "key" : `addWall`,
    "value" : function() {
      var rpm_traffic = this;
      this.wallEntity = this.viewer.entities.add({
        "wall" : {
          "positions" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
            var now = hahaha;
            return rpm_traffic[now(1951)]();
          }, false),
          "minimumHeights" : this.minimumHeights,
          "maximumHeights" : new Cesium["CallbackProperty"](function(canCreateDiscussions) {
            var now = hahaha;
            return rpm_traffic[now(625)];
          }, false),
          "material" : this.wallMaterial
        }
      });
    }
  }, {
    "key" : "remove",
    "value" : function() {
      this.viewer.entities.remove(this.wallEntity);
    }
  }]);
  descriptor = renderFunction;
  expect(instance, [{
    "key" : `createGeometry`,
    "value" : function(value) {
      var data = value;
      var scales = this.addPositionsHeight(data, this.height);
      var buffer = [];
      var st = [];
      var indices = [];
      var values = [];
      var i = 0;
      var score = data.length;
      for (; i < score; i++) {
        var j = i + 1;
        if (j == score) {
          j = 0;
        }
        buffer.push.apply(buffer, [data[i].x, data[i].y, data[i].z]);
        buffer.push.apply(buffer, [data[j].x, data[j].y, data[j].z]);
        buffer.push.apply(buffer, [scales[j].x, scales[j].y, scales[j].z]);
        buffer.push.apply(buffer, [scales[i].x, scales[i].y, scales[i].z]);
        values.push.apply(values, [0, 0, 1]);
        values.push.apply(values, [0, 0, 1]);
        values.push.apply(values, [0, 0, 1]);
        values.push.apply(values, [0, 0, 1]);
        st.push.apply(st, [0, 0, 1, 0, 1, 1, 0, 1]);
        var offset = 4 * i;
        var newIndex = 1 + offset;
        var max = 2 + offset;
        j = 3 + offset;
        indices.push.apply(indices, [offset, newIndex, max, max, j, offset]);
      }
      return value = new Float64Array(buffer), new Cesium["GeometryInstance"]({
        "geometry" : new Cesium["Geometry"]({
          "attributes" : {
            "position" : new Cesium["GeometryAttribute"]({
              "componentDatatype" : Cesium.ComponentDatatype.DOUBLE,
              "componentsPerAttribute" : 3,
              "values" : value
            }),
            "normal" : new Cesium["GeometryAttribute"]({
              "componentDatatype" : Cesium.ComponentDatatype.FLOAT,
              "componentsPerAttribute" : 3,
              "values" : new Float32Array(values)
            }),
            "st" : new Cesium["GeometryAttribute"]({
              "componentDatatype" : Cesium.ComponentDatatype.FLOAT,
              "componentsPerAttribute" : 2,
              "values" : new Float32Array(st)
            })
          },
          "indices" : new Uint16Array(indices),
          "primitiveType" : Cesium.PrimitiveType.TRIANGLES,
          "boundingSphere" : Cesium.BoundingSphere.fromVertices(value)
        })
      });
    }
  }, {
    "key" : `addPrimitive`,
    "value" : function(name) {
      name = this.createGeometry(name);
      this.primitive = new Cesium.Primitive({
        "geometryInstances" : name,
        "appearance" : new Cesium["MaterialAppearance"]({
          "material" : new Cesium["Material"]({
            "translucent" : true,
            "fabric" : {
              "uniforms" : {
                "u_color" : this.color,
                "speed" : this.speed,
                "direction" : this.direction
              },
              "source" : "uniform float direction;uniform float speed;uniform vec4 u_color;czm_material czm_getMaterial( czm_materialInput cmi )\n                        {\n                            czm_material material = czm_getDefaultMaterial(cmi);\n                            vec2 st = cmi.st;\n                            float t = fract(speed*czm_frameNumber/1000.0) * direction;\n                            vec2 st1 = vec2(fract(st.s - t),st.t);\n                            vec4 color = vec4(0.,0.,0.,0.);\n                            float alpha = 1.-st.t;\n                            float value = fract(st1.s/0.25);\n                            alpha *= sin(value * 3.1415926);\n                            color = vec4(u_color.rgb * u_color.a, alpha * 1.2);\n                            material.diffuse = color.rgb;\n                            material.alpha = color.a;\n                            return material;\n                        }"
            }
          }),
          "vertexShaderSource" : "\n                attribute vec3 position3DHigh;\n                attribute vec3 position3DLow;\n                attribute vec3 normal;\n                attribute vec2 st;\n                attribute float batchId;\n                varying vec2 v_st;\n                varying vec3 v_normalEC;\n                varying vec3 v_positionEC;\n                void main()\n                {\n                    vec4 p = czm_translateRelativeToEye(position3DHigh,position3DLow);\n                    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;\n                    v_normalEC = czm_normal * normal;\n                    v_st=st;\n                    gl_Position = czm_modelViewProjectionRelativeToEye * p;\n                }",
          "fragmentShaderSource" : "\n                varying vec3 v_positionEC;\n                varying vec3 v_normalEC;\n                varying vec2 v_st;\n                void main()\n                {\n                    vec3 positionToEyeEC = -v_positionEC;\n                    vec3 normalEC = normalize(v_normalEC);\n                    #ifdef FACE_FORWARD\n                        normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\n                    #endif\n                    czm_materialInput materialInput;\n                    materialInput.normalEC = normalEC;\n                    materialInput.positionToEyeEC = positionToEyeEC;\n                    materialInput.st = v_st;\n                    czm_material material = czm_getMaterial(materialInput);\n                    gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n                }"
        }),
        "asynchronous" : false
      });
      this.viewer.scene.primitives.add(this.primitive);
    }
  }, {
    "key" : `addPositionsHeight`,
    "value" : function(name, x) {
      if (x = Number(x) || 0, isNaN(x) || 0 == x) {
        return name;
      }
      if (name instanceof Array) {
        var set = [];
        var i = 0;
        var length = name.length;
        for (; i < length; i++) {
          var position = Cesium.Cartographic.fromCartesian(name[i]);
          position = Cesium.Cartesian3.fromRadians(position.longitude, position.latitude, position.height + x);
          set.push(position);
        }
        return set;
      }
      var position = Cesium.Cartographic.fromCartesian(name);
      return Cesium.Cartesian3.fromRadians(position.longitude, position.latitude, position.height + x);
    }
  }, {
    "key" : "remove",
    "value" : function() {
      this.viewer.entities.remove(this.wallEntity);
      this.viewer.entities.remove(this.flowWallEntity);
    }
  }]);
  meta = instance;
  xt3d.WallObject = {
    "DynamicWall" : location,
    "MaterialTypes" : user_info,
    "CircleWall" : frame,
    "CircleDiffWall" : init,
    "CircleDiffWallPrimitive" : data,
    "FlowWall" : definition,
    "JustWall" : obj,
    "JustDiffWall" : descriptor,
    "SerratedWall" : meta
  };
  expect(Base, [{
    "key" : `start`,
    "value" : function() {
      this.removeRenderEvent();
      this.clearPrimitive();
      var selection = this.getDegreesArrayHeights(this.positions);
      this.polygonHierarchy = new Cesium["PolygonHierarchy"](Cesium.Cartesian3.fromDegreesArrayHeights(selection));
      this.extrudedHeight = this.options.minHeight || 0;
      selection = this.createGeometry(this.polygonHierarchy);
      this.createPromitive(selection);
      this.addRenderEvent();
    }
  }, {
    "key" : "addRenderEvent",
    "value" : function() {
      var options = this;
      this.clearIntervalId = setInterval(function() {
        options.extrudedHeight += 50 * options.increment;
        if (options.extrudedHeight >= options.options.maxHeight) {
          options.removeRenderEvent();
        }
        options.clearPrimitive();
        var expectedOption = options.createGeometry(options.polygonHierarchy);
        options.createPromitive(expectedOption);
      }, 50);
    }
  }, {
    "key" : `removeRenderEvent`,
    "value" : function() {
      clearInterval(this.clearIntervalId);
    }
  }, {
    "key" : `clearPrimitive`,
    "value" : function() {
      if (this.primitive) {
        this.viewer.scene.primitives.remove(this.primitive);
        this.primitive = void 0;
      }
    }
  }, {
    "key" : `createGeometry`,
    "value" : function(name) {
      return new Cesium.PolygonGeometry({
        "polygonHierarchy" : name,
        "perPositionHeight" : true,
        "extrudedHeight" : this.extrudedHeight
      });
    }
  }, {
    "key" : `createPromitive`,
    "value" : function(name) {
      this.primitive = this.createExtrudedPolygon(name);
    }
  }, {
    "key" : `createExtrudedPolygon`,
    "value" : function(name) {
      return this.viewer.scene.primitives.add(new Cesium["ClassificationPrimitive"]({
        "geometryInstances" : new Cesium.GeometryInstance({
          "geometry" : Cesium.PolygonGeometry.createGeometry(name),
          "attributes" : {
            "color" : Cesium.ColorGeometryInstanceAttribute.fromColor(this.options.color || Cesium.Color.fromRandom({
              "alpha" : 0.8
            })),
            "show" : new Cesium["ShowGeometryInstanceAttribute"](true)
          }
        }),
        "classificationType" : Cesium.ClassificationType.BOTH,
        "asynchronous" : false
      }));
    }
  }, {
    "key" : `getDegreesArrayHeights`,
    "value" : function(name) {
      var arr = this;
      var entriesHolder = [];
      return name.forEach(function(result) {
        var parseInt = hahaha;
        result = Cesium.Cartographic[parseInt(2206)](result);
        entriesHolder[parseInt(2008)](Cesium[parseInt(2090)].toDegrees(result[parseInt(2596)]));
        entriesHolder.push(Cesium[parseInt(2090)][parseInt(1611)](result[parseInt(480)]));
        entriesHolder[parseInt(2008)](arr[parseInt(1724)].minHeight || 0);
      }), entriesHolder;
    }
  }]);
  definition = Base;
  expect(component, [{
    "key" : `init`,
    "value" : function() {
      this.entity = this.viewer.entities.add({
        "position" : this.position
      });
      this.particleSystem = this.createParticleSystem();
      this.viewer.scene.primitives.add(this.particleSystem);
      this.addEvent();
    }
  }, {
    "key" : `addEvent`,
    "value" : function() {
      this.emitterModelMatrix = new Cesium["Matrix4"];
      this.translation = new Cesium["Cartesian3"];
      this.rotation = new Cesium.Quaternion;
      this.hpr = new Cesium["HeadingPitchRoll"];
      this.trs = new Cesium["TranslationRotationScale"];
      this.viewer.scene.preUpdate.addEventListener(this.preUpdateEvent, this);
    }
  }, {
    "key" : `removeEvent`,
    "value" : function() {
      this.viewer.scene.preUpdate.removeEventListener(this.preUpdateEvent, this);
      this.emitterModelMatrix = void 0;
      this.translation = void 0;
      this.rotation = void 0;
      this.hpr = void 0;
      this.trs = void 0;
    }
  }, {
    "key" : `preUpdateEvent`,
    "value" : function(target, name) {
      this.particleSystem.modelMatrix = this.entity.computeModelMatrix(name, new Cesium["Matrix4"]);
      this.hpr = Cesium.HeadingPitchRoll.fromDegrees(this.style.heading, this.style.pitch, 0, this.hpr);
      this.trs.translation = Cesium.Cartesian3.fromElements(0, 0, 0, this.translation);
      this.trs.rotation = Cesium.Quaternion.fromHeadingPitchRoll(this.hpr, this.rotation);
      this.particleSystem.emitterModelMatrix = Cesium.Matrix4.fromTranslationRotationScale(this.trs, this.emitterModelMatrix);
    }
  }, {
    "key" : `createParticleSystem`,
    "value" : function() {
      var console = this;
      return this.gravityScratch = new Cesium["Cartesian3"], new Cesium["ParticleSystem"]({
        "image" : this.style.fountainImage,
        "startColor" : new Cesium.Color(1, 1, 1, 0.6),
        "endColor" : new Cesium["Color"](0.8, 0.86, 1, 0.4),
        "startScale" : this.style.startScale,
        "endScale" : this.style.endScale,
        "minimumParticleLife" : this.style.minimumParticleLife,
        "maximumParticleLife" : this.style.maximumParticleLife,
        "minimumSpeed" : this.style.minimumSpeed,
        "maximumSpeed" : this.style.maximumSpeed,
        "imageSize" : new Cesium["Cartesian2"](this.style.particleSize, this.style.particleSize),
        "emissionRate" : this.style.emissionRate,
        "lifetime" : 16,
        "emitter" : new Cesium.CircleEmitter(0.2),
        "updateCallback" : function(obj, body) {
          var complete = hahaha;
          return console[complete(1326)](obj, body);
        },
        "sizeInMeters" : true,
        "performance" : false
      });
    }
  }, {
    "key" : `applyGravity`,
    "value" : function(target, object) {
      Cesium.Cartesian3.normalize(target.position, this.gravityScratch);
      Cesium.Cartesian3.multiplyByScalar(this.gravityScratch, this.style.gravity * object, this.gravityScratch);
      target.velocity = Cesium.Cartesian3.add(target.velocity, this.gravityScratch, target.velocity);
    }
  }, {
    "key" : `updateStyle`,
    "value" : function() {
    }
  }, {
    "key" : "remove",
    "value" : function() {
      this.removeEvent();
      this.viewer.scene.primitives.remove(this.particleSystem);
      this.viewer.entities.remove(this.entity);
    }
  }, {
    "key" : `getDefaultStyle`,
    "value" : function() {
      return {
        "fountainImage" : "static/images/particlesystem/smoke.png",
        "emissionRate" : 60,
        "gravity" : -5,
        "minimumParticleLife" : 1,
        "maximumParticleLife" : 2,
        "minimumSpeed" : 9,
        "maximumSpeed" : 9.5,
        "startScale" : 2,
        "endScale" : 4,
        "particleSize" : 1,
        "heading" : 110,
        "pitch" : -45
      };
    }
  }]);
  obj = component;
  expect(route, [{
    "key" : `createPrimitive`,
    "value" : function() {
      var D_geometry = new Cesium["PolygonGeometry"]({
        "polygonHierarchy" : new Cesium["PolygonHierarchy"](this.positions),
        "perPositionHeight" : true,
        "vertexFormat" : Cesium.EllipsoidSurfaceAppearance.VERTEX_FORMAT
      });
      return new Cesium["Primitive"]({
        "geometryInstances" : new Cesium.GeometryInstance({
          "geometry" : D_geometry
        }),
        "appearance" : this.getApper(),
        "show" : true
      });
    }
  }, {
    "key" : "getApper",
    "value" : function() {
      var points_fb = new Cesium.EllipsoidSurfaceAppearance({
        "aboveGround" : true
      });
      return points_fb.material = new Cesium["Material"]({
        "fabric" : {
          "type" : "Water",
          "uniforms" : {
            "baseWaterColor" : this.options.baseWaterColor,
            "normalMap" : this.options.normalMap,
            "frequency" : this.options.frequency,
            "animationSpeed" : this.options.animationSpeed,
            "amplitude" : this.options.amplitude,
            "specularIntensity" : this.options.specularIntensity
          }
        }
      }), points_fb;
    }
  }]);
  descriptor = route;
  expect(attach, [{
    "key" : `createPrimitive`,
    "value" : function() {
      var data = this.sideRes;
      var positions = new Float64Array(data.vertexs);
      var attributes = new Cesium["GeometryAttributes"];
      return attributes.position = new Cesium.GeometryAttribute({
        "componentDatatype" : Cesium.ComponentDatatype.DOUBLE,
        "componentsPerAttribute" : 3,
        "values" : positions
      }), attributes.st = new Cesium["GeometryAttribute"]({
        "componentDatatype" : Cesium.ComponentDatatype.FLOAT,
        "componentsPerAttribute" : 2,
        "values" : data.uvs
      }), data = new Cesium["Geometry"]({
        "attributes" : attributes,
        "indices" : data.indexs,
        "primitiveType" : Cesium.PrimitiveType.TRIANGLES,
        "boundingSphere" : Cesium.BoundingSphere.fromVertices(positions)
      }), positions = new Cesium["GeometryInstance"]({
        "geometry" : data
      }), data = new Cesium["RenderState"], data.depthTest.enabled = true, new Cesium.Primitive({
        "geometryInstances" : positions,
        "appearance" : new Cesium["Appearance"]({
          "material" : this.material,
          "renderState" : data,
          "vertexShaderSource" : "attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec2 st;\nattribute float batchId;\n\nvarying vec3 v_positionMC;\nvarying vec3 v_positionEC;\nvarying vec2 v_st;\n\nvoid main()\n{\n    vec4 p = czm_computePosition();\n\n    v_positionMC = position3DHigh + position3DLow;           // position in model coordinates\n    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;     // position in eye coordinates\n    v_st = st;\n\n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\n}\n",
          "fragmentShaderSource" : "varying vec3 v_positionMC;\nvarying vec3 v_positionEC;\nvarying vec2 v_st;\n\nvoid main()\n{\n    czm_materialInput materialInput;\n\n    vec3 normalEC = normalize(czm_normal3D * czm_geodeticSurfaceNormal(v_positionMC, vec3(0.0), vec3(1.0)));\n    #ifdef FACE_FORWARD\n        normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\n    #endif\n\n    materialInput.s = v_st.s;\n    materialInput.st = v_st;\n    materialInput.str = vec3(v_st, 0.0);\n\n    // Convert tangent space material normal to eye space\n    materialInput.normalEC = normalEC;\n    materialInput.tangentToEyeMatrix = czm_eastNorthUpToEyeCoordinates(v_positionMC, materialInput.normalEC);\n\n    // Convert view vector to world space\n    vec3 positionToEyeEC = -v_positionEC;\n    materialInput.positionToEyeEC = positionToEyeEC;\n\n    czm_material material = czm_getMaterial(materialInput);\n\n    #ifdef FLAT\n        gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n    #else\n        gl_FragColor = czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);\n    #endif\n}\n"
        })
      });
    }
  }, {
    "key" : `prepareMaterial`,
    "value" : function() {
      var basemapModel;
      return this.image ? basemapModel = new Cesium["Material"]({
        "fabric" : {
          "uniforms" : {
            "image" : this.image,
            "alpha" : this.alpha,
            "moveVar" : this.moveVar,
            "reflux" : this.moveDir ? -1 : 1,
            "speed" : this.speed,
            "move" : this.move,
            "flipY" : this.flipY
          },
          "source" : "czm_material czm_getMaterial(czm_materialInput materialInput) { \n    czm_material material = czm_getDefaultMaterial(materialInput); \n    vec2 st = materialInput.st;\n    if(move){\n        float r = sqrt((st.x-0.8)*(st.x-0.8) + (st.y-0.8)*(st.y-0.8));\n        float r2 = sqrt((st.x-0.2)*(st.x-0.2) + (st.y-0.2)*(st.y-0.2));\n        float z = cos(moveVar.x*r + czm_frameNumber/100.0*moveVar.y)/moveVar.z;\n        float z2 = cos(moveVar.x*r2 + czm_frameNumber/100.0*moveVar.y)/moveVar.z;\n        st += sqrt(z*z+z2*z2);\n        st.s += reflux * czm_frameNumber/1000.0 * speed;\n        st.s = mod(st.s,1.0);\n    }\n    if(flipY){\n        st = vec2(st.t,st.s);\n    }\n    vec4 colorImage = texture2D(image, st);\n    material.alpha = alpha;\n    material.diffuse = colorImage.rgb; \n    return material; \n}"
        }
      }) : ((basemapModel = Cesium.Material.fromType("Color")).uniforms.color = new Cesium["Color"](0, 1, 0, this.alpha), basemapModel);
    }
  }, {
    "key" : "resetPos",
    "value" : function() {
      if (this.riverPrimitive) {
        this.viewer.scene.primitives.remove(this.riverPrimitive);
        delete this.riverPrimitive;
      }
      this.sideRes = this.Lines2Plane(this.positions, this.width, this.height);
      if (this.sideRes) {
        this.material = this.prepareMaterial();
        this.riverPrimitive = this.createPrimitive();
        this.viewer.scene.primitives.add(this.riverPrimitive);
      }
    }
  }, {
    "key" : `Lines2Plane`,
    "value" : function(obj, value, type) {
      if (!obj || obj.length <= 1 || !value || 0 == value) {
        console.log("\u8bf7\u786e\u8ba4\u53c2\u6570\u7b26\u5408\u89c4\u5219\uff1a\u6570\u7ec4\u957f\u5ea6\u5927\u4e8e1\uff0c\u5bbd\u9ad8\u4e0d\u80fd\u4e3a0\uff01", obj);
      } else {
        var n = obj.length;
        var args = [];
        var ret = [];
        var val = value / 2;
        var i = 0;
        for (; i < n; i++) {
          var name = void 0;
          var result = void 0;
          var data = void 0;
          var root = void 0;
          var branch = void 0;
          data = 0 == i ? (name = obj[i], result = obj[i], obj[i + 1]) : i == n - 1 ? (name = obj[i - 1], result = obj[i], obj[i - 1]) : (name = obj[i - 1], result = obj[i], obj[i + 1]);
          if (0 != type) {
            name = this.RaisePoint(name, type);
            result = this.RaisePoint(result, type);
            data = this.RaisePoint(data, type);
          }
          if (name && result && data) {
            root = (data = this.GetSides(result, data, val)).left;
            branch = data.right;
            if (0 != i) {
              if (i < n - 1) {
                args.push(root);
                ret.push(branch);
                root = (data = this.GetSides(result, name, val)).left;
                branch = data.right;
              } else {
                args.push(branch);
                ret.push(root);
              }
              args.push(branch);
              ret.push(root);
            } else {
              args.push(root);
              ret.push(branch);
              args.push(root);
              ret.push(branch);
            }
          }
        }
        var positions = [];
        var points = [];
        if (args.length == 2 * n) {
          var index = 0;
          for (; index < n; index++) {
            var value = obj[index];
            var count = args[2 * index + 0];
            var i = args[2 * index + 1];
            var data = Cesium.Cartesian3.subtract(count, value, new Cesium["Cartesian3"]);
            var row = Cesium.Cartesian3.subtract(i, value, new Cesium["Cartesian3"]);
            var range = Cesium.Cartesian3.add(data, row, new Cesium["Cartesian3"]);
            var position = Cesium.Cartesian3.add(value, range, new Cesium.Cartesian3);
            positions.push(Cesium.clone(position));
            count = ret[2 * index + 0];
            i = ret[2 * index + 1];
            data = Cesium.Cartesian3.subtract(count, value, new Cesium.Cartesian3);
            row = Cesium.Cartesian3.subtract(i, value, new Cesium.Cartesian3);
            range = Cesium.Cartesian3.add(data, row, new Cesium["Cartesian3"]);
            position = Cesium.Cartesian3.add(value, range, new Cesium["Cartesian3"]);
            points.push(Cesium.clone(position));
          }
          var uvs = [];
          var normals = [];
          var values = [];
          var triangles = [];
          var a = [];
          var i = 0;
          for (; i < n; i++) {
            var encoded = Cesium.EncodedCartesian3.fromCartesian(points[i]);
            normals.push(points[i].x);
            normals.push(points[i].y);
            normals.push(points[i].z);
            values.push(encoded.high.x);
            values.push(encoded.high.y);
            values.push(encoded.high.z);
            triangles.push(encoded.low.x);
            triangles.push(encoded.low.y);
            triangles.push(encoded.low.z);
            uvs.push(1, 1);
            if (i < n - 1) {
              a.push(i + 2 * n);
              a.push(i + 1);
              a.push(i + 1 + n);
              a.push(i + 2 * n);
              a.push(i + 1 + n);
              a.push(n + i + 2 * n);
            }
          }
          var k = 0;
          for (; k < n; k++) {
            var encoded = Cesium.EncodedCartesian3.fromCartesian(positions[k]);
            normals.push(positions[k].x);
            normals.push(positions[k].y);
            normals.push(positions[k].z);
            values.push(encoded.high.x);
            values.push(encoded.high.y);
            values.push(encoded.high.z);
            triangles.push(encoded.low.x);
            triangles.push(encoded.low.y);
            triangles.push(encoded.low.z);
            uvs.push(1, 0);
          }
          var p = 0;
          for (; p < n; p++) {
            var encoded = Cesium.EncodedCartesian3.fromCartesian(points[p]);
            normals.push(points[p].x);
            normals.push(points[p].y);
            normals.push(points[p].z);
            values.push(encoded.high.x);
            values.push(encoded.high.y);
            values.push(encoded.high.z);
            triangles.push(encoded.low.x);
            triangles.push(encoded.low.y);
            triangles.push(encoded.low.z);
            uvs.push(0, 1);
          }
          var j = 0;
          for (; j < n; j++) {
            var encoded = Cesium.EncodedCartesian3.fromCartesian(positions[j]);
            normals.push(positions[j].x);
            normals.push(positions[j].y);
            normals.push(positions[j].z);
            values.push(encoded.high.x);
            values.push(encoded.high.y);
            values.push(encoded.high.z);
            triangles.push(encoded.low.x);
            triangles.push(encoded.low.y);
            triangles.push(encoded.low.z);
            uvs.push(0, 0);
          }
          return {
            "left" : positions,
            "right" : points,
            "self" : obj,
            "vertexs" : new Float32Array(normals),
            "vertexsH" : new Float32Array(values),
            "vertexsL" : new Float32Array(triangles),
            "indexs" : new Uint16Array(a),
            "uvs" : new Float32Array(uvs)
          };
        }
        console.log("\u8ba1\u7b97\u5de6\u53f3\u4fa7\u70b9\u51fa\u95ee\u9898\uff01");
      }
    }
  }, {
    "key" : `RaisePoint`,
    "value" : function(type, value) {
      if (type instanceof Cesium.Cartesian3) {
        if (value && 0 != value) {
          var t = Cesium.Cartesian3.normalize(type, new Cesium["Cartesian3"]);
          t = new Cesium["Ray"](type, t);
          return Cesium.Ray.getPoint(t, value);
        }
        console.log("\u8bf7\u786e\u8ba4\u9ad8\u5ea6\u662f\u975e\u96f6\u6570\u503c\uff01");
      } else {
        console.log("\u8bf7\u786e\u8ba4\u70b9\u662fCartesian3\u7c7b\u578b\uff01");
      }
    }
  }, {
    "key" : `GetSides`,
    "value" : function(target, val, key) {
      var b = Cesium.Cartesian3.normalize(Cesium.Cartesian3.subtract(val, target, new Cesium.Cartesian3), new Cesium["Cartesian3"]);
      var result = Cesium.Cartesian3.normalize(target, new Cesium["Cartesian3"]);
      val = Cesium.Cartesian3.cross(result, b, new Cesium["Cartesian3"]);
      result = Cesium.Cartesian3.cross(b, result, new Cesium["Cartesian3"]);
      val = new Cesium.Ray(target, val);
      result = new Cesium["Ray"](target, result);
      return {
        "left" : Cesium.Ray.getPoint(val, key),
        "right" : Cesium.Ray.getPoint(result, key)
      };
    }
  }, {
    "key" : "remove",
    "value" : function() {
      this.viewer.scene.primitives.remove(this.riverPrimitive);
    }
  }]);
  meta = attach;
  xt3d.WaterPlugin = {
    "FloodAnalysis" : definition,
    "WaterColumn" : obj,
    "WaterPrimitive" : descriptor,
    "DynamicRiver" : meta
  };
  xt3d.Utils = anim;
  meta = function(obj, key, options) {
    return key && watch(obj.prototype, key), options && watch(obj, options), obj;
  };
  var args = Function;
  anim = void 0;
  if (window.mapv) {
    (function(obj, t) {
      if ("function" != typeof t && null !== t) {
        throw new TypeError("Super expression must either be null or a function, not " + (void 0 === t ? "undefined" : loadImage(t)));
      }
      obj.prototype = Object.create(t && t.prototype, {
        "constructor" : {
          "value" : obj,
          "enumerable" : false,
          "writable" : true,
          "configurable" : true
        }
      });
      if (t) {
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(obj, t);
        } else {
          obj.__proto__ = t;
        }
      }
    })(Table, mapv.baseLayer);
    meta(Table, [{
      "key" : `initDevicePixelRatio`,
      "value" : function() {
        this.devicePixelRatio = window.devicePixelRatio || 1;
      }
    }, {
      "key" : `clickEvent`,
      "value" : function(obj) {
        var value = obj.point;
        var data = Table.prototype.__proto__ || Object.getPrototypeOf(Table.prototype);
        _get(data, "clickEvent", this).call(this, value, obj);
      }
    }, {
      "key" : `mousemoveEvent`,
      "value" : function(obj) {
        var value = obj.point;
        var data = Table.prototype.__proto__ || Object.getPrototypeOf(Table.prototype);
        _get(data, "mousemoveEvent", this).call(this, value, obj);
      }
    }, {
      "key" : `addAnimatorEvent`,
      "value" : function() {
      }
    }, {
      "key" : `animatorMovestartEvent`,
      "value" : function() {
        var animationOptions = this.options.animation;
        if (this.isEnabledTime() && this.animator) {
          this.steps.step = animationOptions.stepsRange.start;
        }
      }
    }, {
      "key" : `animatorMoveendEvent`,
      "value" : function() {
        if (this.isEnabledTime()) {
          this.animator;
        }
      }
    }, {
      "key" : `bindEvent`,
      "value" : function() {
        if (this.options.methods) {
          this.options.methods.click;
          this.options.methods.mousemove;
        }
      }
    }, {
      "key" : `unbindEvent`,
      "value" : function() {
        this.map;
      }
    }, {
      "key" : `getContext`,
      "value" : function() {
        return this.canvasLayer.canvas.getContext(this.context);
      }
    }, {
      "key" : `init`,
      "value" : function(value) {
        this.options = value;
        this.initDataRange(value);
        this.context = this.options.context || "2d";
        if (this.options.zIndex && this.canvasLayer && this.canvasLayer.setZIndex) {
          this.canvasLayer.setZIndex(this.options.zIndex);
        }
        this.initAnimator();
      }
    }, {
      "key" : "_canvasUpdate",
      "value" : function(value) {
        var scene = this.scene;
        if (this.canvasLayer && !this.stopAniamation) {
          var animation = this.options.animation;
          var context = this.getContext();
          if (this.isEnabledTime()) {
            if (void 0 === value) {
              return void this.clear(context);
            }
            if ("2d" === this.context) {
              context.save();
              context.globalCompositeOperation = "destination-out";
              context.fillStyle = "rgba(0, 0, 0, .1)";
              context.fillRect(0, 0, context.canvas.width, context.canvas.height);
              context.restore();
            }
          } else {
            this.clear(context);
          }
          if ("2d" === this.context) {
            var k;
            for (k in this.options) {
              context[k] = this.options[k];
            }
          } else {
            context.clear(context.COLOR_BUFFER_BIT);
          }
          var dataGetOptions = {
            "transferCoordinate" : function(x) {
              var getPolygon = hahaha;
              var data = [99999, 99999];
              var y = Cesium[getPolygon(3131)][getPolygon(2770)](x[0], x[1]);
              if (!y) {
                return data;
              }
              return x = scene[getPolygon(687)](y), x ? !(scene.mode === Cesium[getPolygon(1448)][getPolygon(602)] && Cesium.Cartesian3.angleBetween(scene.camera[getPolygon(586)], y) > Cesium.Math[getPolygon(1544)](80)) && [x.x, x.y] : data;
            }
          };
          if (value) {
            dataGetOptions.filter = function(event) {
              var resetFacetCount = hahaha;
              var range = animation[resetFacetCount(1335)] || 10;
              return !!(value && event[resetFacetCount(806)] > value - range && event[resetFacetCount(806)] < value);
            };
          }
          var data = this.dataSet.get(dataGetOptions);
          this.processData(data);
          if ("m" === this.options.unit && this.options.size) {
            this.options._size = this.options.size;
          }
          dataGetOptions = Cesium.SceneTransforms.wgs84ToWindowCoordinates(scene, Cesium.Cartesian3.fromDegrees(0, 0));
          this.drawContext(context, new mapv.DataSet(data), this.options, dataGetOptions);
          if (this.options.updateCallback) {
            this.options.updateCallback(value);
          }
        }
      }
    }, {
      "key" : `updateData`,
      "value" : function(name, object) {
        var v;
        if (name) {
          v = name.get();
          name = Table.prototype.__proto__ || Object.getPrototypeOf(Table.prototype);
          this.dataSet.set(v);
          _get(name, "update", this).call(this, {
            "options" : object
          });
        }
      }
    }, {
      "key" : "addData",
      "value" : function(name, object) {
        if (name) {
          name = name.get;
          this.dataSet.add(name);
          this.update({
            "options" : object
          });
        }
      }
    }, {
      "key" : `getData`,
      "value" : function() {
        return this.dataSet;
      }
    }, {
      "key" : "removeData",
      "value" : function(target) {
        var v;
        if (this.dataSet) {
          v = this.dataSet.get({
            "filter" : function(event) {
              var resetFacetCount = hahaha;
              return null == target || resetFacetCount(827) != typeof target || !target(event);
            }
          });
          this.dataSet.set(v);
          this.update({
            "options" : null
          });
        }
      }
    }, {
      "key" : "clearData",
      "value" : function() {
        if (this.dataSet) {
          this.dataSet.clear();
          this.update({
            "options" : null
          });
        }
      }
    }, {
      "key" : `draw`,
      "value" : function() {
        this.canvasLayer.draw();
      }
    }, {
      "key" : "clear",
      "value" : function(target) {
        if (target && target.hasOwnProperty("clearRect")) {
          target.clearRect(0, 0, target.canvas.width, target.canvas.height);
        }
      }
    }, {
      "key" : `destroy`,
      "value" : function() {
        this.unbindEvent();
        this.clear(this.getContext());
        this.clearData();
        if (this.animator) {
          this.animator.stop();
          this.animator = null;
          this.canvasLayer = null;
        }
      }
    }]);
    anim = Table;
  }
  var Board = anim;
  var publish = function(service, name) {
    if (!(service instanceof name)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };
  (function(constructor, protoProps, staticProps) {
    if (protoProps) {
      defineProperties(constructor.prototype, protoProps);
    }
    if (staticProps) {
      defineProperties(constructor, staticProps);
    }
  })(run, [{
    "key" : `initDevicePixelRatio`,
    "value" : function() {
      this.devicePixelRatio = window.devicePixelRatio || 1;
    }
  }, {
    "key" : "addInnerContainer",
    "value" : function() {
      this.container.appendChild(this.canvas);
    }
  }, {
    "key" : "bindEvent",
    "value" : function() {
      var primaryReplicas = this;
      this.innerMoveStart = this.moveStartEvent.bind(this);
      this.innerMoveEnd = this.moveEndEvent.bind(this);
      this.scene.camera.moveStart.addEventListener(this.innerMoveStart, this);
      this.scene.camera.moveEnd.addEventListener(this.innerMoveEnd, this);
      var handler = new Cesium["ScreenSpaceEventHandler"](this.canvas);
      handler.setInputAction(function(canCreateDiscussions) {
        var stringify = hahaha;
        primaryReplicas[stringify(1783)]();
      }, Cesium.ScreenSpaceEventType.LEFT_UP);
      handler.setInputAction(function(canCreateDiscussions) {
        primaryReplicas.innerMoveEnd();
      }, Cesium.ScreenSpaceEventType.MIDDLE_UP);
      this.handler = handler;
    }
  }, {
    "key" : `unbindEvent`,
    "value" : function() {
      this.scene.camera.moveStart.removeEventListener(this.innerMoveStart, this);
      this.scene.camera.moveEnd.removeEventListener(this.innerMoveEnd, this);
      this.scene.postRender.removeEventListener(this._reset, this);
      if (this.handler) {
        this.handler.destroy();
        this.handler = null;
      }
    }
  }, {
    "key" : `moveStartEvent`,
    "value" : function() {
      if (this.mapvBaseLayer) {
        this.mapvBaseLayer.animatorMovestartEvent();
        this.scene.postRender.addEventListener(this._reset, this);
      }
    }
  }, {
    "key" : `moveEndEvent`,
    "value" : function() {
      this.scene.postRender.removeEventListener(this._reset, this);
      if (this.mapvBaseLayer) {
        this.mapvBaseLayer.animatorMoveendEvent();
      }
      this._reset();
    }
  }, {
    "key" : `zoomStartEvent`,
    "value" : function() {
      this._unvisiable();
    }
  }, {
    "key" : `zoomEndEvent`,
    "value" : function() {
      this._unvisiable();
    }
  }, {
    "key" : "addData",
    "value" : function(name, obj) {
      if (this.mapvBaseLayer) {
        this.mapvBaseLayer.addData(name, obj);
      }
    }
  }, {
    "key" : `updateData`,
    "value" : function(name, value) {
      if (this.mapvBaseLayer) {
        this.mapvBaseLayer.updateData(name, value);
      }
    }
  }, {
    "key" : `getData`,
    "value" : function() {
      if (this.mapvBaseLayer) {
        return this.dataSet = this.mapvBaseLayer.getData(), this.dataSet;
      }
    }
  }, {
    "key" : `removeData`,
    "value" : function(name) {
      if (this.mapvBaseLayer) {
        this.mapvBaseLayer.removeData(name);
      }
    }
  }, {
    "key" : "removeAllData",
    "value" : function() {
      if (this.mapvBaseLayer) {
        this.mapvBaseLayer.clearData();
      }
    }
  }, {
    "key" : `_visiable`,
    "value" : function() {
      return this.canvas.style.display = "block";
    }
  }, {
    "key" : `_unvisiable`,
    "value" : function() {
      return this.canvas.style.display = "none";
    }
  }, {
    "key" : `_createCanvas`,
    "value" : function() {
      var element = document.createElement("canvas");
      element.id = this.mapVOptions.layerid || "mapv0";
      element.style.position = "absolute";
      element.style.top = "0px";
      element.style.left = "0px";
      element.style.pointerEvents = "none";
      element.style.zIndex = this.mapVOptions.zIndex || 100;
      element.width = parseInt(this.map.canvas.width);
      element.height = parseInt(this.map.canvas.height);
      element.style.width = this.map.canvas.style.width;
      element.style.height = this.map.canvas.style.height;
      var ratio = this.devicePixelRatio;
      return "2d" === this.mapVOptions.context && element.getContext(this.mapVOptions.context).scale(ratio, ratio), element;
    }
  }, {
    "key" : `_reset`,
    "value" : function() {
      this.resizeCanvas();
      this.fixPosition();
      this.onResize();
      this.render();
    }
  }, {
    "key" : "draw",
    "value" : function() {
      this._reset();
    }
  }, {
    "key" : "show",
    "value" : function() {
      this._visiable();
    }
  }, {
    "key" : `hide`,
    "value" : function() {
      this._unvisiable();
    }
  }, {
    "key" : `destroy`,
    "value" : function() {
      this.unbindEvent();
      this.remove();
    }
  }, {
    "key" : `remove`,
    "value" : function() {
      if (this.mapvBaseLayer) {
        this.removeAllData();
        this.mapvBaseLayer.destroy();
        this.mapvBaseLayer = void 0;
        this.canvas.parentElement.removeChild(this.canvas);
      }
    }
  }, {
    "key" : `update`,
    "value" : function(target) {
      if (target) {
        this.updateData(target.data, target.options);
      }
    }
  }, {
    "key" : `resizeCanvas`,
    "value" : function() {
      var elem;
      if (this.canvas) {
        (elem = this.canvas).style.position = "absolute";
        elem.style.top = "0px";
        elem.style.left = "0px";
        elem.width = parseInt(this.map.canvas.width);
        elem.height = parseInt(this.map.canvas.height);
        elem.style.width = this.map.canvas.style.width;
        elem.style.height = this.map.canvas.style.height;
      }
    }
  }, {
    "key" : `fixPosition`,
    "value" : function() {
    }
  }, {
    "key" : `onResize`,
    "value" : function() {
    }
  }, {
    "key" : `render`,
    "value" : function() {
      if (this.mapvBaseLayer) {
        this.mapvBaseLayer._canvasUpdate();
      }
    }
  }]);
  anim = run;
  xt3d.MapVLayer = anim;
  expect(right, [{
    "key" : "lngLatToPoint",
    "value" : function() {
      throw new Error("lngLatToPoint\u65b9\u6cd5\u672a\u5b9e\u73b0");
    }
  }, {
    "key" : `pointToLngLat`,
    "value" : function() {
      throw new Error("pointToLngLat\u65b9\u6cd5\u672a\u5b9e\u73b0");
    }
  }]);
  anim = right;
  var Point = (expect(urlChanged, [{
    "key" : "equals",
    "value" : function(target) {
      return target && this.lat === target.lat && this.lng === target.lng;
    }
  }]), urlChanged);
  Point.isInRange = function(options) {
    return options && options.lng <= 180 && -180 <= options.lng && options.lat <= 74 && -74 <= options.lat;
  };
  var Uint8Array = (expect(expandmove, [{
    "key" : `equals`,
    "value" : function(obj) {
      return obj && obj.x === this.x && obj.y === this.y;
    }
  }]), expandmove);
  var helpers = (_inherits(t, anim), expect(t, [{
    "key" : `lngLatToMercator`,
    "value" : function(name) {
      return t.convertLL2MC(name);
    }
  }, {
    "key" : `lngLatToPoint`,
    "value" : function(target) {
      return target = t.convertLL2MC(target), new Uint8Array(target.lng, target.lat);
    }
  }, {
    "key" : "mercatorToLngLat",
    "value" : function(name) {
      return t.convertMC2LL(name);
    }
  }, {
    "key" : `pointToLngLat`,
    "value" : function(obj) {
      return obj = new Point(obj.x, obj.y), t.convertMC2LL(obj);
    }
  }, {
    "key" : "pointToPixel",
    "value" : function(target, x, b, pos, ref) {
      if (target) {
        return target = this.lngLatToMercator(target, ref), b = this.lngLatToMercator(b), ref = this.getZoomUnits(x), x = Math.round((target.lng - b.lng) / ref + pos.width / 2), pos = Math.round((b.lat - target.lat) / ref + pos.height / 2), new Uint8Array(x, pos);
      }
    }
  }, {
    "key" : "pixelToPoint",
    "value" : function(name, target, source, result, num_bands) {
      if (name) {
        var size = this.getZoomUnits(target);
        target = source.lng + size * (name.x - result.width / 2);
        result = source.lat - size * (name.y - result.height / 2);
        result = new Point(target, result);
        return this.mercatorToLngLat(result, num_bands);
      }
    }
  }, {
    "key" : "getZoomUnits",
    "value" : function(value) {
      return Math.pow(2, 18 - value);
    }
  }]), t);
  helpers.EARTHRADIUS = 6370996.81;
  helpers.MCBAND = [12890594.86, 8362377.87, 5591021, 3481989.83, 1678043.12, 0];
  helpers.LLBAND = [75, 60, 45, 30, 15, 0];
  helpers.MC2LL = [[1.410526172116255e-8, 0.00000898305509648872, -1.9939833816331, 200.9824383106796, -187.2403703815547, 91.6087516669843, -23.38765649603339, 2.57121317296198, -0.03801003308653, 17337981.2], [-7.435856389565537e-9, 0.000008983055097726239, -0.78625201886289, 96.32687599759846, -1.85204757529826, -59.36935905485877, 47.40033549296737, -16.50741931063887, 2.28786674699375, 10260144.86], [-3.030883460898826e-8, 0.00000898305509983578, 0.30071316287616, 59.74293618442277, 7.357984074871, 
  -25.38371002664745, 13.45380521110908, -3.29883767235584, 0.32710905363475, 6856817.37], [-1.981981304930552e-8, 0.000008983055099779535, 0.03278182852591, 40.31678527705744, 0.65659298677277, -4.44255534477492, 0.85341911805263, 0.12923347998204, -0.04625736007561, 4482777.06], [3.09191371068437e-9, 0.000008983055096812155, 0.00006995724062, 23.10934304144901, -0.00023663490511, -0.6321817810242, -0.00663494467273, 0.03430082397953, -0.00466043876332, 2555164.4], [2.890871144776878e-9, 0.000008983055095805407, 
  -3.068298e-8, 7.47137025468032, -0.00000353937994, -0.02145144861037, -0.00001234426596, 0.00010322952773, -0.00000323890364, 826088.5]];
  helpers.LL2MC = [[-0.0015702102444, 111320.7020616939, 0x60e374c3105a3, -0x24bb4115e2e164, 0x5cc55543bb0ae8, -0x7ce070193f3784, 0x5e7ca61ddf8150, -0x261a578d8b24d0, 0x665d60f3742ca, 82.5], [0.0008277824516172526, 111320.7020463578, 647795574.6671607, -4082003173.641316, 10774905663.51142, -15171875531.51559, 12053065338.62167, -5124939663.577472, 913311935.9512032, 67.5], [0.00337398766765, 111320.7020202162, 4481351.045890365, -23393751.19931662, 79682215.47186455, -115964993.2797253, 97236711.15602145, 
  -43661946.33752821, 8477230.501135234, 52.5], [0.00220636496208, 111320.7020209128, 51751.86112841131, 3796837.749470245, 992013.7397791013, -1221952.21711287, 1340652.697009075, -620943.6990984312, 144416.9293806241, 37.5], [-0.0003441963504368392, 111320.7020576856, 278.2353980772752, 2485758.690035394, 6070.750963243378, 54821.18345352118, 9540.606633304236, -2710.55326746645, 1405.483844121726, 22.5], [-0.0003218135878613132, 111320.7020701615, 0.00369383431289, 823725.6402795718, 0.46104986909093, 
  2351.343141331292, 1.58060784298199, 8.77738589078284, 0.37238884252424, 7.45]];
  helpers.getDistanceByMC = function(to, from) {
    if (!to || !from) {
      return 0;
    }
    if (!(to = this.convertMC2LL(to))) {
      return 0;
    }
    var lat1Rad = this.toRadians(to.lng);
    var lat2Rad = this.toRadians(to.lat);
    if (!(from = this.convertMC2LL(from))) {
      return 0;
    }
    return to = this.toRadians(from.lng), from = this.toRadians(from.lat), this.getDistance(lat1Rad, to, lat2Rad, from);
  };
  helpers.getDistanceByLL = function(to, from) {
    if (!to || !from) {
      return 0;
    }
    to.lng = this.getLoop(to.lng, -180, 180);
    to.lat = this.getRange(to.lat, -74, 74);
    from.lng = this.getLoop(from.lng, -180, 180);
    from.lat = this.getRange(from.lat, -74, 74);
    var lat1Rad = this.toRadians(to.lng);
    var lat2Rad = this.toRadians(to.lat);
    to = this.toRadians(from.lng);
    from = this.toRadians(from.lat);
    return this.getDistance(lat1Rad, to, lat2Rad, from);
  };
  helpers.convertMC2LL = function(s) {
    var ff = void 0;
    var newCenter = new Point(Math.abs(s.lng), Math.abs(s.lat));
    var i = 0;
    for (; i < this.MCBAND.length; i++) {
      if (newCenter.lat >= this.MCBAND[i]) {
        ff = this.MC2LL[i];
        break;
      }
    }
    return s = this.convertor(s, ff), new Point(s.lng.toFixed(6), s.lat.toFixed(6));
  };
  helpers.convertLL2MC = function(s) {
    var ff = void 0;
    s.lng = this.getLoop(s.lng, -180, 180);
    s.lat = this.getRange(s.lat, -74, 74);
    var newCenter = new Point(s.lng, s.lat);
    var i = 0;
    for (; i < this.LLBAND.length; i++) {
      if (newCenter.lat >= this.LLBAND[i]) {
        ff = this.LL2MC[i];
        break;
      }
    }
    if (!ff) {
      var i = this.LLBAND.length - 1;
      for (; 0 <= i; i--) {
        if (newCenter.lat <= -this.LLBAND[i]) {
          ff = this.LL2MC[i];
          break;
        }
      }
    }
    return s = this.convertor(s, ff), new Point(s.lng.toFixed(2), s.lat.toFixed(2));
  };
  helpers.convertor = function(data, key) {
    if (data && key) {
      var posx = key[0] + key[1] * Math.abs(data.lng);
      var scale = Math.abs(data.lat) / key[9];
      scale = key[2] + key[3] * scale + key[4] * scale * scale + key[5] * scale * scale * scale + key[6] * scale * scale * scale * scale + key[7] * scale * scale * scale * scale * scale + key[8] * scale * scale * scale * scale * scale * scale;
      return posx = posx * (data.lng < 0 ? -1 : 1), scale = scale * (data.lat < 0 ? -1 : 1), new Point(posx, scale);
    }
  };
  helpers.getDistance = function(x, i, radians, a) {
    return this.EARTHRADIUS * Math.acos(Math.sin(radians) * Math.sin(a) + Math.cos(radians) * Math.cos(a) * Math.cos(i - x));
  };
  helpers.toRadians = function(n) {
    return Math.PI * n / 180;
  };
  helpers.toDegrees = function(radians) {
    return 180 * radians / Math.PI;
  };
  helpers.getRange = function(length, min, max) {
    return null != min && (length = Math.max(length, min)), null != max && (length = Math.min(length, max)), length;
  };
  helpers.getLoop = function(result, url, fn) {
    for (; fn < result;) {
      result = result - (fn - url);
    }
    for (; result < url;) {
      result = result + (fn - url);
    }
    return result;
  };
  var n = 52.35987755982988;
  var p = 3.141592653589793;
  var agh = 6378245;
  var c = 0.006693421622965943;
  var deep = function(d, a) {
    var _0x21a959 = 2 * (d = +d) - 100 + 3 * (a = +a) + 0.2 * a * a + 0.1 * d * a + 0.2 * Math.sqrt(Math.abs(d));
    return _0x21a959 = _0x21a959 + 2 * (20 * Math.sin(6 * d * p) + 20 * Math.sin(2 * d * p)) / 3, _0x21a959 = _0x21a959 + 2 * (20 * Math.sin(a * p) + 40 * Math.sin(a / 3 * p)) / 3, _0x21a959 = _0x21a959 + 2 * (160 * Math.sin(a / 12 * p) + 320 * Math.sin(a * p / 30)) / 3;
  };
  var repeat = function(n, max) {
    return max = 300 + (n = +n) + 2 * (max = +max) + 0.1 * n * n + 0.1 * n * max + 0.1 * Math.sqrt(Math.abs(n)), max = max + 2 * (20 * Math.sin(6 * n * p) + 20 * Math.sin(2 * n * p)) / 3, max = max + 2 * (20 * Math.sin(n * p) + 40 * Math.sin(n / 3 * p)) / 3, max = max + 2 * (150 * Math.sin(n / 12 * p) + 300 * Math.sin(n / 30 * p)) / 3;
  };
  var _next = function(length, direction) {
    return direction = +direction, !(73.66 < (length = +length) && length < 135.05 && 3.86 < direction && direction < 53.55);
  };
  var me = {
    "bd09togcj02" : function(y, e) {
      var x = (y = +y) - 0.0065;
      y = (e = +e) - 0.006;
      e = Math.sqrt(x * x + y * y) - 0.00002 * Math.sin(y * n);
      x = Math.atan2(y, x) - 0.000003 * Math.cos(x * n);
      return [e * Math.cos(x), e * Math.sin(x)];
    },
    "gcj02tobd09" : function(d, b) {
      b = +b;
      d = +d;
      var c = Math.sqrt(d * d + b * b) + 0.00002 * Math.sin(b * n);
      d = Math.atan2(b, d) + 0.000003 * Math.cos(d * n);
      return [c * Math.cos(d) + 0.0065, c * Math.sin(d) + 0.006];
    },
    "wgs84togcj02" : function(s, n) {
      if (_next(s = +s, n = +n)) {
        return [s, n];
      }
      var diff = deep(s - 105, n - 35);
      var ch = repeat(s - 105, n - 35);
      var h = n / 180 * p;
      var t = Math.sin(h);
      t = 1 - c * t * t;
      var cgh = Math.sqrt(t);
      diff = 180 * diff / (agh * (1 - c) / (t * cgh) * p);
      return [s + (ch = 180 * ch / (agh / cgh * Math.cos(h) * p)), n + diff];
    },
    "gcj02towgs84" : function(x, n) {
      if (_next(x = +x, n = +n)) {
        return [x, n];
      }
      var diff = deep(x - 105, n - 35);
      var bl = repeat(x - 105, n - 35);
      var h = n / 180 * p;
      var t = Math.sin(h);
      t = 1 - c * t * t;
      var cgh = Math.sqrt(t);
      diff = 180 * diff / (agh * (1 - c) / (t * cgh) * p);
      return [2 * x - (x + (bl = 180 * bl / (agh / cgh * Math.cos(h) * p))), 2 * n - (n + diff)];
    }
  };
  var Assertion = (expect(WebMercatorTilingScheme, [{
    "key" : `getNumberOfXTilesAtLevel`,
    "value" : function(name) {
      return 1 << name;
    }
  }, {
    "key" : `getNumberOfYTilesAtLevel`,
    "value" : function(name) {
      return 1 << name;
    }
  }, {
    "key" : `rectangleToNativeRectangle`,
    "value" : function(value, obj) {
      var southwest = Cesium;
      var defined = southwest.defined;
      var Rectangle = southwest.Rectangle;
      var projection = this._projection;
      southwest = projection.project(Rectangle.southwest(value));
      value = projection.project(Rectangle.northeast(value));
      return defined(obj) ? (obj.west = southwest.x, obj.south = southwest.y, obj.east = value.x, obj.north = value.y, obj) : new Rectangle(southwest.x, southwest.y, value.x, value.y);
    }
  }, {
    "key" : "tileXYToNativeRectangle",
    "value" : function(x, value, type, result) {
      var left = Cesium;
      var defined = left.defined;
      var Rect = left.Rectangle;
      var size = this.resolutions[type];
      left = x * size;
      type = (x + 1) * size;
      x = (1 + (value = -value)) * size;
      size = value * size;
      return defined(result) ? (result.west = left, result.south = size, result.east = type, result.north = x, result) : new Rect(left, size, type, x);
    }
  }, {
    "key" : `tileXYToRectangle`,
    "value" : function(name, value, data, result) {
      var Cartesian2 = Cesium.Cartesian2;
      value = this.tileXYToNativeRectangle(name, value, data, result);
      data = this._projection;
      result = data.unproject(new Cartesian2(value.west, value.south));
      Cartesian2 = data.unproject(new Cartesian2(value.east, value.north));
      return value.west = result.longitude, value.south = result.latitude, value.east = Cartesian2.longitude, value.north = Cartesian2.latitude, value;
    }
  }, {
    "key" : `positionToTileXY`,
    "value" : function(value, name, target) {
      var data = Cesium;
      var queryString = data.Rectangle;
      var isArray = data.defined;
      var Array = data.Cartesian2;
      data = this._rectangle;
      if (queryString.contains(data, value)) {
        data = this._projection.project(value);
        if (isArray(data)) {
          return value = this.resolutions[name], name = Math.floor(data.x / value), value = -Math.floor(data.y / value), isArray(target) ? (target.x = name, target.y = value, target) : new Array(name, value);
        }
      }
    }
  }, {
    "key" : "ellipsoid",
    "get" : function() {
      return this._ellipsoid;
    }
  }, {
    "key" : `rectangle`,
    "get" : function() {
      return this._rectangle;
    }
  }, {
    "key" : `projection`,
    "get" : function() {
      return this._projection;
    }
  }]), WebMercatorTilingScheme);
  expect(expect, [{
    "key" : `getTileCredits`,
    "value" : function(name, source, type) {
      if (!this.ready) {
        throw new Cesium.DeveloperError("getTileCredits must not be called before the imagery provider is ready.");
      }
    }
  }, {
    "key" : `requestImage`,
    "value" : function(type, obj, source, callsite) {
      if (!this.ready) {
        throw new Cesium.DeveloperError("requestImage must not be called before the imagery provider is ready.");
      }
      return Cesium.ImageryProvider.loadImage(this, function(category, _, level, returnRequest) {
        var url = this._url;
        var subdomains = this._subdomains;
        return url = url.replace("{s}", subdomains[(category + _ + level) % subdomains.length]).replace("{x}", category).replace("{y}", -_).replace("{z}", level), this._resource.getDerivedResource({
          "url" : url,
          "request" : returnRequest
        });
      }.call(this, type, obj, source, callsite));
    }
  }, {
    "key" : `url`,
    "get" : function() {
      return this._resource._url;
    }
  }, {
    "key" : "proxy",
    "get" : function() {
      return this._resource.proxy;
    }
  }, {
    "key" : "tileWidth",
    "get" : function() {
      if (!this._ready) {
        throw new Cesium.DeveloperError("tileWidth must not be called before the imagery provider is ready.");
      }
      return this._tileWidth;
    }
  }, {
    "key" : `tileHeight`,
    "get" : function() {
      if (!this._ready) {
        throw new Cesium["DeveloperError"]("tileHeight must not be called before the imagery provider is ready.");
      }
      return this._tileHeight;
    }
  }, {
    "key" : `maximumLevel`,
    "get" : function() {
      if (!this._ready) {
        throw new Cesium["DeveloperError"]("maximumLevel must not be called before the imagery provider is ready.");
      }
      return this._maximumLevel;
    }
  }, {
    "key" : `minimumLevel`,
    "get" : function() {
      if (!this.ready) {
        throw new Cesium["DeveloperError"]("minimumLevel must not be called before the imagery provider is ready.");
      }
      return this._minimumLevel;
    }
  }, {
    "key" : `tilingScheme`,
    "get" : function() {
      if (!this._ready) {
        throw new Cesium["DeveloperError"]("tilingScheme must not be called before the imagery provider is ready.");
      }
      return this._tilingScheme;
    }
  }, {
    "key" : `rectangle`,
    "get" : function() {
      if (!this.ready) {
        throw new Cesium["DeveloperError"]("rectangle must not be called before the imagery provider is ready.");
      }
      return this._rectangle;
    }
  }, {
    "key" : `tileDiscardPolicy`,
    "get" : function() {
      if (!this.ready) {
        throw new Cesium["DeveloperError"]("tileDiscardPolicy must not be called before the imagery provider is ready.");
      }
      return this._tileDiscardPolicy;
    }
  }, {
    "key" : `errorEvent`,
    "get" : function() {
      return this._errorEvent;
    }
  }, {
    "key" : `ready`,
    "get" : function() {
      return this._ready;
    }
  }, {
    "key" : `readyPromise`,
    "get" : function() {
      return this._readyPromise.promise;
    }
  }, {
    "key" : `credit`,
    "get" : function() {
      if (!this.ready) {
        throw new Cesium["DeveloperError"]("credit must not be called before the imagery provider is ready.");
      }
      return this._credit;
    }
  }, {
    "key" : `hasAlphaChannel`,
    "get" : function() {
      if (!this.ready) {
        throw new Cesium["DeveloperError"]("hasAlphaChannel must not be called before the imagery provider is ready.");
      }
      return this._hasAlphaChannel;
    }
  }]);
  expect = expect;
  xt3d.ImageProvider = {
    "BaiduMapImageryProvider" : expect
  };
});
